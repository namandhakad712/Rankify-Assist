/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/.pnpm/css-loader@7.1.2_webpack@5.102.1/node_modules/css-loader/dist/cjs.js!./src/sidebar/index.css":
/*!*****************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/css-loader@7.1.2_webpack@5.102.1/node_modules/css-loader/dist/cjs.js!./src/sidebar/index.css ***!
  \*****************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../node_modules/.pnpm/css-loader@7.1.2_webpack@5.102.1/node_modules/css-loader/dist/runtime/sourceMaps.js */ "../../node_modules/.pnpm/css-loader@7.1.2_webpack@5.102.1/node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../node_modules/.pnpm/css-loader@7.1.2_webpack@5.102.1/node_modules/css-loader/dist/runtime/api.js */ "../../node_modules/.pnpm/css-loader@7.1.2_webpack@5.102.1/node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, `body {
  margin: 0 !important;
}

.streaming-cursor {
  animation: blink 1s infinite;
  color: black;
}

.markdown-body {
  font-size: 14px;
  color: rgba(0, 0, 0, 0.88);
}

.markdown-body p {
  margin: 0 0 8px 0;
  white-space: pre-wrap;
}

.markdown-body ul,
.markdown-body ol {
  margin: 0 0 8px 16px;
}

.markdown-body code {
  background: rgba(0, 0, 0, 0.04);
  padding: 2px 4px;
  border-radius: 4px;
  font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, monospace;
}

.markdown-body pre code {
  display: block;
  padding: 12px;
}

@keyframes blink {
  0%, 50% {
    opacity: 1;
  }
  51%, 100% {
    opacity: 0;
  }
}

.tool-json-pre {
  margin: 0;
  font-size: 12px;
  overflow-x: auto;
  scrollbar-width: none;
  -ms-overflow-style: none;
}

.tool-json-pre::-webkit-scrollbar {
  display: none;
}

.chat-input-rich-container {
  position: relative;
  flex: 1;
  margin: 0 4px;
}

.chat-input-editor {
  max-height: 160px;
  overflow-y: auto;
  border: 1px solid #d9d9d9;
  border-radius: 6px;
  padding: 6px 11px;
  font-size: 14px;
  line-height: 1.5715;
  transition: border-color 0.2s, box-shadow 0.2s;
  white-space: pre-wrap;
  word-break: break-word;
}

.chat-input-editor:focus {
  border-color: #1677ff;
  box-shadow: 0 0 0 2px rgba(22, 119, 255, 0.2);
  outline: none;
}

.chat-input-editor:empty::before {
  content: attr(data-placeholder);
  color: rgba(0, 0, 0, 0.25);
}

.webpage-reference-display {
  color: #1677ff;
  background: rgba(22, 119, 255, 0.12);
  border-radius: 4px;
  padding: 0 4px;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
}

.user-webpage-reference {
  color: white;
  background: #4CAF50;
}

.webpage-reference-display::before {
  content: "@";
  margin-right: 2px;
}

`, "",{"version":3,"sources":["webpack://./src/sidebar/index.css"],"names":[],"mappings":"AAAA;EACE,oBAAoB;AACtB;;AAEA;EACE,4BAA4B;EAC5B,YAAY;AACd;;AAEA;EACE,eAAe;EACf,0BAA0B;AAC5B;;AAEA;EACE,iBAAiB;EACjB,qBAAqB;AACvB;;AAEA;;EAEE,oBAAoB;AACtB;;AAEA;EACE,+BAA+B;EAC/B,gBAAgB;EAChB,kBAAkB;EAClB,4EAA4E;AAC9E;;AAEA;EACE,cAAc;EACd,aAAa;AACf;;AAEA;EACE;IACE,UAAU;EACZ;EACA;IACE,UAAU;EACZ;AACF;;AAEA;EACE,SAAS;EACT,eAAe;EACf,gBAAgB;EAChB,qBAAqB;EACrB,wBAAwB;AAC1B;;AAEA;EACE,aAAa;AACf;;AAEA;EACE,kBAAkB;EAClB,OAAO;EACP,aAAa;AACf;;AAEA;EACE,iBAAiB;EACjB,gBAAgB;EAChB,yBAAyB;EACzB,kBAAkB;EAClB,iBAAiB;EACjB,eAAe;EACf,mBAAmB;EACnB,8CAA8C;EAC9C,qBAAqB;EACrB,sBAAsB;AACxB;;AAEA;EACE,qBAAqB;EACrB,6CAA6C;EAC7C,aAAa;AACf;;AAEA;EACE,+BAA+B;EAC/B,0BAA0B;AAC5B;;AAEA;EACE,cAAc;EACd,oCAAoC;EACpC,kBAAkB;EAClB,cAAc;EACd,eAAe;EACf,oBAAoB;EACpB,mBAAmB;AACrB;;AAEA;EACE,YAAY;EACZ,mBAAmB;AACrB;;AAEA;EACE,YAAY;EACZ,iBAAiB;AACnB","sourcesContent":["body {\n  margin: 0 !important;\n}\n\n.streaming-cursor {\n  animation: blink 1s infinite;\n  color: black;\n}\n\n.markdown-body {\n  font-size: 14px;\n  color: rgba(0, 0, 0, 0.88);\n}\n\n.markdown-body p {\n  margin: 0 0 8px 0;\n  white-space: pre-wrap;\n}\n\n.markdown-body ul,\n.markdown-body ol {\n  margin: 0 0 8px 16px;\n}\n\n.markdown-body code {\n  background: rgba(0, 0, 0, 0.04);\n  padding: 2px 4px;\n  border-radius: 4px;\n  font-family: \"SFMono-Regular\", Consolas, \"Liberation Mono\", Menlo, monospace;\n}\n\n.markdown-body pre code {\n  display: block;\n  padding: 12px;\n}\n\n@keyframes blink {\n  0%, 50% {\n    opacity: 1;\n  }\n  51%, 100% {\n    opacity: 0;\n  }\n}\n\n.tool-json-pre {\n  margin: 0;\n  font-size: 12px;\n  overflow-x: auto;\n  scrollbar-width: none;\n  -ms-overflow-style: none;\n}\n\n.tool-json-pre::-webkit-scrollbar {\n  display: none;\n}\n\n.chat-input-rich-container {\n  position: relative;\n  flex: 1;\n  margin: 0 4px;\n}\n\n.chat-input-editor {\n  max-height: 160px;\n  overflow-y: auto;\n  border: 1px solid #d9d9d9;\n  border-radius: 6px;\n  padding: 6px 11px;\n  font-size: 14px;\n  line-height: 1.5715;\n  transition: border-color 0.2s, box-shadow 0.2s;\n  white-space: pre-wrap;\n  word-break: break-word;\n}\n\n.chat-input-editor:focus {\n  border-color: #1677ff;\n  box-shadow: 0 0 0 2px rgba(22, 119, 255, 0.2);\n  outline: none;\n}\n\n.chat-input-editor:empty::before {\n  content: attr(data-placeholder);\n  color: rgba(0, 0, 0, 0.25);\n}\n\n.webpage-reference-display {\n  color: #1677ff;\n  background: rgba(22, 119, 255, 0.12);\n  border-radius: 4px;\n  padding: 0 4px;\n  cursor: pointer;\n  display: inline-flex;\n  align-items: center;\n}\n\n.user-webpage-reference {\n  color: white;\n  background: #4CAF50;\n}\n\n.webpage-reference-display::before {\n  content: \"@\";\n  margin-right: 2px;\n}\n\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "../../packages/eko-core/dist lazy recursive":
/*!******************************************************************!*\
  !*** ../../packages/eko-core/dist/ lazy strict namespace object ***!
  \******************************************************************/
/***/ ((module) => {

function webpackEmptyAsyncContext(req) {
	// Here Promise.resolve().then() is used instead of new Promise() to prevent
	// uncaught exception popping up in devtools
	return Promise.resolve().then(() => {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	});
}
webpackEmptyAsyncContext.keys = () => ([]);
webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
webpackEmptyAsyncContext.id = "../../packages/eko-core/dist lazy recursive";
module.exports = webpackEmptyAsyncContext;

/***/ }),

/***/ "../../packages/eko-core/dist/index.esm.js":
/*!*************************************************!*\
  !*** ../../packages/eko-core/dist/index.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Agent: () => (/* binding */ Agent),
/* harmony export */   AgentChain: () => (/* binding */ AgentChain),
/* harmony export */   AgentContext: () => (/* binding */ AgentContext),
/* harmony export */   BaseBrowserAgent: () => (/* binding */ BaseBrowserAgent),
/* harmony export */   BaseBrowserLabelsAgent: () => (/* binding */ BaseBrowserLabelsAgent),
/* harmony export */   BaseBrowserScreenAgent: () => (/* binding */ BaseBrowserScreenAgent),
/* harmony export */   Chain: () => (/* binding */ Chain),
/* harmony export */   ChatAgent: () => (/* binding */ ChatAgent),
/* harmony export */   ChatContext: () => (/* binding */ ChatContext),
/* harmony export */   Context: () => (/* binding */ TaskContext),
/* harmony export */   Eko: () => (/* binding */ Eko),
/* harmony export */   EkoMemory: () => (/* binding */ EkoMemory),
/* harmony export */   ForeachTaskTool: () => (/* binding */ ForeachTaskTool),
/* harmony export */   HumanInteractTool: () => (/* binding */ HumanInteractTool),
/* harmony export */   Log: () => (/* binding */ Log),
/* harmony export */   Planner: () => (/* binding */ Planner),
/* harmony export */   RetryLanguageModel: () => (/* binding */ RetryLanguageModel),
/* harmony export */   SimpleHttpMcpClient: () => (/* binding */ SimpleHttpMcpClient),
/* harmony export */   SimpleSseMcpClient: () => (/* binding */ SimpleSseMcpClient),
/* harmony export */   TaskContext: () => (/* binding */ TaskContext),
/* harmony export */   TaskNodeStatusTool: () => (/* binding */ TaskNodeStatusTool),
/* harmony export */   VariableStorageTool: () => (/* binding */ VariableStorageTool),
/* harmony export */   WatchTriggerTool: () => (/* binding */ WatchTriggerTool),
/* harmony export */   buildAgentTree: () => (/* binding */ buildAgentTree),
/* harmony export */   buildSimpleAgentWorkflow: () => (/* binding */ buildSimpleAgentWorkflow),
/* harmony export */   call_timeout: () => (/* binding */ call_timeout),
/* harmony export */   compressImageData: () => (/* binding */ compressImageData),
/* harmony export */   config: () => (/* binding */ config$1),
/* harmony export */   convertToolSchema: () => (/* binding */ convertToolSchema),
/* harmony export */   "default": () => (/* binding */ Eko),
/* harmony export */   extract_page_content: () => (/* binding */ extract_page_content),
/* harmony export */   global: () => (/* binding */ global),
/* harmony export */   mergeTools: () => (/* binding */ mergeTools),
/* harmony export */   parseWorkflow: () => (/* binding */ parseWorkflow),
/* harmony export */   resetWorkflowXml: () => (/* binding */ resetWorkflowXml),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   toFile: () => (/* binding */ toFile),
/* harmony export */   toImage: () => (/* binding */ toImage),
/* harmony export */   uuidv4: () => (/* binding */ uuidv4)
/* harmony export */ });
const config$1 = {
    name: "Eko",
    mode: "normal",
    platform: "mac",
    maxReactNum: 500,
    maxOutputTokens: 16000,
    maxRetryNum: 3,
    agentParallel: false,
    compressThreshold: 80,
    compressTokensThreshold: 80000,
    largeTextLength: 8000,
    fileTextMaxLength: 20000,
    maxDialogueImgFileNum: 1,
    toolResultMultimodal: true,
    parallelToolCalls: true,
    markImageMode: "draw",
    expertModeTodoLoopNum: 10,
    memoryConfig: {
        maxMessageNum: 15,
        maxInputTokens: 64000,
        enableCompression: true,
        compressionThreshold: 10,
        compressionMaxLength: 6000,
    },
};

var LogLevel;
(function (LogLevel) {
    LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
    LogLevel[LogLevel["INFO"] = 1] = "INFO";
    LogLevel[LogLevel["WARN"] = 2] = "WARN";
    LogLevel[LogLevel["ERROR"] = 3] = "ERROR";
    LogLevel[LogLevel["FATAL"] = 4] = "FATAL";
    LogLevel[LogLevel["OFF"] = 5] = "OFF";
})(LogLevel || (LogLevel = {}));
class ConsoleTransport {
    log(level, message) {
        const methods = {
            [LogLevel.DEBUG]: console.debug,
            [LogLevel.INFO]: console.info,
            [LogLevel.WARN]: console.warn,
            [LogLevel.ERROR]: console.error,
            [LogLevel.FATAL]: console.error,
            [LogLevel.OFF]: () => { }
        };
        const method = methods[level] || console.log;
        method(message);
    }
}
class Logger {
    constructor(options = {}) {
        this.level = options.level ?? LogLevel.INFO;
        this.prefix = options.prefix ?? '';
        this.dateFormat = options.dateFormat ?? true;
        this.transports = options.transport ?? [new ConsoleTransport()];
    }
    setLevel(level) {
        this.level = level;
        return this;
    }
    setPrefix(prefix) {
        this.prefix = prefix;
        return this;
    }
    addTransport(transport) {
        this.transports.push(transport);
        return this;
    }
    formatMessage(level, message) {
        const levelNames = {
            [LogLevel.DEBUG]: 'DEBUG',
            [LogLevel.INFO]: 'INFO',
            [LogLevel.WARN]: 'WARN',
            [LogLevel.ERROR]: 'ERROR',
            [LogLevel.FATAL]: 'FATAL',
            [LogLevel.OFF]: 'OFF'
        };
        let formattedMessage = '';
        if (this.dateFormat) {
            formattedMessage += `[${new Date().toLocaleString()}] `;
        }
        formattedMessage += `[${levelNames[level] || 'UNKNOWN'}] `;
        if (this.prefix) {
            formattedMessage += `[${this.prefix}] `;
        }
        formattedMessage += message;
        return formattedMessage;
    }
    log(level, message, ...args) {
        if (level < this.level) {
            return;
        }
        let finalMessage;
        if (message instanceof Error) {
            finalMessage = `${message.message}\n${message.stack}`;
        }
        else {
            finalMessage = message;
        }
        if (args.length > 0) {
            finalMessage += ' ' + args.map(arg => {
                if (arg == null || arg == undefined) {
                    return arg + '';
                }
                else if (arg instanceof Error || (arg.stack && arg.message)) {
                    return `${arg.message}\n${arg.stack}`;
                }
                else if (typeof arg === 'object') {
                    return JSON.stringify(arg);
                }
                return String(arg);
            }).join(' ');
        }
        const formattedMessage = this.formatMessage(level, finalMessage);
        this.transports.forEach(transport => {
            transport.log(level, formattedMessage);
        });
    }
    isEnableDebug() {
        return this.level <= LogLevel.DEBUG;
    }
    debug(message, ...args) {
        this.log(LogLevel.DEBUG, message, ...args);
    }
    isEnableInfo() {
        return this.level <= LogLevel.INFO;
    }
    info(message, ...args) {
        this.log(LogLevel.INFO, message, ...args);
    }
    warn(message, ...args) {
        this.log(LogLevel.WARN, message, ...args);
    }
    error(message, ...args) {
        this.log(LogLevel.ERROR, message, ...args);
    }
    fatal(message, ...args) {
        this.log(LogLevel.FATAL, message, ...args);
    }
    createChild(name, options = {}) {
        const childPrefix = this.prefix ? `${this.prefix}.${name}` : name;
        return new Logger({
            level: options.level || this.level,
            prefix: childPrefix,
            dateFormat: options.dateFormat !== undefined ? options.dateFormat : this.dateFormat,
            transport: options.transport || this.transports
        });
    }
}
const Log = new Logger();

function sleep(time) {
    return new Promise((resolve) => setTimeout(() => resolve(), time));
}
function uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
        const r = (Math.random() * 16) | 0;
        const v = c === "x" ? r : (r & 0x3) | 0x8;
        return v.toString(16);
    });
}
function call_timeout(fun, timeout, error_callback) {
    return new Promise(async (resolve, reject) => {
        let timer = setTimeout(() => {
            reject(new Error("Timeout"));
            error_callback && error_callback("Timeout");
        }, timeout);
        try {
            const result = await fun();
            clearTimeout(timer);
            resolve(result);
        }
        catch (e) {
            clearTimeout(timer);
            reject(e);
            error_callback && error_callback(e + "");
        }
    });
}
function convertToolSchema(tool) {
    if ("function" in tool) {
        return {
            type: "function",
            name: tool.function.name,
            description: tool.function.description,
            inputSchema: tool.function.parameters,
        };
    }
    else if ("input_schema" in tool) {
        return {
            type: "function",
            name: tool.name,
            description: tool.description,
            inputSchema: tool.input_schema,
        };
    }
    else if ("inputSchema" in tool) {
        return {
            type: "function",
            name: tool.name,
            description: tool.description,
            inputSchema: tool.inputSchema,
        };
    }
    else {
        return {
            type: "function",
            name: tool.name,
            description: tool.description,
            inputSchema: tool.parameters,
        };
    }
}
function toImage(mediaData) {
    return toFile(mediaData);
}
function toFile(mediaData, type = "base64|url") {
    if (mediaData.startsWith("http://") || mediaData.startsWith("https://")) {
        return new URL(mediaData);
    }
    else if (mediaData.startsWith("//") &&
        mediaData.indexOf(".") > 0 &&
        mediaData.length < 1000) {
        return new URL("https:" + mediaData);
    }
    if (mediaData.startsWith("data:")) {
        mediaData = mediaData.substring(mediaData.indexOf(",") + 1);
    }
    if (type === "binary|url") {
        // @ts-ignore
        if (typeof Buffer != "undefined") {
            // @ts-ignore
            const buffer = Buffer.from(mediaData, "base64");
            return new Uint8Array(buffer);
        }
        else {
            const binaryString = atob(mediaData);
            const fileData = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                fileData[i] = binaryString.charCodeAt(i);
            }
            return fileData;
        }
    }
    else {
        return mediaData;
    }
}
function getMimeType(data) {
    let mediaType = "image/png";
    if (data.startsWith("data:")) {
        mediaType = data.split(";")[0].split(":")[1];
    }
    else if (data.indexOf(".") > -1) {
        if (data.indexOf(".png") > -1) {
            mediaType = "image/png";
        }
        else if (data.indexOf(".jpg") > -1 || data.indexOf(".jpeg") > -1) {
            mediaType = "image/jpeg";
        }
        else if (data.indexOf(".pdf") > -1) {
            mediaType = "application/pdf";
        }
        else if (data.indexOf(".docx") > -1) {
            mediaType =
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
        }
        else if (data.indexOf(".xlsx") > -1) {
            mediaType =
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
        }
        else if (data.indexOf(".pptx") > -1) {
            mediaType =
                "application/vnd.openxmlformats-officedocument.presentationml.presentation";
        }
        else if (data.indexOf(".txt") > -1) {
            mediaType = "text/plain";
        }
        else if (data.indexOf(".md") > -1) {
            mediaType = "text/markdown";
        }
        else if (data.indexOf(".json") > -1) {
            mediaType = "application/json";
        }
        else if (data.indexOf(".xml") > -1) {
            mediaType = "application/xml";
        }
        else if (data.indexOf(".csv") > -1) {
            mediaType = "text/csv";
        }
    }
    return mediaType;
}
async function compressImageData(imageBase64, imageType, compress, quality) {
    const base64Data = imageBase64;
    const binaryString = typeof atob !== "undefined"
        ? atob(base64Data)
        : // @ts-ignore
            Buffer.from(base64Data, "base64").toString("binary");
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    if (!quality) {
        if (bytes.length >= 1024 * 1024 * 3) {
            quality = 0.6;
        }
        else if (bytes.length >= 1024 * 1024 * 1.5) {
            quality = 0.8;
        }
        else {
            quality = 1;
        }
    }
    const targetByScale = (bitmapWidth, bitmapHeight) => ({
        width: compress.scale
            ? bitmapWidth * compress.scale
            : compress.resizeWidth,
        height: compress.scale
            ? bitmapHeight * compress.scale
            : compress.resizeHeight,
    });
    const hasOffscreen = typeof OffscreenCanvas !== "undefined";
    const hasCreateImageBitmap = typeof createImageBitmap !== "undefined";
    const hasDOM = typeof document !== "undefined" && typeof Image !== "undefined";
    const isNode = typeof window === "undefined" &&
        // @ts-ignore
        typeof process !== "undefined" &&
        // @ts-ignore
        !!process.versions &&
        // @ts-ignore
        !!process.versions.node;
    const loadImageAny = async () => {
        if (hasCreateImageBitmap) {
            const blob = new Blob([bytes], { type: imageType });
            const bitmap = await createImageBitmap(blob);
            return { img: bitmap, width: bitmap.width, height: bitmap.height };
        }
        if (hasDOM) {
            const img = await new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = () => resolve(image);
                image.onerror = (e) => reject(e);
                image.src = `data:${imageType};base64,${imageBase64}`;
            });
            return { img, width: img.width, height: img.height };
        }
        if (isNode) {
            const canvasMod = await loadPackage("canvas");
            const { loadImage } = canvasMod;
            const dataUrl = `data:${imageType};base64,${imageBase64}`;
            const img = await loadImage(dataUrl);
            return { img, width: img.width, height: img.height };
        }
        throw new Error("No image environment available");
    };
    const createCanvasAny = async (width, height) => {
        if (hasOffscreen) {
            const canvas = new OffscreenCanvas(width, height);
            return {
                ctx: canvas.getContext("2d"),
                exportBase64: async (mime, q) => {
                    const blob = await canvas.convertToBlob({ type: mime, quality: q });
                    return await new Promise((res, rej) => {
                        const reader = new FileReader();
                        reader.onloadend = () => {
                            const url = reader.result;
                            res(url.substring(url.indexOf("base64,") + 7));
                        };
                        reader.onerror = () => rej(new Error("Failed to convert blob to base64"));
                        reader.readAsDataURL(blob);
                    });
                },
            };
        }
        if (hasDOM) {
            const canvas = document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            return {
                ctx: canvas.getContext("2d"),
                exportBase64: async (mime, q) => {
                    const dataUrl = canvas.toDataURL(mime, q);
                    return dataUrl.substring(dataUrl.indexOf("base64,") + 7);
                },
            };
        }
        if (isNode) {
            const canvasMod = await loadPackage("canvas");
            const { createCanvas } = canvasMod;
            const canvas = createCanvas(width, height);
            return {
                ctx: canvas.getContext("2d"),
                exportBase64: async (mime, q) => {
                    const buffer = canvas.toBuffer(mime, { quality: q });
                    return ((
                    // @ts-ignore
                    typeof Buffer !== "undefined" ? Buffer.from(buffer) : buffer).toString("base64"));
                },
            };
        }
        throw new Error("No canvas environment available");
    };
    const loaded = await loadImageAny();
    const { width, height } = targetByScale(loaded.width, loaded.height);
    if (loaded.width == width && loaded.height == height && quality == 1) {
        return {
            imageBase64: imageBase64,
            imageType: imageType,
        };
    }
    const { ctx, exportBase64 } = await createCanvasAny(width, height);
    if (!ctx) {
        return {
            imageBase64: imageBase64,
            imageType: imageType,
        };
    }
    ctx.drawImage(loaded.img, 0, 0, width, height);
    const outBase64 = await exportBase64("image/jpeg", quality);
    return {
        imageBase64: outBase64,
        imageType: "image/jpeg",
    };
}
function mergeTools(tools1, tools2) {
    let tools = [];
    let toolMap2 = tools2.reduce((map, tool) => {
        map[tool.name] = tool;
        return map;
    }, {});
    let names = [];
    for (let i = 0; i < tools1.length; i++) {
        let tool1 = tools1[i];
        let tool2 = toolMap2[tool1.name];
        if (tool2) {
            tools.push(tool2);
            delete toolMap2[tool1.name];
        }
        else {
            tools.push(tool1);
        }
    }
    for (let i = 0; i < tools2.length; i++) {
        let tool2 = tools2[i];
        if (toolMap2[tool2.name] && names.indexOf(tool2.name) === -1) {
            tools.push(tool2);
            names.push(tool2.name);
        }
    }
    return tools;
}
function mergeAgents(agents1, agents2) {
    let agents = [];
    let agentMap2 = agents2.reduce((map, agent) => {
        map[agent.Name] = agent;
        return map;
    }, {});
    for (let i = 0; i < agents1.length; i++) {
        let agent1 = agents1[i];
        let agent2 = agentMap2[agent1.Name];
        if (agent2) {
            agents.push(agent2);
            delete agentMap2[agent1.Name];
        }
        else {
            agents.push(agent1);
        }
    }
    for (let i = 0; i < agents2.length; i++) {
        let agent2 = agents2[i];
        if (agentMap2[agent2.Name]) {
            agents.push(agent2);
        }
    }
    return agents;
}
function sub(str, maxLength, appendPoint = true) {
    if (!str) {
        return "";
    }
    if (str.length > maxLength) {
        // return str.substring(0, maxLength) + (appendPoint ? "..." : "");
        return (Array.from(str).slice(0, maxLength).join("") + (appendPoint ? "..." : ""));
    }
    return str;
}
function fixJson(code) {
    if (!code) {
        return {};
    }
    try {
        return JSON.parse(code);
    }
    catch (e) { }
    try {
        return JSON.parse(code + '"}');
    }
    catch (e) { }
    const stack = [];
    for (let i = 0; i < code.length; i++) {
        let s = code[i];
        if (s === "{") {
            stack.push("}");
        }
        else if (s === "}") {
            stack.pop();
        }
        else if (s === "[") {
            stack.push("]");
        }
        else if (s === "]") {
            stack.pop();
        }
        else if (s === '"') {
            if (stack[stack.length - 1] === '"') {
                stack.pop();
            }
            else {
                stack.push('"');
            }
        }
    }
    const missingParts = [];
    while (stack.length > 0) {
        missingParts.push(stack.pop());
    }
    let json = code + missingParts.join("");
    try {
        return JSON.parse(json);
    }
    catch (e) {
        return {};
    }
}
function fixXmlTag(code) {
    code = code.trim();
    if (code.endsWith("<")) {
        code = code.substring(0, code.length - 1);
    }
    if (code.indexOf("&") > -1) {
        code = code.replace(/&(?![a-zA-Z0-9#]+;)/g, "&amp;");
    }
    function fixDoubleChar(code) {
        const stack = [];
        for (let i = 0; i < code.length; i++) {
            let s = code[i];
            if (s === "<") {
                stack.push(">");
            }
            else if (s === ">") {
                stack.pop();
            }
            else if (s === '"') {
                if (stack[stack.length - 1] === '"') {
                    stack.pop();
                }
                else {
                    stack.push('"');
                }
            }
        }
        const missingParts = [];
        while (stack.length > 0) {
            missingParts.push(stack.pop());
        }
        return code + missingParts.join("");
    }
    let eIdx = code.lastIndexOf(" ");
    let endStr = eIdx > -1 ? code.substring(eIdx + 1) : "";
    if (code.endsWith("=")) {
        code += '""';
    }
    else if (endStr == "name" ||
        endStr == "id" ||
        endStr == "depen" ||
        endStr == "depends" ||
        endStr == "dependsOn" ||
        endStr == "input" ||
        endStr == "output" ||
        endStr == "items" ||
        endStr == "event" ||
        endStr == "loop") {
        let idx1 = code.lastIndexOf(">");
        let idx2 = code.lastIndexOf("<");
        if (idx1 < idx2 && code.lastIndexOf(" ") > idx2) {
            code += '=""';
        }
    }
    code = fixDoubleChar(code);
    const stack = [];
    function isSelfClosing(tag) {
        return tag.endsWith("/>");
    }
    for (let i = 0; i < code.length; i++) {
        let s = code[i];
        if (s === "<") {
            const isEndTag = code[i + 1] === "/";
            let endIndex = code.indexOf(">", i);
            let tagContent = code.slice(i, endIndex + 1);
            if (isSelfClosing(tagContent)) ;
            else if (isEndTag) {
                stack.pop();
            }
            else {
                stack.push(tagContent);
            }
            if (endIndex == -1) {
                break;
            }
            i = endIndex;
        }
    }
    const missingParts = [];
    while (stack.length > 0) {
        const top = stack.pop();
        if (top.startsWith("<")) {
            let arr = top.match(/<(\w+)/);
            if (arr) {
                const tagName = arr[1];
                missingParts.push(`</${tagName}>`);
            }
        }
        else {
            missingParts.push(top);
        }
    }
    let completedCode = code + missingParts.join("");
    return completedCode;
}
async function loadPackage(packageName) {
    // @ts-ignore
    if (typeof require !== "undefined") {
        try {
            return await __webpack_require__("../../packages/eko-core/dist lazy recursive")(packageName);
        }
        catch {
            // @ts-ignore
            return require(packageName);
        }
    }
    return await __webpack_require__("../../packages/eko-core/dist lazy recursive")(packageName);
}

// src/errors/ai-sdk-error.ts
var marker$1 = "vercel.ai.error";
var symbol$1 = Symbol.for(marker$1);
var _a$1;
var _AISDKError$1 = class _AISDKError extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name14,
    message,
    cause
  }) {
    super(message);
    this[_a$1] = true;
    this.name = name14;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError.hasMarker(error, marker$1);
  }
  static hasMarker(error, marker15) {
    const markerSymbol = Symbol.for(marker15);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a$1 = symbol$1;
var AISDKError$1 = _AISDKError$1;

// src/errors/api-call-error.ts
var name$1 = "AI_APICallError";
var marker2$1 = `vercel.ai.error.${name$1}`;
var symbol2$1 = Symbol.for(marker2$1);
var _a2$1;
var APICallError$1 = class APICallError extends AISDKError$1 {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name: name$1, message, cause });
    this[_a2$1] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker2$1);
  }
};
_a2$1 = symbol2$1;

// src/errors/empty-response-body-error.ts
var name2$1 = "AI_EmptyResponseBodyError";
var marker3$1 = `vercel.ai.error.${name2$1}`;
var symbol3$1 = Symbol.for(marker3$1);
var _a3$1;
var EmptyResponseBodyError$1 = class EmptyResponseBodyError extends AISDKError$1 {
  // used in isInstance
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name2$1, message });
    this[_a3$1] = true;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker3$1);
  }
};
_a3$1 = symbol3$1;

// src/errors/get-error-message.ts
function getErrorMessage$1(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}

// src/errors/invalid-argument-error.ts
var name3$1 = "AI_InvalidArgumentError";
var marker4$1 = `vercel.ai.error.${name3$1}`;
var symbol4$1 = Symbol.for(marker4$1);
var _a4$1;
var InvalidArgumentError$1 = class InvalidArgumentError extends AISDKError$1 {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name3$1, message, cause });
    this[_a4$1] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker4$1);
  }
};
_a4$1 = symbol4$1;

// src/errors/invalid-prompt-error.ts
var name4$1 = "AI_InvalidPromptError";
var marker5$1 = `vercel.ai.error.${name4$1}`;
var symbol5$1 = Symbol.for(marker5$1);
var _a5$1;
var InvalidPromptError$1 = class InvalidPromptError extends AISDKError$1 {
  constructor({
    prompt,
    message,
    cause
  }) {
    super({ name: name4$1, message: `Invalid prompt: ${message}`, cause });
    this[_a5$1] = true;
    this.prompt = prompt;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker5$1);
  }
};
_a5$1 = symbol5$1;

// src/errors/invalid-response-data-error.ts
var name5$1 = "AI_InvalidResponseDataError";
var marker6$1 = `vercel.ai.error.${name5$1}`;
var symbol6$1 = Symbol.for(marker6$1);
var _a6$1;
var InvalidResponseDataError$1 = class InvalidResponseDataError extends AISDKError$1 {
  constructor({
    data,
    message = `Invalid response data: ${JSON.stringify(data)}.`
  }) {
    super({ name: name5$1, message });
    this[_a6$1] = true;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker6$1);
  }
};
_a6$1 = symbol6$1;

// src/errors/json-parse-error.ts
var name6$1 = "AI_JSONParseError";
var marker7$1 = `vercel.ai.error.${name6$1}`;
var symbol7$1 = Symbol.for(marker7$1);
var _a7$1;
var JSONParseError$1 = class JSONParseError extends AISDKError$1 {
  constructor({ text, cause }) {
    super({
      name: name6$1,
      message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage$1(cause)}`,
      cause
    });
    this[_a7$1] = true;
    this.text = text;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker7$1);
  }
};
_a7$1 = symbol7$1;

// src/errors/load-api-key-error.ts
var name7$1 = "AI_LoadAPIKeyError";
var marker8$1 = `vercel.ai.error.${name7$1}`;
var symbol8$1 = Symbol.for(marker8$1);
var _a8$1;
var LoadAPIKeyError$1 = class LoadAPIKeyError extends AISDKError$1 {
  // used in isInstance
  constructor({ message }) {
    super({ name: name7$1, message });
    this[_a8$1] = true;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker8$1);
  }
};
_a8$1 = symbol8$1;

// src/errors/load-setting-error.ts
var name8 = "AI_LoadSettingError";
var marker9 = `vercel.ai.error.${name8}`;
var symbol9 = Symbol.for(marker9);
var _a9;
var LoadSettingError = class extends AISDKError$1 {
  // used in isInstance
  constructor({ message }) {
    super({ name: name8, message });
    this[_a9] = true;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker9);
  }
};
_a9 = symbol9;

// src/errors/no-such-model-error.ts
var name10 = "AI_NoSuchModelError";
var marker11 = `vercel.ai.error.${name10}`;
var symbol11 = Symbol.for(marker11);
var _a11;
var NoSuchModelError = class extends AISDKError$1 {
  constructor({
    errorName = name10,
    modelId,
    modelType,
    message = `No such ${modelType}: ${modelId}`
  }) {
    super({ name: errorName, message });
    this[_a11] = true;
    this.modelId = modelId;
    this.modelType = modelType;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker11);
  }
};
_a11 = symbol11;

// src/errors/too-many-embedding-values-for-call-error.ts
var name11 = "AI_TooManyEmbeddingValuesForCallError";
var marker12 = `vercel.ai.error.${name11}`;
var symbol12 = Symbol.for(marker12);
var _a12;
var TooManyEmbeddingValuesForCallError = class extends AISDKError$1 {
  constructor(options) {
    super({
      name: name11,
      message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
    });
    this[_a12] = true;
    this.provider = options.provider;
    this.modelId = options.modelId;
    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
    this.values = options.values;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker12);
  }
};
_a12 = symbol12;

// src/errors/type-validation-error.ts
var name12$1 = "AI_TypeValidationError";
var marker13$1 = `vercel.ai.error.${name12$1}`;
var symbol13$1 = Symbol.for(marker13$1);
var _a13$1;
var _TypeValidationError$1 = class _TypeValidationError extends AISDKError$1 {
  constructor({ value, cause }) {
    super({
      name: name12$1,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage$1(cause)}`,
      cause
    });
    this[_a13$1] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker13$1);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });
  }
};
_a13$1 = symbol13$1;
var TypeValidationError$1 = _TypeValidationError$1;

// src/errors/unsupported-functionality-error.ts
var name13$1 = "AI_UnsupportedFunctionalityError";
var marker14$1 = `vercel.ai.error.${name13$1}`;
var symbol14$1 = Symbol.for(marker14$1);
var _a14$1;
var UnsupportedFunctionalityError$1 = class UnsupportedFunctionalityError extends AISDKError$1 {
  constructor({
    functionality,
    message = `'${functionality}' functionality not supported.`
  }) {
    super({ name: name13$1, message });
    this[_a14$1] = true;
    this.functionality = functionality;
  }
  static isInstance(error) {
    return AISDKError$1.hasMarker(error, marker14$1);
  }
};
_a14$1 = symbol14$1;

let ParseError$1 = class ParseError extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop$1(_arg) {
}
function createParser$1(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop$1, onError = noop$1, onRetry = noop$1, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines$1(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError$1(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError$1(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines$1(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}

let EventSourceParserStream$1 = class EventSourceParserStream extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser$1({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};

/** A special constant with type `never` */
function $constructor(name, initializer, params) {
    function init(inst, def) {
        var _a;
        Object.defineProperty(inst, "_zod", {
            value: inst._zod ?? {},
            enumerable: false,
        });
        (_a = inst._zod).traits ?? (_a.traits = new Set());
        inst._zod.traits.add(name);
        initializer(inst, def);
        // support prototype modifications
        for (const k in _.prototype) {
            if (!(k in inst))
                Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
        }
        inst._zod.constr = _;
        inst._zod.def = def;
    }
    // doesn't work if Parent has a constructor with arguments
    const Parent = params?.Parent ?? Object;
    class Definition extends Parent {
    }
    Object.defineProperty(Definition, "name", { value: name });
    function _(def) {
        var _a;
        const inst = params?.Parent ? new Definition() : this;
        init(inst, def);
        (_a = inst._zod).deferred ?? (_a.deferred = []);
        for (const fn of inst._zod.deferred) {
            fn();
        }
        return inst;
    }
    Object.defineProperty(_, "init", { value: init });
    Object.defineProperty(_, Symbol.hasInstance, {
        value: (inst) => {
            if (params?.Parent && inst instanceof params.Parent)
                return true;
            return inst?._zod?.traits?.has(name);
        },
    });
    Object.defineProperty(_, "name", { value: name });
    return _;
}
class $ZodAsyncError extends Error {
    constructor() {
        super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
    }
}
class $ZodEncodeError extends Error {
    constructor(name) {
        super(`Encountered unidirectional transform during encode: ${name}`);
        this.name = "ZodEncodeError";
    }
}
const globalConfig = {};
function config(newConfig) {
    return globalConfig;
}

// functions
function getEnumValues(entries) {
    const numericValues = Object.values(entries).filter((v) => typeof v === "number");
    const values = Object.entries(entries)
        .filter(([k, _]) => numericValues.indexOf(+k) === -1)
        .map(([_, v]) => v);
    return values;
}
function jsonStringifyReplacer(_, value) {
    if (typeof value === "bigint")
        return value.toString();
    return value;
}
function cached(getter) {
    return {
        get value() {
            {
                const value = getter();
                Object.defineProperty(this, "value", { value });
                return value;
            }
        },
    };
}
function nullish(input) {
    return input === null || input === undefined;
}
function cleanRegex(source) {
    const start = source.startsWith("^") ? 1 : 0;
    const end = source.endsWith("$") ? source.length - 1 : source.length;
    return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
    const valDecCount = (val.toString().split(".")[1] || "").length;
    const stepString = step.toString();
    let stepDecCount = (stepString.split(".")[1] || "").length;
    if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
        const match = stepString.match(/\d?e-(\d?)/);
        if (match?.[1]) {
            stepDecCount = Number.parseInt(match[1]);
        }
    }
    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
    const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
    const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
    return (valInt % stepInt) / 10 ** decCount;
}
const EVALUATING = Symbol("evaluating");
function defineLazy(object, key, getter) {
    let value = undefined;
    Object.defineProperty(object, key, {
        get() {
            if (value === EVALUATING) {
                // Circular reference detected, return undefined to break the cycle
                return undefined;
            }
            if (value === undefined) {
                value = EVALUATING;
                value = getter();
            }
            return value;
        },
        set(v) {
            Object.defineProperty(object, key, {
                value: v,
                // configurable: true,
            });
            // object[key] = v;
        },
        configurable: true,
    });
}
function assignProp(target, prop, value) {
    Object.defineProperty(target, prop, {
        value,
        writable: true,
        enumerable: true,
        configurable: true,
    });
}
function mergeDefs(...defs) {
    const mergedDescriptors = {};
    for (const def of defs) {
        const descriptors = Object.getOwnPropertyDescriptors(def);
        Object.assign(mergedDescriptors, descriptors);
    }
    return Object.defineProperties({}, mergedDescriptors);
}
function esc(str) {
    return JSON.stringify(str);
}
const captureStackTrace = ("captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => { });
function isObject(data) {
    return typeof data === "object" && data !== null && !Array.isArray(data);
}
const allowsEval = cached(() => {
    // @ts-ignore
    if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
        return false;
    }
    try {
        const F = Function;
        new F("");
        return true;
    }
    catch (_) {
        return false;
    }
});
function isPlainObject(o) {
    if (isObject(o) === false)
        return false;
    // modified constructor
    const ctor = o.constructor;
    if (ctor === undefined)
        return true;
    // modified prototype
    const prot = ctor.prototype;
    if (isObject(prot) === false)
        return false;
    // ctor doesn't have static `isPrototypeOf`
    if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
        return false;
    }
    return true;
}
function shallowClone(o) {
    if (isPlainObject(o))
        return { ...o };
    if (Array.isArray(o))
        return [...o];
    return o;
}
const propertyKeyTypes = new Set(["string", "number", "symbol"]);
function escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
// zod-specific utils
function clone(inst, def, params) {
    const cl = new inst._zod.constr(def ?? inst._zod.def);
    if (!def || params?.parent)
        cl._zod.parent = inst;
    return cl;
}
function normalizeParams(_params) {
    const params = _params;
    if (!params)
        return {};
    if (typeof params === "string")
        return { error: () => params };
    if (params?.message !== undefined) {
        if (params?.error !== undefined)
            throw new Error("Cannot specify both `message` and `error` params");
        params.error = params.message;
    }
    delete params.message;
    if (typeof params.error === "string")
        return { ...params, error: () => params.error };
    return params;
}
function optionalKeys(shape) {
    return Object.keys(shape).filter((k) => {
        return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
    });
}
const NUMBER_FORMAT_RANGES = {
    safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
    int32: [-2147483648, 2147483647],
    uint32: [0, 4294967295],
    float32: [-34028234663852886e22, 3.4028234663852886e38],
    float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
};
function pick(schema, mask) {
    const currDef = schema._zod.def;
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const newShape = {};
            for (const key in mask) {
                if (!(key in currDef.shape)) {
                    throw new Error(`Unrecognized key: "${key}"`);
                }
                if (!mask[key])
                    continue;
                newShape[key] = currDef.shape[key];
            }
            assignProp(this, "shape", newShape); // self-caching
            return newShape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function omit(schema, mask) {
    const currDef = schema._zod.def;
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const newShape = { ...schema._zod.def.shape };
            for (const key in mask) {
                if (!(key in currDef.shape)) {
                    throw new Error(`Unrecognized key: "${key}"`);
                }
                if (!mask[key])
                    continue;
                delete newShape[key];
            }
            assignProp(this, "shape", newShape); // self-caching
            return newShape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function extend(schema, shape) {
    if (!isPlainObject(shape)) {
        throw new Error("Invalid input to extend: expected a plain object");
    }
    const checks = schema._zod.def.checks;
    const hasChecks = checks && checks.length > 0;
    if (hasChecks) {
        throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
    }
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const _shape = { ...schema._zod.def.shape, ...shape };
            assignProp(this, "shape", _shape); // self-caching
            return _shape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function safeExtend(schema, shape) {
    if (!isPlainObject(shape)) {
        throw new Error("Invalid input to safeExtend: expected a plain object");
    }
    const def = {
        ...schema._zod.def,
        get shape() {
            const _shape = { ...schema._zod.def.shape, ...shape };
            assignProp(this, "shape", _shape); // self-caching
            return _shape;
        },
        checks: schema._zod.def.checks,
    };
    return clone(schema, def);
}
function merge(a, b) {
    const def = mergeDefs(a._zod.def, {
        get shape() {
            const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
            assignProp(this, "shape", _shape); // self-caching
            return _shape;
        },
        get catchall() {
            return b._zod.def.catchall;
        },
        checks: [], // delete existing checks
    });
    return clone(a, def);
}
function partial(Class, schema, mask) {
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const oldShape = schema._zod.def.shape;
            const shape = { ...oldShape };
            if (mask) {
                for (const key in mask) {
                    if (!(key in oldShape)) {
                        throw new Error(`Unrecognized key: "${key}"`);
                    }
                    if (!mask[key])
                        continue;
                    // if (oldShape[key]!._zod.optin === "optional") continue;
                    shape[key] = Class
                        ? new Class({
                            type: "optional",
                            innerType: oldShape[key],
                        })
                        : oldShape[key];
                }
            }
            else {
                for (const key in oldShape) {
                    // if (oldShape[key]!._zod.optin === "optional") continue;
                    shape[key] = Class
                        ? new Class({
                            type: "optional",
                            innerType: oldShape[key],
                        })
                        : oldShape[key];
                }
            }
            assignProp(this, "shape", shape); // self-caching
            return shape;
        },
        checks: [],
    });
    return clone(schema, def);
}
function required(Class, schema, mask) {
    const def = mergeDefs(schema._zod.def, {
        get shape() {
            const oldShape = schema._zod.def.shape;
            const shape = { ...oldShape };
            if (mask) {
                for (const key in mask) {
                    if (!(key in shape)) {
                        throw new Error(`Unrecognized key: "${key}"`);
                    }
                    if (!mask[key])
                        continue;
                    // overwrite with non-optional
                    shape[key] = new Class({
                        type: "nonoptional",
                        innerType: oldShape[key],
                    });
                }
            }
            else {
                for (const key in oldShape) {
                    // overwrite with non-optional
                    shape[key] = new Class({
                        type: "nonoptional",
                        innerType: oldShape[key],
                    });
                }
            }
            assignProp(this, "shape", shape); // self-caching
            return shape;
        },
        checks: [],
    });
    return clone(schema, def);
}
// invalid_type | too_big | too_small | invalid_format | not_multiple_of | unrecognized_keys | invalid_union | invalid_key | invalid_element | invalid_value | custom
function aborted(x, startIndex = 0) {
    if (x.aborted === true)
        return true;
    for (let i = startIndex; i < x.issues.length; i++) {
        if (x.issues[i]?.continue !== true) {
            return true;
        }
    }
    return false;
}
function prefixIssues(path, issues) {
    return issues.map((iss) => {
        var _a;
        (_a = iss).path ?? (_a.path = []);
        iss.path.unshift(path);
        return iss;
    });
}
function unwrapMessage(message) {
    return typeof message === "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config) {
    const full = { ...iss, path: iss.path ?? [] };
    // for backwards compatibility
    if (!iss.message) {
        const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??
            unwrapMessage(ctx?.error?.(iss)) ??
            unwrapMessage(config.customError?.(iss)) ??
            unwrapMessage(config.localeError?.(iss)) ??
            "Invalid input";
        full.message = message;
    }
    // delete (full as any).def;
    delete full.inst;
    delete full.continue;
    if (!ctx?.reportInput) {
        delete full.input;
    }
    return full;
}
function getLengthableOrigin(input) {
    if (Array.isArray(input))
        return "array";
    if (typeof input === "string")
        return "string";
    return "unknown";
}
function issue(...args) {
    const [iss, input, inst] = args;
    if (typeof iss === "string") {
        return {
            message: iss,
            code: "custom",
            input,
            inst,
        };
    }
    return { ...iss };
}

const initializer$1 = (inst, def) => {
    inst.name = "$ZodError";
    Object.defineProperty(inst, "_zod", {
        value: inst._zod,
        enumerable: false,
    });
    Object.defineProperty(inst, "issues", {
        value: def,
        enumerable: false,
    });
    inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
    Object.defineProperty(inst, "toString", {
        value: () => inst.message,
        enumerable: false,
    });
};
const $ZodError = $constructor("$ZodError", initializer$1);
const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
function flattenError(error, mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of error.issues) {
        if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
        }
        else {
            formErrors.push(mapper(sub));
        }
    }
    return { formErrors, fieldErrors };
}
function formatError(error, mapper = (issue) => issue.message) {
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
        for (const issue of error.issues) {
            if (issue.code === "invalid_union" && issue.errors.length) {
                issue.errors.map((issues) => processError({ issues }));
            }
            else if (issue.code === "invalid_key") {
                processError({ issues: issue.issues });
            }
            else if (issue.code === "invalid_element") {
                processError({ issues: issue.issues });
            }
            else if (issue.path.length === 0) {
                fieldErrors._errors.push(mapper(issue));
            }
            else {
                let curr = fieldErrors;
                let i = 0;
                while (i < issue.path.length) {
                    const el = issue.path[i];
                    const terminal = i === issue.path.length - 1;
                    if (!terminal) {
                        curr[el] = curr[el] || { _errors: [] };
                    }
                    else {
                        curr[el] = curr[el] || { _errors: [] };
                        curr[el]._errors.push(mapper(issue));
                    }
                    curr = curr[el];
                    i++;
                }
            }
        }
    };
    processError(error);
    return fieldErrors;
}

const _parse$2 = (_Err) => (schema, value, _ctx, _params) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
    const result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise) {
        throw new $ZodAsyncError();
    }
    if (result.issues.length) {
        const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, _params?.callee);
        throw e;
    }
    return result.value;
};
const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
    let result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise)
        result = await result;
    if (result.issues.length) {
        const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
        captureStackTrace(e, params?.callee);
        throw e;
    }
    return result.value;
};
const _safeParse = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
    const result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise) {
        throw new $ZodAsyncError();
    }
    return result.issues.length
        ? {
            success: false,
            error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config()))),
        }
        : { success: true, data: result.value };
};
const safeParse$1 = /* @__PURE__*/ _safeParse($ZodRealError);
const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
    let result = schema._zod.run({ value, issues: [] }, ctx);
    if (result instanceof Promise)
        result = await result;
    return result.issues.length
        ? {
            success: false,
            error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config()))),
        }
        : { success: true, data: result.value };
};
const safeParseAsync$1 = /* @__PURE__*/ _safeParseAsync($ZodRealError);
const _encode = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _parse$2(_Err)(schema, value, ctx);
};
const _decode = (_Err) => (schema, value, _ctx) => {
    return _parse$2(_Err)(schema, value, _ctx);
};
const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _parseAsync(_Err)(schema, value, ctx);
};
const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
    return _parseAsync(_Err)(schema, value, _ctx);
};
const _safeEncode = (_Err) => (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _safeParse(_Err)(schema, value, ctx);
};
const _safeDecode = (_Err) => (schema, value, _ctx) => {
    return _safeParse(_Err)(schema, value, _ctx);
};
const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
    const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
    return _safeParseAsync(_Err)(schema, value, ctx);
};
const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
    return _safeParseAsync(_Err)(schema, value, _ctx);
};

const cuid = /^[cC][^\s-]{8,}$/;
const cuid2 = /^[0-9a-z]+$/;
const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
const xid = /^[0-9a-vA-V]{20}$/;
const ksuid = /^[A-Za-z0-9]{27}$/;
const nanoid = /^[a-zA-Z0-9_-]{21}$/;
/** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */
const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
/** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */
const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
/** Returns a regex for validating an RFC 9562/4122 UUID.
 *
 * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */
const uuid = (version) => {
    if (!version)
        return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
    return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
/** Practical email validation */
const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
// from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
    return new RegExp(_emoji$1, "u");
}
const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
// https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
const base64url = /^[A-Za-z0-9_-]*$/;
// based on https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address
// export const hostname: RegExp = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
const hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
// https://blog.stevenlevithan.com/archives/validate-phone-number#r4-3 (regex sans spaces)
const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
// const dateSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
const date$1 = /*@__PURE__*/ new RegExp(`^${dateSource}$`);
function timeSource(args) {
    const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
    const regex = typeof args.precision === "number"
        ? args.precision === -1
            ? `${hhmm}`
            : args.precision === 0
                ? `${hhmm}:[0-5]\\d`
                : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}`
        : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
    return regex;
}
function time$1(args) {
    return new RegExp(`^${timeSource(args)}$`);
}
// Adapted from https://stackoverflow.com/a/3143231
function datetime$1(args) {
    const time = timeSource({ precision: args.precision });
    const opts = ["Z"];
    if (args.local)
        opts.push("");
    // if (args.offset) opts.push(`([+-]\\d{2}:\\d{2})`);
    if (args.offset)
        opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
    const timeRegex = `${time}(?:${opts.join("|")})`;
    return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
const string$1 = (params) => {
    const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
    return new RegExp(`^${regex}$`);
};
const integer = /^-?\d+$/;
const number$2 = /^-?\d+(?:\.\d+)?/;
const boolean$1 = /^(?:true|false)$/i;
// regex for string with no uppercase letters
const lowercase = /^[^A-Z]*$/;
// regex for string with no lowercase letters
const uppercase = /^[^a-z]*$/;

// import { $ZodType } from "./schemas.js";
const $ZodCheck = /*@__PURE__*/ $constructor("$ZodCheck", (inst, def) => {
    var _a;
    inst._zod ?? (inst._zod = {});
    inst._zod.def = def;
    (_a = inst._zod).onattach ?? (_a.onattach = []);
});
const numericOriginMap = {
    number: "number",
    bigint: "bigint",
    object: "date",
};
const $ZodCheckLessThan = /*@__PURE__*/ $constructor("$ZodCheckLessThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
        if (def.value < curr) {
            if (def.inclusive)
                bag.maximum = def.value;
            else
                bag.exclusiveMaximum = def.value;
        }
    });
    inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
            return;
        }
        payload.issues.push({
            origin,
            code: "too_big",
            maximum: def.value,
            input: payload.value,
            inclusive: def.inclusive,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckGreaterThan = /*@__PURE__*/ $constructor("$ZodCheckGreaterThan", (inst, def) => {
    $ZodCheck.init(inst, def);
    const origin = numericOriginMap[typeof def.value];
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
        if (def.value > curr) {
            if (def.inclusive)
                bag.minimum = def.value;
            else
                bag.exclusiveMinimum = def.value;
        }
    });
    inst._zod.check = (payload) => {
        if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
            return;
        }
        payload.issues.push({
            origin,
            code: "too_small",
            minimum: def.value,
            input: payload.value,
            inclusive: def.inclusive,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckMultipleOf = 
/*@__PURE__*/ $constructor("$ZodCheckMultipleOf", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst) => {
        var _a;
        (_a = inst._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
    });
    inst._zod.check = (payload) => {
        if (typeof payload.value !== typeof def.value)
            throw new Error("Cannot mix number and bigint in multiple_of check.");
        const isMultiple = typeof payload.value === "bigint"
            ? payload.value % def.value === BigInt(0)
            : floatSafeRemainder(payload.value, def.value) === 0;
        if (isMultiple)
            return;
        payload.issues.push({
            origin: typeof payload.value,
            code: "not_multiple_of",
            divisor: def.value,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckNumberFormat = /*@__PURE__*/ $constructor("$ZodCheckNumberFormat", (inst, def) => {
    $ZodCheck.init(inst, def); // no format checks
    def.format = def.format || "float64";
    const isInt = def.format?.includes("int");
    const origin = isInt ? "int" : "number";
    const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.format = def.format;
        bag.minimum = minimum;
        bag.maximum = maximum;
        if (isInt)
            bag.pattern = integer;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        if (isInt) {
            if (!Number.isInteger(input)) {
                // invalid_format issue
                // payload.issues.push({
                //   expected: def.format,
                //   format: def.format,
                //   code: "invalid_format",
                //   input,
                //   inst,
                // });
                // invalid_type issue
                payload.issues.push({
                    expected: origin,
                    format: def.format,
                    code: "invalid_type",
                    continue: false,
                    input,
                    inst,
                });
                return;
                // not_multiple_of issue
                // payload.issues.push({
                //   code: "not_multiple_of",
                //   origin: "number",
                //   input,
                //   inst,
                //   divisor: 1,
                // });
            }
            if (!Number.isSafeInteger(input)) {
                if (input > 0) {
                    // too_big
                    payload.issues.push({
                        input,
                        code: "too_big",
                        maximum: Number.MAX_SAFE_INTEGER,
                        note: "Integers must be within the safe integer range.",
                        inst,
                        origin,
                        continue: !def.abort,
                    });
                }
                else {
                    // too_small
                    payload.issues.push({
                        input,
                        code: "too_small",
                        minimum: Number.MIN_SAFE_INTEGER,
                        note: "Integers must be within the safe integer range.",
                        inst,
                        origin,
                        continue: !def.abort,
                    });
                }
                return;
            }
        }
        if (input < minimum) {
            payload.issues.push({
                origin: "number",
                input,
                code: "too_small",
                minimum,
                inclusive: true,
                inst,
                continue: !def.abort,
            });
        }
        if (input > maximum) {
            payload.issues.push({
                origin: "number",
                input,
                code: "too_big",
                maximum,
                inst,
            });
        }
    };
});
const $ZodCheckMaxLength = /*@__PURE__*/ $constructor("$ZodCheckMaxLength", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst) => {
        const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY);
        if (def.maximum < curr)
            inst._zod.bag.maximum = def.maximum;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length <= def.maximum)
            return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
            origin,
            code: "too_big",
            maximum: def.maximum,
            inclusive: true,
            input,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckMinLength = /*@__PURE__*/ $constructor("$ZodCheckMinLength", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst) => {
        const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY);
        if (def.minimum > curr)
            inst._zod.bag.minimum = def.minimum;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length >= def.minimum)
            return;
        const origin = getLengthableOrigin(input);
        payload.issues.push({
            origin,
            code: "too_small",
            minimum: def.minimum,
            inclusive: true,
            input,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckLengthEquals = /*@__PURE__*/ $constructor("$ZodCheckLengthEquals", (inst, def) => {
    var _a;
    $ZodCheck.init(inst, def);
    (_a = inst._zod.def).when ?? (_a.when = (payload) => {
        const val = payload.value;
        return !nullish(val) && val.length !== undefined;
    });
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.minimum = def.length;
        bag.maximum = def.length;
        bag.length = def.length;
    });
    inst._zod.check = (payload) => {
        const input = payload.value;
        const length = input.length;
        if (length === def.length)
            return;
        const origin = getLengthableOrigin(input);
        const tooBig = length > def.length;
        payload.issues.push({
            origin,
            ...(tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length }),
            inclusive: true,
            exact: true,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckStringFormat = /*@__PURE__*/ $constructor("$ZodCheckStringFormat", (inst, def) => {
    var _a, _b;
    $ZodCheck.init(inst, def);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.format = def.format;
        if (def.pattern) {
            bag.patterns ?? (bag.patterns = new Set());
            bag.patterns.add(def.pattern);
        }
    });
    if (def.pattern)
        (_a = inst._zod).check ?? (_a.check = (payload) => {
            def.pattern.lastIndex = 0;
            if (def.pattern.test(payload.value))
                return;
            payload.issues.push({
                origin: "string",
                code: "invalid_format",
                format: def.format,
                input: payload.value,
                ...(def.pattern ? { pattern: def.pattern.toString() } : {}),
                inst,
                continue: !def.abort,
            });
        });
    else
        (_b = inst._zod).check ?? (_b.check = () => { });
});
const $ZodCheckRegex = /*@__PURE__*/ $constructor("$ZodCheckRegex", (inst, def) => {
    $ZodCheckStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
        def.pattern.lastIndex = 0;
        if (def.pattern.test(payload.value))
            return;
        payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "regex",
            input: payload.value,
            pattern: def.pattern.toString(),
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckLowerCase = /*@__PURE__*/ $constructor("$ZodCheckLowerCase", (inst, def) => {
    def.pattern ?? (def.pattern = lowercase);
    $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckUpperCase = /*@__PURE__*/ $constructor("$ZodCheckUpperCase", (inst, def) => {
    def.pattern ?? (def.pattern = uppercase);
    $ZodCheckStringFormat.init(inst, def);
});
const $ZodCheckIncludes = /*@__PURE__*/ $constructor("$ZodCheckIncludes", (inst, def) => {
    $ZodCheck.init(inst, def);
    const escapedRegex = escapeRegex(def.includes);
    const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
    def.pattern = pattern;
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.patterns ?? (bag.patterns = new Set());
        bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
        if (payload.value.includes(def.includes, def.position))
            return;
        payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "includes",
            includes: def.includes,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckStartsWith = /*@__PURE__*/ $constructor("$ZodCheckStartsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.patterns ?? (bag.patterns = new Set());
        bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
        if (payload.value.startsWith(def.prefix))
            return;
        payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "starts_with",
            prefix: def.prefix,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckEndsWith = /*@__PURE__*/ $constructor("$ZodCheckEndsWith", (inst, def) => {
    $ZodCheck.init(inst, def);
    const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
    def.pattern ?? (def.pattern = pattern);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.patterns ?? (bag.patterns = new Set());
        bag.patterns.add(pattern);
    });
    inst._zod.check = (payload) => {
        if (payload.value.endsWith(def.suffix))
            return;
        payload.issues.push({
            origin: "string",
            code: "invalid_format",
            format: "ends_with",
            suffix: def.suffix,
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodCheckOverwrite = /*@__PURE__*/ $constructor("$ZodCheckOverwrite", (inst, def) => {
    $ZodCheck.init(inst, def);
    inst._zod.check = (payload) => {
        payload.value = def.tx(payload.value);
    };
});

class Doc {
    constructor(args = []) {
        this.content = [];
        this.indent = 0;
        if (this)
            this.args = args;
    }
    indented(fn) {
        this.indent += 1;
        fn(this);
        this.indent -= 1;
    }
    write(arg) {
        if (typeof arg === "function") {
            arg(this, { execution: "sync" });
            arg(this, { execution: "async" });
            return;
        }
        const content = arg;
        const lines = content.split("\n").filter((x) => x);
        const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
        const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
        for (const line of dedented) {
            this.content.push(line);
        }
    }
    compile() {
        const F = Function;
        const args = this?.args;
        const content = this?.content ?? [``];
        const lines = [...content.map((x) => `  ${x}`)];
        // console.log(lines.join("\n"));
        return new F(...args, lines.join("\n"));
    }
}

const version = {
    major: 4,
    minor: 1,
    patch: 12,
};

const $ZodType = /*@__PURE__*/ $constructor("$ZodType", (inst, def) => {
    var _a;
    inst ?? (inst = {});
    inst._zod.def = def; // set _def property
    inst._zod.bag = inst._zod.bag || {}; // initialize _bag object
    inst._zod.version = version;
    const checks = [...(inst._zod.def.checks ?? [])];
    // if inst is itself a checks.$ZodCheck, run it as a check
    if (inst._zod.traits.has("$ZodCheck")) {
        checks.unshift(inst);
    }
    for (const ch of checks) {
        for (const fn of ch._zod.onattach) {
            fn(inst);
        }
    }
    if (checks.length === 0) {
        // deferred initializer
        // inst._zod.parse is not yet defined
        (_a = inst._zod).deferred ?? (_a.deferred = []);
        inst._zod.deferred?.push(() => {
            inst._zod.run = inst._zod.parse;
        });
    }
    else {
        const runChecks = (payload, checks, ctx) => {
            let isAborted = aborted(payload);
            let asyncResult;
            for (const ch of checks) {
                if (ch._zod.def.when) {
                    const shouldRun = ch._zod.def.when(payload);
                    if (!shouldRun)
                        continue;
                }
                else if (isAborted) {
                    continue;
                }
                const currLen = payload.issues.length;
                const _ = ch._zod.check(payload);
                if (_ instanceof Promise && ctx?.async === false) {
                    throw new $ZodAsyncError();
                }
                if (asyncResult || _ instanceof Promise) {
                    asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                        await _;
                        const nextLen = payload.issues.length;
                        if (nextLen === currLen)
                            return;
                        if (!isAborted)
                            isAborted = aborted(payload, currLen);
                    });
                }
                else {
                    const nextLen = payload.issues.length;
                    if (nextLen === currLen)
                        continue;
                    if (!isAborted)
                        isAborted = aborted(payload, currLen);
                }
            }
            if (asyncResult) {
                return asyncResult.then(() => {
                    return payload;
                });
            }
            return payload;
        };
        // const handleChecksResult = (
        //   checkResult: ParsePayload,
        //   originalResult: ParsePayload,
        //   ctx: ParseContextInternal
        // ): util.MaybeAsync<ParsePayload> => {
        //   // if the checks mutated the value && there are no issues, re-parse the result
        //   if (checkResult.value !== originalResult.value && !checkResult.issues.length)
        //     return inst._zod.parse(checkResult, ctx);
        //   return originalResult;
        // };
        const handleCanaryResult = (canary, payload, ctx) => {
            // abort if the canary is aborted
            if (aborted(canary)) {
                canary.aborted = true;
                return canary;
            }
            // run checks first, then
            const checkResult = runChecks(payload, checks, ctx);
            if (checkResult instanceof Promise) {
                if (ctx.async === false)
                    throw new $ZodAsyncError();
                return checkResult.then((checkResult) => inst._zod.parse(checkResult, ctx));
            }
            return inst._zod.parse(checkResult, ctx);
        };
        inst._zod.run = (payload, ctx) => {
            if (ctx.skipChecks) {
                return inst._zod.parse(payload, ctx);
            }
            if (ctx.direction === "backward") {
                // run canary
                // initial pass (no checks)
                const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
                if (canary instanceof Promise) {
                    return canary.then((canary) => {
                        return handleCanaryResult(canary, payload, ctx);
                    });
                }
                return handleCanaryResult(canary, payload, ctx);
            }
            // forward
            const result = inst._zod.parse(payload, ctx);
            if (result instanceof Promise) {
                if (ctx.async === false)
                    throw new $ZodAsyncError();
                return result.then((result) => runChecks(result, checks, ctx));
            }
            return runChecks(result, checks, ctx);
        };
    }
    inst["~standard"] = {
        validate: (value) => {
            try {
                const r = safeParse$1(inst, value);
                return r.success ? { value: r.data } : { issues: r.error?.issues };
            }
            catch (_) {
                return safeParseAsync$1(inst, value).then((r) => (r.success ? { value: r.data } : { issues: r.error?.issues }));
            }
        },
        vendor: "zod",
        version: 1,
    };
});
const $ZodString = /*@__PURE__*/ $constructor("$ZodString", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? string$1(inst._zod.bag);
    inst._zod.parse = (payload, _) => {
        if (def.coerce)
            try {
                payload.value = String(payload.value);
            }
            catch (_) { }
        if (typeof payload.value === "string")
            return payload;
        payload.issues.push({
            expected: "string",
            code: "invalid_type",
            input: payload.value,
            inst,
        });
        return payload;
    };
});
const $ZodStringFormat = /*@__PURE__*/ $constructor("$ZodStringFormat", (inst, def) => {
    // check initialization must come first
    $ZodCheckStringFormat.init(inst, def);
    $ZodString.init(inst, def);
});
const $ZodGUID = /*@__PURE__*/ $constructor("$ZodGUID", (inst, def) => {
    def.pattern ?? (def.pattern = guid);
    $ZodStringFormat.init(inst, def);
});
const $ZodUUID = /*@__PURE__*/ $constructor("$ZodUUID", (inst, def) => {
    if (def.version) {
        const versionMap = {
            v1: 1,
            v2: 2,
            v3: 3,
            v4: 4,
            v5: 5,
            v6: 6,
            v7: 7,
            v8: 8,
        };
        const v = versionMap[def.version];
        if (v === undefined)
            throw new Error(`Invalid UUID version: "${def.version}"`);
        def.pattern ?? (def.pattern = uuid(v));
    }
    else
        def.pattern ?? (def.pattern = uuid());
    $ZodStringFormat.init(inst, def);
});
const $ZodEmail = /*@__PURE__*/ $constructor("$ZodEmail", (inst, def) => {
    def.pattern ?? (def.pattern = email);
    $ZodStringFormat.init(inst, def);
});
const $ZodURL = /*@__PURE__*/ $constructor("$ZodURL", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
        try {
            // Trim whitespace from input
            const trimmed = payload.value.trim();
            // @ts-ignore
            const url = new URL(trimmed);
            if (def.hostname) {
                def.hostname.lastIndex = 0;
                if (!def.hostname.test(url.hostname)) {
                    payload.issues.push({
                        code: "invalid_format",
                        format: "url",
                        note: "Invalid hostname",
                        pattern: hostname.source,
                        input: payload.value,
                        inst,
                        continue: !def.abort,
                    });
                }
            }
            if (def.protocol) {
                def.protocol.lastIndex = 0;
                if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
                    payload.issues.push({
                        code: "invalid_format",
                        format: "url",
                        note: "Invalid protocol",
                        pattern: def.protocol.source,
                        input: payload.value,
                        inst,
                        continue: !def.abort,
                    });
                }
            }
            // Set the output value based on normalize flag
            if (def.normalize) {
                // Use normalized URL
                payload.value = url.href;
            }
            else {
                // Preserve the original input (trimmed)
                payload.value = trimmed;
            }
            return;
        }
        catch (_) {
            payload.issues.push({
                code: "invalid_format",
                format: "url",
                input: payload.value,
                inst,
                continue: !def.abort,
            });
        }
    };
});
const $ZodEmoji = /*@__PURE__*/ $constructor("$ZodEmoji", (inst, def) => {
    def.pattern ?? (def.pattern = emoji());
    $ZodStringFormat.init(inst, def);
});
const $ZodNanoID = /*@__PURE__*/ $constructor("$ZodNanoID", (inst, def) => {
    def.pattern ?? (def.pattern = nanoid);
    $ZodStringFormat.init(inst, def);
});
const $ZodCUID = /*@__PURE__*/ $constructor("$ZodCUID", (inst, def) => {
    def.pattern ?? (def.pattern = cuid);
    $ZodStringFormat.init(inst, def);
});
const $ZodCUID2 = /*@__PURE__*/ $constructor("$ZodCUID2", (inst, def) => {
    def.pattern ?? (def.pattern = cuid2);
    $ZodStringFormat.init(inst, def);
});
const $ZodULID = /*@__PURE__*/ $constructor("$ZodULID", (inst, def) => {
    def.pattern ?? (def.pattern = ulid);
    $ZodStringFormat.init(inst, def);
});
const $ZodXID = /*@__PURE__*/ $constructor("$ZodXID", (inst, def) => {
    def.pattern ?? (def.pattern = xid);
    $ZodStringFormat.init(inst, def);
});
const $ZodKSUID = /*@__PURE__*/ $constructor("$ZodKSUID", (inst, def) => {
    def.pattern ?? (def.pattern = ksuid);
    $ZodStringFormat.init(inst, def);
});
const $ZodISODateTime = /*@__PURE__*/ $constructor("$ZodISODateTime", (inst, def) => {
    def.pattern ?? (def.pattern = datetime$1(def));
    $ZodStringFormat.init(inst, def);
});
const $ZodISODate = /*@__PURE__*/ $constructor("$ZodISODate", (inst, def) => {
    def.pattern ?? (def.pattern = date$1);
    $ZodStringFormat.init(inst, def);
});
const $ZodISOTime = /*@__PURE__*/ $constructor("$ZodISOTime", (inst, def) => {
    def.pattern ?? (def.pattern = time$1(def));
    $ZodStringFormat.init(inst, def);
});
const $ZodISODuration = /*@__PURE__*/ $constructor("$ZodISODuration", (inst, def) => {
    def.pattern ?? (def.pattern = duration$1);
    $ZodStringFormat.init(inst, def);
});
const $ZodIPv4 = /*@__PURE__*/ $constructor("$ZodIPv4", (inst, def) => {
    def.pattern ?? (def.pattern = ipv4);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.format = `ipv4`;
    });
});
const $ZodIPv6 = /*@__PURE__*/ $constructor("$ZodIPv6", (inst, def) => {
    def.pattern ?? (def.pattern = ipv6);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst) => {
        const bag = inst._zod.bag;
        bag.format = `ipv6`;
    });
    inst._zod.check = (payload) => {
        try {
            // @ts-ignore
            new URL(`http://[${payload.value}]`);
            // return;
        }
        catch {
            payload.issues.push({
                code: "invalid_format",
                format: "ipv6",
                input: payload.value,
                inst,
                continue: !def.abort,
            });
        }
    };
});
const $ZodCIDRv4 = /*@__PURE__*/ $constructor("$ZodCIDRv4", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv4);
    $ZodStringFormat.init(inst, def);
});
const $ZodCIDRv6 = /*@__PURE__*/ $constructor("$ZodCIDRv6", (inst, def) => {
    def.pattern ?? (def.pattern = cidrv6); // not used for validation
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
        const parts = payload.value.split("/");
        try {
            if (parts.length !== 2)
                throw new Error();
            const [address, prefix] = parts;
            if (!prefix)
                throw new Error();
            const prefixNum = Number(prefix);
            if (`${prefixNum}` !== prefix)
                throw new Error();
            if (prefixNum < 0 || prefixNum > 128)
                throw new Error();
            // @ts-ignore
            new URL(`http://[${address}]`);
        }
        catch {
            payload.issues.push({
                code: "invalid_format",
                format: "cidrv6",
                input: payload.value,
                inst,
                continue: !def.abort,
            });
        }
    };
});
//////////////////////////////   ZodBase64   //////////////////////////////
function isValidBase64(data) {
    if (data === "")
        return true;
    if (data.length % 4 !== 0)
        return false;
    try {
        // @ts-ignore
        atob(data);
        return true;
    }
    catch {
        return false;
    }
}
const $ZodBase64 = /*@__PURE__*/ $constructor("$ZodBase64", (inst, def) => {
    def.pattern ?? (def.pattern = base64);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst) => {
        inst._zod.bag.contentEncoding = "base64";
    });
    inst._zod.check = (payload) => {
        if (isValidBase64(payload.value))
            return;
        payload.issues.push({
            code: "invalid_format",
            format: "base64",
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
//////////////////////////////   ZodBase64   //////////////////////////////
function isValidBase64URL(data) {
    if (!base64url.test(data))
        return false;
    const base64 = data.replace(/[-_]/g, (c) => (c === "-" ? "+" : "/"));
    const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, "=");
    return isValidBase64(padded);
}
const $ZodBase64URL = /*@__PURE__*/ $constructor("$ZodBase64URL", (inst, def) => {
    def.pattern ?? (def.pattern = base64url);
    $ZodStringFormat.init(inst, def);
    inst._zod.onattach.push((inst) => {
        inst._zod.bag.contentEncoding = "base64url";
    });
    inst._zod.check = (payload) => {
        if (isValidBase64URL(payload.value))
            return;
        payload.issues.push({
            code: "invalid_format",
            format: "base64url",
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodE164 = /*@__PURE__*/ $constructor("$ZodE164", (inst, def) => {
    def.pattern ?? (def.pattern = e164);
    $ZodStringFormat.init(inst, def);
});
//////////////////////////////   ZodJWT   //////////////////////////////
function isValidJWT(token, algorithm = null) {
    try {
        const tokensParts = token.split(".");
        if (tokensParts.length !== 3)
            return false;
        const [header] = tokensParts;
        if (!header)
            return false;
        // @ts-ignore
        const parsedHeader = JSON.parse(atob(header));
        if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
            return false;
        if (!parsedHeader.alg)
            return false;
        if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
            return false;
        return true;
    }
    catch {
        return false;
    }
}
const $ZodJWT = /*@__PURE__*/ $constructor("$ZodJWT", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    inst._zod.check = (payload) => {
        if (isValidJWT(payload.value, def.alg))
            return;
        payload.issues.push({
            code: "invalid_format",
            format: "jwt",
            input: payload.value,
            inst,
            continue: !def.abort,
        });
    };
});
const $ZodNumber = /*@__PURE__*/ $constructor("$ZodNumber", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = inst._zod.bag.pattern ?? number$2;
    inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
            try {
                payload.value = Number(payload.value);
            }
            catch (_) { }
        const input = payload.value;
        if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
            return payload;
        }
        const received = typeof input === "number"
            ? Number.isNaN(input)
                ? "NaN"
                : !Number.isFinite(input)
                    ? "Infinity"
                    : undefined
            : undefined;
        payload.issues.push({
            expected: "number",
            code: "invalid_type",
            input,
            inst,
            ...(received ? { received } : {}),
        });
        return payload;
    };
});
const $ZodNumberFormat = /*@__PURE__*/ $constructor("$ZodNumber", (inst, def) => {
    $ZodCheckNumberFormat.init(inst, def);
    $ZodNumber.init(inst, def); // no format checksp
});
const $ZodBoolean = /*@__PURE__*/ $constructor("$ZodBoolean", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.pattern = boolean$1;
    inst._zod.parse = (payload, _ctx) => {
        if (def.coerce)
            try {
                payload.value = Boolean(payload.value);
            }
            catch (_) { }
        const input = payload.value;
        if (typeof input === "boolean")
            return payload;
        payload.issues.push({
            expected: "boolean",
            code: "invalid_type",
            input,
            inst,
        });
        return payload;
    };
});
const $ZodAny = /*@__PURE__*/ $constructor("$ZodAny", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
});
const $ZodUnknown = /*@__PURE__*/ $constructor("$ZodUnknown", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload) => payload;
});
const $ZodNever = /*@__PURE__*/ $constructor("$ZodNever", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
        payload.issues.push({
            expected: "never",
            code: "invalid_type",
            input: payload.value,
            inst,
        });
        return payload;
    };
});
function handleArrayResult(result, final, index) {
    if (result.issues.length) {
        final.issues.push(...prefixIssues(index, result.issues));
    }
    final.value[index] = result.value;
}
const $ZodArray = /*@__PURE__*/ $constructor("$ZodArray", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
            payload.issues.push({
                expected: "array",
                code: "invalid_type",
                input,
                inst,
            });
            return payload;
        }
        payload.value = Array(input.length);
        const proms = [];
        for (let i = 0; i < input.length; i++) {
            const item = input[i];
            const result = def.element._zod.run({
                value: item,
                issues: [],
            }, ctx);
            if (result instanceof Promise) {
                proms.push(result.then((result) => handleArrayResult(result, payload, i)));
            }
            else {
                handleArrayResult(result, payload, i);
            }
        }
        if (proms.length) {
            return Promise.all(proms).then(() => payload);
        }
        return payload; //handleArrayResultsAsync(parseResults, final);
    };
});
function handlePropertyResult(result, final, key, input) {
    if (result.issues.length) {
        final.issues.push(...prefixIssues(key, result.issues));
    }
    if (result.value === undefined) {
        if (key in input) {
            final.value[key] = undefined;
        }
    }
    else {
        final.value[key] = result.value;
    }
}
function normalizeDef(def) {
    const keys = Object.keys(def.shape);
    for (const k of keys) {
        if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
            throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
        }
    }
    const okeys = optionalKeys(def.shape);
    return {
        ...def,
        keys,
        keySet: new Set(keys),
        numKeys: keys.length,
        optionalKeys: new Set(okeys),
    };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
    const unrecognized = [];
    // iterate over input keys
    const keySet = def.keySet;
    const _catchall = def.catchall._zod;
    const t = _catchall.def.type;
    for (const key of Object.keys(input)) {
        if (keySet.has(key))
            continue;
        if (t === "never") {
            unrecognized.push(key);
            continue;
        }
        const r = _catchall.run({ value: input[key], issues: [] }, ctx);
        if (r instanceof Promise) {
            proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));
        }
        else {
            handlePropertyResult(r, payload, key, input);
        }
    }
    if (unrecognized.length) {
        payload.issues.push({
            code: "unrecognized_keys",
            keys: unrecognized,
            input,
            inst,
        });
    }
    if (!proms.length)
        return payload;
    return Promise.all(proms).then(() => {
        return payload;
    });
}
const $ZodObject = /*@__PURE__*/ $constructor("$ZodObject", (inst, def) => {
    // requires cast because technically $ZodObject doesn't extend
    $ZodType.init(inst, def);
    // const sh = def.shape;
    const desc = Object.getOwnPropertyDescriptor(def, "shape");
    if (!desc?.get) {
        const sh = def.shape;
        Object.defineProperty(def, "shape", {
            get: () => {
                const newSh = { ...sh };
                Object.defineProperty(def, "shape", {
                    value: newSh,
                });
                return newSh;
            },
        });
    }
    const _normalized = cached(() => normalizeDef(def));
    defineLazy(inst._zod, "propValues", () => {
        const shape = def.shape;
        const propValues = {};
        for (const key in shape) {
            const field = shape[key]._zod;
            if (field.values) {
                propValues[key] ?? (propValues[key] = new Set());
                for (const v of field.values)
                    propValues[key].add(v);
            }
        }
        return propValues;
    });
    const isObject$1 = isObject;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject$1(input)) {
            payload.issues.push({
                expected: "object",
                code: "invalid_type",
                input,
                inst,
            });
            return payload;
        }
        payload.value = {};
        const proms = [];
        const shape = value.shape;
        for (const key of value.keys) {
            const el = shape[key];
            const r = el._zod.run({ value: input[key], issues: [] }, ctx);
            if (r instanceof Promise) {
                proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));
            }
            else {
                handlePropertyResult(r, payload, key, input);
            }
        }
        if (!catchall) {
            return proms.length ? Promise.all(proms).then(() => payload) : payload;
        }
        return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
    };
});
const $ZodObjectJIT = /*@__PURE__*/ $constructor("$ZodObjectJIT", (inst, def) => {
    // requires cast because technically $ZodObject doesn't extend
    $ZodObject.init(inst, def);
    const superParse = inst._zod.parse;
    const _normalized = cached(() => normalizeDef(def));
    const generateFastpass = (shape) => {
        const doc = new Doc(["shape", "payload", "ctx"]);
        const normalized = _normalized.value;
        const parseStr = (key) => {
            const k = esc(key);
            return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
        };
        doc.write(`const input = payload.value;`);
        const ids = Object.create(null);
        let counter = 0;
        for (const key of normalized.keys) {
            ids[key] = `key_${counter++}`;
        }
        // A: preserve key order {
        doc.write(`const newResult = {};`);
        for (const key of normalized.keys) {
            const id = ids[key];
            const k = esc(key);
            doc.write(`const ${id} = ${parseStr(key)};`);
            doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
        }
        doc.write(`payload.value = newResult;`);
        doc.write(`return payload;`);
        const fn = doc.compile();
        return (payload, ctx) => fn(shape, payload, ctx);
    };
    let fastpass;
    const isObject$1 = isObject;
    const jit = !globalConfig.jitless;
    const allowsEval$1 = allowsEval;
    const fastEnabled = jit && allowsEval$1.value; // && !def.catchall;
    const catchall = def.catchall;
    let value;
    inst._zod.parse = (payload, ctx) => {
        value ?? (value = _normalized.value);
        const input = payload.value;
        if (!isObject$1(input)) {
            payload.issues.push({
                expected: "object",
                code: "invalid_type",
                input,
                inst,
            });
            return payload;
        }
        if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
            // always synchronous
            if (!fastpass)
                fastpass = generateFastpass(def.shape);
            payload = fastpass(payload, ctx);
            if (!catchall)
                return payload;
            return handleCatchall([], input, payload, ctx, value, inst);
        }
        return superParse(payload, ctx);
    };
});
function handleUnionResults(results, final, inst, ctx) {
    for (const result of results) {
        if (result.issues.length === 0) {
            final.value = result.value;
            return final;
        }
    }
    const nonaborted = results.filter((r) => !aborted(r));
    if (nonaborted.length === 1) {
        final.value = nonaborted[0].value;
        return nonaborted[0];
    }
    final.issues.push({
        code: "invalid_union",
        input: final.value,
        inst,
        errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config()))),
    });
    return final;
}
const $ZodUnion = /*@__PURE__*/ $constructor("$ZodUnion", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
    defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
    defineLazy(inst._zod, "values", () => {
        if (def.options.every((o) => o._zod.values)) {
            return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
        }
        return undefined;
    });
    defineLazy(inst._zod, "pattern", () => {
        if (def.options.every((o) => o._zod.pattern)) {
            const patterns = def.options.map((o) => o._zod.pattern);
            return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
        }
        return undefined;
    });
    const single = def.options.length === 1;
    const first = def.options[0]._zod.run;
    inst._zod.parse = (payload, ctx) => {
        if (single) {
            return first(payload, ctx);
        }
        let async = false;
        const results = [];
        for (const option of def.options) {
            const result = option._zod.run({
                value: payload.value,
                issues: [],
            }, ctx);
            if (result instanceof Promise) {
                results.push(result);
                async = true;
            }
            else {
                if (result.issues.length === 0)
                    return result;
                results.push(result);
            }
        }
        if (!async)
            return handleUnionResults(results, payload, inst, ctx);
        return Promise.all(results).then((results) => {
            return handleUnionResults(results, payload, inst, ctx);
        });
    };
});
const $ZodDiscriminatedUnion = 
/*@__PURE__*/
$constructor("$ZodDiscriminatedUnion", (inst, def) => {
    $ZodUnion.init(inst, def);
    const _super = inst._zod.parse;
    defineLazy(inst._zod, "propValues", () => {
        const propValues = {};
        for (const option of def.options) {
            const pv = option._zod.propValues;
            if (!pv || Object.keys(pv).length === 0)
                throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
            for (const [k, v] of Object.entries(pv)) {
                if (!propValues[k])
                    propValues[k] = new Set();
                for (const val of v) {
                    propValues[k].add(val);
                }
            }
        }
        return propValues;
    });
    const disc = cached(() => {
        const opts = def.options;
        const map = new Map();
        for (const o of opts) {
            const values = o._zod.propValues?.[def.discriminator];
            if (!values || values.size === 0)
                throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
            for (const v of values) {
                if (map.has(v)) {
                    throw new Error(`Duplicate discriminator value "${String(v)}"`);
                }
                map.set(v, o);
            }
        }
        return map;
    });
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isObject(input)) {
            payload.issues.push({
                code: "invalid_type",
                expected: "object",
                input,
                inst,
            });
            return payload;
        }
        const opt = disc.value.get(input?.[def.discriminator]);
        if (opt) {
            return opt._zod.run(payload, ctx);
        }
        if (def.unionFallback) {
            return _super(payload, ctx);
        }
        // no matching discriminator
        payload.issues.push({
            code: "invalid_union",
            errors: [],
            note: "No matching discriminator",
            discriminator: def.discriminator,
            input,
            path: [def.discriminator],
            inst,
        });
        return payload;
    };
});
const $ZodIntersection = /*@__PURE__*/ $constructor("$ZodIntersection", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        const left = def.left._zod.run({ value: input, issues: [] }, ctx);
        const right = def.right._zod.run({ value: input, issues: [] }, ctx);
        const async = left instanceof Promise || right instanceof Promise;
        if (async) {
            return Promise.all([left, right]).then(([left, right]) => {
                return handleIntersectionResults(payload, left, right);
            });
        }
        return handleIntersectionResults(payload, left, right);
    };
});
function mergeValues(a, b) {
    // const aType = parse.t(a);
    // const bType = parse.t(b);
    if (a === b) {
        return { valid: true, data: a };
    }
    if (a instanceof Date && b instanceof Date && +a === +b) {
        return { valid: true, data: a };
    }
    if (isPlainObject(a) && isPlainObject(b)) {
        const bKeys = Object.keys(b);
        const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
        const newObj = { ...a, ...b };
        for (const key of sharedKeys) {
            const sharedValue = mergeValues(a[key], b[key]);
            if (!sharedValue.valid) {
                return {
                    valid: false,
                    mergeErrorPath: [key, ...sharedValue.mergeErrorPath],
                };
            }
            newObj[key] = sharedValue.data;
        }
        return { valid: true, data: newObj };
    }
    if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) {
            return { valid: false, mergeErrorPath: [] };
        }
        const newArray = [];
        for (let index = 0; index < a.length; index++) {
            const itemA = a[index];
            const itemB = b[index];
            const sharedValue = mergeValues(itemA, itemB);
            if (!sharedValue.valid) {
                return {
                    valid: false,
                    mergeErrorPath: [index, ...sharedValue.mergeErrorPath],
                };
            }
            newArray.push(sharedValue.data);
        }
        return { valid: true, data: newArray };
    }
    return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
    if (left.issues.length) {
        result.issues.push(...left.issues);
    }
    if (right.issues.length) {
        result.issues.push(...right.issues);
    }
    if (aborted(result))
        return result;
    const merged = mergeValues(left.value, right.value);
    if (!merged.valid) {
        throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
    }
    result.value = merged.data;
    return result;
}
const $ZodTuple = /*@__PURE__*/ $constructor("$ZodTuple", (inst, def) => {
    $ZodType.init(inst, def);
    const items = def.items;
    const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!Array.isArray(input)) {
            payload.issues.push({
                input,
                inst,
                expected: "tuple",
                code: "invalid_type",
            });
            return payload;
        }
        payload.value = [];
        const proms = [];
        if (!def.rest) {
            const tooBig = input.length > items.length;
            const tooSmall = input.length < optStart - 1;
            if (tooBig || tooSmall) {
                payload.issues.push({
                    ...(tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }),
                    input,
                    inst,
                    origin: "array",
                });
                return payload;
            }
        }
        let i = -1;
        for (const item of items) {
            i++;
            if (i >= input.length)
                if (i >= optStart)
                    continue;
            const result = item._zod.run({
                value: input[i],
                issues: [],
            }, ctx);
            if (result instanceof Promise) {
                proms.push(result.then((result) => handleTupleResult(result, payload, i)));
            }
            else {
                handleTupleResult(result, payload, i);
            }
        }
        if (def.rest) {
            const rest = input.slice(items.length);
            for (const el of rest) {
                i++;
                const result = def.rest._zod.run({
                    value: el,
                    issues: [],
                }, ctx);
                if (result instanceof Promise) {
                    proms.push(result.then((result) => handleTupleResult(result, payload, i)));
                }
                else {
                    handleTupleResult(result, payload, i);
                }
            }
        }
        if (proms.length)
            return Promise.all(proms).then(() => payload);
        return payload;
    };
});
function handleTupleResult(result, final, index) {
    if (result.issues.length) {
        final.issues.push(...prefixIssues(index, result.issues));
    }
    final.value[index] = result.value;
}
const $ZodRecord = /*@__PURE__*/ $constructor("$ZodRecord", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        const input = payload.value;
        if (!isPlainObject(input)) {
            payload.issues.push({
                expected: "record",
                code: "invalid_type",
                input,
                inst,
            });
            return payload;
        }
        const proms = [];
        if (def.keyType._zod.values) {
            const values = def.keyType._zod.values;
            payload.value = {};
            for (const key of values) {
                if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
                    const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
                    if (result instanceof Promise) {
                        proms.push(result.then((result) => {
                            if (result.issues.length) {
                                payload.issues.push(...prefixIssues(key, result.issues));
                            }
                            payload.value[key] = result.value;
                        }));
                    }
                    else {
                        if (result.issues.length) {
                            payload.issues.push(...prefixIssues(key, result.issues));
                        }
                        payload.value[key] = result.value;
                    }
                }
            }
            let unrecognized;
            for (const key in input) {
                if (!values.has(key)) {
                    unrecognized = unrecognized ?? [];
                    unrecognized.push(key);
                }
            }
            if (unrecognized && unrecognized.length > 0) {
                payload.issues.push({
                    code: "unrecognized_keys",
                    input,
                    inst,
                    keys: unrecognized,
                });
            }
        }
        else {
            payload.value = {};
            for (const key of Reflect.ownKeys(input)) {
                if (key === "__proto__")
                    continue;
                const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
                if (keyResult instanceof Promise) {
                    throw new Error("Async schemas not supported in object keys currently");
                }
                if (keyResult.issues.length) {
                    payload.issues.push({
                        code: "invalid_key",
                        origin: "record",
                        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                        input: key,
                        path: [key],
                        inst,
                    });
                    payload.value[keyResult.value] = keyResult.value;
                    continue;
                }
                const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
                if (result instanceof Promise) {
                    proms.push(result.then((result) => {
                        if (result.issues.length) {
                            payload.issues.push(...prefixIssues(key, result.issues));
                        }
                        payload.value[keyResult.value] = result.value;
                    }));
                }
                else {
                    if (result.issues.length) {
                        payload.issues.push(...prefixIssues(key, result.issues));
                    }
                    payload.value[keyResult.value] = result.value;
                }
            }
        }
        if (proms.length) {
            return Promise.all(proms).then(() => payload);
        }
        return payload;
    };
});
const $ZodEnum = /*@__PURE__*/ $constructor("$ZodEnum", (inst, def) => {
    $ZodType.init(inst, def);
    const values = getEnumValues(def.entries);
    const valuesSet = new Set(values);
    inst._zod.values = valuesSet;
    inst._zod.pattern = new RegExp(`^(${values
        .filter((k) => propertyKeyTypes.has(typeof k))
        .map((o) => (typeof o === "string" ? escapeRegex(o) : o.toString()))
        .join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (valuesSet.has(input)) {
            return payload;
        }
        payload.issues.push({
            code: "invalid_value",
            values,
            input,
            inst,
        });
        return payload;
    };
});
const $ZodLiteral = /*@__PURE__*/ $constructor("$ZodLiteral", (inst, def) => {
    $ZodType.init(inst, def);
    if (def.values.length === 0) {
        throw new Error("Cannot create literal schema with no valid values");
    }
    inst._zod.values = new Set(def.values);
    inst._zod.pattern = new RegExp(`^(${def.values
        .map((o) => (typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)))
        .join("|")})$`);
    inst._zod.parse = (payload, _ctx) => {
        const input = payload.value;
        if (inst._zod.values.has(input)) {
            return payload;
        }
        payload.issues.push({
            code: "invalid_value",
            values: def.values,
            input,
            inst,
        });
        return payload;
    };
});
const $ZodTransform = /*@__PURE__*/ $constructor("$ZodTransform", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            throw new $ZodEncodeError(inst.constructor.name);
        }
        const _out = def.transform(payload.value, payload);
        if (ctx.async) {
            const output = _out instanceof Promise ? _out : Promise.resolve(_out);
            return output.then((output) => {
                payload.value = output;
                return payload;
            });
        }
        if (_out instanceof Promise) {
            throw new $ZodAsyncError();
        }
        payload.value = _out;
        return payload;
    };
});
function handleOptionalResult(result, input) {
    if (result.issues.length && input === undefined) {
        return { issues: [], value: undefined };
    }
    return result;
}
const $ZodOptional = /*@__PURE__*/ $constructor("$ZodOptional", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    inst._zod.optout = "optional";
    defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
    });
    defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
        if (def.innerType._zod.optin === "optional") {
            const result = def.innerType._zod.run(payload, ctx);
            if (result instanceof Promise)
                return result.then((r) => handleOptionalResult(r, payload.value));
            return handleOptionalResult(result, payload.value);
        }
        if (payload.value === undefined) {
            return payload;
        }
        return def.innerType._zod.run(payload, ctx);
    };
});
const $ZodNullable = /*@__PURE__*/ $constructor("$ZodNullable", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "pattern", () => {
        const pattern = def.innerType._zod.pattern;
        return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
    });
    defineLazy(inst._zod, "values", () => {
        return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
        // Forward direction (decode): allow null to pass through
        if (payload.value === null)
            return payload;
        return def.innerType._zod.run(payload, ctx);
    };
});
const $ZodDefault = /*@__PURE__*/ $constructor("$ZodDefault", (inst, def) => {
    $ZodType.init(inst, def);
    // inst._zod.qin = "true";
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
        }
        // Forward direction (decode): apply defaults for undefined input
        if (payload.value === undefined) {
            payload.value = def.defaultValue;
            /**
             * $ZodDefault returns the default value immediately in forward direction.
             * It doesn't pass the default value into the validator ("prefault"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a "prefault" for the pipe.   */
            return payload;
        }
        // Forward direction: continue with default handling
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
            return result.then((result) => handleDefaultResult(result, def));
        }
        return handleDefaultResult(result, def);
    };
});
function handleDefaultResult(payload, def) {
    if (payload.value === undefined) {
        payload.value = def.defaultValue;
    }
    return payload;
}
const $ZodPrefault = /*@__PURE__*/ $constructor("$ZodPrefault", (inst, def) => {
    $ZodType.init(inst, def);
    inst._zod.optin = "optional";
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
        }
        // Forward direction (decode): apply prefault for undefined input
        if (payload.value === undefined) {
            payload.value = def.defaultValue;
        }
        return def.innerType._zod.run(payload, ctx);
    };
});
const $ZodNonOptional = /*@__PURE__*/ $constructor("$ZodNonOptional", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => {
        const v = def.innerType._zod.values;
        return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
    });
    inst._zod.parse = (payload, ctx) => {
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
            return result.then((result) => handleNonOptionalResult(result, inst));
        }
        return handleNonOptionalResult(result, inst);
    };
});
function handleNonOptionalResult(payload, inst) {
    if (!payload.issues.length && payload.value === undefined) {
        payload.issues.push({
            code: "invalid_type",
            expected: "nonoptional",
            input: payload.value,
            inst,
        });
    }
    return payload;
}
const $ZodCatch = /*@__PURE__*/ $constructor("$ZodCatch", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
        }
        // Forward direction (decode): apply catch logic
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
            return result.then((result) => {
                payload.value = result.value;
                if (result.issues.length) {
                    payload.value = def.catchValue({
                        ...payload,
                        error: {
                            issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                        },
                        input: payload.value,
                    });
                    payload.issues = [];
                }
                return payload;
            });
        }
        payload.value = result.value;
        if (result.issues.length) {
            payload.value = def.catchValue({
                ...payload,
                error: {
                    issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                },
                input: payload.value,
            });
            payload.issues = [];
        }
        return payload;
    };
});
const $ZodPipe = /*@__PURE__*/ $constructor("$ZodPipe", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "values", () => def.in._zod.values);
    defineLazy(inst._zod, "optin", () => def.in._zod.optin);
    defineLazy(inst._zod, "optout", () => def.out._zod.optout);
    defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            const right = def.out._zod.run(payload, ctx);
            if (right instanceof Promise) {
                return right.then((right) => handlePipeResult(right, def.in, ctx));
            }
            return handlePipeResult(right, def.in, ctx);
        }
        const left = def.in._zod.run(payload, ctx);
        if (left instanceof Promise) {
            return left.then((left) => handlePipeResult(left, def.out, ctx));
        }
        return handlePipeResult(left, def.out, ctx);
    };
});
function handlePipeResult(left, next, ctx) {
    if (left.issues.length) {
        // prevent further checks
        left.aborted = true;
        return left;
    }
    return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
const $ZodReadonly = /*@__PURE__*/ $constructor("$ZodReadonly", (inst, def) => {
    $ZodType.init(inst, def);
    defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
    defineLazy(inst._zod, "values", () => def.innerType._zod.values);
    defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
    defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
    inst._zod.parse = (payload, ctx) => {
        if (ctx.direction === "backward") {
            return def.innerType._zod.run(payload, ctx);
        }
        const result = def.innerType._zod.run(payload, ctx);
        if (result instanceof Promise) {
            return result.then(handleReadonlyResult);
        }
        return handleReadonlyResult(result);
    };
});
function handleReadonlyResult(payload) {
    payload.value = Object.freeze(payload.value);
    return payload;
}
const $ZodLazy = /*@__PURE__*/ $constructor("$ZodLazy", (inst, def) => {
    $ZodType.init(inst, def);
    // let _innerType!: any;
    // util.defineLazy(def, "getter", () => {
    //   if (!_innerType) {
    //     _innerType = def.getter();
    //   }
    //   return () => _innerType;
    // });
    defineLazy(inst._zod, "innerType", () => def.getter());
    defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
    defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
    defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? undefined);
    defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? undefined);
    inst._zod.parse = (payload, ctx) => {
        const inner = inst._zod.innerType;
        return inner._zod.run(payload, ctx);
    };
});
const $ZodCustom = /*@__PURE__*/ $constructor("$ZodCustom", (inst, def) => {
    $ZodCheck.init(inst, def);
    $ZodType.init(inst, def);
    inst._zod.parse = (payload, _) => {
        return payload;
    };
    inst._zod.check = (payload) => {
        const input = payload.value;
        const r = def.fn(input);
        if (r instanceof Promise) {
            return r.then((r) => handleRefineResult(r, payload, input, inst));
        }
        handleRefineResult(r, payload, input, inst);
        return;
    };
});
function handleRefineResult(result, payload, input, inst) {
    if (!result) {
        const _iss = {
            code: "custom",
            input,
            inst, // incorporates params.error into issue reporting
            path: [...(inst._zod.def.path ?? [])], // incorporates params.error into issue reporting
            continue: !inst._zod.def.abort,
            // params: inst._zod.def.params,
        };
        if (inst._zod.def.params)
            _iss.params = inst._zod.def.params;
        payload.issues.push(issue(_iss));
    }
}

class $ZodRegistry {
    constructor() {
        this._map = new WeakMap();
        this._idmap = new Map();
    }
    add(schema, ..._meta) {
        const meta = _meta[0];
        this._map.set(schema, meta);
        if (meta && typeof meta === "object" && "id" in meta) {
            if (this._idmap.has(meta.id)) {
                throw new Error(`ID ${meta.id} already exists in the registry`);
            }
            this._idmap.set(meta.id, schema);
        }
        return this;
    }
    clear() {
        this._map = new WeakMap();
        this._idmap = new Map();
        return this;
    }
    remove(schema) {
        const meta = this._map.get(schema);
        if (meta && typeof meta === "object" && "id" in meta) {
            this._idmap.delete(meta.id);
        }
        this._map.delete(schema);
        return this;
    }
    get(schema) {
        // return this._map.get(schema) as any;
        // inherit metadata
        const p = schema._zod.parent;
        if (p) {
            const pm = { ...(this.get(p) ?? {}) };
            delete pm.id; // do not inherit id
            const f = { ...pm, ...this._map.get(schema) };
            return Object.keys(f).length ? f : undefined;
        }
        return this._map.get(schema);
    }
    has(schema) {
        return this._map.has(schema);
    }
}
// registries
function registry() {
    return new $ZodRegistry();
}
const globalRegistry = /*@__PURE__*/ registry();

function _string(Class, params) {
    return new Class({
        type: "string",
        ...normalizeParams(params),
    });
}
function _email(Class, params) {
    return new Class({
        type: "string",
        format: "email",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _guid(Class, params) {
    return new Class({
        type: "string",
        format: "guid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _uuid(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _uuidv4(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v4",
        ...normalizeParams(params),
    });
}
function _uuidv6(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v6",
        ...normalizeParams(params),
    });
}
function _uuidv7(Class, params) {
    return new Class({
        type: "string",
        format: "uuid",
        check: "string_format",
        abort: false,
        version: "v7",
        ...normalizeParams(params),
    });
}
function _url(Class, params) {
    return new Class({
        type: "string",
        format: "url",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _emoji(Class, params) {
    return new Class({
        type: "string",
        format: "emoji",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _nanoid(Class, params) {
    return new Class({
        type: "string",
        format: "nanoid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _cuid(Class, params) {
    return new Class({
        type: "string",
        format: "cuid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _cuid2(Class, params) {
    return new Class({
        type: "string",
        format: "cuid2",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _ulid(Class, params) {
    return new Class({
        type: "string",
        format: "ulid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _xid(Class, params) {
    return new Class({
        type: "string",
        format: "xid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _ksuid(Class, params) {
    return new Class({
        type: "string",
        format: "ksuid",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _ipv4(Class, params) {
    return new Class({
        type: "string",
        format: "ipv4",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _ipv6(Class, params) {
    return new Class({
        type: "string",
        format: "ipv6",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _cidrv4(Class, params) {
    return new Class({
        type: "string",
        format: "cidrv4",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _cidrv6(Class, params) {
    return new Class({
        type: "string",
        format: "cidrv6",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _base64(Class, params) {
    return new Class({
        type: "string",
        format: "base64",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _base64url(Class, params) {
    return new Class({
        type: "string",
        format: "base64url",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _e164(Class, params) {
    return new Class({
        type: "string",
        format: "e164",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _jwt(Class, params) {
    return new Class({
        type: "string",
        format: "jwt",
        check: "string_format",
        abort: false,
        ...normalizeParams(params),
    });
}
function _isoDateTime(Class, params) {
    return new Class({
        type: "string",
        format: "datetime",
        check: "string_format",
        offset: false,
        local: false,
        precision: null,
        ...normalizeParams(params),
    });
}
function _isoDate(Class, params) {
    return new Class({
        type: "string",
        format: "date",
        check: "string_format",
        ...normalizeParams(params),
    });
}
function _isoTime(Class, params) {
    return new Class({
        type: "string",
        format: "time",
        check: "string_format",
        precision: null,
        ...normalizeParams(params),
    });
}
function _isoDuration(Class, params) {
    return new Class({
        type: "string",
        format: "duration",
        check: "string_format",
        ...normalizeParams(params),
    });
}
function _number(Class, params) {
    return new Class({
        type: "number",
        checks: [],
        ...normalizeParams(params),
    });
}
function _coercedNumber(Class, params) {
    return new Class({
        type: "number",
        coerce: true,
        checks: [],
        ...normalizeParams(params),
    });
}
function _int(Class, params) {
    return new Class({
        type: "number",
        check: "number_format",
        abort: false,
        format: "safeint",
        ...normalizeParams(params),
    });
}
function _boolean(Class, params) {
    return new Class({
        type: "boolean",
        ...normalizeParams(params),
    });
}
function _any(Class) {
    return new Class({
        type: "any",
    });
}
function _unknown(Class) {
    return new Class({
        type: "unknown",
    });
}
function _never(Class, params) {
    return new Class({
        type: "never",
        ...normalizeParams(params),
    });
}
function _lt(value, params) {
    return new $ZodCheckLessThan({
        check: "less_than",
        ...normalizeParams(params),
        value,
        inclusive: false,
    });
}
function _lte(value, params) {
    return new $ZodCheckLessThan({
        check: "less_than",
        ...normalizeParams(params),
        value,
        inclusive: true,
    });
}
function _gt(value, params) {
    return new $ZodCheckGreaterThan({
        check: "greater_than",
        ...normalizeParams(params),
        value,
        inclusive: false,
    });
}
function _gte(value, params) {
    return new $ZodCheckGreaterThan({
        check: "greater_than",
        ...normalizeParams(params),
        value,
        inclusive: true,
    });
}
function _multipleOf(value, params) {
    return new $ZodCheckMultipleOf({
        check: "multiple_of",
        ...normalizeParams(params),
        value,
    });
}
function _maxLength(maximum, params) {
    const ch = new $ZodCheckMaxLength({
        check: "max_length",
        ...normalizeParams(params),
        maximum,
    });
    return ch;
}
function _minLength(minimum, params) {
    return new $ZodCheckMinLength({
        check: "min_length",
        ...normalizeParams(params),
        minimum,
    });
}
function _length(length, params) {
    return new $ZodCheckLengthEquals({
        check: "length_equals",
        ...normalizeParams(params),
        length,
    });
}
function _regex(pattern, params) {
    return new $ZodCheckRegex({
        check: "string_format",
        format: "regex",
        ...normalizeParams(params),
        pattern,
    });
}
function _lowercase(params) {
    return new $ZodCheckLowerCase({
        check: "string_format",
        format: "lowercase",
        ...normalizeParams(params),
    });
}
function _uppercase(params) {
    return new $ZodCheckUpperCase({
        check: "string_format",
        format: "uppercase",
        ...normalizeParams(params),
    });
}
function _includes(includes, params) {
    return new $ZodCheckIncludes({
        check: "string_format",
        format: "includes",
        ...normalizeParams(params),
        includes,
    });
}
function _startsWith(prefix, params) {
    return new $ZodCheckStartsWith({
        check: "string_format",
        format: "starts_with",
        ...normalizeParams(params),
        prefix,
    });
}
function _endsWith(suffix, params) {
    return new $ZodCheckEndsWith({
        check: "string_format",
        format: "ends_with",
        ...normalizeParams(params),
        suffix,
    });
}
function _overwrite(tx) {
    return new $ZodCheckOverwrite({
        check: "overwrite",
        tx,
    });
}
// normalize
function _normalize(form) {
    return _overwrite((input) => input.normalize(form));
}
// trim
function _trim() {
    return _overwrite((input) => input.trim());
}
// toLowerCase
function _toLowerCase() {
    return _overwrite((input) => input.toLowerCase());
}
// toUpperCase
function _toUpperCase() {
    return _overwrite((input) => input.toUpperCase());
}
function _array(Class, element, params) {
    return new Class({
        type: "array",
        element,
        // get element() {
        //   return element;
        // },
        ...normalizeParams(params),
    });
}
// same as _custom but defaults to abort:false
function _refine(Class, fn, _params) {
    const schema = new Class({
        type: "custom",
        check: "custom",
        fn: fn,
        ...normalizeParams(_params),
    });
    return schema;
}
function _superRefine(fn) {
    const ch = _check((payload) => {
        payload.addIssue = (issue$1) => {
            if (typeof issue$1 === "string") {
                payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
            }
            else {
                // for Zod 3 backwards compatibility
                const _issue = issue$1;
                if (_issue.fatal)
                    _issue.continue = false;
                _issue.code ?? (_issue.code = "custom");
                _issue.input ?? (_issue.input = payload.value);
                _issue.inst ?? (_issue.inst = ch);
                _issue.continue ?? (_issue.continue = !ch._zod.def.abort); // abort is always undefined, so this is always true...
                payload.issues.push(issue(_issue));
            }
        };
        return fn(payload.value, payload);
    });
    return ch;
}
function _check(fn, params) {
    const ch = new $ZodCheck({
        check: "custom",
        ...normalizeParams(params),
    });
    ch._zod.check = fn;
    return ch;
}

class JSONSchemaGenerator {
    constructor(params) {
        this.counter = 0;
        this.metadataRegistry = params?.metadata ?? globalRegistry;
        this.target = params?.target ?? "draft-2020-12";
        this.unrepresentable = params?.unrepresentable ?? "throw";
        this.override = params?.override ?? (() => { });
        this.io = params?.io ?? "output";
        this.seen = new Map();
    }
    process(schema, _params = { path: [], schemaPath: [] }) {
        var _a;
        const def = schema._zod.def;
        const formatMap = {
            guid: "uuid",
            url: "uri",
            datetime: "date-time",
            json_string: "json-string",
            regex: "", // do not set
        };
        // check for schema in seens
        const seen = this.seen.get(schema);
        if (seen) {
            seen.count++;
            // check if cycle
            const isCycle = _params.schemaPath.includes(schema);
            if (isCycle) {
                seen.cycle = _params.path;
            }
            return seen.schema;
        }
        // initialize
        const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
        this.seen.set(schema, result);
        // custom method overrides default behavior
        const overrideSchema = schema._zod.toJSONSchema?.();
        if (overrideSchema) {
            result.schema = overrideSchema;
        }
        else {
            const params = {
                ..._params,
                schemaPath: [..._params.schemaPath, schema],
                path: _params.path,
            };
            const parent = schema._zod.parent;
            if (parent) {
                // schema was cloned from another schema
                result.ref = parent;
                this.process(parent, params);
                this.seen.get(parent).isParent = true;
            }
            else {
                const _json = result.schema;
                switch (def.type) {
                    case "string": {
                        const json = _json;
                        json.type = "string";
                        const { minimum, maximum, format, patterns, contentEncoding } = schema._zod
                            .bag;
                        if (typeof minimum === "number")
                            json.minLength = minimum;
                        if (typeof maximum === "number")
                            json.maxLength = maximum;
                        // custom pattern overrides format
                        if (format) {
                            json.format = formatMap[format] ?? format;
                            if (json.format === "")
                                delete json.format; // empty format is not valid
                        }
                        if (contentEncoding)
                            json.contentEncoding = contentEncoding;
                        if (patterns && patterns.size > 0) {
                            const regexes = [...patterns];
                            if (regexes.length === 1)
                                json.pattern = regexes[0].source;
                            else if (regexes.length > 1) {
                                result.schema.allOf = [
                                    ...regexes.map((regex) => ({
                                        ...(this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0"
                                            ? { type: "string" }
                                            : {}),
                                        pattern: regex.source,
                                    })),
                                ];
                            }
                        }
                        break;
                    }
                    case "number": {
                        const json = _json;
                        const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
                        if (typeof format === "string" && format.includes("int"))
                            json.type = "integer";
                        else
                            json.type = "number";
                        if (typeof exclusiveMinimum === "number") {
                            if (this.target === "draft-4" || this.target === "openapi-3.0") {
                                json.minimum = exclusiveMinimum;
                                json.exclusiveMinimum = true;
                            }
                            else {
                                json.exclusiveMinimum = exclusiveMinimum;
                            }
                        }
                        if (typeof minimum === "number") {
                            json.minimum = minimum;
                            if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                                if (exclusiveMinimum >= minimum)
                                    delete json.minimum;
                                else
                                    delete json.exclusiveMinimum;
                            }
                        }
                        if (typeof exclusiveMaximum === "number") {
                            if (this.target === "draft-4" || this.target === "openapi-3.0") {
                                json.maximum = exclusiveMaximum;
                                json.exclusiveMaximum = true;
                            }
                            else {
                                json.exclusiveMaximum = exclusiveMaximum;
                            }
                        }
                        if (typeof maximum === "number") {
                            json.maximum = maximum;
                            if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                                if (exclusiveMaximum <= maximum)
                                    delete json.maximum;
                                else
                                    delete json.exclusiveMaximum;
                            }
                        }
                        if (typeof multipleOf === "number")
                            json.multipleOf = multipleOf;
                        break;
                    }
                    case "boolean": {
                        const json = _json;
                        json.type = "boolean";
                        break;
                    }
                    case "bigint": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("BigInt cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "symbol": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Symbols cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "null": {
                        if (this.target === "openapi-3.0") {
                            _json.type = "string";
                            _json.nullable = true;
                            _json.enum = [null];
                        }
                        else
                            _json.type = "null";
                        break;
                    }
                    case "any": {
                        break;
                    }
                    case "unknown": {
                        break;
                    }
                    case "undefined": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Undefined cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "void": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Void cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "never": {
                        _json.not = {};
                        break;
                    }
                    case "date": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Date cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "array": {
                        const json = _json;
                        const { minimum, maximum } = schema._zod.bag;
                        if (typeof minimum === "number")
                            json.minItems = minimum;
                        if (typeof maximum === "number")
                            json.maxItems = maximum;
                        json.type = "array";
                        json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
                        break;
                    }
                    case "object": {
                        const json = _json;
                        json.type = "object";
                        json.properties = {};
                        const shape = def.shape; // params.shapeCache.get(schema)!;
                        for (const key in shape) {
                            json.properties[key] = this.process(shape[key], {
                                ...params,
                                path: [...params.path, "properties", key],
                            });
                        }
                        // required keys
                        const allKeys = new Set(Object.keys(shape));
                        // const optionalKeys = new Set(def.optional);
                        const requiredKeys = new Set([...allKeys].filter((key) => {
                            const v = def.shape[key]._zod;
                            if (this.io === "input") {
                                return v.optin === undefined;
                            }
                            else {
                                return v.optout === undefined;
                            }
                        }));
                        if (requiredKeys.size > 0) {
                            json.required = Array.from(requiredKeys);
                        }
                        // catchall
                        if (def.catchall?._zod.def.type === "never") {
                            // strict
                            json.additionalProperties = false;
                        }
                        else if (!def.catchall) {
                            // regular
                            if (this.io === "output")
                                json.additionalProperties = false;
                        }
                        else if (def.catchall) {
                            json.additionalProperties = this.process(def.catchall, {
                                ...params,
                                path: [...params.path, "additionalProperties"],
                            });
                        }
                        break;
                    }
                    case "union": {
                        const json = _json;
                        const options = def.options.map((x, i) => this.process(x, {
                            ...params,
                            path: [...params.path, "anyOf", i],
                        }));
                        json.anyOf = options;
                        break;
                    }
                    case "intersection": {
                        const json = _json;
                        const a = this.process(def.left, {
                            ...params,
                            path: [...params.path, "allOf", 0],
                        });
                        const b = this.process(def.right, {
                            ...params,
                            path: [...params.path, "allOf", 1],
                        });
                        const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
                        const allOf = [
                            ...(isSimpleIntersection(a) ? a.allOf : [a]),
                            ...(isSimpleIntersection(b) ? b.allOf : [b]),
                        ];
                        json.allOf = allOf;
                        break;
                    }
                    case "tuple": {
                        const json = _json;
                        json.type = "array";
                        const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
                        const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
                        const prefixItems = def.items.map((x, i) => this.process(x, {
                            ...params,
                            path: [...params.path, prefixPath, i],
                        }));
                        const rest = def.rest
                            ? this.process(def.rest, {
                                ...params,
                                path: [...params.path, restPath, ...(this.target === "openapi-3.0" ? [def.items.length] : [])],
                            })
                            : null;
                        if (this.target === "draft-2020-12") {
                            json.prefixItems = prefixItems;
                            if (rest) {
                                json.items = rest;
                            }
                        }
                        else if (this.target === "openapi-3.0") {
                            json.items = {
                                anyOf: prefixItems,
                            };
                            if (rest) {
                                json.items.anyOf.push(rest);
                            }
                            json.minItems = prefixItems.length;
                            if (!rest) {
                                json.maxItems = prefixItems.length;
                            }
                        }
                        else {
                            json.items = prefixItems;
                            if (rest) {
                                json.additionalItems = rest;
                            }
                        }
                        // length
                        const { minimum, maximum } = schema._zod.bag;
                        if (typeof minimum === "number")
                            json.minItems = minimum;
                        if (typeof maximum === "number")
                            json.maxItems = maximum;
                        break;
                    }
                    case "record": {
                        const json = _json;
                        json.type = "object";
                        if (this.target === "draft-7" || this.target === "draft-2020-12") {
                            json.propertyNames = this.process(def.keyType, {
                                ...params,
                                path: [...params.path, "propertyNames"],
                            });
                        }
                        json.additionalProperties = this.process(def.valueType, {
                            ...params,
                            path: [...params.path, "additionalProperties"],
                        });
                        break;
                    }
                    case "map": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Map cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "set": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Set cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "enum": {
                        const json = _json;
                        const values = getEnumValues(def.entries);
                        // Number enums can have both string and number values
                        if (values.every((v) => typeof v === "number"))
                            json.type = "number";
                        if (values.every((v) => typeof v === "string"))
                            json.type = "string";
                        json.enum = values;
                        break;
                    }
                    case "literal": {
                        const json = _json;
                        const vals = [];
                        for (const val of def.values) {
                            if (val === undefined) {
                                if (this.unrepresentable === "throw") {
                                    throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                                }
                            }
                            else if (typeof val === "bigint") {
                                if (this.unrepresentable === "throw") {
                                    throw new Error("BigInt literals cannot be represented in JSON Schema");
                                }
                                else {
                                    vals.push(Number(val));
                                }
                            }
                            else {
                                vals.push(val);
                            }
                        }
                        if (vals.length === 0) ;
                        else if (vals.length === 1) {
                            const val = vals[0];
                            json.type = val === null ? "null" : typeof val;
                            if (this.target === "draft-4" || this.target === "openapi-3.0") {
                                json.enum = [val];
                            }
                            else {
                                json.const = val;
                            }
                        }
                        else {
                            if (vals.every((v) => typeof v === "number"))
                                json.type = "number";
                            if (vals.every((v) => typeof v === "string"))
                                json.type = "string";
                            if (vals.every((v) => typeof v === "boolean"))
                                json.type = "string";
                            if (vals.every((v) => v === null))
                                json.type = "null";
                            json.enum = vals;
                        }
                        break;
                    }
                    case "file": {
                        const json = _json;
                        const file = {
                            type: "string",
                            format: "binary",
                            contentEncoding: "binary",
                        };
                        const { minimum, maximum, mime } = schema._zod.bag;
                        if (minimum !== undefined)
                            file.minLength = minimum;
                        if (maximum !== undefined)
                            file.maxLength = maximum;
                        if (mime) {
                            if (mime.length === 1) {
                                file.contentMediaType = mime[0];
                                Object.assign(json, file);
                            }
                            else {
                                json.anyOf = mime.map((m) => {
                                    const mFile = { ...file, contentMediaType: m };
                                    return mFile;
                                });
                            }
                        }
                        else {
                            Object.assign(json, file);
                        }
                        // if (this.unrepresentable === "throw") {
                        //   throw new Error("File cannot be represented in JSON Schema");
                        // }
                        break;
                    }
                    case "transform": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Transforms cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "nullable": {
                        const inner = this.process(def.innerType, params);
                        if (this.target === "openapi-3.0") {
                            result.ref = def.innerType;
                            _json.nullable = true;
                        }
                        else {
                            _json.anyOf = [inner, { type: "null" }];
                        }
                        break;
                    }
                    case "nonoptional": {
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        break;
                    }
                    case "success": {
                        const json = _json;
                        json.type = "boolean";
                        break;
                    }
                    case "default": {
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        _json.default = JSON.parse(JSON.stringify(def.defaultValue));
                        break;
                    }
                    case "prefault": {
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        if (this.io === "input")
                            _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
                        break;
                    }
                    case "catch": {
                        // use conditionals
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        let catchValue;
                        try {
                            catchValue = def.catchValue(undefined);
                        }
                        catch {
                            throw new Error("Dynamic catch values are not supported in JSON Schema");
                        }
                        _json.default = catchValue;
                        break;
                    }
                    case "nan": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("NaN cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "template_literal": {
                        const json = _json;
                        const pattern = schema._zod.pattern;
                        if (!pattern)
                            throw new Error("Pattern not found in template literal");
                        json.type = "string";
                        json.pattern = pattern.source;
                        break;
                    }
                    case "pipe": {
                        const innerType = this.io === "input" ? (def.in._zod.def.type === "transform" ? def.out : def.in) : def.out;
                        this.process(innerType, params);
                        result.ref = innerType;
                        break;
                    }
                    case "readonly": {
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        _json.readOnly = true;
                        break;
                    }
                    // passthrough types
                    case "promise": {
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        break;
                    }
                    case "optional": {
                        this.process(def.innerType, params);
                        result.ref = def.innerType;
                        break;
                    }
                    case "lazy": {
                        const innerType = schema._zod.innerType;
                        this.process(innerType, params);
                        result.ref = innerType;
                        break;
                    }
                    case "custom": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Custom types cannot be represented in JSON Schema");
                        }
                        break;
                    }
                    case "function": {
                        if (this.unrepresentable === "throw") {
                            throw new Error("Function types cannot be represented in JSON Schema");
                        }
                        break;
                    }
                }
            }
        }
        // metadata
        const meta = this.metadataRegistry.get(schema);
        if (meta)
            Object.assign(result.schema, meta);
        if (this.io === "input" && isTransforming(schema)) {
            // examples/defaults only apply to output type of pipe
            delete result.schema.examples;
            delete result.schema.default;
        }
        // set prefault as default
        if (this.io === "input" && result.schema._prefault)
            (_a = result.schema).default ?? (_a.default = result.schema._prefault);
        delete result.schema._prefault;
        // pulling fresh from this.seen in case it was overwritten
        const _result = this.seen.get(schema);
        return _result.schema;
    }
    emit(schema, _params) {
        const params = {
            cycles: _params?.cycles ?? "ref",
            reused: _params?.reused ?? "inline",
            // unrepresentable: _params?.unrepresentable ?? "throw",
            // uri: _params?.uri ?? ((id) => `${id}`),
            external: _params?.external ?? undefined,
        };
        // iterate over seen map;
        const root = this.seen.get(schema);
        if (!root)
            throw new Error("Unprocessed schema. This is a bug in Zod.");
        // initialize result with root schema fields
        // Object.assign(result, seen.cached);
        // returns a ref to the schema
        // defId will be empty if the ref points to an external schema (or #)
        const makeURI = (entry) => {
            // comparing the seen objects because sometimes
            // multiple schemas map to the same seen object.
            // e.g. lazy
            // external is configured
            const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
            if (params.external) {
                const externalId = params.external.registry.get(entry[0])?.id; // ?? "__shared";// `__schema${this.counter++}`;
                // check if schema is in the external registry
                const uriGenerator = params.external.uri ?? ((id) => id);
                if (externalId) {
                    return { ref: uriGenerator(externalId) };
                }
                // otherwise, add to __shared
                const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
                entry[1].defId = id; // set defId so it will be reused if needed
                return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
            }
            if (entry[1] === root) {
                return { ref: "#" };
            }
            // self-contained schema
            const uriPrefix = `#`;
            const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
            const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
            return { defId, ref: defUriPrefix + defId };
        };
        // stored cached version in `def` property
        // remove all properties, set $ref
        const extractToDef = (entry) => {
            // if the schema is already a reference, do not extract it
            if (entry[1].schema.$ref) {
                return;
            }
            const seen = entry[1];
            const { ref, defId } = makeURI(entry);
            seen.def = { ...seen.schema };
            // defId won't be set if the schema is a reference to an external schema
            if (defId)
                seen.defId = defId;
            // wipe away all properties except $ref
            const schema = seen.schema;
            for (const key in schema) {
                delete schema[key];
            }
            schema.$ref = ref;
        };
        // throw on cycles
        // break cycles
        if (params.cycles === "throw") {
            for (const entry of this.seen.entries()) {
                const seen = entry[1];
                if (seen.cycle) {
                    throw new Error("Cycle detected: " +
                        `#/${seen.cycle?.join("/")}/<root>` +
                        '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
                }
            }
        }
        // extract schemas into $defs
        for (const entry of this.seen.entries()) {
            const seen = entry[1];
            // convert root schema to # $ref
            if (schema === entry[0]) {
                extractToDef(entry); // this has special handling for the root schema
                continue;
            }
            // extract schemas that are in the external registry
            if (params.external) {
                const ext = params.external.registry.get(entry[0])?.id;
                if (schema !== entry[0] && ext) {
                    extractToDef(entry);
                    continue;
                }
            }
            // extract schemas with `id` meta
            const id = this.metadataRegistry.get(entry[0])?.id;
            if (id) {
                extractToDef(entry);
                continue;
            }
            // break cycles
            if (seen.cycle) {
                // any
                extractToDef(entry);
                continue;
            }
            // extract reused schemas
            if (seen.count > 1) {
                if (params.reused === "ref") {
                    extractToDef(entry);
                    // biome-ignore lint:
                    continue;
                }
            }
        }
        // flatten _refs
        const flattenRef = (zodSchema, params) => {
            const seen = this.seen.get(zodSchema);
            const schema = seen.def ?? seen.schema;
            const _cached = { ...schema };
            // already seen
            if (seen.ref === null) {
                return;
            }
            // flatten ref if defined
            const ref = seen.ref;
            seen.ref = null; // prevent recursion
            if (ref) {
                flattenRef(ref, params);
                // merge referenced schema into current
                const refSchema = this.seen.get(ref).schema;
                if (refSchema.$ref &&
                    (params.target === "draft-7" || params.target === "draft-4" || params.target === "openapi-3.0")) {
                    schema.allOf = schema.allOf ?? [];
                    schema.allOf.push(refSchema);
                }
                else {
                    Object.assign(schema, refSchema);
                    Object.assign(schema, _cached); // prevent overwriting any fields in the original schema
                }
            }
            // execute overrides
            if (!seen.isParent)
                this.override({
                    zodSchema: zodSchema,
                    jsonSchema: schema,
                    path: seen.path ?? [],
                });
        };
        for (const entry of [...this.seen.entries()].reverse()) {
            flattenRef(entry[0], { target: this.target });
        }
        const result = {};
        if (this.target === "draft-2020-12") {
            result.$schema = "https://json-schema.org/draft/2020-12/schema";
        }
        else if (this.target === "draft-7") {
            result.$schema = "http://json-schema.org/draft-07/schema#";
        }
        else if (this.target === "draft-4") {
            result.$schema = "http://json-schema.org/draft-04/schema#";
        }
        else if (this.target === "openapi-3.0") ;
        else {
            // @ts-ignore
            console.warn(`Invalid target: ${this.target}`);
        }
        if (params.external?.uri) {
            const id = params.external.registry.get(schema)?.id;
            if (!id)
                throw new Error("Schema is missing an `id` property");
            result.$id = params.external.uri(id);
        }
        Object.assign(result, root.def);
        // build defs object
        const defs = params.external?.defs ?? {};
        for (const entry of this.seen.entries()) {
            const seen = entry[1];
            if (seen.def && seen.defId) {
                defs[seen.defId] = seen.def;
            }
        }
        // set definitions in result
        if (params.external) ;
        else {
            if (Object.keys(defs).length > 0) {
                if (this.target === "draft-2020-12") {
                    result.$defs = defs;
                }
                else {
                    result.definitions = defs;
                }
            }
        }
        try {
            // this "finalizes" this schema and ensures all cycles are removed
            // each call to .emit() is functionally independent
            // though the seen map is shared
            return JSON.parse(JSON.stringify(result));
        }
        catch (_err) {
            throw new Error("Error converting schema to JSON.");
        }
    }
}
function toJSONSchema(input, _params) {
    if (input instanceof $ZodRegistry) {
        const gen = new JSONSchemaGenerator(_params);
        const defs = {};
        for (const entry of input._idmap.entries()) {
            const [_, schema] = entry;
            gen.process(schema);
        }
        const schemas = {};
        const external = {
            registry: input,
            uri: _params?.uri,
            defs,
        };
        for (const entry of input._idmap.entries()) {
            const [key, schema] = entry;
            schemas[key] = gen.emit(schema, {
                ..._params,
                external,
            });
        }
        if (Object.keys(defs).length > 0) {
            const defsSegment = gen.target === "draft-2020-12" ? "$defs" : "definitions";
            schemas.__shared = {
                [defsSegment]: defs,
            };
        }
        return { schemas };
    }
    const gen = new JSONSchemaGenerator(_params);
    gen.process(input);
    return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
    const ctx = _ctx ?? { seen: new Set() };
    if (ctx.seen.has(_schema))
        return false;
    ctx.seen.add(_schema);
    const schema = _schema;
    const def = schema._zod.def;
    switch (def.type) {
        case "string":
        case "number":
        case "bigint":
        case "boolean":
        case "date":
        case "symbol":
        case "undefined":
        case "null":
        case "any":
        case "unknown":
        case "never":
        case "void":
        case "literal":
        case "enum":
        case "nan":
        case "file":
        case "template_literal":
            return false;
        case "array": {
            return isTransforming(def.element, ctx);
        }
        case "object": {
            for (const key in def.shape) {
                if (isTransforming(def.shape[key], ctx))
                    return true;
            }
            return false;
        }
        case "union": {
            for (const option of def.options) {
                if (isTransforming(option, ctx))
                    return true;
            }
            return false;
        }
        case "intersection": {
            return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
        }
        case "tuple": {
            for (const item of def.items) {
                if (isTransforming(item, ctx))
                    return true;
            }
            if (def.rest && isTransforming(def.rest, ctx))
                return true;
            return false;
        }
        case "record": {
            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
        }
        case "map": {
            return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
        }
        case "set": {
            return isTransforming(def.valueType, ctx);
        }
        // inner types
        case "promise":
        case "optional":
        case "nonoptional":
        case "nullable":
        case "readonly":
            return isTransforming(def.innerType, ctx);
        case "lazy":
            return isTransforming(def.getter(), ctx);
        case "default": {
            return isTransforming(def.innerType, ctx);
        }
        case "prefault": {
            return isTransforming(def.innerType, ctx);
        }
        case "custom": {
            return false;
        }
        case "transform": {
            return true;
        }
        case "pipe": {
            return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
        }
        case "success": {
            return false;
        }
        case "catch": {
            return false;
        }
        case "function": {
            return false;
        }
    }
    throw new Error(`Unknown schema type: ${def.type}`);
}

const ZodISODateTime = /*@__PURE__*/ $constructor("ZodISODateTime", (inst, def) => {
    $ZodISODateTime.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function datetime(params) {
    return _isoDateTime(ZodISODateTime, params);
}
const ZodISODate = /*@__PURE__*/ $constructor("ZodISODate", (inst, def) => {
    $ZodISODate.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function date(params) {
    return _isoDate(ZodISODate, params);
}
const ZodISOTime = /*@__PURE__*/ $constructor("ZodISOTime", (inst, def) => {
    $ZodISOTime.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function time(params) {
    return _isoTime(ZodISOTime, params);
}
const ZodISODuration = /*@__PURE__*/ $constructor("ZodISODuration", (inst, def) => {
    $ZodISODuration.init(inst, def);
    ZodStringFormat.init(inst, def);
});
function duration(params) {
    return _isoDuration(ZodISODuration, params);
}

const initializer = (inst, issues) => {
    $ZodError.init(inst, issues);
    inst.name = "ZodError";
    Object.defineProperties(inst, {
        format: {
            value: (mapper) => formatError(inst, mapper),
            // enumerable: false,
        },
        flatten: {
            value: (mapper) => flattenError(inst, mapper),
            // enumerable: false,
        },
        addIssue: {
            value: (issue) => {
                inst.issues.push(issue);
                inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
            },
            // enumerable: false,
        },
        addIssues: {
            value: (issues) => {
                inst.issues.push(...issues);
                inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
            },
            // enumerable: false,
        },
        isEmpty: {
            get() {
                return inst.issues.length === 0;
            },
            // enumerable: false,
        },
    });
    // Object.defineProperty(inst, "isEmpty", {
    //   get() {
    //     return inst.issues.length === 0;
    //   },
    // });
};
const ZodRealError = $constructor("ZodError", initializer, {
    Parent: Error,
});
// /** @deprecated Use `z.core.$ZodErrorMapCtx` instead. */
// export type ErrorMapCtx = core.$ZodErrorMapCtx;

const parse = /* @__PURE__ */ _parse$2(ZodRealError);
const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
// Codec functions
const encode = /* @__PURE__ */ _encode(ZodRealError);
const decode = /* @__PURE__ */ _decode(ZodRealError);
const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

const ZodType = /*@__PURE__*/ $constructor("ZodType", (inst, def) => {
    $ZodType.init(inst, def);
    inst.def = def;
    inst.type = def.type;
    Object.defineProperty(inst, "_def", { value: def });
    // base methods
    inst.check = (...checks) => {
        return inst.clone(mergeDefs(def, {
            checks: [
                ...(def.checks ?? []),
                ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch),
            ],
        }));
    };
    inst.clone = (def, params) => clone(inst, def, params);
    inst.brand = () => inst;
    inst.register = ((reg, meta) => {
        reg.add(inst, meta);
        return inst;
    });
    // parsing
    inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });
    inst.safeParse = (data, params) => safeParse(inst, data, params);
    inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
    inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
    inst.spa = inst.safeParseAsync;
    // encoding/decoding
    inst.encode = (data, params) => encode(inst, data, params);
    inst.decode = (data, params) => decode(inst, data, params);
    inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
    inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
    inst.safeEncode = (data, params) => safeEncode(inst, data, params);
    inst.safeDecode = (data, params) => safeDecode(inst, data, params);
    inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
    inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
    // refinements
    inst.refine = (check, params) => inst.check(refine(check, params));
    inst.superRefine = (refinement) => inst.check(superRefine(refinement));
    inst.overwrite = (fn) => inst.check(_overwrite(fn));
    // wrappers
    inst.optional = () => optional(inst);
    inst.nullable = () => nullable(inst);
    inst.nullish = () => optional(nullable(inst));
    inst.nonoptional = (params) => nonoptional(inst, params);
    inst.array = () => array(inst);
    inst.or = (arg) => union([inst, arg]);
    inst.and = (arg) => intersection(inst, arg);
    inst.transform = (tx) => pipe(inst, transform(tx));
    inst.default = (def) => _default(inst, def);
    inst.prefault = (def) => prefault(inst, def);
    // inst.coalesce = (def, params) => coalesce(inst, def, params);
    inst.catch = (params) => _catch(inst, params);
    inst.pipe = (target) => pipe(inst, target);
    inst.readonly = () => readonly(inst);
    // meta
    inst.describe = (description) => {
        const cl = inst.clone();
        globalRegistry.add(cl, { description });
        return cl;
    };
    Object.defineProperty(inst, "description", {
        get() {
            return globalRegistry.get(inst)?.description;
        },
        configurable: true,
    });
    inst.meta = (...args) => {
        if (args.length === 0) {
            return globalRegistry.get(inst);
        }
        const cl = inst.clone();
        globalRegistry.add(cl, args[0]);
        return cl;
    };
    // helpers
    inst.isOptional = () => inst.safeParse(undefined).success;
    inst.isNullable = () => inst.safeParse(null).success;
    return inst;
});
/** @internal */
const _ZodString = /*@__PURE__*/ $constructor("_ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    ZodType.init(inst, def);
    const bag = inst._zod.bag;
    inst.format = bag.format ?? null;
    inst.minLength = bag.minimum ?? null;
    inst.maxLength = bag.maximum ?? null;
    // validations
    inst.regex = (...args) => inst.check(_regex(...args));
    inst.includes = (...args) => inst.check(_includes(...args));
    inst.startsWith = (...args) => inst.check(_startsWith(...args));
    inst.endsWith = (...args) => inst.check(_endsWith(...args));
    inst.min = (...args) => inst.check(_minLength(...args));
    inst.max = (...args) => inst.check(_maxLength(...args));
    inst.length = (...args) => inst.check(_length(...args));
    inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
    inst.lowercase = (params) => inst.check(_lowercase(params));
    inst.uppercase = (params) => inst.check(_uppercase(params));
    // transforms
    inst.trim = () => inst.check(_trim());
    inst.normalize = (...args) => inst.check(_normalize(...args));
    inst.toLowerCase = () => inst.check(_toLowerCase());
    inst.toUpperCase = () => inst.check(_toUpperCase());
});
const ZodString = /*@__PURE__*/ $constructor("ZodString", (inst, def) => {
    $ZodString.init(inst, def);
    _ZodString.init(inst, def);
    inst.email = (params) => inst.check(_email(ZodEmail, params));
    inst.url = (params) => inst.check(_url(ZodURL, params));
    inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
    inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
    inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
    inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
    inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
    inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
    inst.guid = (params) => inst.check(_guid(ZodGUID, params));
    inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
    inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
    inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
    inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
    inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
    inst.xid = (params) => inst.check(_xid(ZodXID, params));
    inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
    inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
    inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
    inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
    inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
    inst.e164 = (params) => inst.check(_e164(ZodE164, params));
    // iso
    inst.datetime = (params) => inst.check(datetime(params));
    inst.date = (params) => inst.check(date(params));
    inst.time = (params) => inst.check(time(params));
    inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
    return _string(ZodString, params);
}
const ZodStringFormat = /*@__PURE__*/ $constructor("ZodStringFormat", (inst, def) => {
    $ZodStringFormat.init(inst, def);
    _ZodString.init(inst, def);
});
const ZodEmail = /*@__PURE__*/ $constructor("ZodEmail", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodEmail.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodGUID = /*@__PURE__*/ $constructor("ZodGUID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodGUID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodUUID = /*@__PURE__*/ $constructor("ZodUUID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodUUID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodURL = /*@__PURE__*/ $constructor("ZodURL", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodURL.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodEmoji = /*@__PURE__*/ $constructor("ZodEmoji", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodEmoji.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodNanoID = /*@__PURE__*/ $constructor("ZodNanoID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodNanoID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodCUID = /*@__PURE__*/ $constructor("ZodCUID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodCUID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodCUID2 = /*@__PURE__*/ $constructor("ZodCUID2", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodCUID2.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodULID = /*@__PURE__*/ $constructor("ZodULID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodULID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodXID = /*@__PURE__*/ $constructor("ZodXID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodXID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodKSUID = /*@__PURE__*/ $constructor("ZodKSUID", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodKSUID.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodIPv4 = /*@__PURE__*/ $constructor("ZodIPv4", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodIPv4.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodIPv6 = /*@__PURE__*/ $constructor("ZodIPv6", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodIPv6.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodCIDRv4 = /*@__PURE__*/ $constructor("ZodCIDRv4", (inst, def) => {
    $ZodCIDRv4.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodCIDRv6 = /*@__PURE__*/ $constructor("ZodCIDRv6", (inst, def) => {
    $ZodCIDRv6.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodBase64 = /*@__PURE__*/ $constructor("ZodBase64", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodBase64.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodBase64URL = /*@__PURE__*/ $constructor("ZodBase64URL", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodBase64URL.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodE164 = /*@__PURE__*/ $constructor("ZodE164", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodE164.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodJWT = /*@__PURE__*/ $constructor("ZodJWT", (inst, def) => {
    // ZodStringFormat.init(inst, def);
    $ZodJWT.init(inst, def);
    ZodStringFormat.init(inst, def);
});
const ZodNumber = /*@__PURE__*/ $constructor("ZodNumber", (inst, def) => {
    $ZodNumber.init(inst, def);
    ZodType.init(inst, def);
    inst.gt = (value, params) => inst.check(_gt(value, params));
    inst.gte = (value, params) => inst.check(_gte(value, params));
    inst.min = (value, params) => inst.check(_gte(value, params));
    inst.lt = (value, params) => inst.check(_lt(value, params));
    inst.lte = (value, params) => inst.check(_lte(value, params));
    inst.max = (value, params) => inst.check(_lte(value, params));
    inst.int = (params) => inst.check(int(params));
    inst.safe = (params) => inst.check(int(params));
    inst.positive = (params) => inst.check(_gt(0, params));
    inst.nonnegative = (params) => inst.check(_gte(0, params));
    inst.negative = (params) => inst.check(_lt(0, params));
    inst.nonpositive = (params) => inst.check(_lte(0, params));
    inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
    inst.step = (value, params) => inst.check(_multipleOf(value, params));
    // inst.finite = (params) => inst.check(core.finite(params));
    inst.finite = () => inst;
    const bag = inst._zod.bag;
    inst.minValue =
        Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
    inst.maxValue =
        Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
    inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
    inst.isFinite = true;
    inst.format = bag.format ?? null;
});
function number$1(params) {
    return _number(ZodNumber, params);
}
const ZodNumberFormat = /*@__PURE__*/ $constructor("ZodNumberFormat", (inst, def) => {
    $ZodNumberFormat.init(inst, def);
    ZodNumber.init(inst, def);
});
function int(params) {
    return _int(ZodNumberFormat, params);
}
const ZodBoolean = /*@__PURE__*/ $constructor("ZodBoolean", (inst, def) => {
    $ZodBoolean.init(inst, def);
    ZodType.init(inst, def);
});
function boolean(params) {
    return _boolean(ZodBoolean, params);
}
const ZodAny = /*@__PURE__*/ $constructor("ZodAny", (inst, def) => {
    $ZodAny.init(inst, def);
    ZodType.init(inst, def);
});
function any() {
    return _any(ZodAny);
}
const ZodUnknown = /*@__PURE__*/ $constructor("ZodUnknown", (inst, def) => {
    $ZodUnknown.init(inst, def);
    ZodType.init(inst, def);
});
function unknown() {
    return _unknown(ZodUnknown);
}
const ZodNever = /*@__PURE__*/ $constructor("ZodNever", (inst, def) => {
    $ZodNever.init(inst, def);
    ZodType.init(inst, def);
});
function never(params) {
    return _never(ZodNever, params);
}
const ZodArray = /*@__PURE__*/ $constructor("ZodArray", (inst, def) => {
    $ZodArray.init(inst, def);
    ZodType.init(inst, def);
    inst.element = def.element;
    inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
    inst.nonempty = (params) => inst.check(_minLength(1, params));
    inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
    inst.length = (len, params) => inst.check(_length(len, params));
    inst.unwrap = () => inst.element;
});
function array(element, params) {
    return _array(ZodArray, element, params);
}
const ZodObject = /*@__PURE__*/ $constructor("ZodObject", (inst, def) => {
    $ZodObjectJIT.init(inst, def);
    ZodType.init(inst, def);
    defineLazy(inst, "shape", () => {
        return def.shape;
    });
    inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
    inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall: catchall });
    inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
    inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
    inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
    inst.extend = (incoming) => {
        return extend(inst, incoming);
    };
    inst.safeExtend = (incoming) => {
        return safeExtend(inst, incoming);
    };
    inst.merge = (other) => merge(inst, other);
    inst.pick = (mask) => pick(inst, mask);
    inst.omit = (mask) => omit(inst, mask);
    inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
    inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
    const def = {
        type: "object",
        shape: shape ?? {},
        ...normalizeParams(params),
    };
    return new ZodObject(def);
}
// looseObject
function looseObject(shape, params) {
    return new ZodObject({
        type: "object",
        shape,
        catchall: unknown(),
        ...normalizeParams(params),
    });
}
const ZodUnion = /*@__PURE__*/ $constructor("ZodUnion", (inst, def) => {
    $ZodUnion.init(inst, def);
    ZodType.init(inst, def);
    inst.options = def.options;
});
function union(options, params) {
    return new ZodUnion({
        type: "union",
        options: options,
        ...normalizeParams(params),
    });
}
const ZodDiscriminatedUnion = /*@__PURE__*/ $constructor("ZodDiscriminatedUnion", (inst, def) => {
    ZodUnion.init(inst, def);
    $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
    // const [options, params] = args;
    return new ZodDiscriminatedUnion({
        type: "union",
        options,
        discriminator,
        ...normalizeParams(params),
    });
}
const ZodIntersection = /*@__PURE__*/ $constructor("ZodIntersection", (inst, def) => {
    $ZodIntersection.init(inst, def);
    ZodType.init(inst, def);
});
function intersection(left, right) {
    return new ZodIntersection({
        type: "intersection",
        left: left,
        right: right,
    });
}
const ZodTuple = /*@__PURE__*/ $constructor("ZodTuple", (inst, def) => {
    $ZodTuple.init(inst, def);
    ZodType.init(inst, def);
    inst.rest = (rest) => inst.clone({
        ...inst._zod.def,
        rest: rest,
    });
});
function tuple(items, _paramsOrRest, _params) {
    const hasRest = _paramsOrRest instanceof $ZodType;
    const params = hasRest ? _params : _paramsOrRest;
    const rest = hasRest ? _paramsOrRest : null;
    return new ZodTuple({
        type: "tuple",
        items: items,
        rest,
        ...normalizeParams(params),
    });
}
const ZodRecord = /*@__PURE__*/ $constructor("ZodRecord", (inst, def) => {
    $ZodRecord.init(inst, def);
    ZodType.init(inst, def);
    inst.keyType = def.keyType;
    inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
    return new ZodRecord({
        type: "record",
        keyType,
        valueType: valueType,
        ...normalizeParams(params),
    });
}
const ZodEnum = /*@__PURE__*/ $constructor("ZodEnum", (inst, def) => {
    $ZodEnum.init(inst, def);
    ZodType.init(inst, def);
    inst.enum = def.entries;
    inst.options = Object.values(def.entries);
    const keys = new Set(Object.keys(def.entries));
    inst.extract = (values, params) => {
        const newEntries = {};
        for (const value of values) {
            if (keys.has(value)) {
                newEntries[value] = def.entries[value];
            }
            else
                throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
            ...def,
            checks: [],
            ...normalizeParams(params),
            entries: newEntries,
        });
    };
    inst.exclude = (values, params) => {
        const newEntries = { ...def.entries };
        for (const value of values) {
            if (keys.has(value)) {
                delete newEntries[value];
            }
            else
                throw new Error(`Key ${value} not found in enum`);
        }
        return new ZodEnum({
            ...def,
            checks: [],
            ...normalizeParams(params),
            entries: newEntries,
        });
    };
});
function _enum(values, params) {
    const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
    return new ZodEnum({
        type: "enum",
        entries,
        ...normalizeParams(params),
    });
}
const ZodLiteral = /*@__PURE__*/ $constructor("ZodLiteral", (inst, def) => {
    $ZodLiteral.init(inst, def);
    ZodType.init(inst, def);
    inst.values = new Set(def.values);
    Object.defineProperty(inst, "value", {
        get() {
            if (def.values.length > 1) {
                throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
            }
            return def.values[0];
        },
    });
});
function literal(value, params) {
    return new ZodLiteral({
        type: "literal",
        values: Array.isArray(value) ? value : [value],
        ...normalizeParams(params),
    });
}
const ZodTransform = /*@__PURE__*/ $constructor("ZodTransform", (inst, def) => {
    $ZodTransform.init(inst, def);
    ZodType.init(inst, def);
    inst._zod.parse = (payload, _ctx) => {
        if (_ctx.direction === "backward") {
            throw new $ZodEncodeError(inst.constructor.name);
        }
        payload.addIssue = (issue$1) => {
            if (typeof issue$1 === "string") {
                payload.issues.push(issue(issue$1, payload.value, def));
            }
            else {
                // for Zod 3 backwards compatibility
                const _issue = issue$1;
                if (_issue.fatal)
                    _issue.continue = false;
                _issue.code ?? (_issue.code = "custom");
                _issue.input ?? (_issue.input = payload.value);
                _issue.inst ?? (_issue.inst = inst);
                // _issue.continue ??= true;
                payload.issues.push(issue(_issue));
            }
        };
        const output = def.transform(payload.value, payload);
        if (output instanceof Promise) {
            return output.then((output) => {
                payload.value = output;
                return payload;
            });
        }
        payload.value = output;
        return payload;
    };
});
function transform(fn) {
    return new ZodTransform({
        type: "transform",
        transform: fn,
    });
}
const ZodOptional = /*@__PURE__*/ $constructor("ZodOptional", (inst, def) => {
    $ZodOptional.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
    return new ZodOptional({
        type: "optional",
        innerType: innerType,
    });
}
const ZodNullable = /*@__PURE__*/ $constructor("ZodNullable", (inst, def) => {
    $ZodNullable.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
    return new ZodNullable({
        type: "nullable",
        innerType: innerType,
    });
}
const ZodDefault = /*@__PURE__*/ $constructor("ZodDefault", (inst, def) => {
    $ZodDefault.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
    return new ZodDefault({
        type: "default",
        innerType: innerType,
        get defaultValue() {
            return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
        },
    });
}
const ZodPrefault = /*@__PURE__*/ $constructor("ZodPrefault", (inst, def) => {
    $ZodPrefault.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
    return new ZodPrefault({
        type: "prefault",
        innerType: innerType,
        get defaultValue() {
            return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
        },
    });
}
const ZodNonOptional = /*@__PURE__*/ $constructor("ZodNonOptional", (inst, def) => {
    $ZodNonOptional.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
    return new ZodNonOptional({
        type: "nonoptional",
        innerType: innerType,
        ...normalizeParams(params),
    });
}
const ZodCatch = /*@__PURE__*/ $constructor("ZodCatch", (inst, def) => {
    $ZodCatch.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
    inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
    return new ZodCatch({
        type: "catch",
        innerType: innerType,
        catchValue: (typeof catchValue === "function" ? catchValue : () => catchValue),
    });
}
const ZodPipe = /*@__PURE__*/ $constructor("ZodPipe", (inst, def) => {
    $ZodPipe.init(inst, def);
    ZodType.init(inst, def);
    inst.in = def.in;
    inst.out = def.out;
});
function pipe(in_, out) {
    return new ZodPipe({
        type: "pipe",
        in: in_,
        out: out,
        // ...util.normalizeParams(params),
    });
}
const ZodReadonly = /*@__PURE__*/ $constructor("ZodReadonly", (inst, def) => {
    $ZodReadonly.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
    return new ZodReadonly({
        type: "readonly",
        innerType: innerType,
    });
}
const ZodLazy = /*@__PURE__*/ $constructor("ZodLazy", (inst, def) => {
    $ZodLazy.init(inst, def);
    ZodType.init(inst, def);
    inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
    return new ZodLazy({
        type: "lazy",
        getter: getter,
    });
}
const ZodCustom = /*@__PURE__*/ $constructor("ZodCustom", (inst, def) => {
    $ZodCustom.init(inst, def);
    ZodType.init(inst, def);
});
function refine(fn, _params = {}) {
    return _refine(ZodCustom, fn, _params);
}
// superRefine
function superRefine(fn) {
    return _superRefine(fn);
}

function number(params) {
    return _coercedNumber(ZodNumber, params);
}

var util;
(function (util) {
    util.assertEqual = (_) => { };
    function assertIs(_arg) { }
    util.assertIs = assertIs;
    function assertNever(_x) {
        throw new Error();
    }
    util.assertNever = assertNever;
    util.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
            obj[item] = item;
        }
        return obj;
    };
    util.getValidEnumValues = (obj) => {
        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
            filtered[k] = obj[k];
        }
        return util.objectValues(filtered);
    };
    util.objectValues = (obj) => {
        return util.objectKeys(obj).map(function (e) {
            return obj[e];
        });
    };
    util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
        : (object) => {
            const keys = [];
            for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                    keys.push(key);
                }
            }
            return keys;
        };
    util.find = (arr, checker) => {
        for (const item of arr) {
            if (checker(item))
                return item;
        }
        return undefined;
    };
    util.isInteger = typeof Number.isInteger === "function"
        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
        : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
    function joinValues(array, separator = " | ") {
        return array.map((val) => (typeof val === "string" ? `'${val}'` : val)).join(separator);
    }
    util.joinValues = joinValues;
    util.jsonStringifyReplacer = (_, value) => {
        if (typeof value === "bigint") {
            return value.toString();
        }
        return value;
    };
})(util || (util = {}));
var objectUtil;
(function (objectUtil) {
    objectUtil.mergeShapes = (first, second) => {
        return {
            ...first,
            ...second, // second overwrites first
        };
    };
})(objectUtil || (objectUtil = {}));
util.arrayToEnum([
    "string",
    "nan",
    "number",
    "integer",
    "float",
    "boolean",
    "date",
    "bigint",
    "symbol",
    "function",
    "undefined",
    "null",
    "array",
    "object",
    "unknown",
    "promise",
    "void",
    "never",
    "map",
    "set",
]);

util.arrayToEnum([
    "invalid_type",
    "invalid_literal",
    "custom",
    "invalid_union",
    "invalid_union_discriminator",
    "invalid_enum_value",
    "unrecognized_keys",
    "invalid_arguments",
    "invalid_return_type",
    "invalid_date",
    "invalid_string",
    "too_small",
    "too_big",
    "invalid_intersection_types",
    "not_multiple_of",
    "not_finite",
]);
class ZodError extends Error {
    get errors() {
        return this.issues;
    }
    constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
            this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
            this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
            // eslint-disable-next-line ban/ban
            Object.setPrototypeOf(this, actualProto);
        }
        else {
            this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
    }
    format(_mapper) {
        const mapper = _mapper ||
            function (issue) {
                return issue.message;
            };
        const fieldErrors = { _errors: [] };
        const processError = (error) => {
            for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                    issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                    processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                    processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                    fieldErrors._errors.push(mapper(issue));
                }
                else {
                    let curr = fieldErrors;
                    let i = 0;
                    while (i < issue.path.length) {
                        const el = issue.path[i];
                        const terminal = i === issue.path.length - 1;
                        if (!terminal) {
                            curr[el] = curr[el] || { _errors: [] };
                            // if (typeof el === "string") {
                            //   curr[el] = curr[el] || { _errors: [] };
                            // } else if (typeof el === "number") {
                            //   const errorArray: any = [];
                            //   errorArray._errors = [];
                            //   curr[el] = curr[el] || errorArray;
                            // }
                        }
                        else {
                            curr[el] = curr[el] || { _errors: [] };
                            curr[el]._errors.push(mapper(issue));
                        }
                        curr = curr[el];
                        i++;
                    }
                }
            }
        };
        processError(this);
        return fieldErrors;
    }
    static assert(value) {
        if (!(value instanceof ZodError)) {
            throw new Error(`Not a ZodError: ${value}`);
        }
    }
    toString() {
        return this.message;
    }
    get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
    }
    get isEmpty() {
        return this.issues.length === 0;
    }
    flatten(mapper = (issue) => issue.message) {
        const fieldErrors = Object.create(null);
        const formErrors = [];
        for (const sub of this.issues) {
            if (sub.path.length > 0) {
                const firstEl = sub.path[0];
                fieldErrors[firstEl] = fieldErrors[firstEl] || [];
                fieldErrors[firstEl].push(mapper(sub));
            }
            else {
                formErrors.push(mapper(sub));
            }
        }
        return { formErrors, fieldErrors };
    }
    get formErrors() {
        return this.flatten();
    }
}
ZodError.create = (issues) => {
    const error = new ZodError(issues);
    return error;
};

var errorUtil;
(function (errorUtil) {
    errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
    // biome-ignore lint:
    errorUtil.toString = (message) => typeof message === "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

var ZodFirstPartyTypeKind;
(function (ZodFirstPartyTypeKind) {
    ZodFirstPartyTypeKind["ZodString"] = "ZodString";
    ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
    ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
    ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
    ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
    ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
    ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
    ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
    ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
    ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
    ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
    ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
    ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
    ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
    ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
    ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
    ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
    ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
    ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
    ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
    ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
    ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
    ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
    ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
    ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
    ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
    ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
    ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
    ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
    ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
    ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
    ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
    ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
    ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
    ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
    ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

// src/combine-headers.ts
function combineHeaders$1(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => ({
      ...combinedHeaders,
      ...currentHeaders != null ? currentHeaders : {}
    }),
    {}
  );
}

// src/extract-response-headers.ts
function extractResponseHeaders$1(response) {
  return Object.fromEntries([...response.headers]);
}
var createIdGenerator$1 = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0; i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError$1({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
var generateId$1 = createIdGenerator$1();

// src/is-abort-error.ts
function isAbortError$1(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}

// src/handle-fetch-error.ts
var FETCH_FAILED_ERROR_MESSAGES$1 = ["fetch failed", "failed to fetch"];
function handleFetchError$1({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError$1(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES$1.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new APICallError$1({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error;
}

// src/get-runtime-environment-user-agent.ts
function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
  var _a, _b, _c;
  if (globalThisAny.window) {
    return `runtime/browser`;
  }
  if ((_a = globalThisAny.navigator) == null ? void 0 : _a.userAgent) {
    return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
  }
  if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {
    return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
  }
  if (globalThisAny.EdgeRuntime) {
    return `runtime/vercel-edge`;
  }
  return "runtime/unknown";
}

// src/remove-undefined-entries.ts
function removeUndefinedEntries$1(record) {
  return Object.fromEntries(
    Object.entries(record).filter(([_key, value]) => value != null)
  );
}

// src/with-user-agent-suffix.ts
function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
  const cleanedHeaders = removeUndefinedEntries$1(
    headers != null ? headers : {}
  );
  const normalizedHeaders = new Headers(cleanedHeaders);
  const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
  normalizedHeaders.set(
    "user-agent",
    [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
  );
  return Object.fromEntries(normalizedHeaders);
}

// src/version.ts
var VERSION$5 = "3.0.12" ;
function loadApiKey$1({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError$1({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError$1({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError$1({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError$1({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}

// src/load-optional-setting.ts
function loadOptionalSetting({
  settingValue,
  environmentVariableName
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null || typeof process === "undefined") {
    return void 0;
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null || typeof settingValue !== "string") {
    return void 0;
  }
  return settingValue;
}
function loadSetting({
  settingValue,
  environmentVariableName,
  settingName,
  description
}) {
  if (typeof settingValue === "string") {
    return settingValue;
  }
  if (settingValue != null) {
    throw new LoadSettingError({
      message: `${description} setting must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadSettingError({
      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  settingValue = process.env[environmentVariableName];
  if (settingValue == null) {
    throw new LoadSettingError({
      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof settingValue !== "string") {
    throw new LoadSettingError({
      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return settingValue;
}

// src/media-type-to-extension.ts
function mediaTypeToExtension(mediaType) {
  var _a;
  const [_type, subtype = ""] = mediaType.toLowerCase().split("/");
  return (_a = {
    mpeg: "mp3",
    "x-wav": "wav",
    opus: "ogg",
    mp4: "m4a",
    "x-m4a": "m4a"
  }[subtype]) != null ? _a : subtype;
}

// src/secure-json-parse.ts
var suspectProtoRx$1 = /"__proto__"\s*:/;
var suspectConstructorRx$1 = /"constructor"\s*:/;
function _parse$1(text) {
  const obj = JSON.parse(text);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx$1.test(text) === false && suspectConstructorRx$1.test(text) === false) {
    return obj;
  }
  return filter$1(obj);
}
function filter$1(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse$1(text) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse$1(text);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
var validatorSymbol$1 = Symbol.for("vercel.ai.validator");
function validator$1(validate) {
  return { [validatorSymbol$1]: true, validate };
}
function isValidator$1(value) {
  return typeof value === "object" && value !== null && validatorSymbol$1 in value && value[validatorSymbol$1] === true && "validate" in value;
}
function lazyValidator(createValidator) {
  let validator2;
  return () => {
    if (validator2 == null) {
      validator2 = createValidator();
    }
    return validator2;
  };
}
function asValidator$1(value) {
  return isValidator$1(value) ? value : typeof value === "function" ? value() : standardSchemaValidator$1(value);
}
function standardSchemaValidator$1(standardSchema) {
  return validator$1(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError$1({
        value,
        cause: result.issues
      })
    };
  });
}

// src/validate-types.ts
async function validateTypes$1({
  value,
  schema
}) {
  const result = await safeValidateTypes$1({ value, schema });
  if (!result.success) {
    throw TypeValidationError$1.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes$1({
  value,
  schema
}) {
  const validator2 = asValidator$1(schema);
  try {
    if (validator2.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator2.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError$1.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError$1.wrap({ value, cause: error }),
      rawValue: value
    };
  }
}

// src/parse-json.ts
async function parseJSON$1({
  text,
  schema
}) {
  try {
    const value = secureJsonParse$1(text);
    if (schema == null) {
      return value;
    }
    return validateTypes$1({ value, schema });
  } catch (error) {
    if (JSONParseError$1.isInstance(error) || TypeValidationError$1.isInstance(error)) {
      throw error;
    }
    throw new JSONParseError$1({ text, cause: error });
  }
}
async function safeParseJSON$1({
  text,
  schema
}) {
  try {
    const value = secureJsonParse$1(text);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes$1({ value, schema });
  } catch (error) {
    return {
      success: false,
      error: JSONParseError$1.isInstance(error) ? error : new JSONParseError$1({ text, cause: error }),
      rawValue: void 0
    };
  }
}
function isParsableJson$1(input) {
  try {
    secureJsonParse$1(input);
    return true;
  } catch (e) {
    return false;
  }
}
function parseJsonEventStream$1({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream$1()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON$1({ text: data, schema }));
      }
    })
  );
}
async function parseProviderOptions({
  provider,
  providerOptions,
  schema
}) {
  if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
    return void 0;
  }
  const parsedProviderOptions = await safeValidateTypes$1({
    value: providerOptions[provider],
    schema
  });
  if (!parsedProviderOptions.success) {
    throw new InvalidArgumentError$1({
      argument: "providerOptions",
      message: `invalid ${provider} provider options`,
      cause: parsedProviderOptions.error
    });
  }
  return parsedProviderOptions.value;
}
var getOriginalFetch2$1 = () => globalThis.fetch;
var postJsonToApi$1 = async ({
  url,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch
}) => postToApi$1({
  url,
  headers: {
    "Content-Type": "application/json",
    ...headers
  },
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch
});
var postFormDataToApi = async ({
  url,
  headers,
  formData,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch
}) => postToApi$1({
  url,
  headers,
  body: {
    content: formData,
    values: Object.fromEntries(formData.entries())
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch
});
var postToApi$1 = async ({
  url,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch = getOriginalFetch2$1()
}) => {
  try {
    const response = await fetch(url, {
      method: "POST",
      headers: withUserAgentSuffix(
        headers,
        `ai-sdk/provider-utils/${VERSION$5}`,
        getRuntimeEnvironmentUserAgent()
      ),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders$1(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (isAbortError$1(error) || APICallError$1.isInstance(error)) {
          throw error;
        }
        throw new APICallError$1({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: body.values
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError$1(error) || APICallError$1.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError$1({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error) {
    throw handleFetchError$1({ error, url, requestBodyValues: body.values });
  }
};

// src/types/tool.ts
function tool(tool2) {
  return tool2;
}

// src/provider-defined-tool-factory.ts
function createProviderDefinedToolFactory({
  id,
  name,
  inputSchema
}) {
  return ({
    execute,
    outputSchema,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    ...args
  }) => tool({
    type: "provider-defined",
    id,
    name,
    args,
    inputSchema,
    outputSchema,
    execute,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable
  });
}
function createProviderDefinedToolFactoryWithOutputSchema({
  id,
  name,
  inputSchema,
  outputSchema
}) {
  return ({
    execute,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable,
    ...args
  }) => tool({
    type: "provider-defined",
    id,
    name,
    args,
    inputSchema,
    outputSchema,
    execute,
    toModelOutput,
    onInputStart,
    onInputDelta,
    onInputAvailable
  });
}

// src/resolve.ts
async function resolve(value) {
  if (typeof value === "function") {
    value = value();
  }
  return Promise.resolve(value);
}
var createJsonErrorResponseHandler$1 = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders$1(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError$1({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = await parseJSON$1({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError$1({
        message: errorToMessage(parsedError),
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError$1({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler$1 = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders$1(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError$1({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream$1({
      stream: response.body,
      schema: chunkSchema
    })
  };
};
var createJsonResponseHandler$1 = (responseSchema) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = await safeParseJSON$1({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders$1(response);
  if (!parsedResult.success) {
    throw new APICallError$1({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
var createBinaryResponseHandler = () => async ({ response, url, requestBodyValues }) => {
  const responseHeaders = extractResponseHeaders$1(response);
  if (!response.body) {
    throw new APICallError$1({
      message: "Response body is empty",
      url,
      requestBodyValues,
      statusCode: response.status,
      responseHeaders,
      responseBody: void 0
    });
  }
  try {
    const buffer = await response.arrayBuffer();
    return {
      responseHeaders,
      value: new Uint8Array(buffer)
    };
  } catch (error) {
    throw new APICallError$1({
      message: "Failed to read response as array buffer",
      url,
      requestBodyValues,
      statusCode: response.status,
      responseHeaders,
      responseBody: void 0,
      cause: error
    });
  }
};

// src/zod-to-json-schema/get-relative-path.ts
var getRelativePath = (pathA, pathB) => {
  let i = 0;
  for (; i < pathA.length && i < pathB.length; i++) {
    if (pathA[i] !== pathB[i]) break;
  }
  return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
};

// src/zod-to-json-schema/options.ts
var ignoreOverride = Symbol(
  "Let zodToJsonSchema decide on which parser to use"
);
var defaultOptions = {
  name: void 0,
  $refStrategy: "root",
  basePath: ["#"],
  effectStrategy: "input",
  pipeStrategy: "all",
  dateStrategy: "format:date-time",
  mapStrategy: "entries",
  removeAdditionalStrategy: "passthrough",
  allowedAdditionalProperties: true,
  rejectedAdditionalProperties: false,
  definitionPath: "definitions",
  strictUnions: false,
  definitions: {},
  errorMessages: false,
  patternStrategy: "escape",
  applyRegexFlags: false,
  emailStrategy: "format:email",
  base64Strategy: "contentEncoding:base64",
  nameStrategy: "ref"
};
var getDefaultOptions = (options) => typeof options === "string" ? {
  ...defaultOptions,
  name: options
} : {
  ...defaultOptions,
  ...options
};

// src/zod-to-json-schema/parsers/any.ts
function parseAnyDef() {
  return {};
}
function parseArrayDef(def, refs) {
  var _a, _b, _c;
  const res = {
    type: "array"
  };
  if (((_a = def.type) == null ? void 0 : _a._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
    res.items = parseDef(def.type._def, {
      ...refs,
      currentPath: [...refs.currentPath, "items"]
    });
  }
  if (def.minLength) {
    res.minItems = def.minLength.value;
  }
  if (def.maxLength) {
    res.maxItems = def.maxLength.value;
  }
  if (def.exactLength) {
    res.minItems = def.exactLength.value;
    res.maxItems = def.exactLength.value;
  }
  return res;
}

// src/zod-to-json-schema/parsers/bigint.ts
function parseBigintDef(def) {
  const res = {
    type: "integer",
    format: "int64"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}

// src/zod-to-json-schema/parsers/boolean.ts
function parseBooleanDef() {
  return { type: "boolean" };
}

// src/zod-to-json-schema/parsers/branded.ts
function parseBrandedDef(_def, refs) {
  return parseDef(_def.type._def, refs);
}

// src/zod-to-json-schema/parsers/catch.ts
var parseCatchDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// src/zod-to-json-schema/parsers/date.ts
function parseDateDef(def, refs, overrideDateStrategy) {
  const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
  if (Array.isArray(strategy)) {
    return {
      anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
    };
  }
  switch (strategy) {
    case "string":
    case "format:date-time":
      return {
        type: "string",
        format: "date-time"
      };
    case "format:date":
      return {
        type: "string",
        format: "date"
      };
    case "integer":
      return integerDateParser(def);
  }
}
var integerDateParser = (def) => {
  const res = {
    type: "integer",
    format: "unix-time"
  };
  for (const check of def.checks) {
    switch (check.kind) {
      case "min":
        res.minimum = check.value;
        break;
      case "max":
        res.maximum = check.value;
        break;
    }
  }
  return res;
};

// src/zod-to-json-schema/parsers/default.ts
function parseDefaultDef(_def, refs) {
  return {
    ...parseDef(_def.innerType._def, refs),
    default: _def.defaultValue()
  };
}

// src/zod-to-json-schema/parsers/effects.ts
function parseEffectsDef(_def, refs) {
  return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();
}

// src/zod-to-json-schema/parsers/enum.ts
function parseEnumDef(def) {
  return {
    type: "string",
    enum: Array.from(def.values)
  };
}

// src/zod-to-json-schema/parsers/intersection.ts
var isJsonSchema7AllOfType = (type) => {
  if ("type" in type && type.type === "string") return false;
  return "allOf" in type;
};
function parseIntersectionDef(def, refs) {
  const allOf = [
    parseDef(def.left._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "0"]
    }),
    parseDef(def.right._def, {
      ...refs,
      currentPath: [...refs.currentPath, "allOf", "1"]
    })
  ].filter((x) => !!x);
  const mergedAllOf = [];
  allOf.forEach((schema) => {
    if (isJsonSchema7AllOfType(schema)) {
      mergedAllOf.push(...schema.allOf);
    } else {
      let nestedSchema = schema;
      if ("additionalProperties" in schema && schema.additionalProperties === false) {
        const { additionalProperties, ...rest } = schema;
        nestedSchema = rest;
      }
      mergedAllOf.push(nestedSchema);
    }
  });
  return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
}

// src/zod-to-json-schema/parsers/literal.ts
function parseLiteralDef(def) {
  const parsedType = typeof def.value;
  if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
    return {
      type: Array.isArray(def.value) ? "array" : "object"
    };
  }
  return {
    type: parsedType === "bigint" ? "integer" : parsedType,
    const: def.value
  };
}

// src/zod-to-json-schema/parsers/string.ts
var emojiRegex = void 0;
var zodPatterns = {
  /**
   * `c` was changed to `[cC]` to replicate /i flag
   */
  cuid: /^[cC][^\s-]{8,}$/,
  cuid2: /^[0-9a-z]+$/,
  ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
  /**
   * `a-z` was added to replicate /i flag
   */
  email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
  /**
   * Constructed a valid Unicode RegExp
   *
   * Lazily instantiate since this type of regex isn't supported
   * in all envs (e.g. React Native).
   *
   * See:
   * https://github.com/colinhacks/zod/issues/2433
   * Fix in Zod:
   * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
   */
  emoji: () => {
    if (emojiRegex === void 0) {
      emojiRegex = RegExp(
        "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
        "u"
      );
    }
    return emojiRegex;
  },
  /**
   * Unused
   */
  uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
  /**
   * Unused
   */
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
  ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
  /**
   * Unused
   */
  ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
  ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
  base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
  base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
  nanoid: /^[a-zA-Z0-9_-]{21}$/,
  jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
};
function parseStringDef(def, refs) {
  const res = {
    type: "string"
  };
  if (def.checks) {
    for (const check of def.checks) {
      switch (check.kind) {
        case "min":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          break;
        case "max":
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "email":
          switch (refs.emailStrategy) {
            case "format:email":
              addFormat(res, "email", check.message, refs);
              break;
            case "format:idn-email":
              addFormat(res, "idn-email", check.message, refs);
              break;
            case "pattern:zod":
              addPattern(res, zodPatterns.email, check.message, refs);
              break;
          }
          break;
        case "url":
          addFormat(res, "uri", check.message, refs);
          break;
        case "uuid":
          addFormat(res, "uuid", check.message, refs);
          break;
        case "regex":
          addPattern(res, check.regex, check.message, refs);
          break;
        case "cuid":
          addPattern(res, zodPatterns.cuid, check.message, refs);
          break;
        case "cuid2":
          addPattern(res, zodPatterns.cuid2, check.message, refs);
          break;
        case "startsWith":
          addPattern(
            res,
            RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),
            check.message,
            refs
          );
          break;
        case "endsWith":
          addPattern(
            res,
            RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),
            check.message,
            refs
          );
          break;
        case "datetime":
          addFormat(res, "date-time", check.message, refs);
          break;
        case "date":
          addFormat(res, "date", check.message, refs);
          break;
        case "time":
          addFormat(res, "time", check.message, refs);
          break;
        case "duration":
          addFormat(res, "duration", check.message, refs);
          break;
        case "length":
          res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
          res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
          break;
        case "includes": {
          addPattern(
            res,
            RegExp(escapeLiteralCheckValue(check.value, refs)),
            check.message,
            refs
          );
          break;
        }
        case "ip": {
          if (check.version !== "v6") {
            addFormat(res, "ipv4", check.message, refs);
          }
          if (check.version !== "v4") {
            addFormat(res, "ipv6", check.message, refs);
          }
          break;
        }
        case "base64url":
          addPattern(res, zodPatterns.base64url, check.message, refs);
          break;
        case "jwt":
          addPattern(res, zodPatterns.jwt, check.message, refs);
          break;
        case "cidr": {
          if (check.version !== "v6") {
            addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
          }
          if (check.version !== "v4") {
            addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
          }
          break;
        }
        case "emoji":
          addPattern(res, zodPatterns.emoji(), check.message, refs);
          break;
        case "ulid": {
          addPattern(res, zodPatterns.ulid, check.message, refs);
          break;
        }
        case "base64": {
          switch (refs.base64Strategy) {
            case "format:binary": {
              addFormat(res, "binary", check.message, refs);
              break;
            }
            case "contentEncoding:base64": {
              res.contentEncoding = "base64";
              break;
            }
            case "pattern:zod": {
              addPattern(res, zodPatterns.base64, check.message, refs);
              break;
            }
          }
          break;
        }
        case "nanoid": {
          addPattern(res, zodPatterns.nanoid, check.message, refs);
        }
      }
    }
  }
  return res;
}
function escapeLiteralCheckValue(literal, refs) {
  return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
}
var ALPHA_NUMERIC = new Set(
  "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
);
function escapeNonAlphaNumeric(source) {
  let result = "";
  for (let i = 0; i < source.length; i++) {
    if (!ALPHA_NUMERIC.has(source[i])) {
      result += "\\";
    }
    result += source[i];
  }
  return result;
}
function addFormat(schema, value, message, refs) {
  var _a;
  if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x) => x.format))) {
    if (!schema.anyOf) {
      schema.anyOf = [];
    }
    if (schema.format) {
      schema.anyOf.push({
        format: schema.format
      });
      delete schema.format;
    }
    schema.anyOf.push({
      format: value,
      ...message && refs.errorMessages && { errorMessage: { format: message } }
    });
  } else {
    schema.format = value;
  }
}
function addPattern(schema, regex, message, refs) {
  var _a;
  if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x) => x.pattern))) {
    if (!schema.allOf) {
      schema.allOf = [];
    }
    if (schema.pattern) {
      schema.allOf.push({
        pattern: schema.pattern
      });
      delete schema.pattern;
    }
    schema.allOf.push({
      pattern: stringifyRegExpWithFlags(regex, refs),
      ...message && refs.errorMessages && { errorMessage: { pattern: message } }
    });
  } else {
    schema.pattern = stringifyRegExpWithFlags(regex, refs);
  }
}
function stringifyRegExpWithFlags(regex, refs) {
  var _a;
  if (!refs.applyRegexFlags || !regex.flags) {
    return regex.source;
  }
  const flags = {
    i: regex.flags.includes("i"),
    // Case-insensitive
    m: regex.flags.includes("m"),
    // `^` and `$` matches adjacent to newline characters
    s: regex.flags.includes("s")
    // `.` matches newlines
  };
  const source = flags.i ? regex.source.toLowerCase() : regex.source;
  let pattern = "";
  let isEscaped = false;
  let inCharGroup = false;
  let inCharRange = false;
  for (let i = 0; i < source.length; i++) {
    if (isEscaped) {
      pattern += source[i];
      isEscaped = false;
      continue;
    }
    if (flags.i) {
      if (inCharGroup) {
        if (source[i].match(/[a-z]/)) {
          if (inCharRange) {
            pattern += source[i];
            pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
            inCharRange = false;
          } else if (source[i + 1] === "-" && ((_a = source[i + 2]) == null ? void 0 : _a.match(/[a-z]/))) {
            pattern += source[i];
            inCharRange = true;
          } else {
            pattern += `${source[i]}${source[i].toUpperCase()}`;
          }
          continue;
        }
      } else if (source[i].match(/[a-z]/)) {
        pattern += `[${source[i]}${source[i].toUpperCase()}]`;
        continue;
      }
    }
    if (flags.m) {
      if (source[i] === "^") {
        pattern += `(^|(?<=[\r
]))`;
        continue;
      } else if (source[i] === "$") {
        pattern += `($|(?=[\r
]))`;
        continue;
      }
    }
    if (flags.s && source[i] === ".") {
      pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
      continue;
    }
    pattern += source[i];
    if (source[i] === "\\") {
      isEscaped = true;
    } else if (inCharGroup && source[i] === "]") {
      inCharGroup = false;
    } else if (!inCharGroup && source[i] === "[") {
      inCharGroup = true;
    }
  }
  try {
    new RegExp(pattern);
  } catch (e) {
    console.warn(
      `Could not convert regex pattern at ${refs.currentPath.join(
        "/"
      )} to a flag-independent form! Falling back to the flag-ignorant source`
    );
    return regex.source;
  }
  return pattern;
}

// src/zod-to-json-schema/parsers/record.ts
function parseRecordDef(def, refs) {
  var _a, _b, _c, _d, _e, _f;
  const schema = {
    type: "object",
    additionalProperties: (_a = parseDef(def.valueType._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    })) != null ? _a : refs.allowedAdditionalProperties
  };
  if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
    const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
    return {
      ...schema,
      propertyNames: keyType
    };
  } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
    return {
      ...schema,
      propertyNames: {
        enum: def.keyType._def.values
      }
    };
  } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
    const { type, ...keyType } = parseBrandedDef(
      def.keyType._def,
      refs
    );
    return {
      ...schema,
      propertyNames: keyType
    };
  }
  return schema;
}

// src/zod-to-json-schema/parsers/map.ts
function parseMapDef(def, refs) {
  if (refs.mapStrategy === "record") {
    return parseRecordDef(def, refs);
  }
  const keys = parseDef(def.keyType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "0"]
  }) || parseAnyDef();
  const values = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items", "items", "1"]
  }) || parseAnyDef();
  return {
    type: "array",
    maxItems: 125,
    items: {
      type: "array",
      items: [keys, values],
      minItems: 2,
      maxItems: 2
    }
  };
}

// src/zod-to-json-schema/parsers/native-enum.ts
function parseNativeEnumDef(def) {
  const object = def.values;
  const actualKeys = Object.keys(def.values).filter((key) => {
    return typeof object[object[key]] !== "number";
  });
  const actualValues = actualKeys.map((key) => object[key]);
  const parsedTypes = Array.from(
    new Set(actualValues.map((values) => typeof values))
  );
  return {
    type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
    enum: actualValues
  };
}

// src/zod-to-json-schema/parsers/never.ts
function parseNeverDef() {
  return { not: parseAnyDef() };
}

// src/zod-to-json-schema/parsers/null.ts
function parseNullDef() {
  return {
    type: "null"
  };
}

// src/zod-to-json-schema/parsers/union.ts
var primitiveMappings = {
  ZodString: "string",
  ZodNumber: "number",
  ZodBigInt: "integer",
  ZodBoolean: "boolean",
  ZodNull: "null"
};
function parseUnionDef(def, refs) {
  const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
  if (options.every(
    (x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length)
  )) {
    const types = options.reduce((types2, x) => {
      const type = primitiveMappings[x._def.typeName];
      return type && !types2.includes(type) ? [...types2, type] : types2;
    }, []);
    return {
      type: types.length > 1 ? types : types[0]
    };
  } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
    const types = options.reduce(
      (acc, x) => {
        const type = typeof x._def.value;
        switch (type) {
          case "string":
          case "number":
          case "boolean":
            return [...acc, type];
          case "bigint":
            return [...acc, "integer"];
          case "object":
            if (x._def.value === null) return [...acc, "null"];
          case "symbol":
          case "undefined":
          case "function":
          default:
            return acc;
        }
      },
      []
    );
    if (types.length === options.length) {
      const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
      return {
        type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
        enum: options.reduce(
          (acc, x) => {
            return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
          },
          []
        )
      };
    }
  } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
    return {
      type: "string",
      enum: options.reduce(
        (acc, x) => [
          ...acc,
          ...x._def.values.filter((x2) => !acc.includes(x2))
        ],
        []
      )
    };
  }
  return asAnyOf(def, refs);
}
var asAnyOf = (def, refs) => {
  const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
    (x, i) => parseDef(x._def, {
      ...refs,
      currentPath: [...refs.currentPath, "anyOf", `${i}`]
    })
  ).filter(
    (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
  );
  return anyOf.length ? { anyOf } : void 0;
};

// src/zod-to-json-schema/parsers/nullable.ts
function parseNullableDef(def, refs) {
  if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
    def.innerType._def.typeName
  ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
    return {
      type: [
        primitiveMappings[def.innerType._def.typeName],
        "null"
      ]
    };
  }
  const base = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "0"]
  });
  return base && { anyOf: [base, { type: "null" }] };
}

// src/zod-to-json-schema/parsers/number.ts
function parseNumberDef(def) {
  const res = {
    type: "number"
  };
  if (!def.checks) return res;
  for (const check of def.checks) {
    switch (check.kind) {
      case "int":
        res.type = "integer";
        break;
      case "min":
        if (check.inclusive) {
          res.minimum = check.value;
        } else {
          res.exclusiveMinimum = check.value;
        }
        break;
      case "max":
        if (check.inclusive) {
          res.maximum = check.value;
        } else {
          res.exclusiveMaximum = check.value;
        }
        break;
      case "multipleOf":
        res.multipleOf = check.value;
        break;
    }
  }
  return res;
}

// src/zod-to-json-schema/parsers/object.ts
function parseObjectDef(def, refs) {
  const result = {
    type: "object",
    properties: {}
  };
  const required = [];
  const shape = def.shape();
  for (const propName in shape) {
    let propDef = shape[propName];
    if (propDef === void 0 || propDef._def === void 0) {
      continue;
    }
    const propOptional = safeIsOptional(propDef);
    const parsedDef = parseDef(propDef._def, {
      ...refs,
      currentPath: [...refs.currentPath, "properties", propName],
      propertyPath: [...refs.currentPath, "properties", propName]
    });
    if (parsedDef === void 0) {
      continue;
    }
    result.properties[propName] = parsedDef;
    if (!propOptional) {
      required.push(propName);
    }
  }
  if (required.length) {
    result.required = required;
  }
  const additionalProperties = decideAdditionalProperties(def, refs);
  if (additionalProperties !== void 0) {
    result.additionalProperties = additionalProperties;
  }
  return result;
}
function decideAdditionalProperties(def, refs) {
  if (def.catchall._def.typeName !== "ZodNever") {
    return parseDef(def.catchall._def, {
      ...refs,
      currentPath: [...refs.currentPath, "additionalProperties"]
    });
  }
  switch (def.unknownKeys) {
    case "passthrough":
      return refs.allowedAdditionalProperties;
    case "strict":
      return refs.rejectedAdditionalProperties;
    case "strip":
      return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
  }
}
function safeIsOptional(schema) {
  try {
    return schema.isOptional();
  } catch (e) {
    return true;
  }
}

// src/zod-to-json-schema/parsers/optional.ts
var parseOptionalDef = (def, refs) => {
  var _a;
  if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
    return parseDef(def.innerType._def, refs);
  }
  const innerSchema = parseDef(def.innerType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "anyOf", "1"]
  });
  return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();
};

// src/zod-to-json-schema/parsers/pipeline.ts
var parsePipelineDef = (def, refs) => {
  if (refs.pipeStrategy === "input") {
    return parseDef(def.in._def, refs);
  } else if (refs.pipeStrategy === "output") {
    return parseDef(def.out._def, refs);
  }
  const a = parseDef(def.in._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", "0"]
  });
  const b = parseDef(def.out._def, {
    ...refs,
    currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
  });
  return {
    allOf: [a, b].filter((x) => x !== void 0)
  };
};

// src/zod-to-json-schema/parsers/promise.ts
function parsePromiseDef(def, refs) {
  return parseDef(def.type._def, refs);
}

// src/zod-to-json-schema/parsers/set.ts
function parseSetDef(def, refs) {
  const items = parseDef(def.valueType._def, {
    ...refs,
    currentPath: [...refs.currentPath, "items"]
  });
  const schema = {
    type: "array",
    uniqueItems: true,
    items
  };
  if (def.minSize) {
    schema.minItems = def.minSize.value;
  }
  if (def.maxSize) {
    schema.maxItems = def.maxSize.value;
  }
  return schema;
}

// src/zod-to-json-schema/parsers/tuple.ts
function parseTupleDef(def, refs) {
  if (def.rest) {
    return {
      type: "array",
      minItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      ),
      additionalItems: parseDef(def.rest._def, {
        ...refs,
        currentPath: [...refs.currentPath, "additionalItems"]
      })
    };
  } else {
    return {
      type: "array",
      minItems: def.items.length,
      maxItems: def.items.length,
      items: def.items.map(
        (x, i) => parseDef(x._def, {
          ...refs,
          currentPath: [...refs.currentPath, "items", `${i}`]
        })
      ).reduce(
        (acc, x) => x === void 0 ? acc : [...acc, x],
        []
      )
    };
  }
}

// src/zod-to-json-schema/parsers/undefined.ts
function parseUndefinedDef() {
  return {
    not: parseAnyDef()
  };
}

// src/zod-to-json-schema/parsers/unknown.ts
function parseUnknownDef() {
  return parseAnyDef();
}

// src/zod-to-json-schema/parsers/readonly.ts
var parseReadonlyDef = (def, refs) => {
  return parseDef(def.innerType._def, refs);
};

// src/zod-to-json-schema/select-parser.ts
var selectParser = (def, typeName, refs) => {
  switch (typeName) {
    case ZodFirstPartyTypeKind.ZodString:
      return parseStringDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNumber:
      return parseNumberDef(def);
    case ZodFirstPartyTypeKind.ZodObject:
      return parseObjectDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBigInt:
      return parseBigintDef(def);
    case ZodFirstPartyTypeKind.ZodBoolean:
      return parseBooleanDef();
    case ZodFirstPartyTypeKind.ZodDate:
      return parseDateDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUndefined:
      return parseUndefinedDef();
    case ZodFirstPartyTypeKind.ZodNull:
      return parseNullDef();
    case ZodFirstPartyTypeKind.ZodArray:
      return parseArrayDef(def, refs);
    case ZodFirstPartyTypeKind.ZodUnion:
    case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
      return parseUnionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodIntersection:
      return parseIntersectionDef(def, refs);
    case ZodFirstPartyTypeKind.ZodTuple:
      return parseTupleDef(def, refs);
    case ZodFirstPartyTypeKind.ZodRecord:
      return parseRecordDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLiteral:
      return parseLiteralDef(def);
    case ZodFirstPartyTypeKind.ZodEnum:
      return parseEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNativeEnum:
      return parseNativeEnumDef(def);
    case ZodFirstPartyTypeKind.ZodNullable:
      return parseNullableDef(def, refs);
    case ZodFirstPartyTypeKind.ZodOptional:
      return parseOptionalDef(def, refs);
    case ZodFirstPartyTypeKind.ZodMap:
      return parseMapDef(def, refs);
    case ZodFirstPartyTypeKind.ZodSet:
      return parseSetDef(def, refs);
    case ZodFirstPartyTypeKind.ZodLazy:
      return () => def.getter()._def;
    case ZodFirstPartyTypeKind.ZodPromise:
      return parsePromiseDef(def, refs);
    case ZodFirstPartyTypeKind.ZodNaN:
    case ZodFirstPartyTypeKind.ZodNever:
      return parseNeverDef();
    case ZodFirstPartyTypeKind.ZodEffects:
      return parseEffectsDef(def, refs);
    case ZodFirstPartyTypeKind.ZodAny:
      return parseAnyDef();
    case ZodFirstPartyTypeKind.ZodUnknown:
      return parseUnknownDef();
    case ZodFirstPartyTypeKind.ZodDefault:
      return parseDefaultDef(def, refs);
    case ZodFirstPartyTypeKind.ZodBranded:
      return parseBrandedDef(def, refs);
    case ZodFirstPartyTypeKind.ZodReadonly:
      return parseReadonlyDef(def, refs);
    case ZodFirstPartyTypeKind.ZodCatch:
      return parseCatchDef(def, refs);
    case ZodFirstPartyTypeKind.ZodPipeline:
      return parsePipelineDef(def, refs);
    case ZodFirstPartyTypeKind.ZodFunction:
    case ZodFirstPartyTypeKind.ZodVoid:
    case ZodFirstPartyTypeKind.ZodSymbol:
      return void 0;
    default:
      return /* @__PURE__ */ ((_) => void 0)();
  }
};

// src/zod-to-json-schema/parse-def.ts
function parseDef(def, refs, forceResolution = false) {
  var _a;
  const seenItem = refs.seen.get(def);
  if (refs.override) {
    const overrideResult = (_a = refs.override) == null ? void 0 : _a.call(
      refs,
      def,
      refs,
      seenItem,
      forceResolution
    );
    if (overrideResult !== ignoreOverride) {
      return overrideResult;
    }
  }
  if (seenItem && !forceResolution) {
    const seenSchema = get$ref(seenItem, refs);
    if (seenSchema !== void 0) {
      return seenSchema;
    }
  }
  const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
  refs.seen.set(def, newItem);
  const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
  const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
  if (jsonSchema2) {
    addMeta(def, refs, jsonSchema2);
  }
  if (refs.postProcess) {
    const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
    newItem.jsonSchema = jsonSchema2;
    return postProcessResult;
  }
  newItem.jsonSchema = jsonSchema2;
  return jsonSchema2;
}
var get$ref = (item, refs) => {
  switch (refs.$refStrategy) {
    case "root":
      return { $ref: item.path.join("/") };
    case "relative":
      return { $ref: getRelativePath(refs.currentPath, item.path) };
    case "none":
    case "seen": {
      if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
        console.warn(
          `Recursive reference detected at ${refs.currentPath.join(
            "/"
          )}! Defaulting to any`
        );
        return parseAnyDef();
      }
      return refs.$refStrategy === "seen" ? parseAnyDef() : void 0;
    }
  }
};
var addMeta = (def, refs, jsonSchema2) => {
  if (def.description) {
    jsonSchema2.description = def.description;
  }
  return jsonSchema2;
};

// src/zod-to-json-schema/refs.ts
var getRefs = (options) => {
  const _options = getDefaultOptions(options);
  const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
  return {
    ..._options,
    currentPath,
    propertyPath: void 0,
    seen: new Map(
      Object.entries(_options.definitions).map(([name, def]) => [
        def._def,
        {
          def: def._def,
          path: [..._options.basePath, _options.definitionPath, name],
          // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
          jsonSchema: void 0
        }
      ])
    )
  };
};

// src/zod-to-json-schema/zod-to-json-schema.ts
var zodToJsonSchema = (schema, options) => {
  var _a;
  const refs = getRefs(options);
  let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
    (acc, [name2, schema2]) => {
      var _a2;
      return {
        ...acc,
        [name2]: (_a2 = parseDef(
          schema2._def,
          {
            ...refs,
            currentPath: [...refs.basePath, refs.definitionPath, name2]
          },
          true
        )) != null ? _a2 : parseAnyDef()
      };
    },
    {}
  ) : void 0;
  const name = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
  const main = (_a = parseDef(
    schema._def,
    name === void 0 ? refs : {
      ...refs,
      currentPath: [...refs.basePath, refs.definitionPath, name]
    },
    false
  )) != null ? _a : parseAnyDef();
  const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
  if (title !== void 0) {
    main.title = title;
  }
  const combined = name === void 0 ? definitions ? {
    ...main,
    [refs.definitionPath]: definitions
  } : main : {
    $ref: [
      ...refs.$refStrategy === "relative" ? [] : refs.basePath,
      refs.definitionPath,
      name
    ].join("/"),
    [refs.definitionPath]: {
      ...definitions,
      [name]: main
    }
  };
  combined.$schema = "http://json-schema.org/draft-07/schema#";
  return combined;
};

// src/zod-to-json-schema/index.ts
var zod_to_json_schema_default = zodToJsonSchema;

// src/zod-schema.ts
function zod3Schema(zodSchema2, options) {
  var _a;
  const useReferences = (_a = void 0 ) != null ? _a : false;
  return jsonSchema(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => zod_to_json_schema_default(zodSchema2, {
      $refStrategy: useReferences ? "root" : "none"
    }),
    {
      validate: async (value) => {
        const result = await zodSchema2.safeParseAsync(value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function zod4Schema(zodSchema2, options) {
  var _a;
  const useReferences = (_a = void 0 ) != null ? _a : false;
  return jsonSchema(
    // defer json schema creation to avoid unnecessary computation when only validation is needed
    () => toJSONSchema(zodSchema2, {
      target: "draft-7",
      io: "output",
      reused: useReferences ? "ref" : "inline"
    }),
    {
      validate: async (value) => {
        const result = await safeParseAsync(zodSchema2, value);
        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
      }
    }
  );
}
function isZod4Schema(zodSchema2) {
  return "_zod" in zodSchema2;
}
function zodSchema(zodSchema2, options) {
  if (isZod4Schema(zodSchema2)) {
    return zod4Schema(zodSchema2);
  } else {
    return zod3Schema(zodSchema2);
  }
}

// src/schema.ts
var schemaSymbol = Symbol.for("vercel.ai.schema");
function lazySchema(createSchema) {
  let schema;
  return () => {
    if (schema == null) {
      schema = createSchema();
    }
    return schema;
  };
}
function jsonSchema(jsonSchema2, {
  validate
} = {}) {
  return {
    [schemaSymbol]: true,
    _type: void 0,
    // should never be used directly
    [validatorSymbol$1]: true,
    get jsonSchema() {
      if (typeof jsonSchema2 === "function") {
        jsonSchema2 = jsonSchema2();
      }
      return jsonSchema2;
    },
    validate
  };
}
function isSchema(value) {
  return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
}
function asSchema(schema) {
  return schema == null ? jsonSchema({
    properties: {},
    additionalProperties: false
  }) : isSchema(schema) ? schema : typeof schema === "function" ? schema() : zodSchema(schema);
}

// src/uint8-utils.ts
var { btoa: btoa$1, atob: atob$1 } = globalThis;
function convertBase64ToUint8Array(base64String) {
  const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
  const latin1string = atob$1(base64Url);
  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
}
function convertUint8ArrayToBase64$1(array) {
  let latin1string = "";
  for (let i = 0; i < array.length; i++) {
    latin1string += String.fromCodePoint(array[i]);
  }
  return btoa$1(latin1string);
}
function convertToBase64(value) {
  return value instanceof Uint8Array ? convertUint8ArrayToBase64$1(value) : value;
}

// src/without-trailing-slash.ts
function withoutTrailingSlash$1(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}

// src/openai-provider.ts
var openaiErrorDataSchema = object({
  error: object({
    message: string(),
    // The additional information below is handled loosely to support
    // OpenAI-compatible providers that have slightly different error
    // responses:
    type: string().nullish(),
    param: any().nullish(),
    code: union([string(), number$1()]).nullish()
  })
});
var openaiFailedResponseHandler = createJsonErrorResponseHandler$1({
  errorSchema: openaiErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
function convertToOpenAIChatMessages({
  prompt,
  systemMessageMode = "system"
}) {
  const messages = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            messages.push({ role: "system", content });
            break;
          }
          case "developer": {
            messages.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({ role: "user", content: content[0].text });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part, index) => {
            var _a, _b, _c;
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`,
                      // OpenAI specific extension: image detail
                      detail: (_b = (_a = part.providerOptions) == null ? void 0 : _a.openai) == null ? void 0 : _b.imageDetail
                    }
                  };
                } else if (part.mediaType.startsWith("audio/")) {
                  if (part.data instanceof URL) {
                    throw new UnsupportedFunctionalityError$1({
                      functionality: "audio file parts with URLs"
                    });
                  }
                  switch (part.mediaType) {
                    case "audio/wav": {
                      return {
                        type: "input_audio",
                        input_audio: {
                          data: convertToBase64(part.data),
                          format: "wav"
                        }
                      };
                    }
                    case "audio/mp3":
                    case "audio/mpeg": {
                      return {
                        type: "input_audio",
                        input_audio: {
                          data: convertToBase64(part.data),
                          format: "mp3"
                        }
                      };
                    }
                    default: {
                      throw new UnsupportedFunctionalityError$1({
                        functionality: `audio content parts with media type ${part.mediaType}`
                      });
                    }
                  }
                } else if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL) {
                    throw new UnsupportedFunctionalityError$1({
                      functionality: "PDF file parts with URLs"
                    });
                  }
                  return {
                    type: "file",
                    file: typeof part.data === "string" && part.data.startsWith("file-") ? { file_id: part.data } : {
                      filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                      file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                    }
                  };
                } else {
                  throw new UnsupportedFunctionalityError$1({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        let text = "";
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { messages, warnings };
}

// src/chat/get-response-metadata.ts
function getResponseMetadata$1({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}

// src/chat/map-openai-finish-reason.ts
function mapOpenAIFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var openaiChatResponseSchema = lazyValidator(
  () => zodSchema(
    object({
      id: string().nullish(),
      created: number$1().nullish(),
      model: string().nullish(),
      choices: array(
        object({
          message: object({
            role: literal("assistant").nullish(),
            content: string().nullish(),
            tool_calls: array(
              object({
                id: string().nullish(),
                type: literal("function"),
                function: object({
                  name: string(),
                  arguments: string()
                })
              })
            ).nullish(),
            annotations: array(
              object({
                type: literal("url_citation"),
                start_index: number$1(),
                end_index: number$1(),
                url: string(),
                title: string()
              })
            ).nullish()
          }),
          index: number$1(),
          logprobs: object({
            content: array(
              object({
                token: string(),
                logprob: number$1(),
                top_logprobs: array(
                  object({
                    token: string(),
                    logprob: number$1()
                  })
                )
              })
            ).nullish()
          }).nullish(),
          finish_reason: string().nullish()
        })
      ),
      usage: object({
        prompt_tokens: number$1().nullish(),
        completion_tokens: number$1().nullish(),
        total_tokens: number$1().nullish(),
        prompt_tokens_details: object({
          cached_tokens: number$1().nullish()
        }).nullish(),
        completion_tokens_details: object({
          reasoning_tokens: number$1().nullish(),
          accepted_prediction_tokens: number$1().nullish(),
          rejected_prediction_tokens: number$1().nullish()
        }).nullish()
      }).nullish()
    })
  )
);
var openaiChatChunkSchema = lazyValidator(
  () => zodSchema(
    union([
      object({
        id: string().nullish(),
        created: number$1().nullish(),
        model: string().nullish(),
        choices: array(
          object({
            delta: object({
              role: _enum(["assistant"]).nullish(),
              content: string().nullish(),
              tool_calls: array(
                object({
                  index: number$1(),
                  id: string().nullish(),
                  type: literal("function").nullish(),
                  function: object({
                    name: string().nullish(),
                    arguments: string().nullish()
                  })
                })
              ).nullish(),
              annotations: array(
                object({
                  type: literal("url_citation"),
                  start_index: number$1(),
                  end_index: number$1(),
                  url: string(),
                  title: string()
                })
              ).nullish()
            }).nullish(),
            logprobs: object({
              content: array(
                object({
                  token: string(),
                  logprob: number$1(),
                  top_logprobs: array(
                    object({
                      token: string(),
                      logprob: number$1()
                    })
                  )
                })
              ).nullish()
            }).nullish(),
            finish_reason: string().nullish(),
            index: number$1()
          })
        ),
        usage: object({
          prompt_tokens: number$1().nullish(),
          completion_tokens: number$1().nullish(),
          total_tokens: number$1().nullish(),
          prompt_tokens_details: object({
            cached_tokens: number$1().nullish()
          }).nullish(),
          completion_tokens_details: object({
            reasoning_tokens: number$1().nullish(),
            accepted_prediction_tokens: number$1().nullish(),
            rejected_prediction_tokens: number$1().nullish()
          }).nullish()
        }).nullish()
      }),
      openaiErrorDataSchema
    ])
  )
);
var openaiChatLanguageModelOptions = lazyValidator(
  () => zodSchema(
    object({
      /**
       * Modify the likelihood of specified tokens appearing in the completion.
       *
       * Accepts a JSON object that maps tokens (specified by their token ID in
       * the GPT tokenizer) to an associated bias value from -100 to 100.
       */
      logitBias: record(number(), number$1()).optional(),
      /**
       * Return the log probabilities of the tokens.
       *
       * Setting to true will return the log probabilities of the tokens that
       * were generated.
       *
       * Setting to a number will return the log probabilities of the top n
       * tokens that were generated.
       */
      logprobs: union([boolean(), number$1()]).optional(),
      /**
       * Whether to enable parallel function calling during tool use. Default to true.
       */
      parallelToolCalls: boolean().optional(),
      /**
       * A unique identifier representing your end-user, which can help OpenAI to
       * monitor and detect abuse.
       */
      user: string().optional(),
      /**
       * Reasoning effort for reasoning models. Defaults to `medium`.
       */
      reasoningEffort: _enum(["minimal", "low", "medium", "high"]).optional(),
      /**
       * Maximum number of completion tokens to generate. Useful for reasoning models.
       */
      maxCompletionTokens: number$1().optional(),
      /**
       * Whether to enable persistence in responses API.
       */
      store: boolean().optional(),
      /**
       * Metadata to associate with the request.
       */
      metadata: record(string().max(64), string().max(512)).optional(),
      /**
       * Parameters for prediction mode.
       */
      prediction: record(string(), any()).optional(),
      /**
       * Whether to use structured outputs.
       *
       * @default true
       */
      structuredOutputs: boolean().optional(),
      /**
       * Service tier for the request.
       * - 'auto': Default service tier. The request will be processed with the service tier configured in the
       *           Project settings. Unless otherwise configured, the Project will use 'default'.
       * - 'flex': 50% cheaper processing at the cost of increased latency. Only available for o3 and o4-mini models.
       * - 'priority': Higher-speed processing with predictably low latency at premium cost. Available for Enterprise customers.
       * - 'default': The request will be processed with the standard pricing and performance for the selected model.
       *
       * @default 'auto'
       */
      serviceTier: _enum(["auto", "flex", "priority", "default"]).optional(),
      /**
       * Whether to use strict JSON schema validation.
       *
       * @default false
       */
      strictJsonSchema: boolean().optional(),
      /**
       * Controls the verbosity of the model's responses.
       * Lower values will result in more concise responses, while higher values will result in more verbose responses.
       */
      textVerbosity: _enum(["low", "medium", "high"]).optional(),
      /**
       * A cache key for prompt caching. Allows manual control over prompt caching behavior.
       * Useful for improving cache hit rates and working around automatic caching issues.
       */
      promptCacheKey: string().optional(),
      /**
       * A stable identifier used to help detect users of your application
       * that may be violating OpenAI's usage policies. The IDs should be a
       * string that uniquely identifies each user. We recommend hashing their
       * username or email address, in order to avoid sending us any identifying
       * information.
       */
      safetyIdentifier: string().optional()
    })
  )
);
function prepareChatTools({
  tools,
  toolChoice,
  structuredOutputs,
  strictJsonSchema
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const openaiTools2 = [];
  for (const tool of tools) {
    switch (tool.type) {
      case "function":
        openaiTools2.push({
          type: "function",
          function: {
            name: tool.name,
            description: tool.description,
            parameters: tool.inputSchema,
            strict: structuredOutputs ? strictJsonSchema : void 0
          }
        });
        break;
      default:
        toolWarnings.push({ type: "unsupported-tool", tool });
        break;
    }
  }
  if (toolChoice == null) {
    return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiTools2, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: openaiTools2,
        toolChoice: {
          type: "function",
          function: {
            name: toolChoice.toolName
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError$1({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}

// src/chat/openai-chat-language-model.ts
var OpenAIChatLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/]
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    tools,
    toolChoice,
    providerOptions
  }) {
    var _a, _b, _c, _d;
    const warnings = [];
    const openaiOptions = (_a = await parseProviderOptions({
      provider: "openai",
      providerOptions,
      schema: openaiChatLanguageModelOptions
    })) != null ? _a : {};
    const structuredOutputs = (_b = openaiOptions.structuredOutputs) != null ? _b : true;
    if (topK != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "topK"
      });
    }
    if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !structuredOutputs) {
      warnings.push({
        type: "unsupported-setting",
        setting: "responseFormat",
        details: "JSON response format schema is only supported with structuredOutputs"
      });
    }
    const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages(
      {
        prompt,
        systemMessageMode: getSystemMessageMode(this.modelId)
      }
    );
    warnings.push(...messageWarnings);
    const strictJsonSchema = (_c = openaiOptions.strictJsonSchema) != null ? _c : false;
    const baseArgs = {
      // model id:
      model: this.modelId,
      // model specific settings:
      logit_bias: openaiOptions.logitBias,
      logprobs: openaiOptions.logprobs === true || typeof openaiOptions.logprobs === "number" ? true : void 0,
      top_logprobs: typeof openaiOptions.logprobs === "number" ? openaiOptions.logprobs : typeof openaiOptions.logprobs === "boolean" ? openaiOptions.logprobs ? 0 : void 0 : void 0,
      user: openaiOptions.user,
      parallel_tool_calls: openaiOptions.parallelToolCalls,
      // standardized settings:
      max_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      frequency_penalty: frequencyPenalty,
      presence_penalty: presencePenalty,
      response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && responseFormat.schema != null ? {
        type: "json_schema",
        json_schema: {
          schema: responseFormat.schema,
          strict: strictJsonSchema,
          name: (_d = responseFormat.name) != null ? _d : "response",
          description: responseFormat.description
        }
      } : { type: "json_object" } : void 0,
      stop: stopSequences,
      seed,
      verbosity: openaiOptions.textVerbosity,
      // openai specific settings:
      // TODO AI SDK 6: remove, we auto-map maxOutputTokens now
      max_completion_tokens: openaiOptions.maxCompletionTokens,
      store: openaiOptions.store,
      metadata: openaiOptions.metadata,
      prediction: openaiOptions.prediction,
      reasoning_effort: openaiOptions.reasoningEffort,
      service_tier: openaiOptions.serviceTier,
      prompt_cache_key: openaiOptions.promptCacheKey,
      safety_identifier: openaiOptions.safetyIdentifier,
      // messages:
      messages
    };
    if (isReasoningModel(this.modelId)) {
      if (baseArgs.temperature != null) {
        baseArgs.temperature = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "temperature",
          details: "temperature is not supported for reasoning models"
        });
      }
      if (baseArgs.top_p != null) {
        baseArgs.top_p = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "topP",
          details: "topP is not supported for reasoning models"
        });
      }
      if (baseArgs.frequency_penalty != null) {
        baseArgs.frequency_penalty = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "frequencyPenalty",
          details: "frequencyPenalty is not supported for reasoning models"
        });
      }
      if (baseArgs.presence_penalty != null) {
        baseArgs.presence_penalty = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "presencePenalty",
          details: "presencePenalty is not supported for reasoning models"
        });
      }
      if (baseArgs.logit_bias != null) {
        baseArgs.logit_bias = void 0;
        warnings.push({
          type: "other",
          message: "logitBias is not supported for reasoning models"
        });
      }
      if (baseArgs.logprobs != null) {
        baseArgs.logprobs = void 0;
        warnings.push({
          type: "other",
          message: "logprobs is not supported for reasoning models"
        });
      }
      if (baseArgs.top_logprobs != null) {
        baseArgs.top_logprobs = void 0;
        warnings.push({
          type: "other",
          message: "topLogprobs is not supported for reasoning models"
        });
      }
      if (baseArgs.max_tokens != null) {
        if (baseArgs.max_completion_tokens == null) {
          baseArgs.max_completion_tokens = baseArgs.max_tokens;
        }
        baseArgs.max_tokens = void 0;
      }
    } else if (this.modelId.startsWith("gpt-4o-search-preview") || this.modelId.startsWith("gpt-4o-mini-search-preview")) {
      if (baseArgs.temperature != null) {
        baseArgs.temperature = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "temperature",
          details: "temperature is not supported for the search preview models and has been removed."
        });
      }
    }
    if (openaiOptions.serviceTier === "flex" && !supportsFlexProcessing(this.modelId)) {
      warnings.push({
        type: "unsupported-setting",
        setting: "serviceTier",
        details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
      });
      baseArgs.service_tier = void 0;
    }
    if (openaiOptions.serviceTier === "priority" && !supportsPriorityProcessing(this.modelId)) {
      warnings.push({
        type: "unsupported-setting",
        setting: "serviceTier",
        details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
      });
      baseArgs.service_tier = void 0;
    }
    const {
      tools: openaiTools2,
      toolChoice: openaiToolChoice,
      toolWarnings
    } = prepareChatTools({
      tools,
      toolChoice,
      structuredOutputs,
      strictJsonSchema
    });
    return {
      args: {
        ...baseArgs,
        tools: openaiTools2,
        tool_choice: openaiToolChoice
      },
      warnings: [...warnings, ...toolWarnings]
    };
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    const { args: body, warnings } = await this.getArgs(options);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi$1({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiChatResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const choice = response.choices[0];
    const content = [];
    const text = choice.message.content;
    if (text != null && text.length > 0) {
      content.push({ type: "text", text });
    }
    for (const toolCall of (_a = choice.message.tool_calls) != null ? _a : []) {
      content.push({
        type: "tool-call",
        toolCallId: (_b = toolCall.id) != null ? _b : generateId$1(),
        toolName: toolCall.function.name,
        input: toolCall.function.arguments
      });
    }
    for (const annotation of (_c = choice.message.annotations) != null ? _c : []) {
      content.push({
        type: "source",
        sourceType: "url",
        id: generateId$1(),
        url: annotation.url,
        title: annotation.title
      });
    }
    const completionTokenDetails = (_d = response.usage) == null ? void 0 : _d.completion_tokens_details;
    const promptTokenDetails = (_e = response.usage) == null ? void 0 : _e.prompt_tokens_details;
    const providerMetadata = { openai: {} };
    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
      providerMetadata.openai.acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
    }
    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
      providerMetadata.openai.rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
    }
    if (((_f = choice.logprobs) == null ? void 0 : _f.content) != null) {
      providerMetadata.openai.logprobs = choice.logprobs.content;
    }
    return {
      content,
      finishReason: mapOpenAIFinishReason(choice.finish_reason),
      usage: {
        inputTokens: (_h = (_g = response.usage) == null ? void 0 : _g.prompt_tokens) != null ? _h : void 0,
        outputTokens: (_j = (_i = response.usage) == null ? void 0 : _i.completion_tokens) != null ? _j : void 0,
        totalTokens: (_l = (_k = response.usage) == null ? void 0 : _k.total_tokens) != null ? _l : void 0,
        reasoningTokens: (_m = completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens) != null ? _m : void 0,
        cachedInputTokens: (_n = promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens) != null ? _n : void 0
      },
      request: { body },
      response: {
        ...getResponseMetadata$1(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings,
      providerMetadata
    };
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const body = {
      ...args,
      stream: true,
      stream_options: {
        include_usage: true
      }
    };
    const { responseHeaders, value: response } = await postJsonToApi$1({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler$1(
        openaiChatChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const toolCalls = [];
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0
    };
    let isFirstChunk = true;
    let isActiveText = false;
    const providerMetadata = { openai: {} };
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if ("error" in value) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: value.error });
              return;
            }
            if (isFirstChunk) {
              isFirstChunk = false;
              controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata$1(value)
              });
            }
            if (value.usage != null) {
              usage.inputTokens = (_a = value.usage.prompt_tokens) != null ? _a : void 0;
              usage.outputTokens = (_b = value.usage.completion_tokens) != null ? _b : void 0;
              usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;
              usage.reasoningTokens = (_e = (_d = value.usage.completion_tokens_details) == null ? void 0 : _d.reasoning_tokens) != null ? _e : void 0;
              usage.cachedInputTokens = (_g = (_f = value.usage.prompt_tokens_details) == null ? void 0 : _f.cached_tokens) != null ? _g : void 0;
              if (((_h = value.usage.completion_tokens_details) == null ? void 0 : _h.accepted_prediction_tokens) != null) {
                providerMetadata.openai.acceptedPredictionTokens = (_i = value.usage.completion_tokens_details) == null ? void 0 : _i.accepted_prediction_tokens;
              }
              if (((_j = value.usage.completion_tokens_details) == null ? void 0 : _j.rejected_prediction_tokens) != null) {
                providerMetadata.openai.rejectedPredictionTokens = (_k = value.usage.completion_tokens_details) == null ? void 0 : _k.rejected_prediction_tokens;
              }
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapOpenAIFinishReason(choice.finish_reason);
            }
            if (((_l = choice == null ? void 0 : choice.logprobs) == null ? void 0 : _l.content) != null) {
              providerMetadata.openai.logprobs = choice.logprobs.content;
            }
            if ((choice == null ? void 0 : choice.delta) == null) {
              return;
            }
            const delta = choice.delta;
            if (delta.content != null) {
              if (!isActiveText) {
                controller.enqueue({ type: "text-start", id: "0" });
                isActiveText = true;
              }
              controller.enqueue({
                type: "text-delta",
                id: "0",
                delta: delta.content
              });
            }
            if (delta.tool_calls != null) {
              for (const toolCallDelta of delta.tool_calls) {
                const index = toolCallDelta.index;
                if (toolCalls[index] == null) {
                  if (toolCallDelta.type !== "function") {
                    throw new InvalidResponseDataError$1({
                      data: toolCallDelta,
                      message: `Expected 'function' type.`
                    });
                  }
                  if (toolCallDelta.id == null) {
                    throw new InvalidResponseDataError$1({
                      data: toolCallDelta,
                      message: `Expected 'id' to be a string.`
                    });
                  }
                  if (((_m = toolCallDelta.function) == null ? void 0 : _m.name) == null) {
                    throw new InvalidResponseDataError$1({
                      data: toolCallDelta,
                      message: `Expected 'function.name' to be a string.`
                    });
                  }
                  controller.enqueue({
                    type: "tool-input-start",
                    id: toolCallDelta.id,
                    toolName: toolCallDelta.function.name
                  });
                  toolCalls[index] = {
                    id: toolCallDelta.id,
                    type: "function",
                    function: {
                      name: toolCallDelta.function.name,
                      arguments: (_n = toolCallDelta.function.arguments) != null ? _n : ""
                    },
                    hasFinished: false
                  };
                  const toolCall2 = toolCalls[index];
                  if (((_o = toolCall2.function) == null ? void 0 : _o.name) != null && ((_p = toolCall2.function) == null ? void 0 : _p.arguments) != null) {
                    if (toolCall2.function.arguments.length > 0) {
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: toolCall2.id,
                        delta: toolCall2.function.arguments
                      });
                    }
                    if (isParsableJson$1(toolCall2.function.arguments)) {
                      controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall2.id
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_q = toolCall2.id) != null ? _q : generateId$1(),
                        toolName: toolCall2.function.name,
                        input: toolCall2.function.arguments
                      });
                      toolCall2.hasFinished = true;
                    }
                  }
                  continue;
                }
                const toolCall = toolCalls[index];
                if (toolCall.hasFinished) {
                  continue;
                }
                if (((_r = toolCallDelta.function) == null ? void 0 : _r.arguments) != null) {
                  toolCall.function.arguments += (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : "";
                }
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCall.id,
                  delta: (_u = toolCallDelta.function.arguments) != null ? _u : ""
                });
                if (((_v = toolCall.function) == null ? void 0 : _v.name) != null && ((_w = toolCall.function) == null ? void 0 : _w.arguments) != null && isParsableJson$1(toolCall.function.arguments)) {
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCall.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: (_x = toolCall.id) != null ? _x : generateId$1(),
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments
                  });
                  toolCall.hasFinished = true;
                }
              }
            }
            if (delta.annotations != null) {
              for (const annotation of delta.annotations) {
                controller.enqueue({
                  type: "source",
                  sourceType: "url",
                  id: generateId$1(),
                  url: annotation.url,
                  title: annotation.title
                });
              }
            }
          },
          flush(controller) {
            if (isActiveText) {
              controller.enqueue({ type: "text-end", id: "0" });
            }
            controller.enqueue({
              type: "finish",
              finishReason,
              usage,
              ...providerMetadata != null ? { providerMetadata } : {}
            });
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
function isReasoningModel(modelId) {
  return (modelId.startsWith("o") || modelId.startsWith("gpt-5")) && !modelId.startsWith("gpt-5-chat");
}
function supportsFlexProcessing(modelId) {
  return modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
}
function supportsPriorityProcessing(modelId) {
  return modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
}
function getSystemMessageMode(modelId) {
  var _a, _b;
  if (!isReasoningModel(modelId)) {
    return "system";
  }
  return (_b = (_a = reasoningModels[modelId]) == null ? void 0 : _a.systemMessageMode) != null ? _b : "developer";
}
var reasoningModels = {
  "o1-mini": {
    systemMessageMode: "remove"
  },
  "o1-mini-2024-09-12": {
    systemMessageMode: "remove"
  },
  "o1-preview": {
    systemMessageMode: "remove"
  },
  "o1-preview-2024-09-12": {
    systemMessageMode: "remove"
  },
  o3: {
    systemMessageMode: "developer"
  },
  "o3-2025-04-16": {
    systemMessageMode: "developer"
  },
  "o3-mini": {
    systemMessageMode: "developer"
  },
  "o3-mini-2025-01-31": {
    systemMessageMode: "developer"
  },
  "o4-mini": {
    systemMessageMode: "developer"
  },
  "o4-mini-2025-04-16": {
    systemMessageMode: "developer"
  }
};
function convertToOpenAICompletionPrompt({
  prompt,
  user = "user",
  assistant = "assistant"
}) {
  let text = "";
  if (prompt[0].role === "system") {
    text += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError$1({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
          }
        }).filter(Boolean).join("");
        text += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "tool-call": {
              throw new UnsupportedFunctionalityError$1({
                functionality: "tool-call messages"
              });
            }
          }
        }).join("");
        text += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError$1({
          functionality: "tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  text += `${assistant}:
`;
  return {
    prompt: text,
    stopSequences: [`
${user}:`]
  };
}

// src/completion/get-response-metadata.ts
function getResponseMetadata2$1({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}

// src/completion/map-openai-finish-reason.ts
function mapOpenAIFinishReason2(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var openaiCompletionResponseSchema = lazyValidator(
  () => zodSchema(
    object({
      id: string().nullish(),
      created: number$1().nullish(),
      model: string().nullish(),
      choices: array(
        object({
          text: string(),
          finish_reason: string(),
          logprobs: object({
            tokens: array(string()),
            token_logprobs: array(number$1()),
            top_logprobs: array(record(string(), number$1())).nullish()
          }).nullish()
        })
      ),
      usage: object({
        prompt_tokens: number$1(),
        completion_tokens: number$1(),
        total_tokens: number$1()
      }).nullish()
    })
  )
);
var openaiCompletionChunkSchema = lazyValidator(
  () => zodSchema(
    union([
      object({
        id: string().nullish(),
        created: number$1().nullish(),
        model: string().nullish(),
        choices: array(
          object({
            text: string(),
            finish_reason: string().nullish(),
            index: number$1(),
            logprobs: object({
              tokens: array(string()),
              token_logprobs: array(number$1()),
              top_logprobs: array(record(string(), number$1())).nullish()
            }).nullish()
          })
        ),
        usage: object({
          prompt_tokens: number$1(),
          completion_tokens: number$1(),
          total_tokens: number$1()
        }).nullish()
      }),
      openaiErrorDataSchema
    ])
  )
);
var openaiCompletionProviderOptions = lazyValidator(
  () => zodSchema(
    object({
      /**
      Echo back the prompt in addition to the completion.
         */
      echo: boolean().optional(),
      /**
      Modify the likelihood of specified tokens appearing in the completion.
      
      Accepts a JSON object that maps tokens (specified by their token ID in
      the GPT tokenizer) to an associated bias value from -100 to 100. You
      can use this tokenizer tool to convert text to token IDs. Mathematically,
      the bias is added to the logits generated by the model prior to sampling.
      The exact effect will vary per model, but values between -1 and 1 should
      decrease or increase likelihood of selection; values like -100 or 100
      should result in a ban or exclusive selection of the relevant token.
      
      As an example, you can pass {"50256": -100} to prevent the <|endoftext|>
      token from being generated.
       */
      logitBias: record(string(), number$1()).optional(),
      /**
      The suffix that comes after a completion of inserted text.
       */
      suffix: string().optional(),
      /**
      A unique identifier representing your end-user, which can help OpenAI to
      monitor and detect abuse. Learn more.
       */
      user: string().optional(),
      /**
      Return the log probabilities of the tokens. Including logprobs will increase
      the response size and can slow down response times. However, it can
      be useful to better understand how the model is behaving.
      Setting to true will return the log probabilities of the tokens that
      were generated.
      Setting to a number will return the log probabilities of the top n
      tokens that were generated.
         */
      logprobs: union([boolean(), number$1()]).optional()
    })
  )
);

// src/completion/openai-completion-language-model.ts
var OpenAICompletionLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      // No URLs are supported for completion models.
    };
    this.modelId = modelId;
    this.config = config;
  }
  get providerOptionsName() {
    return this.config.provider.split(".")[0].trim();
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences: userStopSequences,
    responseFormat,
    tools,
    toolChoice,
    seed,
    providerOptions
  }) {
    const warnings = [];
    const openaiOptions = {
      ...await parseProviderOptions({
        provider: "openai",
        providerOptions,
        schema: openaiCompletionProviderOptions
      }),
      ...await parseProviderOptions({
        provider: this.providerOptionsName,
        providerOptions,
        schema: openaiCompletionProviderOptions
      })
    };
    if (topK != null) {
      warnings.push({ type: "unsupported-setting", setting: "topK" });
    }
    if (tools == null ? void 0 : tools.length) {
      warnings.push({ type: "unsupported-setting", setting: "tools" });
    }
    if (toolChoice != null) {
      warnings.push({ type: "unsupported-setting", setting: "toolChoice" });
    }
    if (responseFormat != null && responseFormat.type !== "text") {
      warnings.push({
        type: "unsupported-setting",
        setting: "responseFormat",
        details: "JSON response format is not supported."
      });
    }
    const { prompt: completionPrompt, stopSequences } = convertToOpenAICompletionPrompt({ prompt });
    const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
    return {
      args: {
        // model id:
        model: this.modelId,
        // model specific settings:
        echo: openaiOptions.echo,
        logit_bias: openaiOptions.logitBias,
        logprobs: (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? 0 : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === false ? void 0 : openaiOptions == null ? void 0 : openaiOptions.logprobs,
        suffix: openaiOptions.suffix,
        user: openaiOptions.user,
        // standardized settings:
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        frequency_penalty: frequencyPenalty,
        presence_penalty: presencePenalty,
        seed,
        // prompt:
        prompt: completionPrompt,
        // stop sequences:
        stop: stop.length > 0 ? stop : void 0
      },
      warnings
    };
  }
  async doGenerate(options) {
    var _a, _b, _c;
    const { args, warnings } = await this.getArgs(options);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi$1({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiCompletionResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const choice = response.choices[0];
    const providerMetadata = { openai: {} };
    if (choice.logprobs != null) {
      providerMetadata.openai.logprobs = choice.logprobs;
    }
    return {
      content: [{ type: "text", text: choice.text }],
      usage: {
        inputTokens: (_a = response.usage) == null ? void 0 : _a.prompt_tokens,
        outputTokens: (_b = response.usage) == null ? void 0 : _b.completion_tokens,
        totalTokens: (_c = response.usage) == null ? void 0 : _c.total_tokens
      },
      finishReason: mapOpenAIFinishReason2(choice.finish_reason),
      request: { body: args },
      response: {
        ...getResponseMetadata2$1(response),
        headers: responseHeaders,
        body: rawResponse
      },
      providerMetadata,
      warnings
    };
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const body = {
      ...args,
      stream: true,
      stream_options: {
        include_usage: true
      }
    };
    const { responseHeaders, value: response } = await postJsonToApi$1({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler$1(
        openaiCompletionChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "unknown";
    const providerMetadata = { openai: {} };
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0
    };
    let isFirstChunk = true;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if ("error" in value) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: value.error });
              return;
            }
            if (isFirstChunk) {
              isFirstChunk = false;
              controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata2$1(value)
              });
              controller.enqueue({ type: "text-start", id: "0" });
            }
            if (value.usage != null) {
              usage.inputTokens = value.usage.prompt_tokens;
              usage.outputTokens = value.usage.completion_tokens;
              usage.totalTokens = value.usage.total_tokens;
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapOpenAIFinishReason2(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.logprobs) != null) {
              providerMetadata.openai.logprobs = choice.logprobs;
            }
            if ((choice == null ? void 0 : choice.text) != null && choice.text.length > 0) {
              controller.enqueue({
                type: "text-delta",
                id: "0",
                delta: choice.text
              });
            }
          },
          flush(controller) {
            if (!isFirstChunk) {
              controller.enqueue({ type: "text-end", id: "0" });
            }
            controller.enqueue({
              type: "finish",
              finishReason,
              providerMetadata,
              usage
            });
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
var openaiEmbeddingProviderOptions = lazyValidator(
  () => zodSchema(
    object({
      /**
      The number of dimensions the resulting output embeddings should have.
      Only supported in text-embedding-3 and later models.
         */
      dimensions: number$1().optional(),
      /**
      A unique identifier representing your end-user, which can help OpenAI to
      monitor and detect abuse. Learn more.
      */
      user: string().optional()
    })
  )
);
var openaiTextEmbeddingResponseSchema$1 = lazyValidator(
  () => zodSchema(
    object({
      data: array(object({ embedding: array(number$1()) })),
      usage: object({ prompt_tokens: number$1() }).nullish()
    })
  )
);

// src/embedding/openai-embedding-model.ts
var OpenAIEmbeddingModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a;
    if (values.length > this.maxEmbeddingsPerCall) {
      throw new TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values
      });
    }
    const openaiOptions = (_a = await parseProviderOptions({
      provider: "openai",
      providerOptions,
      schema: openaiEmbeddingProviderOptions
    })) != null ? _a : {};
    const {
      responseHeaders,
      value: response,
      rawValue
    } = await postJsonToApi$1({
      url: this.config.url({
        path: "/embeddings",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), headers),
      body: {
        model: this.modelId,
        input: values,
        encoding_format: "float",
        dimensions: openaiOptions.dimensions,
        user: openaiOptions.user
      },
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiTextEmbeddingResponseSchema$1
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      embeddings: response.data.map((item) => item.embedding),
      usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
      response: { headers: responseHeaders, body: rawValue }
    };
  }
};
var openaiImageResponseSchema = lazyValidator(
  () => zodSchema(
    object({
      data: array(
        object({
          b64_json: string(),
          revised_prompt: string().optional()
        })
      )
    })
  )
);

// src/image/openai-image-options.ts
var modelMaxImagesPerCall$1 = {
  "dall-e-3": 1,
  "dall-e-2": 10,
  "gpt-image-1": 10,
  "gpt-image-1-mini": 10
};
var hasDefaultResponseFormat = /* @__PURE__ */ new Set([
  "gpt-image-1",
  "gpt-image-1-mini"
]);

// src/image/openai-image-model.ts
var OpenAIImageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
  }
  get maxImagesPerCall() {
    var _a;
    return (_a = modelMaxImagesPerCall$1[this.modelId]) != null ? _a : 1;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a, _b, _c, _d;
    const warnings = [];
    if (aspectRatio != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "aspectRatio",
        details: "This model does not support aspect ratio. Use `size` instead."
      });
    }
    if (seed != null) {
      warnings.push({ type: "unsupported-setting", setting: "seed" });
    }
    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
    const { value: response, responseHeaders } = await postJsonToApi$1({
      url: this.config.url({
        path: "/images/generations",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), headers),
      body: {
        model: this.modelId,
        prompt,
        n,
        size,
        ...(_d = providerOptions.openai) != null ? _d : {},
        ...!hasDefaultResponseFormat.has(this.modelId) ? { response_format: "b64_json" } : {}
      },
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiImageResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      images: response.data.map((item) => item.b64_json),
      warnings,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders
      },
      providerMetadata: {
        openai: {
          images: response.data.map(
            (item) => item.revised_prompt ? {
              revisedPrompt: item.revised_prompt
            } : null
          )
        }
      }
    };
  }
};
var codeInterpreterInputSchema = lazySchema(
  () => zodSchema(
    object({
      code: string().nullish(),
      containerId: string()
    })
  )
);
var codeInterpreterOutputSchema = lazySchema(
  () => zodSchema(
    object({
      outputs: array(
        discriminatedUnion("type", [
          object({ type: literal("logs"), logs: string() }),
          object({ type: literal("image"), url: string() })
        ])
      ).nullish()
    })
  )
);
var codeInterpreterArgsSchema = lazySchema(
  () => zodSchema(
    object({
      container: union([
        string(),
        object({
          fileIds: array(string()).optional()
        })
      ]).optional()
    })
  )
);
var codeInterpreterToolFactory = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.code_interpreter",
  name: "code_interpreter",
  inputSchema: codeInterpreterInputSchema,
  outputSchema: codeInterpreterOutputSchema
});
var codeInterpreter = (args = {}) => {
  return codeInterpreterToolFactory(args);
};
var comparisonFilterSchema = object({
  key: string(),
  type: _enum(["eq", "ne", "gt", "gte", "lt", "lte"]),
  value: union([string(), number$1(), boolean()])
});
var compoundFilterSchema = object({
  type: _enum(["and", "or"]),
  filters: array(
    union([comparisonFilterSchema, lazy(() => compoundFilterSchema)])
  )
});
var fileSearchArgsSchema = lazySchema(
  () => zodSchema(
    object({
      vectorStoreIds: array(string()),
      maxNumResults: number$1().optional(),
      ranking: object({
        ranker: string().optional(),
        scoreThreshold: number$1().optional()
      }).optional(),
      filters: union([comparisonFilterSchema, compoundFilterSchema]).optional()
    })
  )
);
var fileSearchOutputSchema = lazySchema(
  () => zodSchema(
    object({
      queries: array(string()),
      results: array(
        object({
          attributes: record(string(), unknown()),
          fileId: string(),
          filename: string(),
          score: number$1(),
          text: string()
        })
      ).nullable()
    })
  )
);
var fileSearch = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.file_search",
  name: "file_search",
  inputSchema: object({}),
  outputSchema: fileSearchOutputSchema
});
var imageGenerationArgsSchema = lazySchema(
  () => zodSchema(
    object({
      background: _enum(["auto", "opaque", "transparent"]).optional(),
      inputFidelity: _enum(["low", "high"]).optional(),
      inputImageMask: object({
        fileId: string().optional(),
        imageUrl: string().optional()
      }).optional(),
      model: string().optional(),
      moderation: _enum(["auto"]).optional(),
      outputCompression: number$1().int().min(0).max(100).optional(),
      outputFormat: _enum(["png", "jpeg", "webp"]).optional(),
      partialImages: number$1().int().min(0).max(3).optional(),
      quality: _enum(["auto", "low", "medium", "high"]).optional(),
      size: _enum(["1024x1024", "1024x1536", "1536x1024", "auto"]).optional()
    }).strict()
  )
);
var imageGenerationInputSchema = lazySchema(() => zodSchema(object({})));
var imageGenerationOutputSchema = lazySchema(
  () => zodSchema(object({ result: string() }))
);
var imageGenerationToolFactory = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.image_generation",
  name: "image_generation",
  inputSchema: imageGenerationInputSchema,
  outputSchema: imageGenerationOutputSchema
});
var imageGeneration = (args = {}) => {
  return imageGenerationToolFactory(args);
};
var localShellInputSchema = lazySchema(
  () => zodSchema(
    object({
      action: object({
        type: literal("exec"),
        command: array(string()),
        timeoutMs: number$1().optional(),
        user: string().optional(),
        workingDirectory: string().optional(),
        env: record(string(), string()).optional()
      })
    })
  )
);
var localShellOutputSchema = lazySchema(
  () => zodSchema(object({ output: string() }))
);
var localShell = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.local_shell",
  name: "local_shell",
  inputSchema: localShellInputSchema,
  outputSchema: localShellOutputSchema
});
var webSearchArgsSchema = lazySchema(
  () => zodSchema(
    object({
      filters: object({ allowedDomains: array(string()).optional() }).optional(),
      searchContextSize: _enum(["low", "medium", "high"]).optional(),
      userLocation: object({
        type: literal("approximate"),
        country: string().optional(),
        city: string().optional(),
        region: string().optional(),
        timezone: string().optional()
      }).optional()
    })
  )
);
var webSearchInputSchema = lazySchema(() => zodSchema(object({})));
var webSearchOutputSchema = lazySchema(
  () => zodSchema(
    object({
      action: discriminatedUnion("type", [
        object({
          type: literal("search"),
          query: string().optional()
        }),
        object({
          type: literal("openPage"),
          url: string()
        }),
        object({
          type: literal("find"),
          url: string(),
          pattern: string()
        })
      ])
    })
  )
);
var webSearchToolFactory = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.web_search",
  name: "web_search",
  inputSchema: webSearchInputSchema,
  outputSchema: webSearchOutputSchema
});
var webSearch = (args = {}) => webSearchToolFactory(args);
var webSearchPreviewArgsSchema = lazySchema(
  () => zodSchema(
    object({
      searchContextSize: _enum(["low", "medium", "high"]).optional(),
      userLocation: object({
        type: literal("approximate"),
        country: string().optional(),
        city: string().optional(),
        region: string().optional(),
        timezone: string().optional()
      }).optional()
    })
  )
);
var webSearchPreviewInputSchema = lazySchema(
  () => zodSchema(object({}))
);
var webSearchPreviewOutputSchema = lazySchema(
  () => zodSchema(
    object({
      action: discriminatedUnion("type", [
        object({
          type: literal("search"),
          query: string().optional()
        }),
        object({
          type: literal("openPage"),
          url: string()
        }),
        object({
          type: literal("find"),
          url: string(),
          pattern: string()
        })
      ])
    })
  )
);
var webSearchPreview = createProviderDefinedToolFactoryWithOutputSchema({
  id: "openai.web_search_preview",
  name: "web_search_preview",
  inputSchema: webSearchPreviewInputSchema,
  outputSchema: webSearchPreviewOutputSchema
});

// src/openai-tools.ts
var openaiTools = {
  /**
   * The Code Interpreter tool allows models to write and run Python code in a
   * sandboxed environment to solve complex problems in domains like data analysis,
   * coding, and math.
   *
   * @param container - The container to use for the code interpreter.
   *
   * Must have name `code_interpreter`.
   */
  codeInterpreter,
  /**
   * File search is a tool available in the Responses API. It enables models to
   * retrieve information in a knowledge base of previously uploaded files through
   * semantic and keyword search.
   *
   * Must have name `file_search`.
   *
   * @param vectorStoreIds - The vector store IDs to use for the file search.
   * @param maxNumResults - The maximum number of results to return.
   * @param ranking - The ranking options to use for the file search.
   * @param filters - The filters to use for the file search.
   */
  fileSearch,
  /**
   * The image generation tool allows you to generate images using a text prompt,
   * and optionally image inputs. It leverages the GPT Image model,
   * and automatically optimizes text inputs for improved performance.
   *
   * Must have name `image_generation`.
   *
   * @param size - Image dimensions (e.g., 1024x1024, 1024x1536)
   * @param quality - Rendering quality (e.g. low, medium, high)
   * @param format - File output format
   * @param compression - Compression level (0-100%) for JPEG and WebP formats
   * @param background - Transparent or opaque
   */
  imageGeneration,
  /**
   * Local shell is a tool that allows agents to run shell commands locally
   * on a machine you or the user provides.
   *
   * Supported models: `gpt-5-codex` and `codex-mini-latest`
   *
   * Must have name `local_shell`.
   */
  localShell,
  /**
   * Web search allows models to access up-to-date information from the internet
   * and provide answers with sourced citations.
   *
   * Must have name `web_search_preview`.
   *
   * @param searchContextSize - The search context size to use for the web search.
   * @param userLocation - The user location to use for the web search.
   *
   * @deprecated Use `webSearch` instead.
   */
  webSearchPreview,
  /**
   * Web search allows models to access up-to-date information from the internet
   * and provide answers with sourced citations.
   *
   * Must have name `web_search`.
   *
   * @param filters - The filters to use for the web search.
   * @param searchContextSize - The search context size to use for the web search.
   * @param userLocation - The user location to use for the web search.
   */
  webSearch
};
function isFileId(data, prefixes) {
  if (!prefixes) return false;
  return prefixes.some((prefix) => data.startsWith(prefix));
}
async function convertToOpenAIResponsesInput({
  prompt,
  systemMessageMode,
  fileIdPrefixes,
  store,
  hasLocalShellTool = false
}) {
  var _a, _b, _c, _d;
  const input = [];
  const warnings = [];
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        switch (systemMessageMode) {
          case "system": {
            input.push({ role: "system", content });
            break;
          }
          case "developer": {
            input.push({ role: "developer", content });
            break;
          }
          case "remove": {
            warnings.push({
              type: "other",
              message: "system messages are removed for this model"
            });
            break;
          }
          default: {
            const _exhaustiveCheck = systemMessageMode;
            throw new Error(
              `Unsupported system message mode: ${_exhaustiveCheck}`
            );
          }
        }
        break;
      }
      case "user": {
        input.push({
          role: "user",
          content: content.map((part, index) => {
            var _a2, _b2, _c2;
            switch (part.type) {
              case "text": {
                return { type: "input_text", text: part.text };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "input_image",
                    ...part.data instanceof URL ? { image_url: part.data.toString() } : typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                      image_url: `data:${mediaType};base64,${convertToBase64(part.data)}`
                    },
                    detail: (_b2 = (_a2 = part.providerOptions) == null ? void 0 : _a2.openai) == null ? void 0 : _b2.imageDetail
                  };
                } else if (part.mediaType === "application/pdf") {
                  if (part.data instanceof URL) {
                    return {
                      type: "input_file",
                      file_url: part.data.toString()
                    };
                  }
                  return {
                    type: "input_file",
                    ...typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                      filename: (_c2 = part.filename) != null ? _c2 : `part-${index}.pdf`,
                      file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                    }
                  };
                } else {
                  throw new UnsupportedFunctionalityError$1({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          })
        });
        break;
      }
      case "assistant": {
        const reasoningMessages = {};
        const toolCallParts = {};
        for (const part of content) {
          switch (part.type) {
            case "text": {
              const id = (_b = (_a = part.providerOptions) == null ? void 0 : _a.openai) == null ? void 0 : _b.itemId;
              if (store && id != null) {
                input.push({ type: "item_reference", id });
                break;
              }
              input.push({
                role: "assistant",
                content: [{ type: "output_text", text: part.text }],
                id
              });
              break;
            }
            case "tool-call": {
              toolCallParts[part.toolCallId] = part;
              if (part.providerExecuted) {
                break;
              }
              const id = (_d = (_c = part.providerOptions) == null ? void 0 : _c.openai) == null ? void 0 : _d.itemId;
              if (store && id != null) {
                input.push({ type: "item_reference", id });
                break;
              }
              if (hasLocalShellTool && part.toolName === "local_shell") {
                const parsedInput = await validateTypes$1({
                  value: part.input,
                  schema: localShellInputSchema
                });
                input.push({
                  type: "local_shell_call",
                  call_id: part.toolCallId,
                  id,
                  action: {
                    type: "exec",
                    command: parsedInput.action.command,
                    timeout_ms: parsedInput.action.timeoutMs,
                    user: parsedInput.action.user,
                    working_directory: parsedInput.action.workingDirectory,
                    env: parsedInput.action.env
                  }
                });
                break;
              }
              input.push({
                type: "function_call",
                call_id: part.toolCallId,
                name: part.toolName,
                arguments: JSON.stringify(part.input),
                id
              });
              break;
            }
            // assistant tool result parts are from provider-executed tools:
            case "tool-result": {
              if (store) {
                input.push({ type: "item_reference", id: part.toolCallId });
              } else {
                warnings.push({
                  type: "other",
                  message: `Results for OpenAI tool ${part.toolName} are not sent to the API when store is false`
                });
              }
              break;
            }
            case "reasoning": {
              const providerOptions = await parseProviderOptions({
                provider: "openai",
                providerOptions: part.providerOptions,
                schema: openaiResponsesReasoningProviderOptionsSchema
              });
              const reasoningId = providerOptions == null ? void 0 : providerOptions.itemId;
              if (reasoningId != null) {
                const reasoningMessage = reasoningMessages[reasoningId];
                if (store) {
                  if (reasoningMessage === void 0) {
                    input.push({ type: "item_reference", id: reasoningId });
                    reasoningMessages[reasoningId] = {
                      type: "reasoning",
                      id: reasoningId,
                      summary: []
                    };
                  }
                } else {
                  const summaryParts = [];
                  if (part.text.length > 0) {
                    summaryParts.push({
                      type: "summary_text",
                      text: part.text
                    });
                  } else if (reasoningMessage !== void 0) {
                    warnings.push({
                      type: "other",
                      message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(part)}.`
                    });
                  }
                  if (reasoningMessage === void 0) {
                    reasoningMessages[reasoningId] = {
                      type: "reasoning",
                      id: reasoningId,
                      encrypted_content: providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent,
                      summary: summaryParts
                    };
                    input.push(reasoningMessages[reasoningId]);
                  } else {
                    reasoningMessage.summary.push(...summaryParts);
                    if ((providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent) != null) {
                      reasoningMessage.encrypted_content = providerOptions.reasoningEncryptedContent;
                    }
                  }
                }
              } else {
                warnings.push({
                  type: "other",
                  message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(part)}.`
                });
              }
              break;
            }
          }
        }
        break;
      }
      case "tool": {
        for (const part of content) {
          const output = part.output;
          if (hasLocalShellTool && part.toolName === "local_shell" && output.type === "json") {
            const parsedOutput = await validateTypes$1({
              value: output.value,
              schema: localShellOutputSchema
            });
            input.push({
              type: "local_shell_call_output",
              call_id: part.toolCallId,
              output: parsedOutput.output
            });
            break;
          }
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
            case "content":
              contentValue = output.value.map((item) => {
                switch (item.type) {
                  case "text": {
                    return { type: "input_text", text: item.text };
                  }
                  case "media": {
                    return item.mediaType.startsWith("image/") ? {
                      type: "input_image",
                      image_url: `data:${item.mediaType};base64,${item.data}`
                    } : {
                      type: "input_file",
                      filename: "data",
                      file_data: `data:${item.mediaType};base64,${item.data}`
                    };
                  }
                }
              });
              break;
          }
          input.push({
            type: "function_call_output",
            call_id: part.toolCallId,
            output: contentValue
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return { input, warnings };
}
var openaiResponsesReasoningProviderOptionsSchema = object({
  itemId: string().nullish(),
  reasoningEncryptedContent: string().nullish()
});

// src/responses/map-openai-responses-finish-reason.ts
function mapOpenAIResponseFinishReason({
  finishReason,
  hasFunctionCall
}) {
  switch (finishReason) {
    case void 0:
    case null:
      return hasFunctionCall ? "tool-calls" : "stop";
    case "max_output_tokens":
      return "length";
    case "content_filter":
      return "content-filter";
    default:
      return hasFunctionCall ? "tool-calls" : "unknown";
  }
}
var openaiResponsesChunkSchema = lazyValidator(
  () => zodSchema(
    union([
      object({
        type: literal("response.output_text.delta"),
        item_id: string(),
        delta: string(),
        logprobs: array(
          object({
            token: string(),
            logprob: number$1(),
            top_logprobs: array(
              object({
                token: string(),
                logprob: number$1()
              })
            )
          })
        ).nullish()
      }),
      object({
        type: _enum(["response.completed", "response.incomplete"]),
        response: object({
          incomplete_details: object({ reason: string() }).nullish(),
          usage: object({
            input_tokens: number$1(),
            input_tokens_details: object({ cached_tokens: number$1().nullish() }).nullish(),
            output_tokens: number$1(),
            output_tokens_details: object({ reasoning_tokens: number$1().nullish() }).nullish()
          }),
          service_tier: string().nullish()
        })
      }),
      object({
        type: literal("response.created"),
        response: object({
          id: string(),
          created_at: number$1(),
          model: string(),
          service_tier: string().nullish()
        })
      }),
      object({
        type: literal("response.output_item.added"),
        output_index: number$1(),
        item: discriminatedUnion("type", [
          object({
            type: literal("message"),
            id: string()
          }),
          object({
            type: literal("reasoning"),
            id: string(),
            encrypted_content: string().nullish()
          }),
          object({
            type: literal("function_call"),
            id: string(),
            call_id: string(),
            name: string(),
            arguments: string()
          }),
          object({
            type: literal("web_search_call"),
            id: string(),
            status: string()
          }),
          object({
            type: literal("computer_call"),
            id: string(),
            status: string()
          }),
          object({
            type: literal("file_search_call"),
            id: string()
          }),
          object({
            type: literal("image_generation_call"),
            id: string()
          }),
          object({
            type: literal("code_interpreter_call"),
            id: string(),
            container_id: string(),
            code: string().nullable(),
            outputs: array(
              discriminatedUnion("type", [
                object({ type: literal("logs"), logs: string() }),
                object({ type: literal("image"), url: string() })
              ])
            ).nullable(),
            status: string()
          })
        ])
      }),
      object({
        type: literal("response.output_item.done"),
        output_index: number$1(),
        item: discriminatedUnion("type", [
          object({
            type: literal("message"),
            id: string()
          }),
          object({
            type: literal("reasoning"),
            id: string(),
            encrypted_content: string().nullish()
          }),
          object({
            type: literal("function_call"),
            id: string(),
            call_id: string(),
            name: string(),
            arguments: string(),
            status: literal("completed")
          }),
          object({
            type: literal("code_interpreter_call"),
            id: string(),
            code: string().nullable(),
            container_id: string(),
            outputs: array(
              discriminatedUnion("type", [
                object({ type: literal("logs"), logs: string() }),
                object({ type: literal("image"), url: string() })
              ])
            ).nullable()
          }),
          object({
            type: literal("image_generation_call"),
            id: string(),
            result: string()
          }),
          object({
            type: literal("web_search_call"),
            id: string(),
            status: string(),
            action: discriminatedUnion("type", [
              object({
                type: literal("search"),
                query: string().nullish()
              }),
              object({
                type: literal("open_page"),
                url: string()
              }),
              object({
                type: literal("find"),
                url: string(),
                pattern: string()
              })
            ])
          }),
          object({
            type: literal("file_search_call"),
            id: string(),
            queries: array(string()),
            results: array(
              object({
                attributes: record(string(), unknown()),
                file_id: string(),
                filename: string(),
                score: number$1(),
                text: string()
              })
            ).nullish()
          }),
          object({
            type: literal("local_shell_call"),
            id: string(),
            call_id: string(),
            action: object({
              type: literal("exec"),
              command: array(string()),
              timeout_ms: number$1().optional(),
              user: string().optional(),
              working_directory: string().optional(),
              env: record(string(), string()).optional()
            })
          }),
          object({
            type: literal("computer_call"),
            id: string(),
            status: literal("completed")
          })
        ])
      }),
      object({
        type: literal("response.function_call_arguments.delta"),
        item_id: string(),
        output_index: number$1(),
        delta: string()
      }),
      object({
        type: literal("response.image_generation_call.partial_image"),
        item_id: string(),
        output_index: number$1(),
        partial_image_b64: string()
      }),
      object({
        type: literal("response.code_interpreter_call_code.delta"),
        item_id: string(),
        output_index: number$1(),
        delta: string()
      }),
      object({
        type: literal("response.code_interpreter_call_code.done"),
        item_id: string(),
        output_index: number$1(),
        code: string()
      }),
      object({
        type: literal("response.output_text.annotation.added"),
        annotation: discriminatedUnion("type", [
          object({
            type: literal("url_citation"),
            url: string(),
            title: string()
          }),
          object({
            type: literal("file_citation"),
            file_id: string(),
            filename: string().nullish(),
            index: number$1().nullish(),
            start_index: number$1().nullish(),
            end_index: number$1().nullish(),
            quote: string().nullish()
          })
        ])
      }),
      object({
        type: literal("response.reasoning_summary_part.added"),
        item_id: string(),
        summary_index: number$1()
      }),
      object({
        type: literal("response.reasoning_summary_text.delta"),
        item_id: string(),
        summary_index: number$1(),
        delta: string()
      }),
      object({
        type: literal("response.reasoning_summary_part.done"),
        item_id: string(),
        summary_index: number$1()
      }),
      object({
        type: literal("error"),
        code: string(),
        message: string(),
        param: string().nullish(),
        sequence_number: number$1()
      }),
      object({ type: string() }).loose().transform((value) => ({
        type: "unknown_chunk",
        message: value.type
      }))
      // fallback for unknown chunks
    ])
  )
);
var openaiResponsesResponseSchema = lazyValidator(
  () => zodSchema(
    object({
      id: string(),
      created_at: number$1(),
      error: object({
        code: string(),
        message: string()
      }).nullish(),
      model: string(),
      output: array(
        discriminatedUnion("type", [
          object({
            type: literal("message"),
            role: literal("assistant"),
            id: string(),
            content: array(
              object({
                type: literal("output_text"),
                text: string(),
                logprobs: array(
                  object({
                    token: string(),
                    logprob: number$1(),
                    top_logprobs: array(
                      object({
                        token: string(),
                        logprob: number$1()
                      })
                    )
                  })
                ).nullish(),
                annotations: array(
                  discriminatedUnion("type", [
                    object({
                      type: literal("url_citation"),
                      start_index: number$1(),
                      end_index: number$1(),
                      url: string(),
                      title: string()
                    }),
                    object({
                      type: literal("file_citation"),
                      file_id: string(),
                      filename: string().nullish(),
                      index: number$1().nullish(),
                      start_index: number$1().nullish(),
                      end_index: number$1().nullish(),
                      quote: string().nullish()
                    }),
                    object({
                      type: literal("container_file_citation")
                    })
                  ])
                )
              })
            )
          }),
          object({
            type: literal("web_search_call"),
            id: string(),
            status: string(),
            action: discriminatedUnion("type", [
              object({
                type: literal("search"),
                query: string().nullish()
              }),
              object({
                type: literal("open_page"),
                url: string()
              }),
              object({
                type: literal("find"),
                url: string(),
                pattern: string()
              })
            ])
          }),
          object({
            type: literal("file_search_call"),
            id: string(),
            queries: array(string()),
            results: array(
              object({
                attributes: record(string(), unknown()),
                file_id: string(),
                filename: string(),
                score: number$1(),
                text: string()
              })
            ).nullish()
          }),
          object({
            type: literal("code_interpreter_call"),
            id: string(),
            code: string().nullable(),
            container_id: string(),
            outputs: array(
              discriminatedUnion("type", [
                object({ type: literal("logs"), logs: string() }),
                object({ type: literal("image"), url: string() })
              ])
            ).nullable()
          }),
          object({
            type: literal("image_generation_call"),
            id: string(),
            result: string()
          }),
          object({
            type: literal("local_shell_call"),
            id: string(),
            call_id: string(),
            action: object({
              type: literal("exec"),
              command: array(string()),
              timeout_ms: number$1().optional(),
              user: string().optional(),
              working_directory: string().optional(),
              env: record(string(), string()).optional()
            })
          }),
          object({
            type: literal("function_call"),
            call_id: string(),
            name: string(),
            arguments: string(),
            id: string()
          }),
          object({
            type: literal("computer_call"),
            id: string(),
            status: string().optional()
          }),
          object({
            type: literal("reasoning"),
            id: string(),
            encrypted_content: string().nullish(),
            summary: array(
              object({
                type: literal("summary_text"),
                text: string()
              })
            )
          })
        ])
      ),
      service_tier: string().nullish(),
      incomplete_details: object({ reason: string() }).nullish(),
      usage: object({
        input_tokens: number$1(),
        input_tokens_details: object({ cached_tokens: number$1().nullish() }).nullish(),
        output_tokens: number$1(),
        output_tokens_details: object({ reasoning_tokens: number$1().nullish() }).nullish()
      })
    })
  )
);
var TOP_LOGPROBS_MAX = 20;
var openaiResponsesProviderOptionsSchema = lazyValidator(
  () => zodSchema(
    object({
      include: array(
        _enum([
          "reasoning.encrypted_content",
          // handled internally by default, only needed for unknown reasoning models
          "file_search_call.results",
          "message.output_text.logprobs"
        ])
      ).nullish(),
      instructions: string().nullish(),
      /**
       * Return the log probabilities of the tokens.
       *
       * Setting to true will return the log probabilities of the tokens that
       * were generated.
       *
       * Setting to a number will return the log probabilities of the top n
       * tokens that were generated.
       *
       * @see https://platform.openai.com/docs/api-reference/responses/create
       * @see https://cookbook.openai.com/examples/using_logprobs
       */
      logprobs: union([boolean(), number$1().min(1).max(TOP_LOGPROBS_MAX)]).optional(),
      /**
       * The maximum number of total calls to built-in tools that can be processed in a response.
       * This maximum number applies across all built-in tool calls, not per individual tool.
       * Any further attempts to call a tool by the model will be ignored.
       */
      maxToolCalls: number$1().nullish(),
      metadata: any().nullish(),
      parallelToolCalls: boolean().nullish(),
      previousResponseId: string().nullish(),
      promptCacheKey: string().nullish(),
      reasoningEffort: string().nullish(),
      reasoningSummary: string().nullish(),
      safetyIdentifier: string().nullish(),
      serviceTier: _enum(["auto", "flex", "priority", "default"]).nullish(),
      store: boolean().nullish(),
      strictJsonSchema: boolean().nullish(),
      textVerbosity: _enum(["low", "medium", "high"]).nullish(),
      user: string().nullish()
    })
  )
);
async function prepareResponsesTools({
  tools,
  toolChoice,
  strictJsonSchema
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const openaiTools2 = [];
  for (const tool of tools) {
    switch (tool.type) {
      case "function":
        openaiTools2.push({
          type: "function",
          name: tool.name,
          description: tool.description,
          parameters: tool.inputSchema,
          strict: strictJsonSchema
        });
        break;
      case "provider-defined": {
        switch (tool.id) {
          case "openai.file_search": {
            const args = await validateTypes$1({
              value: tool.args,
              schema: fileSearchArgsSchema
            });
            openaiTools2.push({
              type: "file_search",
              vector_store_ids: args.vectorStoreIds,
              max_num_results: args.maxNumResults,
              ranking_options: args.ranking ? {
                ranker: args.ranking.ranker,
                score_threshold: args.ranking.scoreThreshold
              } : void 0,
              filters: args.filters
            });
            break;
          }
          case "openai.local_shell": {
            openaiTools2.push({
              type: "local_shell"
            });
            break;
          }
          case "openai.web_search_preview": {
            const args = await validateTypes$1({
              value: tool.args,
              schema: webSearchPreviewArgsSchema
            });
            openaiTools2.push({
              type: "web_search_preview",
              search_context_size: args.searchContextSize,
              user_location: args.userLocation
            });
            break;
          }
          case "openai.web_search": {
            const args = await validateTypes$1({
              value: tool.args,
              schema: webSearchArgsSchema
            });
            openaiTools2.push({
              type: "web_search",
              filters: args.filters != null ? { allowed_domains: args.filters.allowedDomains } : void 0,
              search_context_size: args.searchContextSize,
              user_location: args.userLocation
            });
            break;
          }
          case "openai.code_interpreter": {
            const args = await validateTypes$1({
              value: tool.args,
              schema: codeInterpreterArgsSchema
            });
            openaiTools2.push({
              type: "code_interpreter",
              container: args.container == null ? { type: "auto", file_ids: void 0 } : typeof args.container === "string" ? args.container : { type: "auto", file_ids: args.container.fileIds }
            });
            break;
          }
          case "openai.image_generation": {
            const args = await validateTypes$1({
              value: tool.args,
              schema: imageGenerationArgsSchema
            });
            openaiTools2.push({
              type: "image_generation",
              background: args.background,
              input_fidelity: args.inputFidelity,
              input_image_mask: args.inputImageMask ? {
                file_id: args.inputImageMask.fileId,
                image_url: args.inputImageMask.imageUrl
              } : void 0,
              model: args.model,
              size: args.size,
              quality: args.quality,
              moderation: args.moderation,
              output_format: args.outputFormat,
              output_compression: args.outputCompression
            });
            break;
          }
        }
        break;
      }
      default:
        toolWarnings.push({ type: "unsupported-tool", tool });
        break;
    }
  }
  if (toolChoice == null) {
    return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiTools2, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: openaiTools2,
        toolChoice: toolChoice.toolName === "code_interpreter" || toolChoice.toolName === "file_search" || toolChoice.toolName === "image_generation" || toolChoice.toolName === "web_search_preview" || toolChoice.toolName === "web_search" ? { type: toolChoice.toolName } : { type: "function", name: toolChoice.toolName },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError$1({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}

// src/responses/openai-responses-language-model.ts
var OpenAIResponsesLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.supportedUrls = {
      "image/*": [/^https?:\/\/.*$/],
      "application/pdf": [/^https?:\/\/.*$/]
    };
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    maxOutputTokens,
    temperature,
    stopSequences,
    topP,
    topK,
    presencePenalty,
    frequencyPenalty,
    seed,
    prompt,
    providerOptions,
    tools,
    toolChoice,
    responseFormat
  }) {
    var _a, _b, _c, _d;
    const warnings = [];
    const modelConfig = getResponsesModelConfig(this.modelId);
    if (topK != null) {
      warnings.push({ type: "unsupported-setting", setting: "topK" });
    }
    if (seed != null) {
      warnings.push({ type: "unsupported-setting", setting: "seed" });
    }
    if (presencePenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "presencePenalty"
      });
    }
    if (frequencyPenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "frequencyPenalty"
      });
    }
    if (stopSequences != null) {
      warnings.push({ type: "unsupported-setting", setting: "stopSequences" });
    }
    const openaiOptions = await parseProviderOptions({
      provider: "openai",
      providerOptions,
      schema: openaiResponsesProviderOptionsSchema
    });
    const { input, warnings: inputWarnings } = await convertToOpenAIResponsesInput({
      prompt,
      systemMessageMode: modelConfig.systemMessageMode,
      fileIdPrefixes: this.config.fileIdPrefixes,
      store: (_a = openaiOptions == null ? void 0 : openaiOptions.store) != null ? _a : true,
      hasLocalShellTool: hasOpenAITool("openai.local_shell")
    });
    warnings.push(...inputWarnings);
    const strictJsonSchema = (_b = openaiOptions == null ? void 0 : openaiOptions.strictJsonSchema) != null ? _b : false;
    let include = openaiOptions == null ? void 0 : openaiOptions.include;
    function addInclude(key) {
      if (include == null) {
        include = [key];
      } else if (!include.includes(key)) {
        include = [...include, key];
      }
    }
    function hasOpenAITool(id) {
      return (tools == null ? void 0 : tools.find(
        (tool) => tool.type === "provider-defined" && tool.id === id
      )) != null;
    }
    const topLogprobs = typeof (openaiOptions == null ? void 0 : openaiOptions.logprobs) === "number" ? openaiOptions == null ? void 0 : openaiOptions.logprobs : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? TOP_LOGPROBS_MAX : void 0;
    if (topLogprobs) {
      addInclude("message.output_text.logprobs");
    }
    const webSearchToolName = (_c = tools == null ? void 0 : tools.find(
      (tool) => tool.type === "provider-defined" && (tool.id === "openai.web_search" || tool.id === "openai.web_search_preview")
    )) == null ? void 0 : _c.name;
    if (webSearchToolName) {
      addInclude("web_search_call.action.sources");
    }
    if (hasOpenAITool("openai.code_interpreter")) {
      addInclude("code_interpreter_call.outputs");
    }
    const store = openaiOptions == null ? void 0 : openaiOptions.store;
    if (store === false && modelConfig.isReasoningModel) {
      addInclude("reasoning.encrypted_content");
    }
    const baseArgs = {
      model: this.modelId,
      input,
      temperature,
      top_p: topP,
      max_output_tokens: maxOutputTokens,
      ...((responseFormat == null ? void 0 : responseFormat.type) === "json" || (openaiOptions == null ? void 0 : openaiOptions.textVerbosity)) && {
        text: {
          ...(responseFormat == null ? void 0 : responseFormat.type) === "json" && {
            format: responseFormat.schema != null ? {
              type: "json_schema",
              strict: strictJsonSchema,
              name: (_d = responseFormat.name) != null ? _d : "response",
              description: responseFormat.description,
              schema: responseFormat.schema
            } : { type: "json_object" }
          },
          ...(openaiOptions == null ? void 0 : openaiOptions.textVerbosity) && {
            verbosity: openaiOptions.textVerbosity
          }
        }
      },
      // provider options:
      max_tool_calls: openaiOptions == null ? void 0 : openaiOptions.maxToolCalls,
      metadata: openaiOptions == null ? void 0 : openaiOptions.metadata,
      parallel_tool_calls: openaiOptions == null ? void 0 : openaiOptions.parallelToolCalls,
      previous_response_id: openaiOptions == null ? void 0 : openaiOptions.previousResponseId,
      store,
      user: openaiOptions == null ? void 0 : openaiOptions.user,
      instructions: openaiOptions == null ? void 0 : openaiOptions.instructions,
      service_tier: openaiOptions == null ? void 0 : openaiOptions.serviceTier,
      include,
      prompt_cache_key: openaiOptions == null ? void 0 : openaiOptions.promptCacheKey,
      safety_identifier: openaiOptions == null ? void 0 : openaiOptions.safetyIdentifier,
      top_logprobs: topLogprobs,
      // model-specific settings:
      ...modelConfig.isReasoningModel && ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null || (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) && {
        reasoning: {
          ...(openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null && {
            effort: openaiOptions.reasoningEffort
          },
          ...(openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null && {
            summary: openaiOptions.reasoningSummary
          }
        }
      },
      ...modelConfig.requiredAutoTruncation && {
        truncation: "auto"
      }
    };
    if (modelConfig.isReasoningModel) {
      if (baseArgs.temperature != null) {
        baseArgs.temperature = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "temperature",
          details: "temperature is not supported for reasoning models"
        });
      }
      if (baseArgs.top_p != null) {
        baseArgs.top_p = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "topP",
          details: "topP is not supported for reasoning models"
        });
      }
    } else {
      if ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "reasoningEffort",
          details: "reasoningEffort is not supported for non-reasoning models"
        });
      }
      if ((openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "reasoningSummary",
          details: "reasoningSummary is not supported for non-reasoning models"
        });
      }
    }
    if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "flex" && !modelConfig.supportsFlexProcessing) {
      warnings.push({
        type: "unsupported-setting",
        setting: "serviceTier",
        details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
      });
      delete baseArgs.service_tier;
    }
    if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "priority" && !modelConfig.supportsPriorityProcessing) {
      warnings.push({
        type: "unsupported-setting",
        setting: "serviceTier",
        details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
      });
      delete baseArgs.service_tier;
    }
    const {
      tools: openaiTools2,
      toolChoice: openaiToolChoice,
      toolWarnings
    } = await prepareResponsesTools({
      tools,
      toolChoice,
      strictJsonSchema
    });
    return {
      webSearchToolName,
      args: {
        ...baseArgs,
        tools: openaiTools2,
        tool_choice: openaiToolChoice
      },
      warnings: [...warnings, ...toolWarnings],
      store
    };
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
    const {
      args: body,
      warnings,
      webSearchToolName
    } = await this.getArgs(options);
    const url = this.config.url({
      path: "/responses",
      modelId: this.modelId
    });
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi$1({
      url,
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiResponsesResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    if (response.error) {
      throw new APICallError$1({
        message: response.error.message,
        url,
        requestBodyValues: body,
        statusCode: 400,
        responseHeaders,
        responseBody: rawResponse,
        isRetryable: false
      });
    }
    const content = [];
    const logprobs = [];
    let hasFunctionCall = false;
    for (const part of response.output) {
      switch (part.type) {
        case "reasoning": {
          if (part.summary.length === 0) {
            part.summary.push({ type: "summary_text", text: "" });
          }
          for (const summary of part.summary) {
            content.push({
              type: "reasoning",
              text: summary.text,
              providerMetadata: {
                openai: {
                  itemId: part.id,
                  reasoningEncryptedContent: (_a = part.encrypted_content) != null ? _a : null
                }
              }
            });
          }
          break;
        }
        case "image_generation_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.id,
            toolName: "image_generation",
            input: "{}",
            providerExecuted: true
          });
          content.push({
            type: "tool-result",
            toolCallId: part.id,
            toolName: "image_generation",
            result: {
              result: part.result
            },
            providerExecuted: true
          });
          break;
        }
        case "local_shell_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.call_id,
            toolName: "local_shell",
            input: JSON.stringify({
              action: part.action
            }),
            providerMetadata: {
              openai: {
                itemId: part.id
              }
            }
          });
          break;
        }
        case "message": {
          for (const contentPart of part.content) {
            if (((_c = (_b = options.providerOptions) == null ? void 0 : _b.openai) == null ? void 0 : _c.logprobs) && contentPart.logprobs) {
              logprobs.push(contentPart.logprobs);
            }
            content.push({
              type: "text",
              text: contentPart.text,
              providerMetadata: {
                openai: {
                  itemId: part.id
                }
              }
            });
            for (const annotation of contentPart.annotations) {
              if (annotation.type === "url_citation") {
                content.push({
                  type: "source",
                  sourceType: "url",
                  id: (_f = (_e = (_d = this.config).generateId) == null ? void 0 : _e.call(_d)) != null ? _f : generateId$1(),
                  url: annotation.url,
                  title: annotation.title
                });
              } else if (annotation.type === "file_citation") {
                content.push({
                  type: "source",
                  sourceType: "document",
                  id: (_i = (_h = (_g = this.config).generateId) == null ? void 0 : _h.call(_g)) != null ? _i : generateId$1(),
                  mediaType: "text/plain",
                  title: (_k = (_j = annotation.quote) != null ? _j : annotation.filename) != null ? _k : "Document",
                  filename: (_l = annotation.filename) != null ? _l : annotation.file_id
                });
              }
            }
          }
          break;
        }
        case "function_call": {
          hasFunctionCall = true;
          content.push({
            type: "tool-call",
            toolCallId: part.call_id,
            toolName: part.name,
            input: part.arguments,
            providerMetadata: {
              openai: {
                itemId: part.id
              }
            }
          });
          break;
        }
        case "web_search_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.id,
            toolName: webSearchToolName != null ? webSearchToolName : "web_search",
            input: JSON.stringify({}),
            providerExecuted: true
          });
          content.push({
            type: "tool-result",
            toolCallId: part.id,
            toolName: webSearchToolName != null ? webSearchToolName : "web_search",
            result: mapWebSearchOutput(part.action),
            providerExecuted: true
          });
          break;
        }
        case "computer_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.id,
            toolName: "computer_use",
            input: "",
            providerExecuted: true
          });
          content.push({
            type: "tool-result",
            toolCallId: part.id,
            toolName: "computer_use",
            result: {
              type: "computer_use_tool_result",
              status: part.status || "completed"
            },
            providerExecuted: true
          });
          break;
        }
        case "file_search_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.id,
            toolName: "file_search",
            input: "{}",
            providerExecuted: true
          });
          content.push({
            type: "tool-result",
            toolCallId: part.id,
            toolName: "file_search",
            result: {
              queries: part.queries,
              results: (_n = (_m = part.results) == null ? void 0 : _m.map((result) => ({
                attributes: result.attributes,
                fileId: result.file_id,
                filename: result.filename,
                score: result.score,
                text: result.text
              }))) != null ? _n : null
            },
            providerExecuted: true
          });
          break;
        }
        case "code_interpreter_call": {
          content.push({
            type: "tool-call",
            toolCallId: part.id,
            toolName: "code_interpreter",
            input: JSON.stringify({
              code: part.code,
              containerId: part.container_id
            }),
            providerExecuted: true
          });
          content.push({
            type: "tool-result",
            toolCallId: part.id,
            toolName: "code_interpreter",
            result: {
              outputs: part.outputs
            },
            providerExecuted: true
          });
          break;
        }
      }
    }
    const providerMetadata = {
      openai: { responseId: response.id }
    };
    if (logprobs.length > 0) {
      providerMetadata.openai.logprobs = logprobs;
    }
    if (typeof response.service_tier === "string") {
      providerMetadata.openai.serviceTier = response.service_tier;
    }
    return {
      content,
      finishReason: mapOpenAIResponseFinishReason({
        finishReason: (_o = response.incomplete_details) == null ? void 0 : _o.reason,
        hasFunctionCall
      }),
      usage: {
        inputTokens: response.usage.input_tokens,
        outputTokens: response.usage.output_tokens,
        totalTokens: response.usage.input_tokens + response.usage.output_tokens,
        reasoningTokens: (_q = (_p = response.usage.output_tokens_details) == null ? void 0 : _p.reasoning_tokens) != null ? _q : void 0,
        cachedInputTokens: (_s = (_r = response.usage.input_tokens_details) == null ? void 0 : _r.cached_tokens) != null ? _s : void 0
      },
      request: { body },
      response: {
        id: response.id,
        timestamp: new Date(response.created_at * 1e3),
        modelId: response.model,
        headers: responseHeaders,
        body: rawResponse
      },
      providerMetadata,
      warnings
    };
  }
  async doStream(options) {
    const {
      args: body,
      warnings,
      webSearchToolName,
      store
    } = await this.getArgs(options);
    const { responseHeaders, value: response } = await postJsonToApi$1({
      url: this.config.url({
        path: "/responses",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body: {
        ...body,
        stream: true
      },
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler$1(
        openaiResponsesChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const self = this;
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0
    };
    const logprobs = [];
    let responseId = null;
    const ongoingToolCalls = {};
    let hasFunctionCall = false;
    const activeReasoning = {};
    let serviceTier;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if (isResponseOutputItemAddedChunk(value)) {
              if (value.item.type === "function_call") {
                ongoingToolCalls[value.output_index] = {
                  toolName: value.item.name,
                  toolCallId: value.item.call_id
                };
                controller.enqueue({
                  type: "tool-input-start",
                  id: value.item.call_id,
                  toolName: value.item.name
                });
              } else if (value.item.type === "web_search_call") {
                ongoingToolCalls[value.output_index] = {
                  toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                  toolCallId: value.item.id
                };
                controller.enqueue({
                  type: "tool-input-start",
                  id: value.item.id,
                  toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                  providerExecuted: true
                });
                controller.enqueue({
                  type: "tool-input-end",
                  id: value.item.id
                });
                controller.enqueue({
                  type: "tool-call",
                  toolCallId: value.item.id,
                  toolName: "web_search",
                  input: JSON.stringify({}),
                  providerExecuted: true
                });
              } else if (value.item.type === "computer_call") {
                ongoingToolCalls[value.output_index] = {
                  toolName: "computer_use",
                  toolCallId: value.item.id
                };
                controller.enqueue({
                  type: "tool-input-start",
                  id: value.item.id,
                  toolName: "computer_use",
                  providerExecuted: true
                });
              } else if (value.item.type === "code_interpreter_call") {
                ongoingToolCalls[value.output_index] = {
                  toolName: "code_interpreter",
                  toolCallId: value.item.id,
                  codeInterpreter: {
                    containerId: value.item.container_id
                  }
                };
                controller.enqueue({
                  type: "tool-input-start",
                  id: value.item.id,
                  toolName: "code_interpreter",
                  providerExecuted: true
                });
                controller.enqueue({
                  type: "tool-input-delta",
                  id: value.item.id,
                  delta: `{"containerId":"${value.item.container_id}","code":"`
                });
              } else if (value.item.type === "file_search_call") {
                controller.enqueue({
                  type: "tool-call",
                  toolCallId: value.item.id,
                  toolName: "file_search",
                  input: "{}",
                  providerExecuted: true
                });
              } else if (value.item.type === "image_generation_call") {
                controller.enqueue({
                  type: "tool-call",
                  toolCallId: value.item.id,
                  toolName: "image_generation",
                  input: "{}",
                  providerExecuted: true
                });
              } else if (value.item.type === "message") {
                controller.enqueue({
                  type: "text-start",
                  id: value.item.id,
                  providerMetadata: {
                    openai: {
                      itemId: value.item.id
                    }
                  }
                });
              } else if (isResponseOutputItemAddedChunk(value) && value.item.type === "reasoning") {
                activeReasoning[value.item.id] = {
                  encryptedContent: value.item.encrypted_content,
                  summaryParts: { 0: "active" }
                };
                controller.enqueue({
                  type: "reasoning-start",
                  id: `${value.item.id}:0`,
                  providerMetadata: {
                    openai: {
                      itemId: value.item.id,
                      reasoningEncryptedContent: (_a = value.item.encrypted_content) != null ? _a : null
                    }
                  }
                });
              }
            } else if (isResponseOutputItemDoneChunk(value)) {
              if (value.item.type === "function_call") {
                ongoingToolCalls[value.output_index] = void 0;
                hasFunctionCall = true;
                controller.enqueue({
                  type: "tool-input-end",
                  id: value.item.call_id
                });
                controller.enqueue({
                  type: "tool-call",
                  toolCallId: value.item.call_id,
                  toolName: value.item.name,
                  input: value.item.arguments,
                  providerMetadata: {
                    openai: {
                      itemId: value.item.id
                    }
                  }
                });
              } else if (value.item.type === "web_search_call") {
                ongoingToolCalls[value.output_index] = void 0;
                controller.enqueue({
                  type: "tool-result",
                  toolCallId: value.item.id,
                  toolName: "web_search",
                  result: mapWebSearchOutput(value.item.action),
                  providerExecuted: true
                });
              } else if (value.item.type === "computer_call") {
                ongoingToolCalls[value.output_index] = void 0;
                controller.enqueue({
                  type: "tool-input-end",
                  id: value.item.id
                });
                controller.enqueue({
                  type: "tool-call",
                  toolCallId: value.item.id,
                  toolName: "computer_use",
                  input: "",
                  providerExecuted: true
                });
                controller.enqueue({
                  type: "tool-result",
                  toolCallId: value.item.id,
                  toolName: "computer_use",
                  result: {
                    type: "computer_use_tool_result",
                    status: value.item.status || "completed"
                  },
                  providerExecuted: true
                });
              } else if (value.item.type === "file_search_call") {
                ongoingToolCalls[value.output_index] = void 0;
                controller.enqueue({
                  type: "tool-result",
                  toolCallId: value.item.id,
                  toolName: "file_search",
                  result: {
                    queries: value.item.queries,
                    results: (_c = (_b = value.item.results) == null ? void 0 : _b.map((result) => ({
                      attributes: result.attributes,
                      fileId: result.file_id,
                      filename: result.filename,
                      score: result.score,
                      text: result.text
                    }))) != null ? _c : null
                  },
                  providerExecuted: true
                });
              } else if (value.item.type === "code_interpreter_call") {
                ongoingToolCalls[value.output_index] = void 0;
                controller.enqueue({
                  type: "tool-result",
                  toolCallId: value.item.id,
                  toolName: "code_interpreter",
                  result: {
                    outputs: value.item.outputs
                  },
                  providerExecuted: true
                });
              } else if (value.item.type === "image_generation_call") {
                controller.enqueue({
                  type: "tool-result",
                  toolCallId: value.item.id,
                  toolName: "image_generation",
                  result: {
                    result: value.item.result
                  },
                  providerExecuted: true
                });
              } else if (value.item.type === "local_shell_call") {
                ongoingToolCalls[value.output_index] = void 0;
                controller.enqueue({
                  type: "tool-call",
                  toolCallId: value.item.call_id,
                  toolName: "local_shell",
                  input: JSON.stringify({
                    action: {
                      type: "exec",
                      command: value.item.action.command,
                      timeoutMs: value.item.action.timeout_ms,
                      user: value.item.action.user,
                      workingDirectory: value.item.action.working_directory,
                      env: value.item.action.env
                    }
                  }),
                  providerMetadata: {
                    openai: { itemId: value.item.id }
                  }
                });
              } else if (value.item.type === "message") {
                controller.enqueue({
                  type: "text-end",
                  id: value.item.id
                });
              } else if (value.item.type === "reasoning") {
                const activeReasoningPart = activeReasoning[value.item.id];
                const summaryPartIndices = Object.entries(
                  activeReasoningPart.summaryParts
                ).filter(
                  ([_, status]) => status === "active" || status === "can-conclude"
                ).map(([summaryIndex]) => summaryIndex);
                for (const summaryIndex of summaryPartIndices) {
                  controller.enqueue({
                    type: "reasoning-end",
                    id: `${value.item.id}:${summaryIndex}`,
                    providerMetadata: {
                      openai: {
                        itemId: value.item.id,
                        reasoningEncryptedContent: (_d = value.item.encrypted_content) != null ? _d : null
                      }
                    }
                  });
                }
                delete activeReasoning[value.item.id];
              }
            } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {
              const toolCall = ongoingToolCalls[value.output_index];
              if (toolCall != null) {
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCall.toolCallId,
                  delta: value.delta
                });
              }
            } else if (isResponseCodeInterpreterCallCodeDeltaChunk(value)) {
              const toolCall = ongoingToolCalls[value.output_index];
              if (toolCall != null) {
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCall.toolCallId,
                  // The delta is code, which is embedding in a JSON string.
                  // To escape it, we use JSON.stringify and slice to remove the outer quotes.
                  delta: JSON.stringify(value.delta).slice(1, -1)
                });
              }
            } else if (isResponseCodeInterpreterCallCodeDoneChunk(value)) {
              const toolCall = ongoingToolCalls[value.output_index];
              if (toolCall != null) {
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCall.toolCallId,
                  delta: '"}'
                });
                controller.enqueue({
                  type: "tool-input-end",
                  id: toolCall.toolCallId
                });
                controller.enqueue({
                  type: "tool-call",
                  toolCallId: toolCall.toolCallId,
                  toolName: "code_interpreter",
                  input: JSON.stringify({
                    code: value.code,
                    containerId: toolCall.codeInterpreter.containerId
                  }),
                  providerExecuted: true
                });
              }
            } else if (isResponseCreatedChunk(value)) {
              responseId = value.response.id;
              controller.enqueue({
                type: "response-metadata",
                id: value.response.id,
                timestamp: new Date(value.response.created_at * 1e3),
                modelId: value.response.model
              });
            } else if (isTextDeltaChunk(value)) {
              controller.enqueue({
                type: "text-delta",
                id: value.item_id,
                delta: value.delta
              });
              if (((_f = (_e = options.providerOptions) == null ? void 0 : _e.openai) == null ? void 0 : _f.logprobs) && value.logprobs) {
                logprobs.push(value.logprobs);
              }
            } else if (value.type === "response.reasoning_summary_part.added") {
              if (value.summary_index > 0) {
                const activeReasoningPart = activeReasoning[value.item_id];
                activeReasoningPart.summaryParts[value.summary_index] = "active";
                for (const summaryIndex of Object.keys(
                  activeReasoningPart.summaryParts
                )) {
                  if (activeReasoningPart.summaryParts[summaryIndex] === "can-conclude") {
                    controller.enqueue({
                      type: "reasoning-end",
                      id: `${value.item_id}:${summaryIndex}`,
                      providerMetadata: { openai: { itemId: value.item_id } }
                    });
                    activeReasoningPart.summaryParts[summaryIndex] = "concluded";
                  }
                }
                controller.enqueue({
                  type: "reasoning-start",
                  id: `${value.item_id}:${value.summary_index}`,
                  providerMetadata: {
                    openai: {
                      itemId: value.item_id,
                      reasoningEncryptedContent: (_h = (_g = activeReasoning[value.item_id]) == null ? void 0 : _g.encryptedContent) != null ? _h : null
                    }
                  }
                });
              }
            } else if (value.type === "response.reasoning_summary_text.delta") {
              controller.enqueue({
                type: "reasoning-delta",
                id: `${value.item_id}:${value.summary_index}`,
                delta: value.delta,
                providerMetadata: {
                  openai: {
                    itemId: value.item_id
                  }
                }
              });
            } else if (value.type === "response.reasoning_summary_part.done") {
              if (store) {
                controller.enqueue({
                  type: "reasoning-end",
                  id: `${value.item_id}:${value.summary_index}`,
                  providerMetadata: {
                    openai: { itemId: value.item_id }
                  }
                });
                activeReasoning[value.item_id].summaryParts[value.summary_index] = "concluded";
              } else {
                activeReasoning[value.item_id].summaryParts[value.summary_index] = "can-conclude";
              }
            } else if (isResponseFinishedChunk(value)) {
              finishReason = mapOpenAIResponseFinishReason({
                finishReason: (_i = value.response.incomplete_details) == null ? void 0 : _i.reason,
                hasFunctionCall
              });
              usage.inputTokens = value.response.usage.input_tokens;
              usage.outputTokens = value.response.usage.output_tokens;
              usage.totalTokens = value.response.usage.input_tokens + value.response.usage.output_tokens;
              usage.reasoningTokens = (_k = (_j = value.response.usage.output_tokens_details) == null ? void 0 : _j.reasoning_tokens) != null ? _k : void 0;
              usage.cachedInputTokens = (_m = (_l = value.response.usage.input_tokens_details) == null ? void 0 : _l.cached_tokens) != null ? _m : void 0;
              if (typeof value.response.service_tier === "string") {
                serviceTier = value.response.service_tier;
              }
            } else if (isResponseAnnotationAddedChunk(value)) {
              if (value.annotation.type === "url_citation") {
                controller.enqueue({
                  type: "source",
                  sourceType: "url",
                  id: (_p = (_o = (_n = self.config).generateId) == null ? void 0 : _o.call(_n)) != null ? _p : generateId$1(),
                  url: value.annotation.url,
                  title: value.annotation.title
                });
              } else if (value.annotation.type === "file_citation") {
                controller.enqueue({
                  type: "source",
                  sourceType: "document",
                  id: (_s = (_r = (_q = self.config).generateId) == null ? void 0 : _r.call(_q)) != null ? _s : generateId$1(),
                  mediaType: "text/plain",
                  title: (_u = (_t = value.annotation.quote) != null ? _t : value.annotation.filename) != null ? _u : "Document",
                  filename: (_v = value.annotation.filename) != null ? _v : value.annotation.file_id
                });
              }
            } else if (isErrorChunk(value)) {
              controller.enqueue({ type: "error", error: value });
            }
          },
          flush(controller) {
            const providerMetadata = {
              openai: {
                responseId
              }
            };
            if (logprobs.length > 0) {
              providerMetadata.openai.logprobs = logprobs;
            }
            if (serviceTier !== void 0) {
              providerMetadata.openai.serviceTier = serviceTier;
            }
            controller.enqueue({
              type: "finish",
              finishReason,
              usage,
              providerMetadata
            });
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
function isTextDeltaChunk(chunk) {
  return chunk.type === "response.output_text.delta";
}
function isResponseOutputItemDoneChunk(chunk) {
  return chunk.type === "response.output_item.done";
}
function isResponseFinishedChunk(chunk) {
  return chunk.type === "response.completed" || chunk.type === "response.incomplete";
}
function isResponseCreatedChunk(chunk) {
  return chunk.type === "response.created";
}
function isResponseFunctionCallArgumentsDeltaChunk(chunk) {
  return chunk.type === "response.function_call_arguments.delta";
}
function isResponseCodeInterpreterCallCodeDeltaChunk(chunk) {
  return chunk.type === "response.code_interpreter_call_code.delta";
}
function isResponseCodeInterpreterCallCodeDoneChunk(chunk) {
  return chunk.type === "response.code_interpreter_call_code.done";
}
function isResponseOutputItemAddedChunk(chunk) {
  return chunk.type === "response.output_item.added";
}
function isResponseAnnotationAddedChunk(chunk) {
  return chunk.type === "response.output_text.annotation.added";
}
function isErrorChunk(chunk) {
  return chunk.type === "error";
}
function getResponsesModelConfig(modelId) {
  const supportsFlexProcessing2 = modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
  const supportsPriorityProcessing2 = modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
  const defaults = {
    requiredAutoTruncation: false,
    systemMessageMode: "system",
    supportsFlexProcessing: supportsFlexProcessing2,
    supportsPriorityProcessing: supportsPriorityProcessing2
  };
  if (modelId.startsWith("gpt-5-chat")) {
    return {
      ...defaults,
      isReasoningModel: false
    };
  }
  if (modelId.startsWith("o") || modelId.startsWith("gpt-5") || modelId.startsWith("codex-") || modelId.startsWith("computer-use")) {
    if (modelId.startsWith("o1-mini") || modelId.startsWith("o1-preview")) {
      return {
        ...defaults,
        isReasoningModel: true,
        systemMessageMode: "remove"
      };
    }
    return {
      ...defaults,
      isReasoningModel: true,
      systemMessageMode: "developer"
    };
  }
  return {
    ...defaults,
    isReasoningModel: false
  };
}
function mapWebSearchOutput(action) {
  var _a;
  switch (action.type) {
    case "search":
      return { action: { type: "search", query: (_a = action.query) != null ? _a : void 0 } };
    case "open_page":
      return { action: { type: "openPage", url: action.url } };
    case "find":
      return {
        action: { type: "find", url: action.url, pattern: action.pattern }
      };
  }
}
var openaiSpeechProviderOptionsSchema = lazyValidator(
  () => zodSchema(
    object({
      instructions: string().nullish(),
      speed: number$1().min(0.25).max(4).default(1).nullish()
    })
  )
);

// src/speech/openai-speech-model.ts
var OpenAISpeechModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    text,
    voice = "alloy",
    outputFormat = "mp3",
    speed,
    instructions,
    language,
    providerOptions
  }) {
    const warnings = [];
    const openAIOptions = await parseProviderOptions({
      provider: "openai",
      providerOptions,
      schema: openaiSpeechProviderOptionsSchema
    });
    const requestBody = {
      model: this.modelId,
      input: text,
      voice,
      response_format: "mp3",
      speed,
      instructions
    };
    if (outputFormat) {
      if (["mp3", "opus", "aac", "flac", "wav", "pcm"].includes(outputFormat)) {
        requestBody.response_format = outputFormat;
      } else {
        warnings.push({
          type: "unsupported-setting",
          setting: "outputFormat",
          details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`
        });
      }
    }
    if (openAIOptions) {
      const speechModelOptions = {};
      for (const key in speechModelOptions) {
        const value = speechModelOptions[key];
        if (value !== void 0) {
          requestBody[key] = value;
        }
      }
    }
    if (language) {
      warnings.push({
        type: "unsupported-setting",
        setting: "language",
        details: `OpenAI speech models do not support language selection. Language parameter "${language}" was ignored.`
      });
    }
    return {
      requestBody,
      warnings
    };
  }
  async doGenerate(options) {
    var _a, _b, _c;
    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
    const { requestBody, warnings } = await this.getArgs(options);
    const {
      value: audio,
      responseHeaders,
      rawValue: rawResponse
    } = await postJsonToApi$1({
      url: this.config.url({
        path: "/audio/speech",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body: requestBody,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createBinaryResponseHandler(),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    return {
      audio,
      warnings,
      request: {
        body: JSON.stringify(requestBody)
      },
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders,
        body: rawResponse
      }
    };
  }
};
var openaiTranscriptionResponseSchema = lazyValidator(
  () => zodSchema(
    object({
      text: string(),
      language: string().nullish(),
      duration: number$1().nullish(),
      words: array(
        object({
          word: string(),
          start: number$1(),
          end: number$1()
        })
      ).nullish(),
      segments: array(
        object({
          id: number$1(),
          seek: number$1(),
          start: number$1(),
          end: number$1(),
          text: string(),
          tokens: array(number$1()),
          temperature: number$1(),
          avg_logprob: number$1(),
          compression_ratio: number$1(),
          no_speech_prob: number$1()
        })
      ).nullish()
    })
  )
);
var openAITranscriptionProviderOptions = lazyValidator(
  () => zodSchema(
    object({
      /**
       * Additional information to include in the transcription response.
       */
      include: array(string()).optional(),
      /**
       * The language of the input audio in ISO-639-1 format.
       */
      language: string().optional(),
      /**
       * An optional text to guide the model's style or continue a previous audio segment.
       */
      prompt: string().optional(),
      /**
       * The sampling temperature, between 0 and 1.
       * @default 0
       */
      temperature: number$1().min(0).max(1).default(0).optional(),
      /**
       * The timestamp granularities to populate for this transcription.
       * @default ['segment']
       */
      timestampGranularities: array(_enum(["word", "segment"])).default(["segment"]).optional()
    })
  )
);

// src/transcription/openai-transcription-model.ts
var languageMap = {
  afrikaans: "af",
  arabic: "ar",
  armenian: "hy",
  azerbaijani: "az",
  belarusian: "be",
  bosnian: "bs",
  bulgarian: "bg",
  catalan: "ca",
  chinese: "zh",
  croatian: "hr",
  czech: "cs",
  danish: "da",
  dutch: "nl",
  english: "en",
  estonian: "et",
  finnish: "fi",
  french: "fr",
  galician: "gl",
  german: "de",
  greek: "el",
  hebrew: "he",
  hindi: "hi",
  hungarian: "hu",
  icelandic: "is",
  indonesian: "id",
  italian: "it",
  japanese: "ja",
  kannada: "kn",
  kazakh: "kk",
  korean: "ko",
  latvian: "lv",
  lithuanian: "lt",
  macedonian: "mk",
  malay: "ms",
  marathi: "mr",
  maori: "mi",
  nepali: "ne",
  norwegian: "no",
  persian: "fa",
  polish: "pl",
  portuguese: "pt",
  romanian: "ro",
  russian: "ru",
  serbian: "sr",
  slovak: "sk",
  slovenian: "sl",
  spanish: "es",
  swahili: "sw",
  swedish: "sv",
  tagalog: "tl",
  tamil: "ta",
  thai: "th",
  turkish: "tr",
  ukrainian: "uk",
  urdu: "ur",
  vietnamese: "vi",
  welsh: "cy"
};
var OpenAITranscriptionModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
  }
  get provider() {
    return this.config.provider;
  }
  async getArgs({
    audio,
    mediaType,
    providerOptions
  }) {
    const warnings = [];
    const openAIOptions = await parseProviderOptions({
      provider: "openai",
      providerOptions,
      schema: openAITranscriptionProviderOptions
    });
    const formData = new FormData();
    const blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([convertBase64ToUint8Array(audio)]);
    formData.append("model", this.modelId);
    const fileExtension = mediaTypeToExtension(mediaType);
    formData.append(
      "file",
      new File([blob], "audio", { type: mediaType }),
      `audio.${fileExtension}`
    );
    if (openAIOptions) {
      const transcriptionModelOptions = {
        include: openAIOptions.include,
        language: openAIOptions.language,
        prompt: openAIOptions.prompt,
        // https://platform.openai.com/docs/api-reference/audio/createTranscription#audio_createtranscription-response_format
        // prefer verbose_json to get segments for models that support it
        response_format: [
          "gpt-4o-transcribe",
          "gpt-4o-mini-transcribe"
        ].includes(this.modelId) ? "json" : "verbose_json",
        temperature: openAIOptions.temperature,
        timestamp_granularities: openAIOptions.timestampGranularities
      };
      for (const [key, value] of Object.entries(transcriptionModelOptions)) {
        if (value != null) {
          if (Array.isArray(value)) {
            for (const item of value) {
              formData.append(`${key}[]`, String(item));
            }
          } else {
            formData.append(key, String(value));
          }
        }
      }
    }
    return {
      formData,
      warnings
    };
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
    const { formData, warnings } = await this.getArgs(options);
    const {
      value: response,
      responseHeaders,
      rawValue: rawResponse
    } = await postFormDataToApi({
      url: this.config.url({
        path: "/audio/transcriptions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      formData,
      failedResponseHandler: openaiFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiTranscriptionResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const language = response.language != null && response.language in languageMap ? languageMap[response.language] : void 0;
    return {
      text: response.text,
      segments: (_g = (_f = (_d = response.segments) == null ? void 0 : _d.map((segment) => ({
        text: segment.text,
        startSecond: segment.start,
        endSecond: segment.end
      }))) != null ? _f : (_e = response.words) == null ? void 0 : _e.map((word) => ({
        text: word.word,
        startSecond: word.start,
        endSecond: word.end
      }))) != null ? _g : [],
      language,
      durationInSeconds: (_h = response.duration) != null ? _h : void 0,
      warnings,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders,
        body: rawResponse
      }
    };
  }
};

// src/version.ts
var VERSION$4 = "2.0.52" ;

// src/openai-provider.ts
function createOpenAI(options = {}) {
  var _a, _b;
  const baseURL = (_a = withoutTrailingSlash$1(
    loadOptionalSetting({
      settingValue: options.baseURL,
      environmentVariableName: "OPENAI_BASE_URL"
    })
  )) != null ? _a : "https://api.openai.com/v1";
  const providerName = (_b = options.name) != null ? _b : "openai";
  const getHeaders = () => withUserAgentSuffix(
    {
      Authorization: `Bearer ${loadApiKey$1({
        apiKey: options.apiKey,
        environmentVariableName: "OPENAI_API_KEY",
        description: "OpenAI"
      })}`,
      "OpenAI-Organization": options.organization,
      "OpenAI-Project": options.project,
      ...options.headers
    },
    `ai-sdk/openai/${VERSION$4}`
  );
  const createChatModel = (modelId) => new OpenAIChatLanguageModel(modelId, {
    provider: `${providerName}.chat`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createCompletionModel = (modelId) => new OpenAICompletionLanguageModel(modelId, {
    provider: `${providerName}.completion`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createEmbeddingModel = (modelId) => new OpenAIEmbeddingModel(modelId, {
    provider: `${providerName}.embedding`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createImageModel = (modelId) => new OpenAIImageModel(modelId, {
    provider: `${providerName}.image`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createTranscriptionModel = (modelId) => new OpenAITranscriptionModel(modelId, {
    provider: `${providerName}.transcription`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createSpeechModel = (modelId) => new OpenAISpeechModel(modelId, {
    provider: `${providerName}.speech`,
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createLanguageModel = (modelId) => {
    if (new.target) {
      throw new Error(
        "The OpenAI model function cannot be called with the new keyword."
      );
    }
    return createResponsesModel(modelId);
  };
  const createResponsesModel = (modelId) => {
    return new OpenAIResponsesLanguageModel(modelId, {
      provider: `${providerName}.responses`,
      url: ({ path }) => `${baseURL}${path}`,
      headers: getHeaders,
      fetch: options.fetch,
      fileIdPrefixes: ["file-"]
    });
  };
  const provider = function(modelId) {
    return createLanguageModel(modelId);
  };
  provider.languageModel = createLanguageModel;
  provider.chat = createChatModel;
  provider.completion = createCompletionModel;
  provider.responses = createResponsesModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.transcription = createTranscriptionModel;
  provider.transcriptionModel = createTranscriptionModel;
  provider.speech = createSpeechModel;
  provider.speechModel = createSpeechModel;
  provider.tools = openaiTools;
  return provider;
}
createOpenAI();

// src/anthropic-provider.ts

// src/version.ts
var VERSION$3 = "2.0.33" ;
var anthropicErrorDataSchema$1 = lazySchema(
  () => zodSchema(
    object({
      type: literal("error"),
      error: object({
        type: string(),
        message: string()
      })
    })
  )
);
var anthropicFailedResponseHandler = createJsonErrorResponseHandler$1({
  errorSchema: anthropicErrorDataSchema$1,
  errorToMessage: (data) => data.error.message
});
var anthropicMessagesResponseSchema = lazySchema(
  () => zodSchema(
    object({
      type: literal("message"),
      id: string().nullish(),
      model: string().nullish(),
      content: array(
        discriminatedUnion("type", [
          object({
            type: literal("text"),
            text: string(),
            citations: array(
              discriminatedUnion("type", [
                object({
                  type: literal("web_search_result_location"),
                  cited_text: string(),
                  url: string(),
                  title: string(),
                  encrypted_index: string()
                }),
                object({
                  type: literal("page_location"),
                  cited_text: string(),
                  document_index: number$1(),
                  document_title: string().nullable(),
                  start_page_number: number$1(),
                  end_page_number: number$1()
                }),
                object({
                  type: literal("char_location"),
                  cited_text: string(),
                  document_index: number$1(),
                  document_title: string().nullable(),
                  start_char_index: number$1(),
                  end_char_index: number$1()
                })
              ])
            ).optional()
          }),
          object({
            type: literal("thinking"),
            thinking: string(),
            signature: string()
          }),
          object({
            type: literal("redacted_thinking"),
            data: string()
          }),
          object({
            type: literal("tool_use"),
            id: string(),
            name: string(),
            input: unknown()
          }),
          object({
            type: literal("server_tool_use"),
            id: string(),
            name: string(),
            input: record(string(), unknown()).nullish()
          }),
          object({
            type: literal("web_fetch_tool_result"),
            tool_use_id: string(),
            content: union([
              object({
                type: literal("web_fetch_result"),
                url: string(),
                retrieved_at: string(),
                content: object({
                  type: literal("document"),
                  title: string().nullable(),
                  citations: object({ enabled: boolean() }).optional(),
                  source: object({
                    type: literal("text"),
                    media_type: string(),
                    data: string()
                  })
                })
              }),
              object({
                type: literal("web_fetch_tool_result_error"),
                error_code: string()
              })
            ])
          }),
          object({
            type: literal("web_search_tool_result"),
            tool_use_id: string(),
            content: union([
              array(
                object({
                  type: literal("web_search_result"),
                  url: string(),
                  title: string(),
                  encrypted_content: string(),
                  page_age: string().nullish()
                })
              ),
              object({
                type: literal("web_search_tool_result_error"),
                error_code: string()
              })
            ])
          }),
          // code execution results for code_execution_20250522 tool:
          object({
            type: literal("code_execution_tool_result"),
            tool_use_id: string(),
            content: union([
              object({
                type: literal("code_execution_result"),
                stdout: string(),
                stderr: string(),
                return_code: number$1()
              }),
              object({
                type: literal("code_execution_tool_result_error"),
                error_code: string()
              })
            ])
          }),
          // bash code execution results for code_execution_20250825 tool:
          object({
            type: literal("bash_code_execution_tool_result"),
            tool_use_id: string(),
            content: discriminatedUnion("type", [
              object({
                type: literal("bash_code_execution_result"),
                content: array(
                  object({
                    type: literal("bash_code_execution_output"),
                    file_id: string()
                  })
                ),
                stdout: string(),
                stderr: string(),
                return_code: number$1()
              }),
              object({
                type: literal("bash_code_execution_tool_result_error"),
                error_code: string()
              })
            ])
          }),
          // text editor code execution results for code_execution_20250825 tool:
          object({
            type: literal("text_editor_code_execution_tool_result"),
            tool_use_id: string(),
            content: discriminatedUnion("type", [
              object({
                type: literal("text_editor_code_execution_tool_result_error"),
                error_code: string()
              }),
              object({
                type: literal("text_editor_code_execution_view_result"),
                content: string(),
                file_type: string(),
                num_lines: number$1().nullable(),
                start_line: number$1().nullable(),
                total_lines: number$1().nullable()
              }),
              object({
                type: literal("text_editor_code_execution_create_result"),
                is_file_update: boolean()
              }),
              object({
                type: literal(
                  "text_editor_code_execution_str_replace_result"
                ),
                lines: array(string()).nullable(),
                new_lines: number$1().nullable(),
                new_start: number$1().nullable(),
                old_lines: number$1().nullable(),
                old_start: number$1().nullable()
              })
            ])
          })
        ])
      ),
      stop_reason: string().nullish(),
      stop_sequence: string().nullish(),
      usage: looseObject({
        input_tokens: number$1(),
        output_tokens: number$1(),
        cache_creation_input_tokens: number$1().nullish(),
        cache_read_input_tokens: number$1().nullish()
      })
    })
  )
);
var anthropicMessagesChunkSchema = lazySchema(
  () => zodSchema(
    discriminatedUnion("type", [
      object({
        type: literal("message_start"),
        message: object({
          id: string().nullish(),
          model: string().nullish(),
          usage: looseObject({
            input_tokens: number$1(),
            cache_creation_input_tokens: number$1().nullish(),
            cache_read_input_tokens: number$1().nullish()
          })
        })
      }),
      object({
        type: literal("content_block_start"),
        index: number$1(),
        content_block: discriminatedUnion("type", [
          object({
            type: literal("text"),
            text: string()
          }),
          object({
            type: literal("thinking"),
            thinking: string()
          }),
          object({
            type: literal("tool_use"),
            id: string(),
            name: string()
          }),
          object({
            type: literal("redacted_thinking"),
            data: string()
          }),
          object({
            type: literal("server_tool_use"),
            id: string(),
            name: string(),
            input: record(string(), unknown()).nullish()
          }),
          object({
            type: literal("web_fetch_tool_result"),
            tool_use_id: string(),
            content: union([
              object({
                type: literal("web_fetch_result"),
                url: string(),
                retrieved_at: string(),
                content: object({
                  type: literal("document"),
                  title: string().nullable(),
                  citations: object({ enabled: boolean() }).optional(),
                  source: object({
                    type: literal("text"),
                    media_type: string(),
                    data: string()
                  })
                })
              }),
              object({
                type: literal("web_fetch_tool_result_error"),
                error_code: string()
              })
            ])
          }),
          object({
            type: literal("web_search_tool_result"),
            tool_use_id: string(),
            content: union([
              array(
                object({
                  type: literal("web_search_result"),
                  url: string(),
                  title: string(),
                  encrypted_content: string(),
                  page_age: string().nullish()
                })
              ),
              object({
                type: literal("web_search_tool_result_error"),
                error_code: string()
              })
            ])
          }),
          // code execution results for code_execution_20250522 tool:
          object({
            type: literal("code_execution_tool_result"),
            tool_use_id: string(),
            content: union([
              object({
                type: literal("code_execution_result"),
                stdout: string(),
                stderr: string(),
                return_code: number$1()
              }),
              object({
                type: literal("code_execution_tool_result_error"),
                error_code: string()
              })
            ])
          }),
          // bash code execution results for code_execution_20250825 tool:
          object({
            type: literal("bash_code_execution_tool_result"),
            tool_use_id: string(),
            content: discriminatedUnion("type", [
              object({
                type: literal("bash_code_execution_result"),
                content: array(
                  object({
                    type: literal("bash_code_execution_output"),
                    file_id: string()
                  })
                ),
                stdout: string(),
                stderr: string(),
                return_code: number$1()
              }),
              object({
                type: literal("bash_code_execution_tool_result_error"),
                error_code: string()
              })
            ])
          }),
          // text editor code execution results for code_execution_20250825 tool:
          object({
            type: literal("text_editor_code_execution_tool_result"),
            tool_use_id: string(),
            content: discriminatedUnion("type", [
              object({
                type: literal("text_editor_code_execution_tool_result_error"),
                error_code: string()
              }),
              object({
                type: literal("text_editor_code_execution_view_result"),
                content: string(),
                file_type: string(),
                num_lines: number$1().nullable(),
                start_line: number$1().nullable(),
                total_lines: number$1().nullable()
              }),
              object({
                type: literal("text_editor_code_execution_create_result"),
                is_file_update: boolean()
              }),
              object({
                type: literal(
                  "text_editor_code_execution_str_replace_result"
                ),
                lines: array(string()).nullable(),
                new_lines: number$1().nullable(),
                new_start: number$1().nullable(),
                old_lines: number$1().nullable(),
                old_start: number$1().nullable()
              })
            ])
          })
        ])
      }),
      object({
        type: literal("content_block_delta"),
        index: number$1(),
        delta: discriminatedUnion("type", [
          object({
            type: literal("input_json_delta"),
            partial_json: string()
          }),
          object({
            type: literal("text_delta"),
            text: string()
          }),
          object({
            type: literal("thinking_delta"),
            thinking: string()
          }),
          object({
            type: literal("signature_delta"),
            signature: string()
          }),
          object({
            type: literal("citations_delta"),
            citation: discriminatedUnion("type", [
              object({
                type: literal("web_search_result_location"),
                cited_text: string(),
                url: string(),
                title: string(),
                encrypted_index: string()
              }),
              object({
                type: literal("page_location"),
                cited_text: string(),
                document_index: number$1(),
                document_title: string().nullable(),
                start_page_number: number$1(),
                end_page_number: number$1()
              }),
              object({
                type: literal("char_location"),
                cited_text: string(),
                document_index: number$1(),
                document_title: string().nullable(),
                start_char_index: number$1(),
                end_char_index: number$1()
              })
            ])
          })
        ])
      }),
      object({
        type: literal("content_block_stop"),
        index: number$1()
      }),
      object({
        type: literal("error"),
        error: object({
          type: string(),
          message: string()
        })
      }),
      object({
        type: literal("message_delta"),
        delta: object({
          stop_reason: string().nullish(),
          stop_sequence: string().nullish()
        }),
        usage: looseObject({
          output_tokens: number$1(),
          cache_creation_input_tokens: number$1().nullish()
        })
      }),
      object({
        type: literal("message_stop")
      }),
      object({
        type: literal("ping")
      })
    ])
  )
);
var anthropicReasoningMetadataSchema = lazySchema(
  () => zodSchema(
    object({
      signature: string().optional(),
      redactedData: string().optional()
    })
  )
);
var anthropicFilePartProviderOptions = object({
  /**
   * Citation configuration for this document.
   * When enabled, this document will generate citations in the response.
   */
  citations: object({
    /**
     * Enable citations for this document
     */
    enabled: boolean()
  }).optional(),
  /**
   * Custom title for the document.
   * If not provided, the filename will be used.
   */
  title: string().optional(),
  /**
   * Context about the document that will be passed to the model
   * but not used towards cited content.
   * Useful for storing document metadata as text or stringified JSON.
   */
  context: string().optional()
});
var anthropicProviderOptions = object({
  sendReasoning: boolean().optional(),
  thinking: object({
    type: union([literal("enabled"), literal("disabled")]),
    budgetTokens: number$1().optional()
  }).optional(),
  /**
   * Whether to disable parallel function calling during tool use. Default is false.
   * When set to true, Claude will use at most one tool per response.
   */
  disableParallelToolUse: boolean().optional(),
  /**
   * Cache control settings for this message.
   * See https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching
   */
  cacheControl: object({
    type: literal("ephemeral"),
    ttl: union([literal("5m"), literal("1h")]).optional()
  }).optional(),
  /**
   * Agent Skills configuration. Skills enable Claude to perform specialized tasks
   * like document processing (PPTX, DOCX, PDF, XLSX) and data analysis.
   * Requires code execution tool to be enabled.
   */
  container: object({
    id: string().optional(),
    skills: array(
      object({
        type: union([literal("anthropic"), literal("custom")]),
        skillId: string(),
        version: string().optional()
      })
    ).optional()
  }).optional()
});

// src/get-cache-control.ts
var MAX_CACHE_BREAKPOINTS$1 = 4;
function getCacheControl$2(providerMetadata) {
  var _a;
  const anthropic2 = providerMetadata == null ? void 0 : providerMetadata.anthropic;
  const cacheControlValue = (_a = anthropic2 == null ? void 0 : anthropic2.cacheControl) != null ? _a : anthropic2 == null ? void 0 : anthropic2.cache_control;
  return cacheControlValue;
}
var CacheControlValidator$1 = class CacheControlValidator {
  constructor() {
    this.breakpointCount = 0;
    this.warnings = [];
  }
  getCacheControl(providerMetadata, context) {
    const cacheControlValue = getCacheControl$2(providerMetadata);
    if (!cacheControlValue) {
      return void 0;
    }
    if (!context.canCache) {
      this.warnings.push({
        type: "unsupported-setting",
        setting: "cacheControl",
        details: `cache_control cannot be set on ${context.type}. It will be ignored.`
      });
      return void 0;
    }
    this.breakpointCount++;
    if (this.breakpointCount > MAX_CACHE_BREAKPOINTS$1) {
      this.warnings.push({
        type: "unsupported-setting",
        setting: "cacheControl",
        details: `Maximum ${MAX_CACHE_BREAKPOINTS$1} cache breakpoints exceeded (found ${this.breakpointCount}). This breakpoint will be ignored.`
      });
      return void 0;
    }
    return cacheControlValue;
  }
  getWarnings() {
    return this.warnings;
  }
};
var textEditor_20250728ArgsSchema$1 = lazySchema(
  () => zodSchema(
    object({
      maxCharacters: number$1().optional()
    })
  )
);
var textEditor_20250728InputSchema$1 = lazySchema(
  () => zodSchema(
    object({
      command: _enum(["view", "create", "str_replace", "insert"]),
      path: string(),
      file_text: string().optional(),
      insert_line: number$1().int().optional(),
      new_str: string().optional(),
      old_str: string().optional(),
      view_range: array(number$1().int()).optional()
    })
  )
);
var factory$1 = createProviderDefinedToolFactory({
  id: "anthropic.text_editor_20250728",
  name: "str_replace_based_edit_tool",
  inputSchema: textEditor_20250728InputSchema$1
});
var textEditor_20250728$1 = (args = {}) => {
  return factory$1(args);
};
var webSearch_20250305ArgsSchema$1 = lazySchema(
  () => zodSchema(
    object({
      maxUses: number$1().optional(),
      allowedDomains: array(string()).optional(),
      blockedDomains: array(string()).optional(),
      userLocation: object({
        type: literal("approximate"),
        city: string().optional(),
        region: string().optional(),
        country: string().optional(),
        timezone: string().optional()
      }).optional()
    })
  )
);
var webSearch_20250305OutputSchema$1 = lazySchema(
  () => zodSchema(
    array(
      object({
        url: string(),
        title: string(),
        pageAge: string().nullable(),
        encryptedContent: string(),
        type: literal("web_search_result")
      })
    )
  )
);
var webSearch_20250305InputSchema$1 = lazySchema(
  () => zodSchema(
    object({
      query: string()
    })
  )
);
var factory2$1 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "anthropic.web_search_20250305",
  name: "web_search",
  inputSchema: webSearch_20250305InputSchema$1,
  outputSchema: webSearch_20250305OutputSchema$1
});
var webSearch_20250305$1 = (args = {}) => {
  return factory2$1(args);
};
var webFetch_20250910ArgsSchema$1 = lazySchema(
  () => zodSchema(
    object({
      maxUses: number$1().optional(),
      allowedDomains: array(string()).optional(),
      blockedDomains: array(string()).optional(),
      citations: object({ enabled: boolean() }).optional(),
      maxContentTokens: number$1().optional()
    })
  )
);
var webFetch_20250910OutputSchema$1 = lazySchema(
  () => zodSchema(
    object({
      type: literal("web_fetch_result"),
      url: string(),
      content: object({
        type: literal("document"),
        title: string(),
        citations: object({ enabled: boolean() }).optional(),
        source: union([
          object({
            type: literal("base64"),
            mediaType: literal("application/pdf"),
            data: string()
          }),
          object({
            type: literal("text"),
            mediaType: literal("text/plain"),
            data: string()
          })
        ])
      }),
      retrievedAt: string().nullable()
    })
  )
);
var webFetch_20250910InputSchema$1 = lazySchema(
  () => zodSchema(
    object({
      url: string()
    })
  )
);
var factory3$1 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "anthropic.web_fetch_20250910",
  name: "web_fetch",
  inputSchema: webFetch_20250910InputSchema$1,
  outputSchema: webFetch_20250910OutputSchema$1
});
var webFetch_20250910$1 = (args = {}) => {
  return factory3$1(args);
};
async function prepareTools$4({
  tools,
  toolChoice,
  disableParallelToolUse,
  cacheControlValidator
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  const betas = /* @__PURE__ */ new Set();
  const validator = cacheControlValidator || new CacheControlValidator$1();
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
  }
  const anthropicTools2 = [];
  for (const tool of tools) {
    switch (tool.type) {
      case "function": {
        const cacheControl = validator.getCacheControl(tool.providerOptions, {
          type: "tool definition",
          canCache: true
        });
        anthropicTools2.push({
          name: tool.name,
          description: tool.description,
          input_schema: tool.inputSchema,
          cache_control: cacheControl
        });
        break;
      }
      case "provider-defined": {
        switch (tool.id) {
          case "anthropic.code_execution_20250522": {
            betas.add("code-execution-2025-05-22");
            anthropicTools2.push({
              type: "code_execution_20250522",
              name: "code_execution",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.code_execution_20250825": {
            betas.add("code-execution-2025-08-25");
            anthropicTools2.push({
              type: "code_execution_20250825",
              name: "code_execution"
            });
            break;
          }
          case "anthropic.computer_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "computer",
              type: "computer_20250124",
              display_width_px: tool.args.displayWidthPx,
              display_height_px: tool.args.displayHeightPx,
              display_number: tool.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.computer_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools2.push({
              name: "computer",
              type: "computer_20241022",
              display_width_px: tool.args.displayWidthPx,
              display_height_px: tool.args.displayHeightPx,
              display_number: tool.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "str_replace_editor",
              type: "text_editor_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools2.push({
              name: "str_replace_editor",
              type: "text_editor_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250429": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250429",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250728": {
            const args = await validateTypes$1({
              value: tool.args,
              schema: textEditor_20250728ArgsSchema$1
            });
            anthropicTools2.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250728",
              max_characters: args.maxCharacters,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "bash",
              type: "bash_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools2.push({
              name: "bash",
              type: "bash_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.memory_20250818": {
            betas.add("context-management-2025-06-27");
            anthropicTools2.push({
              name: "memory",
              type: "memory_20250818"
            });
            break;
          }
          case "anthropic.web_fetch_20250910": {
            betas.add("web-fetch-2025-09-10");
            const args = await validateTypes$1({
              value: tool.args,
              schema: webFetch_20250910ArgsSchema$1
            });
            anthropicTools2.push({
              type: "web_fetch_20250910",
              name: "web_fetch",
              max_uses: args.maxUses,
              allowed_domains: args.allowedDomains,
              blocked_domains: args.blockedDomains,
              citations: args.citations,
              max_content_tokens: args.maxContentTokens,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.web_search_20250305": {
            const args = await validateTypes$1({
              value: tool.args,
              schema: webSearch_20250305ArgsSchema$1
            });
            anthropicTools2.push({
              type: "web_search_20250305",
              name: "web_search",
              max_uses: args.maxUses,
              allowed_domains: args.allowedDomains,
              blocked_domains: args.blockedDomains,
              user_location: args.userLocation,
              cache_control: void 0
            });
            break;
          }
          default: {
            toolWarnings.push({ type: "unsupported-tool", tool });
            break;
          }
        }
        break;
      }
      default: {
        toolWarnings.push({ type: "unsupported-tool", tool });
        break;
      }
    }
  }
  if (toolChoice == null) {
    return {
      tools: anthropicTools2,
      toolChoice: disableParallelToolUse ? { type: "auto", disable_parallel_tool_use: disableParallelToolUse } : void 0,
      toolWarnings,
      betas
    };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "auto",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "required":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "any",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "none":
      return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
    case "tool":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "tool",
          name: toolChoice.toolName,
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError$1({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var codeExecution_20250522OutputSchema$1 = lazySchema(
  () => zodSchema(
    object({
      type: literal("code_execution_result"),
      stdout: string(),
      stderr: string(),
      return_code: number$1()
    })
  )
);
var codeExecution_20250522InputSchema$1 = lazySchema(
  () => zodSchema(
    object({
      code: string()
    })
  )
);
var factory4$1 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "anthropic.code_execution_20250522",
  name: "code_execution",
  inputSchema: codeExecution_20250522InputSchema$1,
  outputSchema: codeExecution_20250522OutputSchema$1
});
var codeExecution_20250522$1 = (args = {}) => {
  return factory4$1(args);
};
var codeExecution_20250825OutputSchema$1 = lazySchema(
  () => zodSchema(
    discriminatedUnion("type", [
      object({
        type: literal("bash_code_execution_result"),
        content: array(
          object({
            type: literal("bash_code_execution_output"),
            file_id: string()
          })
        ),
        stdout: string(),
        stderr: string(),
        return_code: number$1()
      }),
      object({
        type: literal("bash_code_execution_tool_result_error"),
        error_code: string()
      }),
      object({
        type: literal("text_editor_code_execution_tool_result_error"),
        error_code: string()
      }),
      object({
        type: literal("text_editor_code_execution_view_result"),
        content: string(),
        file_type: string(),
        num_lines: number$1().nullable(),
        start_line: number$1().nullable(),
        total_lines: number$1().nullable()
      }),
      object({
        type: literal("text_editor_code_execution_create_result"),
        is_file_update: boolean()
      }),
      object({
        type: literal("text_editor_code_execution_str_replace_result"),
        lines: array(string()).nullable(),
        new_lines: number$1().nullable(),
        new_start: number$1().nullable(),
        old_lines: number$1().nullable(),
        old_start: number$1().nullable()
      })
    ])
  )
);
var codeExecution_20250825InputSchema$1 = lazySchema(
  () => zodSchema(
    discriminatedUnion("type", [
      object({
        type: literal("bash_code_execution"),
        command: string()
      }),
      discriminatedUnion("command", [
        object({
          type: literal("text_editor_code_execution"),
          command: literal("view"),
          path: string()
        }),
        object({
          type: literal("text_editor_code_execution"),
          command: literal("create"),
          path: string(),
          file_text: string().nullish()
        }),
        object({
          type: literal("text_editor_code_execution"),
          command: literal("str_replace"),
          path: string(),
          old_str: string(),
          new_str: string()
        })
      ])
    ])
  )
);
var factory5$1 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "anthropic.code_execution_20250825",
  name: "code_execution",
  inputSchema: codeExecution_20250825InputSchema$1,
  outputSchema: codeExecution_20250825OutputSchema$1
});
var codeExecution_20250825$1 = (args = {}) => {
  return factory5$1(args);
};

// src/convert-to-anthropic-messages-prompt.ts
function convertToString(data) {
  if (typeof data === "string") {
    return Buffer.from(data, "base64").toString("utf-8");
  }
  if (data instanceof Uint8Array) {
    return new TextDecoder().decode(data);
  }
  if (data instanceof URL) {
    throw new UnsupportedFunctionalityError$1({
      functionality: "URL-based text documents are not supported for citations"
    });
  }
  throw new UnsupportedFunctionalityError$1({
    functionality: `unsupported data type for text documents: ${typeof data}`
  });
}
async function convertToAnthropicMessagesPrompt({
  prompt,
  sendReasoning,
  warnings,
  cacheControlValidator
}) {
  var _a, _b, _c, _d, _e;
  const betas = /* @__PURE__ */ new Set();
  const blocks = groupIntoBlocks$1(prompt);
  const validator = cacheControlValidator || new CacheControlValidator$1();
  let system = void 0;
  const messages = [];
  async function shouldEnableCitations(providerMetadata) {
    var _a2, _b2;
    const anthropicOptions = await parseProviderOptions({
      provider: "anthropic",
      providerOptions: providerMetadata,
      schema: anthropicFilePartProviderOptions
    });
    return (_b2 = (_a2 = anthropicOptions == null ? void 0 : anthropicOptions.citations) == null ? void 0 : _a2.enabled) != null ? _b2 : false;
  }
  async function getDocumentMetadata(providerMetadata) {
    const anthropicOptions = await parseProviderOptions({
      provider: "anthropic",
      providerOptions: providerMetadata,
      schema: anthropicFilePartProviderOptions
    });
    return {
      title: anthropicOptions == null ? void 0 : anthropicOptions.title,
      context: anthropicOptions == null ? void 0 : anthropicOptions.context
    };
  }
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    const isLastBlock = i === blocks.length - 1;
    const type = block.type;
    switch (type) {
      case "system": {
        if (system != null) {
          throw new UnsupportedFunctionalityError$1({
            functionality: "Multiple system messages that are separated by user/assistant messages"
          });
        }
        system = block.messages.map(({ content, providerOptions }) => ({
          type: "text",
          text: content,
          cache_control: validator.getCacheControl(providerOptions, {
            type: "system message",
            canCache: true
          })
        }));
        break;
      }
      case "user": {
        const anthropicContent = [];
        for (const message of block.messages) {
          const { role, content } = message;
          switch (role) {
            case "user": {
              for (let j = 0; j < content.length; j++) {
                const part = content[j];
                const isLastPart = j === content.length - 1;
                const cacheControl = (_a = validator.getCacheControl(part.providerOptions, {
                  type: "user message part",
                  canCache: true
                })) != null ? _a : isLastPart ? validator.getCacheControl(message.providerOptions, {
                  type: "user message",
                  canCache: true
                }) : void 0;
                switch (part.type) {
                  case "text": {
                    anthropicContent.push({
                      type: "text",
                      text: part.text,
                      cache_control: cacheControl
                    });
                    break;
                  }
                  case "file": {
                    if (part.mediaType.startsWith("image/")) {
                      anthropicContent.push({
                        type: "image",
                        source: part.data instanceof URL ? {
                          type: "url",
                          url: part.data.toString()
                        } : {
                          type: "base64",
                          media_type: part.mediaType === "image/*" ? "image/jpeg" : part.mediaType,
                          data: convertToBase64(part.data)
                        },
                        cache_control: cacheControl
                      });
                    } else if (part.mediaType === "application/pdf") {
                      betas.add("pdfs-2024-09-25");
                      const enableCitations = await shouldEnableCitations(
                        part.providerOptions
                      );
                      const metadata = await getDocumentMetadata(
                        part.providerOptions
                      );
                      anthropicContent.push({
                        type: "document",
                        source: part.data instanceof URL ? {
                          type: "url",
                          url: part.data.toString()
                        } : {
                          type: "base64",
                          media_type: "application/pdf",
                          data: convertToBase64(part.data)
                        },
                        title: (_b = metadata.title) != null ? _b : part.filename,
                        ...metadata.context && { context: metadata.context },
                        ...enableCitations && {
                          citations: { enabled: true }
                        },
                        cache_control: cacheControl
                      });
                    } else if (part.mediaType === "text/plain") {
                      const enableCitations = await shouldEnableCitations(
                        part.providerOptions
                      );
                      const metadata = await getDocumentMetadata(
                        part.providerOptions
                      );
                      anthropicContent.push({
                        type: "document",
                        source: part.data instanceof URL ? {
                          type: "url",
                          url: part.data.toString()
                        } : {
                          type: "text",
                          media_type: "text/plain",
                          data: convertToString(part.data)
                        },
                        title: (_c = metadata.title) != null ? _c : part.filename,
                        ...metadata.context && { context: metadata.context },
                        ...enableCitations && {
                          citations: { enabled: true }
                        },
                        cache_control: cacheControl
                      });
                    } else {
                      throw new UnsupportedFunctionalityError$1({
                        functionality: `media type: ${part.mediaType}`
                      });
                    }
                    break;
                  }
                }
              }
              break;
            }
            case "tool": {
              for (let i2 = 0; i2 < content.length; i2++) {
                const part = content[i2];
                const isLastPart = i2 === content.length - 1;
                const cacheControl = (_d = validator.getCacheControl(part.providerOptions, {
                  type: "tool result part",
                  canCache: true
                })) != null ? _d : isLastPart ? validator.getCacheControl(message.providerOptions, {
                  type: "tool result message",
                  canCache: true
                }) : void 0;
                const output = part.output;
                let contentValue;
                switch (output.type) {
                  case "content":
                    contentValue = output.value.map((contentPart) => {
                      switch (contentPart.type) {
                        case "text":
                          return {
                            type: "text",
                            text: contentPart.text
                          };
                        case "media": {
                          if (contentPart.mediaType.startsWith("image/")) {
                            return {
                              type: "image",
                              source: {
                                type: "base64",
                                media_type: contentPart.mediaType,
                                data: contentPart.data
                              }
                            };
                          }
                          if (contentPart.mediaType === "application/pdf") {
                            betas.add("pdfs-2024-09-25");
                            return {
                              type: "document",
                              source: {
                                type: "base64",
                                media_type: contentPart.mediaType,
                                data: contentPart.data
                              }
                            };
                          }
                          throw new UnsupportedFunctionalityError$1({
                            functionality: `media type: ${contentPart.mediaType}`
                          });
                        }
                      }
                    });
                    break;
                  case "text":
                  case "error-text":
                    contentValue = output.value;
                    break;
                  case "json":
                  case "error-json":
                  default:
                    contentValue = JSON.stringify(output.value);
                    break;
                }
                anthropicContent.push({
                  type: "tool_result",
                  tool_use_id: part.toolCallId,
                  content: contentValue,
                  is_error: output.type === "error-text" || output.type === "error-json" ? true : void 0,
                  cache_control: cacheControl
                });
              }
              break;
            }
            default: {
              const _exhaustiveCheck = role;
              throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
            }
          }
        }
        messages.push({ role: "user", content: anthropicContent });
        break;
      }
      case "assistant": {
        const anthropicContent = [];
        for (let j = 0; j < block.messages.length; j++) {
          const message = block.messages[j];
          const isLastMessage = j === block.messages.length - 1;
          const { content } = message;
          for (let k = 0; k < content.length; k++) {
            const part = content[k];
            const isLastContentPart = k === content.length - 1;
            const cacheControl = (_e = validator.getCacheControl(part.providerOptions, {
              type: "assistant message part",
              canCache: true
            })) != null ? _e : isLastContentPart ? validator.getCacheControl(message.providerOptions, {
              type: "assistant message",
              canCache: true
            }) : void 0;
            switch (part.type) {
              case "text": {
                anthropicContent.push({
                  type: "text",
                  text: (
                    // trim the last text part if it's the last message in the block
                    // because Anthropic does not allow trailing whitespace
                    // in pre-filled assistant responses
                    isLastBlock && isLastMessage && isLastContentPart ? part.text.trim() : part.text
                  ),
                  cache_control: cacheControl
                });
                break;
              }
              case "reasoning": {
                if (sendReasoning) {
                  const reasoningMetadata = await parseProviderOptions({
                    provider: "anthropic",
                    providerOptions: part.providerOptions,
                    schema: anthropicReasoningMetadataSchema
                  });
                  if (reasoningMetadata != null) {
                    if (reasoningMetadata.signature != null) {
                      validator.getCacheControl(part.providerOptions, {
                        type: "thinking block",
                        canCache: false
                      });
                      anthropicContent.push({
                        type: "thinking",
                        thinking: part.text,
                        signature: reasoningMetadata.signature
                      });
                    } else if (reasoningMetadata.redactedData != null) {
                      validator.getCacheControl(part.providerOptions, {
                        type: "redacted thinking block",
                        canCache: false
                      });
                      anthropicContent.push({
                        type: "redacted_thinking",
                        data: reasoningMetadata.redactedData
                      });
                    } else {
                      warnings.push({
                        type: "other",
                        message: "unsupported reasoning metadata"
                      });
                    }
                  } else {
                    warnings.push({
                      type: "other",
                      message: "unsupported reasoning metadata"
                    });
                  }
                } else {
                  warnings.push({
                    type: "other",
                    message: "sending reasoning content is disabled for this model"
                  });
                }
                break;
              }
              case "tool-call": {
                if (part.providerExecuted) {
                  if (part.toolName === "code_execution" && part.input != null && typeof part.input === "object" && "type" in part.input && typeof part.input.type === "string" && (part.input.type === "bash_code_execution" || part.input.type === "text_editor_code_execution")) {
                    anthropicContent.push({
                      type: "server_tool_use",
                      id: part.toolCallId,
                      name: part.input.type,
                      // map back to subtool name
                      input: part.input,
                      cache_control: cacheControl
                    });
                  } else if (part.toolName === "code_execution" || // code execution 20250522
                  part.toolName === "web_fetch" || part.toolName === "web_search") {
                    anthropicContent.push({
                      type: "server_tool_use",
                      id: part.toolCallId,
                      name: part.toolName,
                      input: part.input,
                      cache_control: cacheControl
                    });
                  } else {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool call for tool ${part.toolName} is not supported`
                    });
                  }
                  break;
                }
                anthropicContent.push({
                  type: "tool_use",
                  id: part.toolCallId,
                  name: part.toolName,
                  input: part.input,
                  cache_control: cacheControl
                });
                break;
              }
              case "tool-result": {
                if (part.toolName === "code_execution") {
                  const output = part.output;
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  if (output.value == null || typeof output.value !== "object" || !("type" in output.value) || typeof output.value.type !== "string") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output value is not a valid code execution result for tool ${part.toolName}`
                    });
                    break;
                  }
                  if (output.value.type === "code_execution_result") {
                    const codeExecutionOutput = await validateTypes$1({
                      value: output.value,
                      schema: codeExecution_20250522OutputSchema$1
                    });
                    anthropicContent.push({
                      type: "code_execution_tool_result",
                      tool_use_id: part.toolCallId,
                      content: {
                        type: codeExecutionOutput.type,
                        stdout: codeExecutionOutput.stdout,
                        stderr: codeExecutionOutput.stderr,
                        return_code: codeExecutionOutput.return_code
                      },
                      cache_control: cacheControl
                    });
                  } else {
                    const codeExecutionOutput = await validateTypes$1({
                      value: output.value,
                      schema: codeExecution_20250825OutputSchema$1
                    });
                    anthropicContent.push(
                      codeExecutionOutput.type === "bash_code_execution_result" || codeExecutionOutput.type === "bash_code_execution_tool_result_error" ? {
                        type: "bash_code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        cache_control: cacheControl,
                        content: codeExecutionOutput
                      } : {
                        type: "text_editor_code_execution_tool_result",
                        tool_use_id: part.toolCallId,
                        cache_control: cacheControl,
                        content: codeExecutionOutput
                      }
                    );
                  }
                  break;
                }
                if (part.toolName === "web_fetch") {
                  const output = part.output;
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  const webFetchOutput = await validateTypes$1({
                    value: output.value,
                    schema: webFetch_20250910OutputSchema$1
                  });
                  anthropicContent.push({
                    type: "web_fetch_tool_result",
                    tool_use_id: part.toolCallId,
                    content: {
                      type: "web_fetch_result",
                      url: webFetchOutput.url,
                      retrieved_at: webFetchOutput.retrievedAt,
                      content: {
                        type: "document",
                        title: webFetchOutput.content.title,
                        citations: webFetchOutput.content.citations,
                        source: {
                          type: webFetchOutput.content.source.type,
                          media_type: webFetchOutput.content.source.mediaType,
                          data: webFetchOutput.content.source.data
                        }
                      }
                    },
                    cache_control: cacheControl
                  });
                  break;
                }
                if (part.toolName === "web_search") {
                  const output = part.output;
                  if (output.type !== "json") {
                    warnings.push({
                      type: "other",
                      message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                    });
                    break;
                  }
                  const webSearchOutput = await validateTypes$1({
                    value: output.value,
                    schema: webSearch_20250305OutputSchema$1
                  });
                  anthropicContent.push({
                    type: "web_search_tool_result",
                    tool_use_id: part.toolCallId,
                    content: webSearchOutput.map((result) => ({
                      url: result.url,
                      title: result.title,
                      page_age: result.pageAge,
                      encrypted_content: result.encryptedContent,
                      type: result.type
                    })),
                    cache_control: cacheControl
                  });
                  break;
                }
                warnings.push({
                  type: "other",
                  message: `provider executed tool result for tool ${part.toolName} is not supported`
                });
                break;
              }
            }
          }
        }
        messages.push({ role: "assistant", content: anthropicContent });
        break;
      }
      default: {
        const _exhaustiveCheck = type;
        throw new Error(`content type: ${_exhaustiveCheck}`);
      }
    }
  }
  return {
    prompt: { system, messages },
    betas
  };
}
function groupIntoBlocks$1(prompt) {
  const blocks = [];
  let currentBlock = void 0;
  for (const message of prompt) {
    const { role } = message;
    switch (role) {
      case "system": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "system") {
          currentBlock = { type: "system", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "assistant": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "assistant") {
          currentBlock = { type: "assistant", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "user": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "tool": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return blocks;
}

// src/map-anthropic-stop-reason.ts
function mapAnthropicStopReason({
  finishReason,
  isJsonResponseFromTool
}) {
  switch (finishReason) {
    case "pause_turn":
    case "end_turn":
    case "stop_sequence":
      return "stop";
    case "refusal":
      return "content-filter";
    case "tool_use":
      return isJsonResponseFromTool ? "stop" : "tool-calls";
    case "max_tokens":
      return "length";
    default:
      return "unknown";
  }
}

// src/anthropic-messages-language-model.ts
function createCitationSource(citation, citationDocuments, generateId3) {
  var _a;
  if (citation.type !== "page_location" && citation.type !== "char_location") {
    return;
  }
  const documentInfo = citationDocuments[citation.document_index];
  if (!documentInfo) {
    return;
  }
  return {
    type: "source",
    sourceType: "document",
    id: generateId3(),
    mediaType: documentInfo.mediaType,
    title: (_a = citation.document_title) != null ? _a : documentInfo.title,
    filename: documentInfo.filename,
    providerMetadata: {
      anthropic: citation.type === "page_location" ? {
        citedText: citation.cited_text,
        startPageNumber: citation.start_page_number,
        endPageNumber: citation.end_page_number
      } : {
        citedText: citation.cited_text,
        startCharIndex: citation.start_char_index,
        endCharIndex: citation.end_char_index
      }
    }
  };
}
var AnthropicMessagesLanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    var _a;
    this.modelId = modelId;
    this.config = config;
    this.generateId = (_a = config.generateId) != null ? _a : generateId$1;
  }
  supportsUrl(url) {
    return url.protocol === "https:";
  }
  get provider() {
    return this.config.provider;
  }
  get supportedUrls() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    tools,
    toolChoice,
    providerOptions
  }) {
    var _a, _b, _c, _d;
    const warnings = [];
    if (frequencyPenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "frequencyPenalty"
      });
    }
    if (presencePenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "presencePenalty"
      });
    }
    if (seed != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "seed"
      });
    }
    if ((responseFormat == null ? void 0 : responseFormat.type) === "json") {
      if (responseFormat.schema == null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "responseFormat",
          details: "JSON response format requires a schema. The response format is ignored."
        });
      } else if (tools != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "tools",
          details: "JSON response format does not support tools. The provided tools are ignored."
        });
      }
    }
    const jsonResponseTool = (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null ? {
      type: "function",
      name: "json",
      description: "Respond with a JSON object.",
      inputSchema: responseFormat.schema
    } : void 0;
    const anthropicOptions = await parseProviderOptions({
      provider: "anthropic",
      providerOptions,
      schema: anthropicProviderOptions
    });
    const cacheControlValidator = new CacheControlValidator$1();
    const { prompt: messagesPrompt, betas } = await convertToAnthropicMessagesPrompt({
      prompt,
      sendReasoning: (_a = anthropicOptions == null ? void 0 : anthropicOptions.sendReasoning) != null ? _a : true,
      warnings,
      cacheControlValidator
    });
    const isThinking = ((_b = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _b.type) === "enabled";
    const thinkingBudget = (_c = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _c.budgetTokens;
    const maxOutputTokensForModel = getMaxOutputTokensForModel(this.modelId);
    const maxTokens = maxOutputTokens != null ? maxOutputTokens : maxOutputTokensForModel;
    const baseArgs = {
      // model id:
      model: this.modelId,
      // standardized settings:
      max_tokens: maxTokens,
      temperature,
      top_k: topK,
      top_p: topP,
      stop_sequences: stopSequences,
      // provider specific settings:
      ...isThinking && {
        thinking: { type: "enabled", budget_tokens: thinkingBudget }
      },
      // container with agent skills:
      ...(anthropicOptions == null ? void 0 : anthropicOptions.container) && {
        container: {
          id: anthropicOptions.container.id,
          skills: (_d = anthropicOptions.container.skills) == null ? void 0 : _d.map((skill) => ({
            type: skill.type,
            skill_id: skill.skillId,
            version: skill.version
          }))
        }
      },
      // prompt:
      system: messagesPrompt.system,
      messages: messagesPrompt.messages
    };
    if (isThinking) {
      if (thinkingBudget == null) {
        throw new UnsupportedFunctionalityError$1({
          functionality: "thinking requires a budget"
        });
      }
      if (baseArgs.temperature != null) {
        baseArgs.temperature = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "temperature",
          details: "temperature is not supported when thinking is enabled"
        });
      }
      if (topK != null) {
        baseArgs.top_k = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "topK",
          details: "topK is not supported when thinking is enabled"
        });
      }
      if (topP != null) {
        baseArgs.top_p = void 0;
        warnings.push({
          type: "unsupported-setting",
          setting: "topP",
          details: "topP is not supported when thinking is enabled"
        });
      }
      baseArgs.max_tokens = maxTokens + thinkingBudget;
    }
    if (baseArgs.max_tokens > maxOutputTokensForModel) {
      if (maxOutputTokens != null) {
        warnings.push({
          type: "unsupported-setting",
          setting: "maxOutputTokens",
          details: `${baseArgs.max_tokens} (maxOutputTokens + thinkingBudget) is greater than ${this.modelId} ${maxOutputTokensForModel} max output tokens. The max output tokens have been limited to ${maxOutputTokensForModel}.`
        });
      }
      baseArgs.max_tokens = maxOutputTokensForModel;
    }
    if ((anthropicOptions == null ? void 0 : anthropicOptions.container) && anthropicOptions.container.skills && anthropicOptions.container.skills.length > 0) {
      betas.add("code-execution-2025-08-25");
      betas.add("skills-2025-10-02");
      betas.add("files-api-2025-04-14");
      if (!(tools == null ? void 0 : tools.some(
        (tool) => tool.type === "provider-defined" && tool.id === "anthropic.code_execution_20250825"
      ))) {
        warnings.push({
          type: "other",
          message: "code execution tool is required when using skills"
        });
      }
    }
    const {
      tools: anthropicTools2,
      toolChoice: anthropicToolChoice,
      toolWarnings,
      betas: toolsBetas
    } = await prepareTools$4(
      jsonResponseTool != null ? {
        tools: [jsonResponseTool],
        toolChoice: { type: "tool", toolName: jsonResponseTool.name },
        disableParallelToolUse: true,
        cacheControlValidator
      } : {
        tools: tools != null ? tools : [],
        toolChoice,
        disableParallelToolUse: anthropicOptions == null ? void 0 : anthropicOptions.disableParallelToolUse,
        cacheControlValidator
      }
    );
    const cacheWarnings = cacheControlValidator.getWarnings();
    return {
      args: {
        ...baseArgs,
        tools: anthropicTools2,
        tool_choice: anthropicToolChoice
      },
      warnings: [...warnings, ...toolWarnings, ...cacheWarnings],
      betas: /* @__PURE__ */ new Set([...betas, ...toolsBetas]),
      usesJsonResponseTool: jsonResponseTool != null
    };
  }
  async getHeaders({
    betas,
    headers
  }) {
    return combineHeaders$1(
      await resolve(this.config.headers),
      betas.size > 0 ? { "anthropic-beta": Array.from(betas).join(",") } : {},
      headers
    );
  }
  buildRequestUrl(isStreaming) {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.config).buildRequestUrl) == null ? void 0 : _b.call(_a, this.config.baseURL, isStreaming)) != null ? _c : `${this.config.baseURL}/messages`;
  }
  transformRequestBody(args) {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.config).transformRequestBody) == null ? void 0 : _b.call(_a, args)) != null ? _c : args;
  }
  extractCitationDocuments(prompt) {
    const isCitationPart = (part) => {
      var _a, _b;
      if (part.type !== "file") {
        return false;
      }
      if (part.mediaType !== "application/pdf" && part.mediaType !== "text/plain") {
        return false;
      }
      const anthropic2 = (_a = part.providerOptions) == null ? void 0 : _a.anthropic;
      const citationsConfig = anthropic2 == null ? void 0 : anthropic2.citations;
      return (_b = citationsConfig == null ? void 0 : citationsConfig.enabled) != null ? _b : false;
    };
    return prompt.filter((message) => message.role === "user").flatMap((message) => message.content).filter(isCitationPart).map((part) => {
      var _a;
      const filePart = part;
      return {
        title: (_a = filePart.filename) != null ? _a : "Untitled Document",
        filename: filePart.filename,
        mediaType: filePart.mediaType
      };
    });
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f;
    const { args, warnings, betas, usesJsonResponseTool } = await this.getArgs(options);
    const citationDocuments = this.extractCitationDocuments(options.prompt);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi$1({
      url: this.buildRequestUrl(false),
      headers: await this.getHeaders({ betas, headers: options.headers }),
      body: this.transformRequestBody(args),
      failedResponseHandler: anthropicFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        anthropicMessagesResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const content = [];
    for (const part of response.content) {
      switch (part.type) {
        case "text": {
          if (!usesJsonResponseTool) {
            content.push({ type: "text", text: part.text });
            if (part.citations) {
              for (const citation of part.citations) {
                const source = createCitationSource(
                  citation,
                  citationDocuments,
                  this.generateId
                );
                if (source) {
                  content.push(source);
                }
              }
            }
          }
          break;
        }
        case "thinking": {
          content.push({
            type: "reasoning",
            text: part.thinking,
            providerMetadata: {
              anthropic: {
                signature: part.signature
              }
            }
          });
          break;
        }
        case "redacted_thinking": {
          content.push({
            type: "reasoning",
            text: "",
            providerMetadata: {
              anthropic: {
                redactedData: part.data
              }
            }
          });
          break;
        }
        case "tool_use": {
          content.push(
            // when a json response tool is used, the tool call becomes the text:
            usesJsonResponseTool ? {
              type: "text",
              text: JSON.stringify(part.input)
            } : {
              type: "tool-call",
              toolCallId: part.id,
              toolName: part.name,
              input: JSON.stringify(part.input)
            }
          );
          break;
        }
        case "server_tool_use": {
          if (part.name === "text_editor_code_execution" || part.name === "bash_code_execution") {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: "code_execution",
              input: JSON.stringify({ type: part.name, ...part.input }),
              providerExecuted: true
            });
          } else if (part.name === "web_search" || part.name === "code_execution" || part.name === "web_fetch") {
            content.push({
              type: "tool-call",
              toolCallId: part.id,
              toolName: part.name,
              input: JSON.stringify(part.input),
              providerExecuted: true
            });
          }
          break;
        }
        case "web_fetch_tool_result": {
          if (part.content.type === "web_fetch_result") {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: "web_fetch",
              result: {
                type: "web_fetch_result",
                url: part.content.url,
                retrievedAt: part.content.retrieved_at,
                content: {
                  type: part.content.content.type,
                  title: part.content.content.title,
                  citations: part.content.content.citations,
                  source: {
                    type: part.content.content.source.type,
                    mediaType: part.content.content.source.media_type,
                    data: part.content.content.source.data
                  }
                }
              },
              providerExecuted: true
            });
          } else if (part.content.type === "web_fetch_tool_result_error") {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: "web_fetch",
              isError: true,
              result: {
                type: "web_fetch_tool_result_error",
                errorCode: part.content.error_code
              },
              providerExecuted: true
            });
          }
          break;
        }
        case "web_search_tool_result": {
          if (Array.isArray(part.content)) {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: "web_search",
              result: part.content.map((result) => {
                var _a2;
                return {
                  url: result.url,
                  title: result.title,
                  pageAge: (_a2 = result.page_age) != null ? _a2 : null,
                  encryptedContent: result.encrypted_content,
                  type: result.type
                };
              }),
              providerExecuted: true
            });
            for (const result of part.content) {
              content.push({
                type: "source",
                sourceType: "url",
                id: this.generateId(),
                url: result.url,
                title: result.title,
                providerMetadata: {
                  anthropic: {
                    pageAge: (_a = result.page_age) != null ? _a : null
                  }
                }
              });
            }
          } else {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: "web_search",
              isError: true,
              result: {
                type: "web_search_tool_result_error",
                errorCode: part.content.error_code
              },
              providerExecuted: true
            });
          }
          break;
        }
        // code execution 20250522:
        case "code_execution_tool_result": {
          if (part.content.type === "code_execution_result") {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: "code_execution",
              result: {
                type: part.content.type,
                stdout: part.content.stdout,
                stderr: part.content.stderr,
                return_code: part.content.return_code
              },
              providerExecuted: true
            });
          } else if (part.content.type === "code_execution_tool_result_error") {
            content.push({
              type: "tool-result",
              toolCallId: part.tool_use_id,
              toolName: "code_execution",
              isError: true,
              result: {
                type: "code_execution_tool_result_error",
                errorCode: part.content.error_code
              },
              providerExecuted: true
            });
          }
          break;
        }
        // code execution 20250825:
        case "bash_code_execution_tool_result":
        case "text_editor_code_execution_tool_result": {
          content.push({
            type: "tool-result",
            toolCallId: part.tool_use_id,
            toolName: "code_execution",
            result: part.content,
            providerExecuted: true
          });
          break;
        }
      }
    }
    return {
      content,
      finishReason: mapAnthropicStopReason({
        finishReason: response.stop_reason,
        isJsonResponseFromTool: usesJsonResponseTool
      }),
      usage: {
        inputTokens: response.usage.input_tokens,
        outputTokens: response.usage.output_tokens,
        totalTokens: response.usage.input_tokens + response.usage.output_tokens,
        cachedInputTokens: (_b = response.usage.cache_read_input_tokens) != null ? _b : void 0
      },
      request: { body: args },
      response: {
        id: (_c = response.id) != null ? _c : void 0,
        modelId: (_d = response.model) != null ? _d : void 0,
        headers: responseHeaders,
        body: rawResponse
      },
      warnings,
      providerMetadata: {
        anthropic: {
          usage: response.usage,
          cacheCreationInputTokens: (_e = response.usage.cache_creation_input_tokens) != null ? _e : null,
          stopSequence: (_f = response.stop_sequence) != null ? _f : null
        }
      }
    };
  }
  async doStream(options) {
    const { args, warnings, betas, usesJsonResponseTool } = await this.getArgs(options);
    const citationDocuments = this.extractCitationDocuments(options.prompt);
    const body = { ...args, stream: true };
    const { responseHeaders, value: response } = await postJsonToApi$1({
      url: this.buildRequestUrl(true),
      headers: await this.getHeaders({ betas, headers: options.headers }),
      body: this.transformRequestBody(body),
      failedResponseHandler: anthropicFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler$1(
        anthropicMessagesChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0
    };
    const contentBlocks = {};
    let rawUsage = void 0;
    let cacheCreationInputTokens = null;
    let stopSequence = null;
    let blockType = void 0;
    const generateId3 = this.generateId;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            switch (value.type) {
              case "ping": {
                return;
              }
              case "content_block_start": {
                const contentBlockType = value.content_block.type;
                blockType = contentBlockType;
                switch (contentBlockType) {
                  case "text": {
                    contentBlocks[value.index] = { type: "text" };
                    controller.enqueue({
                      type: "text-start",
                      id: String(value.index)
                    });
                    return;
                  }
                  case "thinking": {
                    contentBlocks[value.index] = { type: "reasoning" };
                    controller.enqueue({
                      type: "reasoning-start",
                      id: String(value.index)
                    });
                    return;
                  }
                  case "redacted_thinking": {
                    contentBlocks[value.index] = { type: "reasoning" };
                    controller.enqueue({
                      type: "reasoning-start",
                      id: String(value.index),
                      providerMetadata: {
                        anthropic: {
                          redactedData: value.content_block.data
                        }
                      }
                    });
                    return;
                  }
                  case "tool_use": {
                    contentBlocks[value.index] = usesJsonResponseTool ? { type: "text" } : {
                      type: "tool-call",
                      toolCallId: value.content_block.id,
                      toolName: value.content_block.name,
                      input: "",
                      firstDelta: true
                    };
                    controller.enqueue(
                      usesJsonResponseTool ? { type: "text-start", id: String(value.index) } : {
                        type: "tool-input-start",
                        id: value.content_block.id,
                        toolName: value.content_block.name
                      }
                    );
                    return;
                  }
                  case "server_tool_use": {
                    if ([
                      "web_fetch",
                      "web_search",
                      // code execution 20250825:
                      "code_execution",
                      // code execution 20250825 text editor:
                      "text_editor_code_execution",
                      // code execution 20250825 bash:
                      "bash_code_execution"
                    ].includes(value.content_block.name)) {
                      contentBlocks[value.index] = {
                        type: "tool-call",
                        toolCallId: value.content_block.id,
                        toolName: value.content_block.name,
                        input: "",
                        providerExecuted: true,
                        firstDelta: true
                      };
                      const mappedToolName = value.content_block.name === "text_editor_code_execution" || value.content_block.name === "bash_code_execution" ? "code_execution" : value.content_block.name;
                      controller.enqueue({
                        type: "tool-input-start",
                        id: value.content_block.id,
                        toolName: mappedToolName,
                        providerExecuted: true
                      });
                    }
                    return;
                  }
                  case "web_fetch_tool_result": {
                    const part = value.content_block;
                    if (part.content.type === "web_fetch_result") {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "web_fetch",
                        result: {
                          type: "web_fetch_result",
                          url: part.content.url,
                          retrievedAt: part.content.retrieved_at,
                          content: {
                            type: part.content.content.type,
                            title: part.content.content.title,
                            citations: part.content.content.citations,
                            source: {
                              type: part.content.content.source.type,
                              mediaType: part.content.content.source.media_type,
                              data: part.content.content.source.data
                            }
                          }
                        }
                      });
                    } else if (part.content.type === "web_fetch_tool_result_error") {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "web_fetch",
                        isError: true,
                        result: {
                          type: "web_fetch_tool_result_error",
                          errorCode: part.content.error_code
                        },
                        providerExecuted: true
                      });
                    }
                    return;
                  }
                  case "web_search_tool_result": {
                    const part = value.content_block;
                    if (Array.isArray(part.content)) {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "web_search",
                        result: part.content.map((result) => {
                          var _a2;
                          return {
                            url: result.url,
                            title: result.title,
                            pageAge: (_a2 = result.page_age) != null ? _a2 : null,
                            encryptedContent: result.encrypted_content,
                            type: result.type
                          };
                        }),
                        providerExecuted: true
                      });
                      for (const result of part.content) {
                        controller.enqueue({
                          type: "source",
                          sourceType: "url",
                          id: generateId3(),
                          url: result.url,
                          title: result.title,
                          providerMetadata: {
                            anthropic: {
                              pageAge: (_a = result.page_age) != null ? _a : null
                            }
                          }
                        });
                      }
                    } else {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "web_search",
                        isError: true,
                        result: {
                          type: "web_search_tool_result_error",
                          errorCode: part.content.error_code
                        },
                        providerExecuted: true
                      });
                    }
                    return;
                  }
                  // code execution 20250522:
                  case "code_execution_tool_result": {
                    const part = value.content_block;
                    if (part.content.type === "code_execution_result") {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "code_execution",
                        result: {
                          type: part.content.type,
                          stdout: part.content.stdout,
                          stderr: part.content.stderr,
                          return_code: part.content.return_code
                        },
                        providerExecuted: true
                      });
                    } else if (part.content.type === "code_execution_tool_result_error") {
                      controller.enqueue({
                        type: "tool-result",
                        toolCallId: part.tool_use_id,
                        toolName: "code_execution",
                        isError: true,
                        result: {
                          type: "code_execution_tool_result_error",
                          errorCode: part.content.error_code
                        },
                        providerExecuted: true
                      });
                    }
                    return;
                  }
                  // code execution 20250825:
                  case "bash_code_execution_tool_result":
                  case "text_editor_code_execution_tool_result": {
                    const part = value.content_block;
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId: part.tool_use_id,
                      toolName: "code_execution",
                      result: part.content,
                      providerExecuted: true
                    });
                    return;
                  }
                  default: {
                    const _exhaustiveCheck = contentBlockType;
                    throw new Error(
                      `Unsupported content block type: ${_exhaustiveCheck}`
                    );
                  }
                }
              }
              case "content_block_stop": {
                if (contentBlocks[value.index] != null) {
                  const contentBlock = contentBlocks[value.index];
                  switch (contentBlock.type) {
                    case "text": {
                      controller.enqueue({
                        type: "text-end",
                        id: String(value.index)
                      });
                      break;
                    }
                    case "reasoning": {
                      controller.enqueue({
                        type: "reasoning-end",
                        id: String(value.index)
                      });
                      break;
                    }
                    case "tool-call":
                      if (!usesJsonResponseTool) {
                        controller.enqueue({
                          type: "tool-input-end",
                          id: contentBlock.toolCallId
                        });
                        const toolName = contentBlock.toolName === "text_editor_code_execution" || contentBlock.toolName === "bash_code_execution" ? "code_execution" : contentBlock.toolName;
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: contentBlock.toolCallId,
                          toolName,
                          input: contentBlock.input,
                          providerExecuted: contentBlock.providerExecuted
                        });
                      }
                      break;
                  }
                  delete contentBlocks[value.index];
                }
                blockType = void 0;
                return;
              }
              case "content_block_delta": {
                const deltaType = value.delta.type;
                switch (deltaType) {
                  case "text_delta": {
                    if (usesJsonResponseTool) {
                      return;
                    }
                    controller.enqueue({
                      type: "text-delta",
                      id: String(value.index),
                      delta: value.delta.text
                    });
                    return;
                  }
                  case "thinking_delta": {
                    controller.enqueue({
                      type: "reasoning-delta",
                      id: String(value.index),
                      delta: value.delta.thinking
                    });
                    return;
                  }
                  case "signature_delta": {
                    if (blockType === "thinking") {
                      controller.enqueue({
                        type: "reasoning-delta",
                        id: String(value.index),
                        delta: "",
                        providerMetadata: {
                          anthropic: {
                            signature: value.delta.signature
                          }
                        }
                      });
                    }
                    return;
                  }
                  case "input_json_delta": {
                    const contentBlock = contentBlocks[value.index];
                    let delta = value.delta.partial_json;
                    if (delta.length === 0) {
                      return;
                    }
                    if (usesJsonResponseTool) {
                      if ((contentBlock == null ? void 0 : contentBlock.type) !== "text") {
                        return;
                      }
                      controller.enqueue({
                        type: "text-delta",
                        id: String(value.index),
                        delta
                      });
                    } else {
                      if ((contentBlock == null ? void 0 : contentBlock.type) !== "tool-call") {
                        return;
                      }
                      if (contentBlock.firstDelta && (contentBlock.toolName === "bash_code_execution" || contentBlock.toolName === "text_editor_code_execution")) {
                        delta = `{"type": "${contentBlock.toolName}",${delta.substring(1)}`;
                      }
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: contentBlock.toolCallId,
                        delta
                      });
                      contentBlock.input += delta;
                      contentBlock.firstDelta = false;
                    }
                    return;
                  }
                  case "citations_delta": {
                    const citation = value.delta.citation;
                    const source = createCitationSource(
                      citation,
                      citationDocuments,
                      generateId3
                    );
                    if (source) {
                      controller.enqueue(source);
                    }
                    return;
                  }
                  default: {
                    const _exhaustiveCheck = deltaType;
                    throw new Error(
                      `Unsupported delta type: ${_exhaustiveCheck}`
                    );
                  }
                }
              }
              case "message_start": {
                usage.inputTokens = value.message.usage.input_tokens;
                usage.cachedInputTokens = (_b = value.message.usage.cache_read_input_tokens) != null ? _b : void 0;
                rawUsage = {
                  ...value.message.usage
                };
                cacheCreationInputTokens = (_c = value.message.usage.cache_creation_input_tokens) != null ? _c : null;
                controller.enqueue({
                  type: "response-metadata",
                  id: (_d = value.message.id) != null ? _d : void 0,
                  modelId: (_e = value.message.model) != null ? _e : void 0
                });
                return;
              }
              case "message_delta": {
                usage.outputTokens = value.usage.output_tokens;
                usage.totalTokens = ((_f = usage.inputTokens) != null ? _f : 0) + ((_g = value.usage.output_tokens) != null ? _g : 0);
                finishReason = mapAnthropicStopReason({
                  finishReason: value.delta.stop_reason,
                  isJsonResponseFromTool: usesJsonResponseTool
                });
                stopSequence = (_h = value.delta.stop_sequence) != null ? _h : null;
                rawUsage = {
                  ...rawUsage,
                  ...value.usage
                };
                return;
              }
              case "message_stop": {
                controller.enqueue({
                  type: "finish",
                  finishReason,
                  usage,
                  providerMetadata: {
                    anthropic: {
                      usage: rawUsage != null ? rawUsage : null,
                      cacheCreationInputTokens,
                      stopSequence
                    }
                  }
                });
                return;
              }
              case "error": {
                controller.enqueue({ type: "error", error: value.error });
                return;
              }
              default: {
                const _exhaustiveCheck = value;
                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
              }
            }
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
function getMaxOutputTokensForModel(modelId) {
  if (modelId.includes("claude-sonnet-4-") || modelId.includes("claude-3-7-sonnet") || modelId.includes("claude-haiku-4-5")) {
    return 64e3;
  } else if (modelId.includes("claude-opus-4-")) {
    return 32e3;
  } else if (modelId.includes("claude-3-5-haiku")) {
    return 8192;
  } else {
    return 4096;
  }
}
var bash_20241022InputSchema$1 = lazySchema(
  () => zodSchema(
    object({
      command: string(),
      restart: boolean().optional()
    })
  )
);
var bash_20241022$1 = createProviderDefinedToolFactory({
  id: "anthropic.bash_20241022",
  name: "bash",
  inputSchema: bash_20241022InputSchema$1
});
var bash_20250124InputSchema$1 = lazySchema(
  () => zodSchema(
    object({
      command: string(),
      restart: boolean().optional()
    })
  )
);
var bash_20250124$1 = createProviderDefinedToolFactory({
  id: "anthropic.bash_20250124",
  name: "bash",
  inputSchema: bash_20250124InputSchema$1
});
var computer_20241022InputSchema$1 = lazySchema(
  () => zodSchema(
    object({
      action: _enum([
        "key",
        "type",
        "mouse_move",
        "left_click",
        "left_click_drag",
        "right_click",
        "middle_click",
        "double_click",
        "screenshot",
        "cursor_position"
      ]),
      coordinate: array(number$1().int()).optional(),
      text: string().optional()
    })
  )
);
var computer_20241022$1 = createProviderDefinedToolFactory({
  id: "anthropic.computer_20241022",
  name: "computer",
  inputSchema: computer_20241022InputSchema$1
});
var computer_20250124InputSchema$1 = lazySchema(
  () => zodSchema(
    object({
      action: _enum([
        "key",
        "hold_key",
        "type",
        "cursor_position",
        "mouse_move",
        "left_mouse_down",
        "left_mouse_up",
        "left_click",
        "left_click_drag",
        "right_click",
        "middle_click",
        "double_click",
        "triple_click",
        "scroll",
        "wait",
        "screenshot"
      ]),
      coordinate: tuple([number$1().int(), number$1().int()]).optional(),
      duration: number$1().optional(),
      scroll_amount: number$1().optional(),
      scroll_direction: _enum(["up", "down", "left", "right"]).optional(),
      start_coordinate: tuple([number$1().int(), number$1().int()]).optional(),
      text: string().optional()
    })
  )
);
var computer_20250124$1 = createProviderDefinedToolFactory({
  id: "anthropic.computer_20250124",
  name: "computer",
  inputSchema: computer_20250124InputSchema$1
});
var memory_20250818InputSchema$1 = lazySchema(
  () => zodSchema(
    discriminatedUnion("command", [
      object({
        command: literal("view"),
        path: string(),
        view_range: tuple([number$1(), number$1()]).optional()
      }),
      object({
        command: literal("create"),
        path: string(),
        file_text: string()
      }),
      object({
        command: literal("str_replace"),
        path: string(),
        old_str: string(),
        new_str: string()
      }),
      object({
        command: literal("insert"),
        path: string(),
        insert_line: number$1(),
        insert_text: string()
      }),
      object({
        command: literal("delete"),
        path: string()
      }),
      object({
        command: literal("rename"),
        old_path: string(),
        new_path: string()
      })
    ])
  )
);
var memory_20250818$1 = createProviderDefinedToolFactory({
  id: "anthropic.memory_20250818",
  name: "memory",
  inputSchema: memory_20250818InputSchema$1
});
var textEditor_20241022InputSchema$1 = lazySchema(
  () => zodSchema(
    object({
      command: _enum(["view", "create", "str_replace", "insert", "undo_edit"]),
      path: string(),
      file_text: string().optional(),
      insert_line: number$1().int().optional(),
      new_str: string().optional(),
      old_str: string().optional(),
      view_range: array(number$1().int()).optional()
    })
  )
);
var textEditor_20241022$1 = createProviderDefinedToolFactory({
  id: "anthropic.text_editor_20241022",
  name: "str_replace_editor",
  inputSchema: textEditor_20241022InputSchema$1
});
var textEditor_20250124InputSchema$1 = lazySchema(
  () => zodSchema(
    object({
      command: _enum(["view", "create", "str_replace", "insert", "undo_edit"]),
      path: string(),
      file_text: string().optional(),
      insert_line: number$1().int().optional(),
      new_str: string().optional(),
      old_str: string().optional(),
      view_range: array(number$1().int()).optional()
    })
  )
);
var textEditor_20250124$1 = createProviderDefinedToolFactory({
  id: "anthropic.text_editor_20250124",
  name: "str_replace_editor",
  inputSchema: textEditor_20250124InputSchema$1
});
var textEditor_20250429InputSchema$1 = lazySchema(
  () => zodSchema(
    object({
      command: _enum(["view", "create", "str_replace", "insert"]),
      path: string(),
      file_text: string().optional(),
      insert_line: number$1().int().optional(),
      new_str: string().optional(),
      old_str: string().optional(),
      view_range: array(number$1().int()).optional()
    })
  )
);
var textEditor_20250429$1 = createProviderDefinedToolFactory({
  id: "anthropic.text_editor_20250429",
  name: "str_replace_based_edit_tool",
  inputSchema: textEditor_20250429InputSchema$1
});

// src/anthropic-tools.ts
var anthropicTools$1 = {
  /**
   * The bash tool enables Claude to execute shell commands in a persistent bash session,
   * allowing system operations, script execution, and command-line automation.
   *
   * Image results are supported.
   *
   * Tool name must be `bash`.
   */
  bash_20241022: bash_20241022$1,
  /**
   * The bash tool enables Claude to execute shell commands in a persistent bash session,
   * allowing system operations, script execution, and command-line automation.
   *
   * Image results are supported.
   *
   * Tool name must be `bash`.
   */
  bash_20250124: bash_20250124$1,
  /**
   * Claude can analyze data, create visualizations, perform complex calculations,
   * run system commands, create and edit files, and process uploaded files directly within
   * the API conversation.
   *
   * The code execution tool allows Claude to run Bash commands and manipulate files,
   * including writing code, in a secure, sandboxed environment.
   *
   * Tool name must be `code_execution`.
   */
  codeExecution_20250522: codeExecution_20250522$1,
  /**
   * Claude can analyze data, create visualizations, perform complex calculations,
   * run system commands, create and edit files, and process uploaded files directly within
   * the API conversation.
   *
   * The code execution tool allows Claude to run both Python and Bash commands and manipulate files,
   * including writing code, in a secure, sandboxed environment.
   *
   * This is the latest version with enhanced Bash support and file operations.
   *
   * Tool name must be `code_execution`.
   */
  codeExecution_20250825: codeExecution_20250825$1,
  /**
   * Claude can interact with computer environments through the computer use tool, which
   * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
   *
   * Image results are supported.
   *
   * Tool name must be `computer`.
   *
   * @param displayWidthPx - The width of the display being controlled by the model in pixels.
   * @param displayHeightPx - The height of the display being controlled by the model in pixels.
   * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
   */
  computer_20241022: computer_20241022$1,
  /**
   * Claude can interact with computer environments through the computer use tool, which
   * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
   *
   * Image results are supported.
   *
   * Tool name must be `computer`.
   *
   * @param displayWidthPx - The width of the display being controlled by the model in pixels.
   * @param displayHeightPx - The height of the display being controlled by the model in pixels.
   * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
   */
  computer_20250124: computer_20250124$1,
  /**
   * The memory tool enables Claude to store and retrieve information across conversations through a memory file directory.
   * Claude can create, read, update, and delete files that persist between sessions,
   * allowing it to build knowledge over time without keeping everything in the context window.
   * The memory tool operates client-sideyou control where and how the data is stored through your own infrastructure.
   *
   * Supported models: Claude Sonnet 4.5, Claude Sonnet 4, Claude Opus 4.1, Claude Opus 4.
   *
   * Tool name must be `memory`.
   */
  memory_20250818: memory_20250818$1,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Supported models: Claude Sonnet 3.5
   *
   * Tool name must be `str_replace_editor`.
   */
  textEditor_20241022: textEditor_20241022$1,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Supported models: Claude Sonnet 3.7
   *
   * Tool name must be `str_replace_editor`.
   */
  textEditor_20250124: textEditor_20250124$1,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Note: This version does not support the "undo_edit" command.
   *
   * Tool name must be `str_replace_based_edit_tool`.
   *
   * @deprecated Use textEditor_20250728 instead
   */
  textEditor_20250429: textEditor_20250429$1,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Note: This version does not support the "undo_edit" command and adds optional max_characters parameter.
   *
   * Supported models: Claude Sonnet 4, Opus 4, and Opus 4.1
   *
   * Tool name must be `str_replace_based_edit_tool`.
   *
   * @param maxCharacters - Optional maximum number of characters to view in the file
   */
  textEditor_20250728: textEditor_20250728$1,
  /**
   * Creates a web fetch tool that gives Claude direct access to real-time web content.
   *
   * Tool name must be `web_fetch`.
   *
   * @param maxUses - The max_uses parameter limits the number of web fetches performed
   * @param allowedDomains - Only fetch from these domains
   * @param blockedDomains - Never fetch from these domains
   * @param citations - Unlike web search where citations are always enabled, citations are optional for web fetch. Set "citations": {"enabled": true} to enable Claude to cite specific passages from fetched documents.
   * @param maxContentTokens - The max_content_tokens parameter limits the amount of content that will be included in the context.
   */
  webFetch_20250910: webFetch_20250910$1,
  /**
   * Creates a web search tool that gives Claude direct access to real-time web content.
   *
   * Tool name must be `web_search`.
   *
   * @param maxUses - Maximum number of web searches Claude can perform during the conversation.
   * @param allowedDomains - Optional list of domains that Claude is allowed to search.
   * @param blockedDomains - Optional list of domains that Claude should avoid when searching.
   * @param userLocation - Optional user location information to provide geographically relevant search results.
   */
  webSearch_20250305: webSearch_20250305$1
};

// src/anthropic-provider.ts
function createAnthropic(options = {}) {
  var _a;
  const baseURL = (_a = withoutTrailingSlash$1(options.baseURL)) != null ? _a : "https://api.anthropic.com/v1";
  const getHeaders = () => withUserAgentSuffix(
    {
      "anthropic-version": "2023-06-01",
      "x-api-key": loadApiKey$1({
        apiKey: options.apiKey,
        environmentVariableName: "ANTHROPIC_API_KEY",
        description: "Anthropic"
      }),
      ...options.headers
    },
    `ai-sdk/anthropic/${VERSION$3}`
  );
  const createChatModel = (modelId) => {
    var _a2;
    return new AnthropicMessagesLanguageModel(modelId, {
      provider: "anthropic.messages",
      baseURL,
      headers: getHeaders,
      fetch: options.fetch,
      generateId: (_a2 = options.generateId) != null ? _a2 : generateId$1,
      supportedUrls: () => ({
        "image/*": [/^https?:\/\/.*$/]
      })
    });
  };
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Anthropic model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.messages = createChatModel;
  provider.textEmbeddingModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
  };
  provider.imageModel = (modelId) => {
    throw new NoSuchModelError({ modelId, modelType: "imageModel" });
  };
  provider.tools = anthropicTools$1;
  return provider;
}
createAnthropic();

// src/google-provider.ts

// src/version.ts
var VERSION$2 = "2.0.23" ;
var googleErrorDataSchema = lazySchema(
  () => zodSchema(
    object({
      error: object({
        code: number$1().nullable(),
        message: string(),
        status: string()
      })
    })
  )
);
var googleFailedResponseHandler = createJsonErrorResponseHandler$1({
  errorSchema: googleErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
var googleGenerativeAIEmbeddingProviderOptions = lazySchema(
  () => zodSchema(
    object({
      /**
       * Optional. Optional reduced dimension for the output embedding.
       * If set, excessive values in the output embedding are truncated from the end.
       */
      outputDimensionality: number$1().optional(),
      /**
       * Optional. Specifies the task type for generating embeddings.
       * Supported task types:
       * - SEMANTIC_SIMILARITY: Optimized for text similarity.
       * - CLASSIFICATION: Optimized for text classification.
       * - CLUSTERING: Optimized for clustering texts based on similarity.
       * - RETRIEVAL_DOCUMENT: Optimized for document retrieval.
       * - RETRIEVAL_QUERY: Optimized for query-based retrieval.
       * - QUESTION_ANSWERING: Optimized for answering questions.
       * - FACT_VERIFICATION: Optimized for verifying factual information.
       * - CODE_RETRIEVAL_QUERY: Optimized for retrieving code blocks based on natural language queries.
       */
      taskType: _enum([
        "SEMANTIC_SIMILARITY",
        "CLASSIFICATION",
        "CLUSTERING",
        "RETRIEVAL_DOCUMENT",
        "RETRIEVAL_QUERY",
        "QUESTION_ANSWERING",
        "FACT_VERIFICATION",
        "CODE_RETRIEVAL_QUERY"
      ]).optional()
    })
  )
);

// src/google-generative-ai-embedding-model.ts
var GoogleGenerativeAIEmbeddingModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.maxEmbeddingsPerCall = 2048;
    this.supportsParallelCalls = true;
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    const googleOptions = await parseProviderOptions({
      provider: "google",
      providerOptions,
      schema: googleGenerativeAIEmbeddingProviderOptions
    });
    if (values.length > this.maxEmbeddingsPerCall) {
      throw new TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values
      });
    }
    const mergedHeaders = combineHeaders$1(
      await resolve(this.config.headers),
      headers
    );
    if (values.length === 1) {
      const {
        responseHeaders: responseHeaders2,
        value: response2,
        rawValue: rawValue2
      } = await postJsonToApi$1({
        url: `${this.config.baseURL}/models/${this.modelId}:embedContent`,
        headers: mergedHeaders,
        body: {
          model: `models/${this.modelId}`,
          content: {
            parts: [{ text: values[0] }]
          },
          outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
          taskType: googleOptions == null ? void 0 : googleOptions.taskType
        },
        failedResponseHandler: googleFailedResponseHandler,
        successfulResponseHandler: createJsonResponseHandler$1(
          googleGenerativeAISingleEmbeddingResponseSchema
        ),
        abortSignal,
        fetch: this.config.fetch
      });
      return {
        embeddings: [response2.embedding.values],
        usage: void 0,
        response: { headers: responseHeaders2, body: rawValue2 }
      };
    }
    const {
      responseHeaders,
      value: response,
      rawValue
    } = await postJsonToApi$1({
      url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`,
      headers: mergedHeaders,
      body: {
        requests: values.map((value) => ({
          model: `models/${this.modelId}`,
          content: { role: "user", parts: [{ text: value }] },
          outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
          taskType: googleOptions == null ? void 0 : googleOptions.taskType
        }))
      },
      failedResponseHandler: googleFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        googleGenerativeAITextEmbeddingResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      embeddings: response.embeddings.map((item) => item.values),
      usage: void 0,
      response: { headers: responseHeaders, body: rawValue }
    };
  }
};
var googleGenerativeAITextEmbeddingResponseSchema = lazySchema(
  () => zodSchema(
    object({
      embeddings: array(object({ values: array(number$1()) }))
    })
  )
);
var googleGenerativeAISingleEmbeddingResponseSchema = lazySchema(
  () => zodSchema(
    object({
      embedding: object({ values: array(number$1()) })
    })
  )
);

// src/convert-json-schema-to-openapi-schema.ts
function convertJSONSchemaToOpenAPISchema(jsonSchema) {
  if (jsonSchema == null || isEmptyObjectSchema(jsonSchema)) {
    return void 0;
  }
  if (typeof jsonSchema === "boolean") {
    return { type: "boolean", properties: {} };
  }
  const {
    type,
    description,
    required,
    properties,
    items,
    allOf,
    anyOf,
    oneOf,
    format,
    const: constValue,
    minLength,
    enum: enumValues
  } = jsonSchema;
  const result = {};
  if (description) result.description = description;
  if (required) result.required = required;
  if (format) result.format = format;
  if (constValue !== void 0) {
    result.enum = [constValue];
  }
  if (type) {
    if (Array.isArray(type)) {
      if (type.includes("null")) {
        result.type = type.filter((t) => t !== "null")[0];
        result.nullable = true;
      } else {
        result.type = type;
      }
    } else if (type === "null") {
      result.type = "null";
    } else {
      result.type = type;
    }
  }
  if (enumValues !== void 0) {
    result.enum = enumValues;
  }
  if (properties != null) {
    result.properties = Object.entries(properties).reduce(
      (acc, [key, value]) => {
        acc[key] = convertJSONSchemaToOpenAPISchema(value);
        return acc;
      },
      {}
    );
  }
  if (items) {
    result.items = Array.isArray(items) ? items.map(convertJSONSchemaToOpenAPISchema) : convertJSONSchemaToOpenAPISchema(items);
  }
  if (allOf) {
    result.allOf = allOf.map(convertJSONSchemaToOpenAPISchema);
  }
  if (anyOf) {
    if (anyOf.some(
      (schema) => typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null"
    )) {
      const nonNullSchemas = anyOf.filter(
        (schema) => !(typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null")
      );
      if (nonNullSchemas.length === 1) {
        const converted = convertJSONSchemaToOpenAPISchema(nonNullSchemas[0]);
        if (typeof converted === "object") {
          result.nullable = true;
          Object.assign(result, converted);
        }
      } else {
        result.anyOf = nonNullSchemas.map(convertJSONSchemaToOpenAPISchema);
        result.nullable = true;
      }
    } else {
      result.anyOf = anyOf.map(convertJSONSchemaToOpenAPISchema);
    }
  }
  if (oneOf) {
    result.oneOf = oneOf.map(convertJSONSchemaToOpenAPISchema);
  }
  if (minLength !== void 0) {
    result.minLength = minLength;
  }
  return result;
}
function isEmptyObjectSchema(jsonSchema) {
  return jsonSchema != null && typeof jsonSchema === "object" && jsonSchema.type === "object" && (jsonSchema.properties == null || Object.keys(jsonSchema.properties).length === 0) && !jsonSchema.additionalProperties;
}
function convertToGoogleGenerativeAIMessages(prompt, options) {
  var _a;
  const systemInstructionParts = [];
  const contents = [];
  let systemMessagesAllowed = true;
  const isGemmaModel = (_a = options == null ? void 0 : options.isGemmaModel) != null ? _a : false;
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        if (!systemMessagesAllowed) {
          throw new UnsupportedFunctionalityError$1({
            functionality: "system messages are only supported at the beginning of the conversation"
          });
        }
        systemInstructionParts.push({ text: content });
        break;
      }
      case "user": {
        systemMessagesAllowed = false;
        const parts = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              parts.push({ text: part.text });
              break;
            }
            case "file": {
              const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
              parts.push(
                part.data instanceof URL ? {
                  fileData: {
                    mimeType: mediaType,
                    fileUri: part.data.toString()
                  }
                } : {
                  inlineData: {
                    mimeType: mediaType,
                    data: convertToBase64(part.data)
                  }
                }
              );
              break;
            }
          }
        }
        contents.push({ role: "user", parts });
        break;
      }
      case "assistant": {
        systemMessagesAllowed = false;
        contents.push({
          role: "model",
          parts: content.map((part) => {
            var _a2, _b, _c, _d, _e, _f;
            switch (part.type) {
              case "text": {
                return part.text.length === 0 ? void 0 : {
                  text: part.text,
                  thoughtSignature: (_b = (_a2 = part.providerOptions) == null ? void 0 : _a2.google) == null ? void 0 : _b.thoughtSignature
                };
              }
              case "reasoning": {
                return part.text.length === 0 ? void 0 : {
                  text: part.text,
                  thought: true,
                  thoughtSignature: (_d = (_c = part.providerOptions) == null ? void 0 : _c.google) == null ? void 0 : _d.thoughtSignature
                };
              }
              case "file": {
                if (part.mediaType !== "image/png") {
                  throw new UnsupportedFunctionalityError$1({
                    functionality: "Only PNG images are supported in assistant messages"
                  });
                }
                if (part.data instanceof URL) {
                  throw new UnsupportedFunctionalityError$1({
                    functionality: "File data URLs in assistant messages are not supported"
                  });
                }
                return {
                  inlineData: {
                    mimeType: part.mediaType,
                    data: convertToBase64(part.data)
                  }
                };
              }
              case "tool-call": {
                return {
                  functionCall: {
                    name: part.toolName,
                    args: part.input
                  },
                  thoughtSignature: (_f = (_e = part.providerOptions) == null ? void 0 : _e.google) == null ? void 0 : _f.thoughtSignature
                };
              }
            }
          }).filter((part) => part !== void 0)
        });
        break;
      }
      case "tool": {
        systemMessagesAllowed = false;
        const parts = [];
        for (const part of content) {
          const output = part.output;
          if (output.type === "content") {
            for (const contentPart of output.value) {
              switch (contentPart.type) {
                case "text":
                  parts.push({
                    functionResponse: {
                      name: part.toolName,
                      response: {
                        name: part.toolName,
                        content: contentPart.text
                      }
                    }
                  });
                  break;
                case "media":
                  parts.push(
                    {
                      inlineData: {
                        mimeType: contentPart.mediaType,
                        data: contentPart.data
                      }
                    },
                    {
                      text: "Tool executed successfully and returned this image as a response"
                    }
                  );
                  break;
                default:
                  parts.push({ text: JSON.stringify(contentPart) });
                  break;
              }
            }
          } else {
            parts.push({
              functionResponse: {
                name: part.toolName,
                response: {
                  name: part.toolName,
                  content: output.value
                }
              }
            });
          }
        }
        contents.push({
          role: "user",
          parts
        });
        break;
      }
    }
  }
  if (isGemmaModel && systemInstructionParts.length > 0 && contents.length > 0 && contents[0].role === "user") {
    const systemText = systemInstructionParts.map((part) => part.text).join("\n\n");
    contents[0].parts.unshift({ text: systemText + "\n\n" });
  }
  return {
    systemInstruction: systemInstructionParts.length > 0 && !isGemmaModel ? { parts: systemInstructionParts } : void 0,
    contents
  };
}

// src/get-model-path.ts
function getModelPath(modelId) {
  return modelId.includes("/") ? modelId : `models/${modelId}`;
}
var googleGenerativeAIProviderOptions = lazySchema(
  () => zodSchema(
    object({
      responseModalities: array(_enum(["TEXT", "IMAGE"])).optional(),
      thinkingConfig: object({
        thinkingBudget: number$1().optional(),
        includeThoughts: boolean().optional()
      }).optional(),
      /**
       * Optional.
       * The name of the cached content used as context to serve the prediction.
       * Format: cachedContents/{cachedContent}
       */
      cachedContent: string().optional(),
      /**
       * Optional. Enable structured output. Default is true.
       *
       * This is useful when the JSON Schema contains elements that are
       * not supported by the OpenAPI schema version that
       * Google Generative AI uses. You can use this to disable
       * structured outputs if you need to.
       */
      structuredOutputs: boolean().optional(),
      /**
       * Optional. A list of unique safety settings for blocking unsafe content.
       */
      safetySettings: array(
        object({
          category: _enum([
            "HARM_CATEGORY_UNSPECIFIED",
            "HARM_CATEGORY_HATE_SPEECH",
            "HARM_CATEGORY_DANGEROUS_CONTENT",
            "HARM_CATEGORY_HARASSMENT",
            "HARM_CATEGORY_SEXUALLY_EXPLICIT",
            "HARM_CATEGORY_CIVIC_INTEGRITY"
          ]),
          threshold: _enum([
            "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
            "BLOCK_LOW_AND_ABOVE",
            "BLOCK_MEDIUM_AND_ABOVE",
            "BLOCK_ONLY_HIGH",
            "BLOCK_NONE",
            "OFF"
          ])
        })
      ).optional(),
      threshold: _enum([
        "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
        "BLOCK_LOW_AND_ABOVE",
        "BLOCK_MEDIUM_AND_ABOVE",
        "BLOCK_ONLY_HIGH",
        "BLOCK_NONE",
        "OFF"
      ]).optional(),
      /**
       * Optional. Enables timestamp understanding for audio-only files.
       *
       * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/audio-understanding
       */
      audioTimestamp: boolean().optional(),
      /**
       * Optional. Defines labels used in billing reports. Available on Vertex AI only.
       *
       * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/add-labels-to-api-calls
       */
      labels: record(string(), string()).optional(),
      /**
       * Optional. If specified, the media resolution specified will be used.
       *
       * https://ai.google.dev/api/generate-content#MediaResolution
       */
      mediaResolution: _enum([
        "MEDIA_RESOLUTION_UNSPECIFIED",
        "MEDIA_RESOLUTION_LOW",
        "MEDIA_RESOLUTION_MEDIUM",
        "MEDIA_RESOLUTION_HIGH"
      ]).optional(),
      /**
       * Optional. Configures the image generation aspect ratio for Gemini models.
       *
       * https://ai.google.dev/gemini-api/docs/image-generation#aspect_ratios
       */
      imageConfig: object({
        aspectRatio: _enum([
          "1:1",
          "2:3",
          "3:2",
          "3:4",
          "4:3",
          "4:5",
          "5:4",
          "9:16",
          "16:9",
          "21:9"
        ]).optional()
      }).optional()
    })
  )
);
function prepareTools$3({
  tools,
  toolChoice,
  modelId
}) {
  var _a;
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  const isGemini2 = modelId.includes("gemini-2");
  const supportsDynamicRetrieval = modelId.includes("gemini-1.5-flash") && !modelId.includes("-8b");
  if (tools == null) {
    return { tools: void 0, toolConfig: void 0, toolWarnings };
  }
  const hasFunctionTools = tools.some((tool) => tool.type === "function");
  const hasProviderDefinedTools = tools.some(
    (tool) => tool.type === "provider-defined"
  );
  if (hasFunctionTools && hasProviderDefinedTools) {
    toolWarnings.push({
      type: "unsupported-tool",
      tool: tools.find((tool) => tool.type === "function"),
      details: "Cannot mix function tools with provider-defined tools in the same request. Please use either function tools or provider-defined tools, but not both."
    });
  }
  if (hasProviderDefinedTools) {
    const googleTools2 = [];
    const providerDefinedTools = tools.filter(
      (tool) => tool.type === "provider-defined"
    );
    providerDefinedTools.forEach((tool) => {
      switch (tool.id) {
        case "google.google_search":
          if (isGemini2) {
            googleTools2.push({ googleSearch: {} });
          } else if (supportsDynamicRetrieval) {
            googleTools2.push({
              googleSearchRetrieval: {
                dynamicRetrievalConfig: {
                  mode: tool.args.mode,
                  dynamicThreshold: tool.args.dynamicThreshold
                }
              }
            });
          } else {
            googleTools2.push({ googleSearchRetrieval: {} });
          }
          break;
        case "google.url_context":
          if (isGemini2) {
            googleTools2.push({ urlContext: {} });
          } else {
            toolWarnings.push({
              type: "unsupported-tool",
              tool,
              details: "The URL context tool is not supported with other Gemini models than Gemini 2."
            });
          }
          break;
        case "google.code_execution":
          if (isGemini2) {
            googleTools2.push({ codeExecution: {} });
          } else {
            toolWarnings.push({
              type: "unsupported-tool",
              tool,
              details: "The code execution tools is not supported with other Gemini models than Gemini 2."
            });
          }
          break;
        default:
          toolWarnings.push({ type: "unsupported-tool", tool });
          break;
      }
    });
    return {
      tools: googleTools2.length > 0 ? googleTools2 : void 0,
      toolConfig: void 0,
      toolWarnings
    };
  }
  const functionDeclarations = [];
  for (const tool of tools) {
    switch (tool.type) {
      case "function":
        functionDeclarations.push({
          name: tool.name,
          description: (_a = tool.description) != null ? _a : "",
          parameters: convertJSONSchemaToOpenAPISchema(tool.inputSchema)
        });
        break;
      default:
        toolWarnings.push({ type: "unsupported-tool", tool });
        break;
    }
  }
  if (toolChoice == null) {
    return {
      tools: { functionDeclarations },
      toolConfig: void 0,
      toolWarnings
    };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
      return {
        tools: { functionDeclarations },
        toolConfig: { functionCallingConfig: { mode: "AUTO" } },
        toolWarnings
      };
    case "none":
      return {
        tools: { functionDeclarations },
        toolConfig: { functionCallingConfig: { mode: "NONE" } },
        toolWarnings
      };
    case "required":
      return {
        tools: { functionDeclarations },
        toolConfig: { functionCallingConfig: { mode: "ANY" } },
        toolWarnings
      };
    case "tool":
      return {
        tools: { functionDeclarations },
        toolConfig: {
          functionCallingConfig: {
            mode: "ANY",
            allowedFunctionNames: [toolChoice.toolName]
          }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError$1({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}

// src/map-google-generative-ai-finish-reason.ts
function mapGoogleGenerativeAIFinishReason({
  finishReason,
  hasToolCalls
}) {
  switch (finishReason) {
    case "STOP":
      return hasToolCalls ? "tool-calls" : "stop";
    case "MAX_TOKENS":
      return "length";
    case "IMAGE_SAFETY":
    case "RECITATION":
    case "SAFETY":
    case "BLOCKLIST":
    case "PROHIBITED_CONTENT":
    case "SPII":
      return "content-filter";
    case "FINISH_REASON_UNSPECIFIED":
    case "OTHER":
      return "other";
    case "MALFORMED_FUNCTION_CALL":
      return "error";
    default:
      return "unknown";
  }
}

// src/google-generative-ai-language-model.ts
var GoogleGenerativeAILanguageModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    var _a;
    this.modelId = modelId;
    this.config = config;
    this.generateId = (_a = config.generateId) != null ? _a : generateId$1;
  }
  get provider() {
    return this.config.provider;
  }
  get supportedUrls() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    tools,
    toolChoice,
    providerOptions
  }) {
    var _a, _b;
    const warnings = [];
    const googleOptions = await parseProviderOptions({
      provider: "google",
      providerOptions,
      schema: googleGenerativeAIProviderOptions
    });
    if (((_a = googleOptions == null ? void 0 : googleOptions.thinkingConfig) == null ? void 0 : _a.includeThoughts) === true && !this.config.provider.startsWith("google.vertex.")) {
      warnings.push({
        type: "other",
        message: `The 'includeThoughts' option is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).`
      });
    }
    const isGemmaModel = this.modelId.toLowerCase().startsWith("gemma-");
    const { contents, systemInstruction } = convertToGoogleGenerativeAIMessages(
      prompt,
      { isGemmaModel }
    );
    const {
      tools: googleTools2,
      toolConfig: googleToolConfig,
      toolWarnings
    } = prepareTools$3({
      tools,
      toolChoice,
      modelId: this.modelId
    });
    return {
      args: {
        generationConfig: {
          // standardized settings:
          maxOutputTokens,
          temperature,
          topK,
          topP,
          frequencyPenalty,
          presencePenalty,
          stopSequences,
          seed,
          // response format:
          responseMimeType: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? "application/json" : void 0,
          responseSchema: (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && // Google GenAI does not support all OpenAPI Schema features,
          // so this is needed as an escape hatch:
          // TODO convert into provider option
          ((_b = googleOptions == null ? void 0 : googleOptions.structuredOutputs) != null ? _b : true) ? convertJSONSchemaToOpenAPISchema(responseFormat.schema) : void 0,
          ...(googleOptions == null ? void 0 : googleOptions.audioTimestamp) && {
            audioTimestamp: googleOptions.audioTimestamp
          },
          // provider options:
          responseModalities: googleOptions == null ? void 0 : googleOptions.responseModalities,
          thinkingConfig: googleOptions == null ? void 0 : googleOptions.thinkingConfig,
          ...(googleOptions == null ? void 0 : googleOptions.imageConfig) && {
            imageConfig: googleOptions.imageConfig
          },
          ...(googleOptions == null ? void 0 : googleOptions.mediaResolution) && {
            mediaResolution: googleOptions.mediaResolution
          }
        },
        contents,
        systemInstruction: isGemmaModel ? void 0 : systemInstruction,
        safetySettings: googleOptions == null ? void 0 : googleOptions.safetySettings,
        tools: googleTools2,
        toolConfig: googleToolConfig,
        cachedContent: googleOptions == null ? void 0 : googleOptions.cachedContent,
        labels: googleOptions == null ? void 0 : googleOptions.labels
      },
      warnings: [...warnings, ...toolWarnings]
    };
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
    const { args, warnings } = await this.getArgs(options);
    const body = JSON.stringify(args);
    const mergedHeaders = combineHeaders$1(
      await resolve(this.config.headers),
      options.headers
    );
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi$1({
      url: `${this.config.baseURL}/${getModelPath(
        this.modelId
      )}:generateContent`,
      headers: mergedHeaders,
      body: args,
      failedResponseHandler: googleFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(responseSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const candidate = response.candidates[0];
    const content = [];
    const parts = (_b = (_a = candidate.content) == null ? void 0 : _a.parts) != null ? _b : [];
    const usageMetadata = response.usageMetadata;
    let lastCodeExecutionToolCallId;
    for (const part of parts) {
      if ("executableCode" in part && ((_c = part.executableCode) == null ? void 0 : _c.code)) {
        const toolCallId = this.config.generateId();
        lastCodeExecutionToolCallId = toolCallId;
        content.push({
          type: "tool-call",
          toolCallId,
          toolName: "code_execution",
          input: JSON.stringify(part.executableCode),
          providerExecuted: true
        });
      } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
        content.push({
          type: "tool-result",
          // Assumes a result directly follows its corresponding call part.
          toolCallId: lastCodeExecutionToolCallId,
          toolName: "code_execution",
          result: {
            outcome: part.codeExecutionResult.outcome,
            output: part.codeExecutionResult.output
          },
          providerExecuted: true
        });
        lastCodeExecutionToolCallId = void 0;
      } else if ("text" in part && part.text != null && part.text.length > 0) {
        content.push({
          type: part.thought === true ? "reasoning" : "text",
          text: part.text,
          providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
        });
      } else if ("functionCall" in part) {
        content.push({
          type: "tool-call",
          toolCallId: this.config.generateId(),
          toolName: part.functionCall.name,
          input: JSON.stringify(part.functionCall.args),
          providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
        });
      } else if ("inlineData" in part) {
        content.push({
          type: "file",
          data: part.inlineData.data,
          mediaType: part.inlineData.mimeType
        });
      }
    }
    const sources = (_d = extractSources({
      groundingMetadata: candidate.groundingMetadata,
      generateId: this.config.generateId
    })) != null ? _d : [];
    for (const source of sources) {
      content.push(source);
    }
    return {
      content,
      finishReason: mapGoogleGenerativeAIFinishReason({
        finishReason: candidate.finishReason,
        hasToolCalls: content.some((part) => part.type === "tool-call")
      }),
      usage: {
        inputTokens: (_e = usageMetadata == null ? void 0 : usageMetadata.promptTokenCount) != null ? _e : void 0,
        outputTokens: (_f = usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount) != null ? _f : void 0,
        totalTokens: (_g = usageMetadata == null ? void 0 : usageMetadata.totalTokenCount) != null ? _g : void 0,
        reasoningTokens: (_h = usageMetadata == null ? void 0 : usageMetadata.thoughtsTokenCount) != null ? _h : void 0,
        cachedInputTokens: (_i = usageMetadata == null ? void 0 : usageMetadata.cachedContentTokenCount) != null ? _i : void 0
      },
      warnings,
      providerMetadata: {
        google: {
          promptFeedback: (_j = response.promptFeedback) != null ? _j : null,
          groundingMetadata: (_k = candidate.groundingMetadata) != null ? _k : null,
          urlContextMetadata: (_l = candidate.urlContextMetadata) != null ? _l : null,
          safetyRatings: (_m = candidate.safetyRatings) != null ? _m : null,
          usageMetadata: usageMetadata != null ? usageMetadata : null
        }
      },
      request: { body },
      response: {
        // TODO timestamp, model id, id
        headers: responseHeaders,
        body: rawResponse
      }
    };
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const body = JSON.stringify(args);
    const headers = combineHeaders$1(
      await resolve(this.config.headers),
      options.headers
    );
    const { responseHeaders, value: response } = await postJsonToApi$1({
      url: `${this.config.baseURL}/${getModelPath(
        this.modelId
      )}:streamGenerateContent?alt=sse`,
      headers,
      body: args,
      failedResponseHandler: googleFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler$1(chunkSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0
    };
    let providerMetadata = void 0;
    const generateId3 = this.config.generateId;
    let hasToolCalls = false;
    let currentTextBlockId = null;
    let currentReasoningBlockId = null;
    let blockCounter = 0;
    const emittedSourceUrls = /* @__PURE__ */ new Set();
    let lastCodeExecutionToolCallId;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            const usageMetadata = value.usageMetadata;
            if (usageMetadata != null) {
              usage.inputTokens = (_a = usageMetadata.promptTokenCount) != null ? _a : void 0;
              usage.outputTokens = (_b = usageMetadata.candidatesTokenCount) != null ? _b : void 0;
              usage.totalTokens = (_c = usageMetadata.totalTokenCount) != null ? _c : void 0;
              usage.reasoningTokens = (_d = usageMetadata.thoughtsTokenCount) != null ? _d : void 0;
              usage.cachedInputTokens = (_e = usageMetadata.cachedContentTokenCount) != null ? _e : void 0;
            }
            const candidate = (_f = value.candidates) == null ? void 0 : _f[0];
            if (candidate == null) {
              return;
            }
            const content = candidate.content;
            const sources = extractSources({
              groundingMetadata: candidate.groundingMetadata,
              generateId: generateId3
            });
            if (sources != null) {
              for (const source of sources) {
                if (source.sourceType === "url" && !emittedSourceUrls.has(source.url)) {
                  emittedSourceUrls.add(source.url);
                  controller.enqueue(source);
                }
              }
            }
            if (content != null) {
              const parts = (_g = content.parts) != null ? _g : [];
              for (const part of parts) {
                if ("executableCode" in part && ((_h = part.executableCode) == null ? void 0 : _h.code)) {
                  const toolCallId = generateId3();
                  lastCodeExecutionToolCallId = toolCallId;
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId,
                    toolName: "code_execution",
                    input: JSON.stringify(part.executableCode),
                    providerExecuted: true
                  });
                  hasToolCalls = true;
                } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
                  const toolCallId = lastCodeExecutionToolCallId;
                  if (toolCallId) {
                    controller.enqueue({
                      type: "tool-result",
                      toolCallId,
                      toolName: "code_execution",
                      result: {
                        outcome: part.codeExecutionResult.outcome,
                        output: part.codeExecutionResult.output
                      },
                      providerExecuted: true
                    });
                    lastCodeExecutionToolCallId = void 0;
                  }
                } else if ("text" in part && part.text != null && part.text.length > 0) {
                  if (part.thought === true) {
                    if (currentTextBlockId !== null) {
                      controller.enqueue({
                        type: "text-end",
                        id: currentTextBlockId
                      });
                      currentTextBlockId = null;
                    }
                    if (currentReasoningBlockId === null) {
                      currentReasoningBlockId = String(blockCounter++);
                      controller.enqueue({
                        type: "reasoning-start",
                        id: currentReasoningBlockId,
                        providerMetadata: part.thoughtSignature ? {
                          google: {
                            thoughtSignature: part.thoughtSignature
                          }
                        } : void 0
                      });
                    }
                    controller.enqueue({
                      type: "reasoning-delta",
                      id: currentReasoningBlockId,
                      delta: part.text,
                      providerMetadata: part.thoughtSignature ? {
                        google: { thoughtSignature: part.thoughtSignature }
                      } : void 0
                    });
                  } else {
                    if (currentReasoningBlockId !== null) {
                      controller.enqueue({
                        type: "reasoning-end",
                        id: currentReasoningBlockId
                      });
                      currentReasoningBlockId = null;
                    }
                    if (currentTextBlockId === null) {
                      currentTextBlockId = String(blockCounter++);
                      controller.enqueue({
                        type: "text-start",
                        id: currentTextBlockId,
                        providerMetadata: part.thoughtSignature ? {
                          google: {
                            thoughtSignature: part.thoughtSignature
                          }
                        } : void 0
                      });
                    }
                    controller.enqueue({
                      type: "text-delta",
                      id: currentTextBlockId,
                      delta: part.text,
                      providerMetadata: part.thoughtSignature ? {
                        google: { thoughtSignature: part.thoughtSignature }
                      } : void 0
                    });
                  }
                }
              }
              const inlineDataParts = getInlineDataParts(content.parts);
              if (inlineDataParts != null) {
                for (const part of inlineDataParts) {
                  controller.enqueue({
                    type: "file",
                    mediaType: part.inlineData.mimeType,
                    data: part.inlineData.data
                  });
                }
              }
              const toolCallDeltas = getToolCallsFromParts({
                parts: content.parts,
                generateId: generateId3
              });
              if (toolCallDeltas != null) {
                for (const toolCall of toolCallDeltas) {
                  controller.enqueue({
                    type: "tool-input-start",
                    id: toolCall.toolCallId,
                    toolName: toolCall.toolName,
                    providerMetadata: toolCall.providerMetadata
                  });
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: toolCall.toolCallId,
                    delta: toolCall.args,
                    providerMetadata: toolCall.providerMetadata
                  });
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCall.toolCallId,
                    providerMetadata: toolCall.providerMetadata
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: toolCall.toolCallId,
                    toolName: toolCall.toolName,
                    input: toolCall.args,
                    providerMetadata: toolCall.providerMetadata
                  });
                  hasToolCalls = true;
                }
              }
            }
            if (candidate.finishReason != null) {
              finishReason = mapGoogleGenerativeAIFinishReason({
                finishReason: candidate.finishReason,
                hasToolCalls
              });
              providerMetadata = {
                google: {
                  promptFeedback: (_i = value.promptFeedback) != null ? _i : null,
                  groundingMetadata: (_j = candidate.groundingMetadata) != null ? _j : null,
                  urlContextMetadata: (_k = candidate.urlContextMetadata) != null ? _k : null,
                  safetyRatings: (_l = candidate.safetyRatings) != null ? _l : null
                }
              };
              if (usageMetadata != null) {
                providerMetadata.google.usageMetadata = usageMetadata;
              }
            }
          },
          flush(controller) {
            if (currentTextBlockId !== null) {
              controller.enqueue({
                type: "text-end",
                id: currentTextBlockId
              });
            }
            if (currentReasoningBlockId !== null) {
              controller.enqueue({
                type: "reasoning-end",
                id: currentReasoningBlockId
              });
            }
            controller.enqueue({
              type: "finish",
              finishReason,
              usage,
              providerMetadata
            });
          }
        })
      ),
      response: { headers: responseHeaders },
      request: { body }
    };
  }
};
function getToolCallsFromParts({
  parts,
  generateId: generateId3
}) {
  const functionCallParts = parts == null ? void 0 : parts.filter(
    (part) => "functionCall" in part
  );
  return functionCallParts == null || functionCallParts.length === 0 ? void 0 : functionCallParts.map((part) => ({
    type: "tool-call",
    toolCallId: generateId3(),
    toolName: part.functionCall.name,
    args: JSON.stringify(part.functionCall.args),
    providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
  }));
}
function getInlineDataParts(parts) {
  return parts == null ? void 0 : parts.filter(
    (part) => "inlineData" in part
  );
}
function extractSources({
  groundingMetadata,
  generateId: generateId3
}) {
  var _a;
  return (_a = groundingMetadata == null ? void 0 : groundingMetadata.groundingChunks) == null ? void 0 : _a.filter(
    (chunk) => chunk.web != null
  ).map((chunk) => ({
    type: "source",
    sourceType: "url",
    id: generateId3(),
    url: chunk.web.uri,
    title: chunk.web.title
  }));
}
var getGroundingMetadataSchema = () => object({
  webSearchQueries: array(string()).nullish(),
  retrievalQueries: array(string()).nullish(),
  searchEntryPoint: object({ renderedContent: string() }).nullish(),
  groundingChunks: array(
    object({
      web: object({ uri: string(), title: string() }).nullish(),
      retrievedContext: object({ uri: string(), title: string() }).nullish()
    })
  ).nullish(),
  groundingSupports: array(
    object({
      segment: object({
        startIndex: number$1().nullish(),
        endIndex: number$1().nullish(),
        text: string().nullish()
      }),
      segment_text: string().nullish(),
      groundingChunkIndices: array(number$1()).nullish(),
      supportChunkIndices: array(number$1()).nullish(),
      confidenceScores: array(number$1()).nullish(),
      confidenceScore: array(number$1()).nullish()
    })
  ).nullish(),
  retrievalMetadata: union([
    object({
      webDynamicRetrievalScore: number$1()
    }),
    object({})
  ]).nullish()
});
var getContentSchema = () => object({
  parts: array(
    union([
      // note: order matters since text can be fully empty
      object({
        functionCall: object({
          name: string(),
          args: unknown()
        }),
        thoughtSignature: string().nullish()
      }),
      object({
        inlineData: object({
          mimeType: string(),
          data: string()
        })
      }),
      object({
        executableCode: object({
          language: string(),
          code: string()
        }).nullish(),
        codeExecutionResult: object({
          outcome: string(),
          output: string()
        }).nullish(),
        text: string().nullish(),
        thought: boolean().nullish(),
        thoughtSignature: string().nullish()
      })
    ])
  ).nullish()
});
var getSafetyRatingSchema = () => object({
  category: string().nullish(),
  probability: string().nullish(),
  probabilityScore: number$1().nullish(),
  severity: string().nullish(),
  severityScore: number$1().nullish(),
  blocked: boolean().nullish()
});
var usageSchema$1 = object({
  cachedContentTokenCount: number$1().nullish(),
  thoughtsTokenCount: number$1().nullish(),
  promptTokenCount: number$1().nullish(),
  candidatesTokenCount: number$1().nullish(),
  totalTokenCount: number$1().nullish()
});
var getUrlContextMetadataSchema = () => object({
  urlMetadata: array(
    object({
      retrievedUrl: string(),
      urlRetrievalStatus: string()
    })
  )
});
var responseSchema = lazySchema(
  () => zodSchema(
    object({
      candidates: array(
        object({
          content: getContentSchema().nullish().or(object({}).strict()),
          finishReason: string().nullish(),
          safetyRatings: array(getSafetyRatingSchema()).nullish(),
          groundingMetadata: getGroundingMetadataSchema().nullish(),
          urlContextMetadata: getUrlContextMetadataSchema().nullish()
        })
      ),
      usageMetadata: usageSchema$1.nullish(),
      promptFeedback: object({
        blockReason: string().nullish(),
        safetyRatings: array(getSafetyRatingSchema()).nullish()
      }).nullish()
    })
  )
);
var chunkSchema = lazySchema(
  () => zodSchema(
    object({
      candidates: array(
        object({
          content: getContentSchema().nullish(),
          finishReason: string().nullish(),
          safetyRatings: array(getSafetyRatingSchema()).nullish(),
          groundingMetadata: getGroundingMetadataSchema().nullish(),
          urlContextMetadata: getUrlContextMetadataSchema().nullish()
        })
      ).nullish(),
      usageMetadata: usageSchema$1.nullish(),
      promptFeedback: object({
        blockReason: string().nullish(),
        safetyRatings: array(getSafetyRatingSchema()).nullish()
      }).nullish()
    })
  )
);
var codeExecution = createProviderDefinedToolFactoryWithOutputSchema({
  id: "google.code_execution",
  name: "code_execution",
  inputSchema: object({
    language: string().describe("The programming language of the code."),
    code: string().describe("The code to be executed.")
  }),
  outputSchema: object({
    outcome: string().describe('The outcome of the execution (e.g., "OUTCOME_OK").'),
    output: string().describe("The output from the code execution.")
  })
});
var googleSearch = createProviderDefinedToolFactory({
  id: "google.google_search",
  name: "google_search",
  inputSchema: lazySchema(
    () => zodSchema(
      object({
        mode: _enum(["MODE_DYNAMIC", "MODE_UNSPECIFIED"]).default("MODE_UNSPECIFIED"),
        dynamicThreshold: number$1().default(1)
      })
    )
  )
});
var urlContext = createProviderDefinedToolFactory({
  id: "google.url_context",
  name: "url_context",
  inputSchema: lazySchema(() => zodSchema(object({})))
});

// src/google-tools.ts
var googleTools = {
  /**
   * Creates a Google search tool that gives Google direct access to real-time web content.
   * Must have name "google_search".
   */
  googleSearch,
  /**
   * Creates a URL context tool that gives Google direct access to real-time web content.
   * Must have name "url_context".
   */
  urlContext,
  /**
   * A tool that enables the model to generate and run Python code.
   * Must have name "code_execution".
   *
   * @note Ensure the selected model supports Code Execution.
   * Multi-tool usage with the code execution tool is typically compatible with Gemini >=2 models.
   *
   * @see https://ai.google.dev/gemini-api/docs/code-execution (Google AI)
   * @see https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/code-execution-api (Vertex AI)
   */
  codeExecution
};
var GoogleGenerativeAIImageModel = class {
  constructor(modelId, settings, config) {
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
    this.specificationVersion = "v2";
  }
  get maxImagesPerCall() {
    var _a;
    return (_a = this.settings.maxImagesPerCall) != null ? _a : 4;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate(options) {
    var _a, _b, _c;
    const {
      prompt,
      n = 1,
      size = "1024x1024",
      aspectRatio = "1:1",
      seed,
      providerOptions,
      headers,
      abortSignal
    } = options;
    const warnings = [];
    if (size != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "size",
        details: "This model does not support the `size` option. Use `aspectRatio` instead."
      });
    }
    if (seed != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "seed",
        details: "This model does not support the `seed` option through this provider."
      });
    }
    const googleOptions = await parseProviderOptions({
      provider: "google",
      providerOptions,
      schema: googleImageProviderOptionsSchema
    });
    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
    const parameters = {
      sampleCount: n
    };
    if (aspectRatio != null) {
      parameters.aspectRatio = aspectRatio;
    }
    if (googleOptions) {
      Object.assign(parameters, googleOptions);
    }
    const body = {
      instances: [{ prompt }],
      parameters
    };
    const { responseHeaders, value: response } = await postJsonToApi$1({
      url: `${this.config.baseURL}/models/${this.modelId}:predict`,
      headers: combineHeaders$1(await resolve(this.config.headers), headers),
      body,
      failedResponseHandler: googleFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        googleImageResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      images: response.predictions.map(
        (p) => p.bytesBase64Encoded
      ),
      warnings: warnings != null ? warnings : [],
      providerMetadata: {
        google: {
          images: response.predictions.map((prediction) => ({
            // Add any prediction-specific metadata here
          }))
        }
      },
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders
      }
    };
  }
};
var googleImageResponseSchema = lazySchema(
  () => zodSchema(
    object({
      predictions: array(object({ bytesBase64Encoded: string() })).default([])
    })
  )
);
var googleImageProviderOptionsSchema = lazySchema(
  () => zodSchema(
    object({
      personGeneration: _enum(["dont_allow", "allow_adult", "allow_all"]).nullish(),
      aspectRatio: _enum(["1:1", "3:4", "4:3", "9:16", "16:9"]).nullish()
    })
  )
);

// src/google-provider.ts
function createGoogleGenerativeAI(options = {}) {
  var _a;
  const baseURL = (_a = withoutTrailingSlash$1(options.baseURL)) != null ? _a : "https://generativelanguage.googleapis.com/v1beta";
  const getHeaders = () => withUserAgentSuffix(
    {
      "x-goog-api-key": loadApiKey$1({
        apiKey: options.apiKey,
        environmentVariableName: "GOOGLE_GENERATIVE_AI_API_KEY",
        description: "Google Generative AI"
      }),
      ...options.headers
    },
    `ai-sdk/google/${VERSION$2}`
  );
  const createChatModel = (modelId) => {
    var _a2;
    return new GoogleGenerativeAILanguageModel(modelId, {
      provider: "google.generative-ai",
      baseURL,
      headers: getHeaders,
      generateId: (_a2 = options.generateId) != null ? _a2 : generateId$1,
      supportedUrls: () => ({
        "*": [
          // Google Generative Language "files" endpoint
          // e.g. https://generativelanguage.googleapis.com/v1beta/files/...
          new RegExp(`^${baseURL}/files/.*$`),
          // YouTube URLs (public or unlisted videos)
          new RegExp(
            `^https://(?:www\\.)?youtube\\.com/watch\\?v=[\\w-]+(?:&[\\w=&.-]*)?$`
          ),
          new RegExp(`^https://youtu\\.be/[\\w-]+(?:\\?[\\w=&.-]*)?$`)
        ]
      }),
      fetch: options.fetch
    });
  };
  const createEmbeddingModel = (modelId) => new GoogleGenerativeAIEmbeddingModel(modelId, {
    provider: "google.generative-ai",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  });
  const createImageModel = (modelId, settings = {}) => new GoogleGenerativeAIImageModel(modelId, settings, {
    provider: "google.generative-ai",
    baseURL,
    headers: getHeaders,
    fetch: options.fetch
  });
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Google Generative AI model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  provider.languageModel = createChatModel;
  provider.chat = createChatModel;
  provider.generativeAI = createChatModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.tools = googleTools;
  return provider;
}
createGoogleGenerativeAI();

// src/anthropic-messages-language-model.ts
var anthropicErrorDataSchema = lazySchema(
  () => zodSchema(
    object({
      type: literal("error"),
      error: object({
        type: string(),
        message: string()
      })
    })
  )
);
createJsonErrorResponseHandler$1({
  errorSchema: anthropicErrorDataSchema,
  errorToMessage: (data) => data.error.message
});
object({
  /**
   * Citation configuration for this document.
   * When enabled, this document will generate citations in the response.
   */
  citations: object({
    /**
     * Enable citations for this document
     */
    enabled: boolean()
  }).optional(),
  /**
   * Custom title for the document.
   * If not provided, the filename will be used.
   */
  title: string().optional(),
  /**
   * Context about the document that will be passed to the model
   * but not used towards cited content.
   * Useful for storing document metadata as text or stringified JSON.
   */
  context: string().optional()
});
object({
  sendReasoning: boolean().optional(),
  thinking: object({
    type: union([literal("enabled"), literal("disabled")]),
    budgetTokens: number$1().optional()
  }).optional(),
  /**
   * Whether to disable parallel function calling during tool use. Default is false.
   * When set to true, Claude will use at most one tool per response.
   */
  disableParallelToolUse: boolean().optional(),
  /**
   * Cache control settings for this message.
   * See https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching
   */
  cacheControl: object({
    type: literal("ephemeral"),
    ttl: union([literal("5m"), literal("1h")]).optional()
  }).optional(),
  /**
   * Agent Skills configuration. Skills enable Claude to perform specialized tasks
   * like document processing (PPTX, DOCX, PDF, XLSX) and data analysis.
   * Requires code execution tool to be enabled.
   */
  container: object({
    id: string().optional(),
    skills: array(
      object({
        type: union([literal("anthropic"), literal("custom")]),
        skillId: string(),
        version: string().optional()
      })
    ).optional()
  }).optional()
});

// src/get-cache-control.ts
var MAX_CACHE_BREAKPOINTS = 4;
function getCacheControl$1(providerMetadata) {
  var _a;
  const anthropic = providerMetadata == null ? void 0 : providerMetadata.anthropic;
  const cacheControlValue = (_a = anthropic == null ? void 0 : anthropic.cacheControl) != null ? _a : anthropic == null ? void 0 : anthropic.cache_control;
  return cacheControlValue;
}
var CacheControlValidator = class {
  constructor() {
    this.breakpointCount = 0;
    this.warnings = [];
  }
  getCacheControl(providerMetadata, context) {
    const cacheControlValue = getCacheControl$1(providerMetadata);
    if (!cacheControlValue) {
      return void 0;
    }
    if (!context.canCache) {
      this.warnings.push({
        type: "unsupported-setting",
        setting: "cacheControl",
        details: `cache_control cannot be set on ${context.type}. It will be ignored.`
      });
      return void 0;
    }
    this.breakpointCount++;
    if (this.breakpointCount > MAX_CACHE_BREAKPOINTS) {
      this.warnings.push({
        type: "unsupported-setting",
        setting: "cacheControl",
        details: `Maximum ${MAX_CACHE_BREAKPOINTS} cache breakpoints exceeded (found ${this.breakpointCount}). This breakpoint will be ignored.`
      });
      return void 0;
    }
    return cacheControlValue;
  }
  getWarnings() {
    return this.warnings;
  }
};
var textEditor_20250728ArgsSchema = lazySchema(
  () => zodSchema(
    object({
      maxCharacters: number$1().optional()
    })
  )
);
var textEditor_20250728InputSchema = lazySchema(
  () => zodSchema(
    object({
      command: _enum(["view", "create", "str_replace", "insert"]),
      path: string(),
      file_text: string().optional(),
      insert_line: number$1().int().optional(),
      new_str: string().optional(),
      old_str: string().optional(),
      view_range: array(number$1().int()).optional()
    })
  )
);
var factory = createProviderDefinedToolFactory({
  id: "anthropic.text_editor_20250728",
  name: "str_replace_based_edit_tool",
  inputSchema: textEditor_20250728InputSchema
});
var textEditor_20250728 = (args = {}) => {
  return factory(args);
};
var webSearch_20250305ArgsSchema = lazySchema(
  () => zodSchema(
    object({
      maxUses: number$1().optional(),
      allowedDomains: array(string()).optional(),
      blockedDomains: array(string()).optional(),
      userLocation: object({
        type: literal("approximate"),
        city: string().optional(),
        region: string().optional(),
        country: string().optional(),
        timezone: string().optional()
      }).optional()
    })
  )
);
var webSearch_20250305OutputSchema = lazySchema(
  () => zodSchema(
    array(
      object({
        url: string(),
        title: string(),
        pageAge: string().nullable(),
        encryptedContent: string(),
        type: literal("web_search_result")
      })
    )
  )
);
var webSearch_20250305InputSchema = lazySchema(
  () => zodSchema(
    object({
      query: string()
    })
  )
);
var factory2 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "anthropic.web_search_20250305",
  name: "web_search",
  inputSchema: webSearch_20250305InputSchema,
  outputSchema: webSearch_20250305OutputSchema
});
var webSearch_20250305 = (args = {}) => {
  return factory2(args);
};
var webFetch_20250910ArgsSchema = lazySchema(
  () => zodSchema(
    object({
      maxUses: number$1().optional(),
      allowedDomains: array(string()).optional(),
      blockedDomains: array(string()).optional(),
      citations: object({ enabled: boolean() }).optional(),
      maxContentTokens: number$1().optional()
    })
  )
);
var webFetch_20250910OutputSchema = lazySchema(
  () => zodSchema(
    object({
      type: literal("web_fetch_result"),
      url: string(),
      content: object({
        type: literal("document"),
        title: string(),
        citations: object({ enabled: boolean() }).optional(),
        source: union([
          object({
            type: literal("base64"),
            mediaType: literal("application/pdf"),
            data: string()
          }),
          object({
            type: literal("text"),
            mediaType: literal("text/plain"),
            data: string()
          })
        ])
      }),
      retrievedAt: string().nullable()
    })
  )
);
var webFetch_20250910InputSchema = lazySchema(
  () => zodSchema(
    object({
      url: string()
    })
  )
);
var factory3 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "anthropic.web_fetch_20250910",
  name: "web_fetch",
  inputSchema: webFetch_20250910InputSchema,
  outputSchema: webFetch_20250910OutputSchema
});
var webFetch_20250910 = (args = {}) => {
  return factory3(args);
};
async function prepareTools$2({
  tools,
  toolChoice,
  disableParallelToolUse,
  cacheControlValidator
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  const betas = /* @__PURE__ */ new Set();
  const validator = cacheControlValidator || new CacheControlValidator();
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
  }
  const anthropicTools2 = [];
  for (const tool of tools) {
    switch (tool.type) {
      case "function": {
        const cacheControl = validator.getCacheControl(tool.providerOptions, {
          type: "tool definition",
          canCache: true
        });
        anthropicTools2.push({
          name: tool.name,
          description: tool.description,
          input_schema: tool.inputSchema,
          cache_control: cacheControl
        });
        break;
      }
      case "provider-defined": {
        switch (tool.id) {
          case "anthropic.code_execution_20250522": {
            betas.add("code-execution-2025-05-22");
            anthropicTools2.push({
              type: "code_execution_20250522",
              name: "code_execution",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.code_execution_20250825": {
            betas.add("code-execution-2025-08-25");
            anthropicTools2.push({
              type: "code_execution_20250825",
              name: "code_execution"
            });
            break;
          }
          case "anthropic.computer_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "computer",
              type: "computer_20250124",
              display_width_px: tool.args.displayWidthPx,
              display_height_px: tool.args.displayHeightPx,
              display_number: tool.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.computer_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools2.push({
              name: "computer",
              type: "computer_20241022",
              display_width_px: tool.args.displayWidthPx,
              display_height_px: tool.args.displayHeightPx,
              display_number: tool.args.displayNumber,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "str_replace_editor",
              type: "text_editor_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools2.push({
              name: "str_replace_editor",
              type: "text_editor_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250429": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250429",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.text_editor_20250728": {
            const args = await validateTypes$1({
              value: tool.args,
              schema: textEditor_20250728ArgsSchema
            });
            anthropicTools2.push({
              name: "str_replace_based_edit_tool",
              type: "text_editor_20250728",
              max_characters: args.maxCharacters,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20250124": {
            betas.add("computer-use-2025-01-24");
            anthropicTools2.push({
              name: "bash",
              type: "bash_20250124",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.bash_20241022": {
            betas.add("computer-use-2024-10-22");
            anthropicTools2.push({
              name: "bash",
              type: "bash_20241022",
              cache_control: void 0
            });
            break;
          }
          case "anthropic.memory_20250818": {
            betas.add("context-management-2025-06-27");
            anthropicTools2.push({
              name: "memory",
              type: "memory_20250818"
            });
            break;
          }
          case "anthropic.web_fetch_20250910": {
            betas.add("web-fetch-2025-09-10");
            const args = await validateTypes$1({
              value: tool.args,
              schema: webFetch_20250910ArgsSchema
            });
            anthropicTools2.push({
              type: "web_fetch_20250910",
              name: "web_fetch",
              max_uses: args.maxUses,
              allowed_domains: args.allowedDomains,
              blocked_domains: args.blockedDomains,
              citations: args.citations,
              max_content_tokens: args.maxContentTokens,
              cache_control: void 0
            });
            break;
          }
          case "anthropic.web_search_20250305": {
            const args = await validateTypes$1({
              value: tool.args,
              schema: webSearch_20250305ArgsSchema
            });
            anthropicTools2.push({
              type: "web_search_20250305",
              name: "web_search",
              max_uses: args.maxUses,
              allowed_domains: args.allowedDomains,
              blocked_domains: args.blockedDomains,
              user_location: args.userLocation,
              cache_control: void 0
            });
            break;
          }
          default: {
            toolWarnings.push({ type: "unsupported-tool", tool });
            break;
          }
        }
        break;
      }
      default: {
        toolWarnings.push({ type: "unsupported-tool", tool });
        break;
      }
    }
  }
  if (toolChoice == null) {
    return {
      tools: anthropicTools2,
      toolChoice: disableParallelToolUse ? { type: "auto", disable_parallel_tool_use: disableParallelToolUse } : void 0,
      toolWarnings,
      betas
    };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "auto",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "required":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "any",
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    case "none":
      return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
    case "tool":
      return {
        tools: anthropicTools2,
        toolChoice: {
          type: "tool",
          name: toolChoice.toolName,
          disable_parallel_tool_use: disableParallelToolUse
        },
        toolWarnings,
        betas
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError$1({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}
var codeExecution_20250522OutputSchema = lazySchema(
  () => zodSchema(
    object({
      type: literal("code_execution_result"),
      stdout: string(),
      stderr: string(),
      return_code: number$1()
    })
  )
);
var codeExecution_20250522InputSchema = lazySchema(
  () => zodSchema(
    object({
      code: string()
    })
  )
);
var factory4 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "anthropic.code_execution_20250522",
  name: "code_execution",
  inputSchema: codeExecution_20250522InputSchema,
  outputSchema: codeExecution_20250522OutputSchema
});
var codeExecution_20250522 = (args = {}) => {
  return factory4(args);
};
var codeExecution_20250825OutputSchema = lazySchema(
  () => zodSchema(
    discriminatedUnion("type", [
      object({
        type: literal("bash_code_execution_result"),
        content: array(
          object({
            type: literal("bash_code_execution_output"),
            file_id: string()
          })
        ),
        stdout: string(),
        stderr: string(),
        return_code: number$1()
      }),
      object({
        type: literal("bash_code_execution_tool_result_error"),
        error_code: string()
      }),
      object({
        type: literal("text_editor_code_execution_tool_result_error"),
        error_code: string()
      }),
      object({
        type: literal("text_editor_code_execution_view_result"),
        content: string(),
        file_type: string(),
        num_lines: number$1().nullable(),
        start_line: number$1().nullable(),
        total_lines: number$1().nullable()
      }),
      object({
        type: literal("text_editor_code_execution_create_result"),
        is_file_update: boolean()
      }),
      object({
        type: literal("text_editor_code_execution_str_replace_result"),
        lines: array(string()).nullable(),
        new_lines: number$1().nullable(),
        new_start: number$1().nullable(),
        old_lines: number$1().nullable(),
        old_start: number$1().nullable()
      })
    ])
  )
);
var codeExecution_20250825InputSchema = lazySchema(
  () => zodSchema(
    discriminatedUnion("type", [
      object({
        type: literal("bash_code_execution"),
        command: string()
      }),
      discriminatedUnion("command", [
        object({
          type: literal("text_editor_code_execution"),
          command: literal("view"),
          path: string()
        }),
        object({
          type: literal("text_editor_code_execution"),
          command: literal("create"),
          path: string(),
          file_text: string().nullish()
        }),
        object({
          type: literal("text_editor_code_execution"),
          command: literal("str_replace"),
          path: string(),
          old_str: string(),
          new_str: string()
        })
      ])
    ])
  )
);
var factory5 = createProviderDefinedToolFactoryWithOutputSchema({
  id: "anthropic.code_execution_20250825",
  name: "code_execution",
  inputSchema: codeExecution_20250825InputSchema,
  outputSchema: codeExecution_20250825OutputSchema
});
var codeExecution_20250825 = (args = {}) => {
  return factory5(args);
};
var bash_20241022InputSchema = lazySchema(
  () => zodSchema(
    object({
      command: string(),
      restart: boolean().optional()
    })
  )
);
var bash_20241022 = createProviderDefinedToolFactory({
  id: "anthropic.bash_20241022",
  name: "bash",
  inputSchema: bash_20241022InputSchema
});
var bash_20250124InputSchema = lazySchema(
  () => zodSchema(
    object({
      command: string(),
      restart: boolean().optional()
    })
  )
);
var bash_20250124 = createProviderDefinedToolFactory({
  id: "anthropic.bash_20250124",
  name: "bash",
  inputSchema: bash_20250124InputSchema
});
var computer_20241022InputSchema = lazySchema(
  () => zodSchema(
    object({
      action: _enum([
        "key",
        "type",
        "mouse_move",
        "left_click",
        "left_click_drag",
        "right_click",
        "middle_click",
        "double_click",
        "screenshot",
        "cursor_position"
      ]),
      coordinate: array(number$1().int()).optional(),
      text: string().optional()
    })
  )
);
var computer_20241022 = createProviderDefinedToolFactory({
  id: "anthropic.computer_20241022",
  name: "computer",
  inputSchema: computer_20241022InputSchema
});
var computer_20250124InputSchema = lazySchema(
  () => zodSchema(
    object({
      action: _enum([
        "key",
        "hold_key",
        "type",
        "cursor_position",
        "mouse_move",
        "left_mouse_down",
        "left_mouse_up",
        "left_click",
        "left_click_drag",
        "right_click",
        "middle_click",
        "double_click",
        "triple_click",
        "scroll",
        "wait",
        "screenshot"
      ]),
      coordinate: tuple([number$1().int(), number$1().int()]).optional(),
      duration: number$1().optional(),
      scroll_amount: number$1().optional(),
      scroll_direction: _enum(["up", "down", "left", "right"]).optional(),
      start_coordinate: tuple([number$1().int(), number$1().int()]).optional(),
      text: string().optional()
    })
  )
);
var computer_20250124 = createProviderDefinedToolFactory({
  id: "anthropic.computer_20250124",
  name: "computer",
  inputSchema: computer_20250124InputSchema
});
var memory_20250818InputSchema = lazySchema(
  () => zodSchema(
    discriminatedUnion("command", [
      object({
        command: literal("view"),
        path: string(),
        view_range: tuple([number$1(), number$1()]).optional()
      }),
      object({
        command: literal("create"),
        path: string(),
        file_text: string()
      }),
      object({
        command: literal("str_replace"),
        path: string(),
        old_str: string(),
        new_str: string()
      }),
      object({
        command: literal("insert"),
        path: string(),
        insert_line: number$1(),
        insert_text: string()
      }),
      object({
        command: literal("delete"),
        path: string()
      }),
      object({
        command: literal("rename"),
        old_path: string(),
        new_path: string()
      })
    ])
  )
);
var memory_20250818 = createProviderDefinedToolFactory({
  id: "anthropic.memory_20250818",
  name: "memory",
  inputSchema: memory_20250818InputSchema
});
var textEditor_20241022InputSchema = lazySchema(
  () => zodSchema(
    object({
      command: _enum(["view", "create", "str_replace", "insert", "undo_edit"]),
      path: string(),
      file_text: string().optional(),
      insert_line: number$1().int().optional(),
      new_str: string().optional(),
      old_str: string().optional(),
      view_range: array(number$1().int()).optional()
    })
  )
);
var textEditor_20241022 = createProviderDefinedToolFactory({
  id: "anthropic.text_editor_20241022",
  name: "str_replace_editor",
  inputSchema: textEditor_20241022InputSchema
});
var textEditor_20250124InputSchema = lazySchema(
  () => zodSchema(
    object({
      command: _enum(["view", "create", "str_replace", "insert", "undo_edit"]),
      path: string(),
      file_text: string().optional(),
      insert_line: number$1().int().optional(),
      new_str: string().optional(),
      old_str: string().optional(),
      view_range: array(number$1().int()).optional()
    })
  )
);
var textEditor_20250124 = createProviderDefinedToolFactory({
  id: "anthropic.text_editor_20250124",
  name: "str_replace_editor",
  inputSchema: textEditor_20250124InputSchema
});
var textEditor_20250429InputSchema = lazySchema(
  () => zodSchema(
    object({
      command: _enum(["view", "create", "str_replace", "insert"]),
      path: string(),
      file_text: string().optional(),
      insert_line: number$1().int().optional(),
      new_str: string().optional(),
      old_str: string().optional(),
      view_range: array(number$1().int()).optional()
    })
  )
);
var textEditor_20250429 = createProviderDefinedToolFactory({
  id: "anthropic.text_editor_20250429",
  name: "str_replace_based_edit_tool",
  inputSchema: textEditor_20250429InputSchema
});

// src/anthropic-tools.ts
var anthropicTools = {
  /**
   * The bash tool enables Claude to execute shell commands in a persistent bash session,
   * allowing system operations, script execution, and command-line automation.
   *
   * Image results are supported.
   *
   * Tool name must be `bash`.
   */
  bash_20241022,
  /**
   * The bash tool enables Claude to execute shell commands in a persistent bash session,
   * allowing system operations, script execution, and command-line automation.
   *
   * Image results are supported.
   *
   * Tool name must be `bash`.
   */
  bash_20250124,
  /**
   * Claude can analyze data, create visualizations, perform complex calculations,
   * run system commands, create and edit files, and process uploaded files directly within
   * the API conversation.
   *
   * The code execution tool allows Claude to run Bash commands and manipulate files,
   * including writing code, in a secure, sandboxed environment.
   *
   * Tool name must be `code_execution`.
   */
  codeExecution_20250522,
  /**
   * Claude can analyze data, create visualizations, perform complex calculations,
   * run system commands, create and edit files, and process uploaded files directly within
   * the API conversation.
   *
   * The code execution tool allows Claude to run both Python and Bash commands and manipulate files,
   * including writing code, in a secure, sandboxed environment.
   *
   * This is the latest version with enhanced Bash support and file operations.
   *
   * Tool name must be `code_execution`.
   */
  codeExecution_20250825,
  /**
   * Claude can interact with computer environments through the computer use tool, which
   * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
   *
   * Image results are supported.
   *
   * Tool name must be `computer`.
   *
   * @param displayWidthPx - The width of the display being controlled by the model in pixels.
   * @param displayHeightPx - The height of the display being controlled by the model in pixels.
   * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
   */
  computer_20241022,
  /**
   * Claude can interact with computer environments through the computer use tool, which
   * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
   *
   * Image results are supported.
   *
   * Tool name must be `computer`.
   *
   * @param displayWidthPx - The width of the display being controlled by the model in pixels.
   * @param displayHeightPx - The height of the display being controlled by the model in pixels.
   * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
   */
  computer_20250124,
  /**
   * The memory tool enables Claude to store and retrieve information across conversations through a memory file directory.
   * Claude can create, read, update, and delete files that persist between sessions,
   * allowing it to build knowledge over time without keeping everything in the context window.
   * The memory tool operates client-sideyou control where and how the data is stored through your own infrastructure.
   *
   * Supported models: Claude Sonnet 4.5, Claude Sonnet 4, Claude Opus 4.1, Claude Opus 4.
   *
   * Tool name must be `memory`.
   */
  memory_20250818,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Supported models: Claude Sonnet 3.5
   *
   * Tool name must be `str_replace_editor`.
   */
  textEditor_20241022,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Supported models: Claude Sonnet 3.7
   *
   * Tool name must be `str_replace_editor`.
   */
  textEditor_20250124,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Note: This version does not support the "undo_edit" command.
   *
   * Tool name must be `str_replace_based_edit_tool`.
   *
   * @deprecated Use textEditor_20250728 instead
   */
  textEditor_20250429,
  /**
   * Claude can use an Anthropic-defined text editor tool to view and modify text files,
   * helping you debug, fix, and improve your code or other text documents. This allows Claude
   * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
   *
   * Note: This version does not support the "undo_edit" command and adds optional max_characters parameter.
   *
   * Supported models: Claude Sonnet 4, Opus 4, and Opus 4.1
   *
   * Tool name must be `str_replace_based_edit_tool`.
   *
   * @param maxCharacters - Optional maximum number of characters to view in the file
   */
  textEditor_20250728,
  /**
   * Creates a web fetch tool that gives Claude direct access to real-time web content.
   *
   * Tool name must be `web_fetch`.
   *
   * @param maxUses - The max_uses parameter limits the number of web fetches performed
   * @param allowedDomains - Only fetch from these domains
   * @param blockedDomains - Never fetch from these domains
   * @param citations - Unlike web search where citations are always enabled, citations are optional for web fetch. Set "citations": {"enabled": true} to enable Claude to cite specific passages from fetched documents.
   * @param maxContentTokens - The max_content_tokens parameter limits the amount of content that will be included in the context.
   */
  webFetch_20250910,
  /**
   * Creates a web search tool that gives Claude direct access to real-time web content.
   *
   * Tool name must be `web_search`.
   *
   * @param maxUses - Maximum number of web searches Claude can perform during the conversation.
   * @param allowedDomains - Optional list of domains that Claude is allowed to search.
   * @param blockedDomains - Optional list of domains that Claude should avoid when searching.
   * @param userLocation - Optional user location information to provide geographically relevant search results.
   */
  webSearch_20250305
};

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise, SuppressedError, Symbol, Iterator */


function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

const fromUtf8$1 = (input) => new TextEncoder().encode(input);

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
// Quick polyfill
typeof Buffer !== "undefined" && Buffer.from
    ? function (input) { return Buffer.from(input, "utf8"); }
    : fromUtf8$1;

// Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
// IE 11 does not support Array.from, so we do it manually
function uint32ArrayFrom(a_lookUpTable) {
    if (!Uint32Array.from) {
        var return_array = new Uint32Array(a_lookUpTable.length);
        var a_index = 0;
        while (a_index < a_lookUpTable.length) {
            return_array[a_index] = a_lookUpTable[a_index];
            a_index += 1;
        }
        return return_array;
    }
    return Uint32Array.from(a_lookUpTable);
}

var Crc32 = /** @class */ (function () {
    function Crc32() {
        this.checksum = 0xffffffff;
    }
    Crc32.prototype.update = function (data) {
        var e_1, _a;
        try {
            for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var byte = data_1_1.value;
                this.checksum =
                    (this.checksum >>> 8) ^ lookupTable[(this.checksum ^ byte) & 0xff];
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this;
    };
    Crc32.prototype.digest = function () {
        return (this.checksum ^ 0xffffffff) >>> 0;
    };
    return Crc32;
}());
// prettier-ignore
var a_lookUpTable = [
    0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
    0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
    0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
    0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
    0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
    0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
    0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
    0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
    0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
    0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
    0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
    0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
    0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
    0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
    0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
    0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
    0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
    0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
    0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
    0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
    0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
    0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
    0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
    0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
    0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
    0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
    0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
    0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
    0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
    0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
    0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
    0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
    0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
    0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
    0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
    0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
    0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
    0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
    0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
    0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
    0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
    0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
    0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
    0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
    0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
    0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
    0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
    0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
    0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
    0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
    0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
    0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
    0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
    0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
    0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
    0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
    0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
    0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
    0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
    0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
    0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
    0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
    0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
    0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,
];
var lookupTable = uint32ArrayFrom(a_lookUpTable);

const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for (let i = 0; i < 256; i++) {
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for (let i = 0; i < encoded.length; i += 2) {
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        }
        else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
function toHex(bytes) {
    let out = "";
    for (let i = 0; i < bytes.byteLength; i++) {
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}

class Int64 {
    constructor(bytes) {
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
            throw new Error("Int64 buffers must be exactly 8 bytes");
        }
    }
    static fromNumber(number) {
        if (number > 9223372036854776000 || number < -9223372036854776e3) {
            throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
            bytes[i] = remaining;
        }
        if (number < 0) {
            negate(bytes);
        }
        return new Int64(bytes);
    }
    valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 0b10000000;
        if (negative) {
            negate(bytes);
        }
        return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
        return String(this.valueOf());
    }
}
function negate(bytes) {
    for (let i = 0; i < 8; i++) {
        bytes[i] ^= 0xff;
    }
    for (let i = 7; i > -1; i--) {
        bytes[i]++;
        if (bytes[i] !== 0)
            break;
    }
}

class HeaderMarshaller {
    constructor(toUtf8, fromUtf8) {
        this.toUtf8 = toUtf8;
        this.fromUtf8 = fromUtf8;
    }
    format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)) {
            const bytes = this.fromUtf8(headerName);
            chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks) {
            out.set(chunk, position);
            position += chunk.byteLength;
        }
        return out;
    }
    formatHeaderValue(header) {
        switch (header.type) {
            case "boolean":
                return Uint8Array.from([header.value ? 0 : 1]);
            case "byte":
                return Uint8Array.from([2, header.value]);
            case "short":
                const shortView = new DataView(new ArrayBuffer(3));
                shortView.setUint8(0, 3);
                shortView.setInt16(1, header.value, false);
                return new Uint8Array(shortView.buffer);
            case "integer":
                const intView = new DataView(new ArrayBuffer(5));
                intView.setUint8(0, 4);
                intView.setInt32(1, header.value, false);
                return new Uint8Array(intView.buffer);
            case "long":
                const longBytes = new Uint8Array(9);
                longBytes[0] = 5;
                longBytes.set(header.value.bytes, 1);
                return longBytes;
            case "binary":
                const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
                binView.setUint8(0, 6);
                binView.setUint16(1, header.value.byteLength, false);
                const binBytes = new Uint8Array(binView.buffer);
                binBytes.set(header.value, 3);
                return binBytes;
            case "string":
                const utf8Bytes = this.fromUtf8(header.value);
                const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
                strView.setUint8(0, 7);
                strView.setUint16(1, utf8Bytes.byteLength, false);
                const strBytes = new Uint8Array(strView.buffer);
                strBytes.set(utf8Bytes, 3);
                return strBytes;
            case "timestamp":
                const tsBytes = new Uint8Array(9);
                tsBytes[0] = 8;
                tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
                return tsBytes;
            case "uuid":
                if (!UUID_PATTERN.test(header.value)) {
                    throw new Error(`Invalid UUID received: ${header.value}`);
                }
                const uuidBytes = new Uint8Array(17);
                uuidBytes[0] = 9;
                uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
                return uuidBytes;
        }
    }
    parse(headers) {
        const out = {};
        let position = 0;
        while (position < headers.byteLength) {
            const nameLength = headers.getUint8(position++);
            const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
            position += nameLength;
            switch (headers.getUint8(position++)) {
                case 0:
                    out[name] = {
                        type: BOOLEAN_TAG,
                        value: true,
                    };
                    break;
                case 1:
                    out[name] = {
                        type: BOOLEAN_TAG,
                        value: false,
                    };
                    break;
                case 2:
                    out[name] = {
                        type: BYTE_TAG,
                        value: headers.getInt8(position++),
                    };
                    break;
                case 3:
                    out[name] = {
                        type: SHORT_TAG,
                        value: headers.getInt16(position, false),
                    };
                    position += 2;
                    break;
                case 4:
                    out[name] = {
                        type: INT_TAG,
                        value: headers.getInt32(position, false),
                    };
                    position += 4;
                    break;
                case 5:
                    out[name] = {
                        type: LONG_TAG,
                        value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)),
                    };
                    position += 8;
                    break;
                case 6:
                    const binaryLength = headers.getUint16(position, false);
                    position += 2;
                    out[name] = {
                        type: BINARY_TAG,
                        value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength),
                    };
                    position += binaryLength;
                    break;
                case 7:
                    const stringLength = headers.getUint16(position, false);
                    position += 2;
                    out[name] = {
                        type: STRING_TAG,
                        value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength)),
                    };
                    position += stringLength;
                    break;
                case 8:
                    out[name] = {
                        type: TIMESTAMP_TAG,
                        value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf()),
                    };
                    position += 8;
                    break;
                case 9:
                    const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
                    position += 16;
                    out[name] = {
                        type: UUID_TAG,
                        value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`,
                    };
                    break;
                default:
                    throw new Error(`Unrecognized header type tag`);
            }
        }
        return out;
    }
}
var HEADER_VALUE_TYPE;
(function (HEADER_VALUE_TYPE) {
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolTrue"] = 0] = "boolTrue";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolFalse"] = 1] = "boolFalse";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byte"] = 2] = "byte";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["short"] = 3] = "short";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["integer"] = 4] = "integer";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["long"] = 5] = "long";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byteArray"] = 6] = "byteArray";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["string"] = 7] = "string";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["timestamp"] = 8] = "timestamp";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
const BOOLEAN_TAG = "boolean";
const BYTE_TAG = "byte";
const SHORT_TAG = "short";
const INT_TAG = "integer";
const LONG_TAG = "long";
const BINARY_TAG = "binary";
const STRING_TAG = "string";
const TIMESTAMP_TAG = "timestamp";
const UUID_TAG = "uuid";
const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

const PRELUDE_MEMBER_LENGTH = 4;
const PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
const CHECKSUM_LENGTH = 4;
const MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
function splitMessage({ byteLength, byteOffset, buffer }) {
    if (byteLength < MINIMUM_MESSAGE_LENGTH) {
        throw new Error("Provided message too short to accommodate event stream message overhead");
    }
    const view = new DataView(buffer, byteOffset, byteLength);
    const messageLength = view.getUint32(0, false);
    if (byteLength !== messageLength) {
        throw new Error("Reported message length does not match received message length");
    }
    const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
    const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
    const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
    const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
    if (expectedPreludeChecksum !== checksummer.digest()) {
        throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
    }
    checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
    if (expectedMessageChecksum !== checksummer.digest()) {
        throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
    }
    return {
        headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
        body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH)),
    };
}

class EventStreamCodec {
    constructor(toUtf8, fromUtf8) {
        this.headerMarshaller = new HeaderMarshaller(toUtf8, fromUtf8);
        this.messageBuffer = [];
        this.isEndOfStream = false;
    }
    feed(message) {
        this.messageBuffer.push(this.decode(message));
    }
    endOfStream() {
        this.isEndOfStream = true;
    }
    getMessage() {
        const message = this.messageBuffer.pop();
        const isEndOfStream = this.isEndOfStream;
        return {
            getMessage() {
                return message;
            },
            isEndOfStream() {
                return isEndOfStream;
            },
        };
    }
    getAvailableMessages() {
        const messages = this.messageBuffer;
        this.messageBuffer = [];
        const isEndOfStream = this.isEndOfStream;
        return {
            getMessages() {
                return messages;
            },
            isEndOfStream() {
                return isEndOfStream;
            },
        };
    }
    encode({ headers: rawHeaders, body }) {
        const headers = this.headerMarshaller.format(rawHeaders);
        const length = headers.byteLength + body.byteLength + 16;
        const out = new Uint8Array(length);
        const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        const checksum = new Crc32();
        view.setUint32(0, length, false);
        view.setUint32(4, headers.byteLength, false);
        view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
        out.set(headers, 12);
        out.set(body, headers.byteLength + 12);
        view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
        return out;
    }
    decode(message) {
        const { headers, body } = splitMessage(message);
        return { headers: this.headerMarshaller.parse(headers), body };
    }
    formatHeaders(rawHeaders) {
        return this.headerMarshaller.format(rawHeaders);
    }
}

const fromUtf8 = (input) => new TextEncoder().encode(input);

const toUtf8 = (input) => {
    if (typeof input === "string") {
        return input;
    }
    if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
        throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
    }
    return new TextDecoder("utf-8").decode(input);
};

/**
 * @license MIT <https://opensource.org/licenses/MIT>
 * @copyright Michael Hart 2024
 */
const encoder = new TextEncoder();
const HOST_SERVICES = {
  appstream2: 'appstream',
  cloudhsmv2: 'cloudhsm',
  email: 'ses',
  marketplace: 'aws-marketplace',
  mobile: 'AWSMobileHubService',
  pinpoint: 'mobiletargeting',
  queue: 'sqs',
  'git-codecommit': 'codecommit',
  'mturk-requester-sandbox': 'mturk-requester',
  'personalize-runtime': 'personalize',
};
const UNSIGNABLE_HEADERS = new Set([
  'authorization',
  'content-type',
  'content-length',
  'user-agent',
  'presigned-expires',
  'expect',
  'x-amzn-trace-id',
  'range',
  'connection',
]);
class AwsV4Signer {
  constructor({ method, url, headers, body, accessKeyId, secretAccessKey, sessionToken, service, region, cache, datetime, signQuery, appendSessionToken, allHeaders, singleEncode }) {
    if (url == null) throw new TypeError('url is a required option')
    if (accessKeyId == null) throw new TypeError('accessKeyId is a required option')
    if (secretAccessKey == null) throw new TypeError('secretAccessKey is a required option')
    this.method = method || (body ? 'POST' : 'GET');
    this.url = new URL(url);
    this.headers = new Headers(headers || {});
    this.body = body;
    this.accessKeyId = accessKeyId;
    this.secretAccessKey = secretAccessKey;
    this.sessionToken = sessionToken;
    let guessedService, guessedRegion;
    if (!service || !region) {
[guessedService, guessedRegion] = guessServiceRegion(this.url, this.headers);
    }
    this.service = service || guessedService || '';
    this.region = region || guessedRegion || 'us-east-1';
    this.cache = cache || new Map();
    this.datetime = datetime || new Date().toISOString().replace(/[:-]|\.\d{3}/g, '');
    this.signQuery = signQuery;
    this.appendSessionToken = appendSessionToken || this.service === 'iotdevicegateway';
    this.headers.delete('Host');
    if (this.service === 's3' && !this.signQuery && !this.headers.has('X-Amz-Content-Sha256')) {
      this.headers.set('X-Amz-Content-Sha256', 'UNSIGNED-PAYLOAD');
    }
    const params = this.signQuery ? this.url.searchParams : this.headers;
    params.set('X-Amz-Date', this.datetime);
    if (this.sessionToken && !this.appendSessionToken) {
      params.set('X-Amz-Security-Token', this.sessionToken);
    }
    this.signableHeaders = ['host', ...this.headers.keys()]
      .filter(header => allHeaders || !UNSIGNABLE_HEADERS.has(header))
      .sort();
    this.signedHeaders = this.signableHeaders.join(';');
    this.canonicalHeaders = this.signableHeaders
      .map(header => header + ':' + (header === 'host' ? this.url.host : (this.headers.get(header) || '').replace(/\s+/g, ' ')))
      .join('\n');
    this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, 'aws4_request'].join('/');
    if (this.signQuery) {
      if (this.service === 's3' && !params.has('X-Amz-Expires')) {
        params.set('X-Amz-Expires', '86400');
      }
      params.set('X-Amz-Algorithm', 'AWS4-HMAC-SHA256');
      params.set('X-Amz-Credential', this.accessKeyId + '/' + this.credentialString);
      params.set('X-Amz-SignedHeaders', this.signedHeaders);
    }
    if (this.service === 's3') {
      try {
        this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\+/g, ' '));
      } catch (e) {
        this.encodedPath = this.url.pathname;
      }
    } else {
      this.encodedPath = this.url.pathname.replace(/\/+/g, '/');
    }
    if (!singleEncode) {
      this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, '/');
    }
    this.encodedPath = encodeRfc3986(this.encodedPath);
    const seenKeys = new Set();
    this.encodedSearch = [...this.url.searchParams]
      .filter(([k]) => {
        if (!k) return false
        if (this.service === 's3') {
          if (seenKeys.has(k)) return false
          seenKeys.add(k);
        }
        return true
      })
      .map(pair => pair.map(p => encodeRfc3986(encodeURIComponent(p))))
      .sort(([k1, v1], [k2, v2]) => k1 < k2 ? -1 : k1 > k2 ? 1 : v1 < v2 ? -1 : v1 > v2 ? 1 : 0)
      .map(pair => pair.join('='))
      .join('&');
  }
  async sign() {
    if (this.signQuery) {
      this.url.searchParams.set('X-Amz-Signature', await this.signature());
      if (this.sessionToken && this.appendSessionToken) {
        this.url.searchParams.set('X-Amz-Security-Token', this.sessionToken);
      }
    } else {
      this.headers.set('Authorization', await this.authHeader());
    }
    return {
      method: this.method,
      url: this.url,
      headers: this.headers,
      body: this.body,
    }
  }
  async authHeader() {
    return [
      'AWS4-HMAC-SHA256 Credential=' + this.accessKeyId + '/' + this.credentialString,
      'SignedHeaders=' + this.signedHeaders,
      'Signature=' + (await this.signature()),
    ].join(', ')
  }
  async signature() {
    const date = this.datetime.slice(0, 8);
    const cacheKey = [this.secretAccessKey, date, this.region, this.service].join();
    let kCredentials = this.cache.get(cacheKey);
    if (!kCredentials) {
      const kDate = await hmac('AWS4' + this.secretAccessKey, date);
      const kRegion = await hmac(kDate, this.region);
      const kService = await hmac(kRegion, this.service);
      kCredentials = await hmac(kService, 'aws4_request');
      this.cache.set(cacheKey, kCredentials);
    }
    return buf2hex(await hmac(kCredentials, await this.stringToSign()))
  }
  async stringToSign() {
    return [
      'AWS4-HMAC-SHA256',
      this.datetime,
      this.credentialString,
      buf2hex(await hash(await this.canonicalString())),
    ].join('\n')
  }
  async canonicalString() {
    return [
      this.method.toUpperCase(),
      this.encodedPath,
      this.encodedSearch,
      this.canonicalHeaders + '\n',
      this.signedHeaders,
      await this.hexBodyHash(),
    ].join('\n')
  }
  async hexBodyHash() {
    let hashHeader = this.headers.get('X-Amz-Content-Sha256') || (this.service === 's3' && this.signQuery ? 'UNSIGNED-PAYLOAD' : null);
    if (hashHeader == null) {
      if (this.body && typeof this.body !== 'string' && !('byteLength' in this.body)) {
        throw new Error('body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header')
      }
      hashHeader = buf2hex(await hash(this.body || ''));
    }
    return hashHeader
  }
}
async function hmac(key, string) {
  const cryptoKey = await crypto.subtle.importKey(
    'raw',
    typeof key === 'string' ? encoder.encode(key) : key,
    { name: 'HMAC', hash: { name: 'SHA-256' } },
    false,
    ['sign'],
  );
  return crypto.subtle.sign('HMAC', cryptoKey, encoder.encode(string))
}
async function hash(content) {
  return crypto.subtle.digest('SHA-256', typeof content === 'string' ? encoder.encode(content) : content)
}
const HEX_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
function buf2hex(arrayBuffer) {
  const buffer = new Uint8Array(arrayBuffer);
  let out = '';
  for (let idx = 0; idx < buffer.length; idx++) {
    const n = buffer[idx];
    out += HEX_CHARS[(n >>> 4) & 0xF];
    out += HEX_CHARS[n & 0xF];
  }
  return out
}
function encodeRfc3986(urlEncodedStr) {
  return urlEncodedStr.replace(/[!'()*]/g, c => '%' + c.charCodeAt(0).toString(16).toUpperCase())
}
function guessServiceRegion(url, headers) {
  const { hostname, pathname } = url;
  if (hostname.endsWith('.on.aws')) {
    const match = hostname.match(/^[^.]{1,63}\.lambda-url\.([^.]{1,63})\.on\.aws$/);
    return match != null ? ['lambda', match[1] || ''] : ['', '']
  }
  if (hostname.endsWith('.r2.cloudflarestorage.com')) {
    return ['s3', 'auto']
  }
  if (hostname.endsWith('.backblazeb2.com')) {
    const match = hostname.match(/^(?:[^.]{1,63}\.)?s3\.([^.]{1,63})\.backblazeb2\.com$/);
    return match != null ? ['s3', match[1] || ''] : ['', '']
  }
  const match = hostname.replace('dualstack.', '').match(/([^.]{1,63})\.(?:([^.]{0,63})\.)?amazonaws\.com(?:\.cn)?$/);
  let service = (match && match[1]) || '';
  let region = match && match[2];
  if (region === 'us-gov') {
    region = 'us-gov-west-1';
  } else if (region === 's3' || region === 's3-accelerate') {
    region = 'us-east-1';
    service = 's3';
  } else if (service === 'iot') {
    if (hostname.startsWith('iot.')) {
      service = 'execute-api';
    } else if (hostname.startsWith('data.jobs.iot.')) {
      service = 'iot-jobs-data';
    } else {
      service = pathname === '/mqtt' ? 'iotdevicegateway' : 'iotdata';
    }
  } else if (service === 'autoscaling') {
    const targetPrefix = (headers.get('X-Amz-Target') || '').split('.')[0];
    if (targetPrefix === 'AnyScaleFrontendService') {
      service = 'application-autoscaling';
    } else if (targetPrefix === 'AnyScaleScalingPlannerFrontendService') {
      service = 'autoscaling-plans';
    }
  } else if (region == null && service.startsWith('s3-')) {
    region = service.slice(3).replace(/^fips-|^external-1/, '');
    service = 's3';
  } else if (service.endsWith('-fips')) {
    service = service.slice(0, -5);
  } else if (region && /-\d$/.test(service) && !/-\d$/.test(region)) {
[service, region] = [region, service];
  }
  return [HOST_SERVICES[service] || service, region || '']
}

// src/bedrock-provider.ts

// src/version.ts
var VERSION$1 = "3.0.43" ;

// src/bedrock-api-types.ts
var BEDROCK_CACHE_POINT = {
  cachePoint: { type: "default" }
};
var BEDROCK_STOP_REASONS = [
  "stop",
  "stop_sequence",
  "end_turn",
  "length",
  "max_tokens",
  "content-filter",
  "content_filtered",
  "guardrail_intervened",
  "tool-calls",
  "tool_use"
];
var BEDROCK_IMAGE_MIME_TYPES = {
  "image/jpeg": "jpeg",
  "image/png": "png",
  "image/gif": "gif",
  "image/webp": "webp"
};
var BEDROCK_DOCUMENT_MIME_TYPES = {
  "application/pdf": "pdf",
  "text/csv": "csv",
  "application/msword": "doc",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
  "application/vnd.ms-excel": "xls",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
  "text/html": "html",
  "text/plain": "txt",
  "text/markdown": "md"
};
var bedrockFilePartProviderOptions = object({
  /**
   * Citation configuration for this document.
   * When enabled, this document will generate citations in the response.
   */
  citations: object({
    /**
     * Enable citations for this document
     */
    enabled: boolean()
  }).optional()
});
var bedrockProviderOptions = object({
  /**
   * Additional inference parameters that the model supports,
   * beyond the base set of inference parameters that Converse
   * supports in the inferenceConfig field
   */
  additionalModelRequestFields: record(string(), any()).optional(),
  reasoningConfig: object({
    type: union([literal("enabled"), literal("disabled")]).optional(),
    budgetTokens: number$1().optional()
  }).optional()
});
var BedrockErrorSchema = object({
  message: string(),
  type: string().nullish()
});
var createBedrockEventStreamResponseHandler = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders$1(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError$1({});
  }
  const codec = new EventStreamCodec(toUtf8, fromUtf8);
  let buffer = new Uint8Array(0);
  const textDecoder = new TextDecoder();
  return {
    responseHeaders,
    value: response.body.pipeThrough(
      new TransformStream({
        async transform(chunk, controller) {
          var _a, _b;
          const newBuffer = new Uint8Array(buffer.length + chunk.length);
          newBuffer.set(buffer);
          newBuffer.set(chunk, buffer.length);
          buffer = newBuffer;
          while (buffer.length >= 4) {
            const totalLength = new DataView(
              buffer.buffer,
              buffer.byteOffset,
              buffer.byteLength
            ).getUint32(0, false);
            if (buffer.length < totalLength) {
              break;
            }
            try {
              const subView = buffer.subarray(0, totalLength);
              const decoded = codec.decode(subView);
              buffer = buffer.slice(totalLength);
              if (((_a = decoded.headers[":message-type"]) == null ? void 0 : _a.value) === "event") {
                const data = textDecoder.decode(decoded.body);
                const parsedDataResult = await safeParseJSON$1({ text: data });
                if (!parsedDataResult.success) {
                  controller.enqueue(parsedDataResult);
                  break;
                }
                delete parsedDataResult.value.p;
                let wrappedData = {
                  [(_b = decoded.headers[":event-type"]) == null ? void 0 : _b.value]: parsedDataResult.value
                };
                const validatedWrappedData = await safeValidateTypes$1({
                  value: wrappedData,
                  schema: chunkSchema
                });
                if (!validatedWrappedData.success) {
                  controller.enqueue(validatedWrappedData);
                } else {
                  controller.enqueue({
                    success: true,
                    value: validatedWrappedData.value,
                    rawValue: wrappedData
                  });
                }
              }
            } catch (e) {
              break;
            }
          }
        }
      })
    )
  };
};
async function prepareTools$1({
  tools,
  toolChoice,
  modelId
}) {
  const toolWarnings = [];
  const betas = /* @__PURE__ */ new Set();
  if (tools == null || tools.length === 0) {
    return {
      toolConfig: {},
      additionalTools: void 0,
      betas,
      toolWarnings
    };
  }
  const supportedTools = tools.filter((tool) => {
    if (tool.type === "provider-defined" && tool.id === "anthropic.web_search_20250305") {
      toolWarnings.push({
        type: "unsupported-tool",
        tool,
        details: "The web_search_20250305 tool is not supported on Amazon Bedrock."
      });
      return false;
    }
    return true;
  });
  if (supportedTools.length === 0) {
    return {
      toolConfig: {},
      additionalTools: void 0,
      betas,
      toolWarnings
    };
  }
  const isAnthropicModel = modelId.includes("anthropic.");
  const providerDefinedTools = supportedTools.filter(
    (t) => t.type === "provider-defined"
  );
  const functionTools = supportedTools.filter((t) => t.type === "function");
  let additionalTools = void 0;
  const bedrockTools = [];
  const usingAnthropicTools = isAnthropicModel && providerDefinedTools.length > 0;
  if (usingAnthropicTools) {
    if (functionTools.length > 0) {
      toolWarnings.push({
        type: "unsupported-setting",
        setting: "tools",
        details: "Mixed Anthropic provider-defined tools and standard function tools are not supported in a single call to Bedrock. Only Anthropic tools will be used."
      });
    }
    const {
      toolChoice: preparedAnthropicToolChoice,
      toolWarnings: anthropicToolWarnings,
      betas: anthropicBetas
    } = await prepareTools$2({
      tools: providerDefinedTools,
      toolChoice
    });
    toolWarnings.push(...anthropicToolWarnings);
    anthropicBetas.forEach((beta) => betas.add(beta));
    if (preparedAnthropicToolChoice) {
      additionalTools = {
        tool_choice: preparedAnthropicToolChoice
      };
    }
    for (const tool of providerDefinedTools) {
      const toolFactory = Object.values(anthropicTools).find((factory) => {
        const instance = factory({});
        return instance.id === tool.id;
      });
      if (toolFactory != null) {
        const fullToolDefinition = toolFactory({});
        bedrockTools.push({
          toolSpec: {
            name: tool.name,
            inputSchema: {
              json: asSchema(fullToolDefinition.inputSchema).jsonSchema
            }
          }
        });
      } else {
        toolWarnings.push({ type: "unsupported-tool", tool });
      }
    }
  } else {
    for (const tool of providerDefinedTools) {
      toolWarnings.push({ type: "unsupported-tool", tool });
    }
  }
  for (const tool of functionTools) {
    bedrockTools.push({
      toolSpec: {
        name: tool.name,
        description: tool.description,
        inputSchema: {
          json: tool.inputSchema
        }
      }
    });
  }
  let bedrockToolChoice = void 0;
  if (!usingAnthropicTools && bedrockTools.length > 0 && toolChoice) {
    const type = toolChoice.type;
    switch (type) {
      case "auto":
        bedrockToolChoice = { auto: {} };
        break;
      case "required":
        bedrockToolChoice = { any: {} };
        break;
      case "none":
        bedrockTools.length = 0;
        bedrockToolChoice = void 0;
        break;
      case "tool":
        bedrockToolChoice = { tool: { name: toolChoice.toolName } };
        break;
      default: {
        const _exhaustiveCheck = type;
        throw new UnsupportedFunctionalityError$1({
          functionality: `tool choice type: ${_exhaustiveCheck}`
        });
      }
    }
  }
  const toolConfig = bedrockTools.length > 0 ? { tools: bedrockTools, toolChoice: bedrockToolChoice } : {};
  return {
    toolConfig,
    additionalTools,
    betas,
    toolWarnings
  };
}
function getCachePoint(providerMetadata) {
  var _a;
  return (_a = providerMetadata == null ? void 0 : providerMetadata.bedrock) == null ? void 0 : _a.cachePoint;
}
async function shouldEnableCitations(providerMetadata) {
  var _a, _b;
  const bedrockOptions = await parseProviderOptions({
    provider: "bedrock",
    providerOptions: providerMetadata,
    schema: bedrockFilePartProviderOptions
  });
  return (_b = (_a = bedrockOptions == null ? void 0 : bedrockOptions.citations) == null ? void 0 : _a.enabled) != null ? _b : false;
}
async function convertToBedrockChatMessages(prompt) {
  var _a;
  const blocks = groupIntoBlocks(prompt);
  let system = [];
  const messages = [];
  let documentCounter = 0;
  const generateDocumentName = () => `document-${++documentCounter}`;
  for (let i = 0; i < blocks.length; i++) {
    const block = blocks[i];
    const isLastBlock = i === blocks.length - 1;
    const type = block.type;
    switch (type) {
      case "system": {
        if (messages.length > 0) {
          throw new UnsupportedFunctionalityError$1({
            functionality: "Multiple system messages that are separated by user/assistant messages"
          });
        }
        for (const message of block.messages) {
          system.push({ text: message.content });
          if (getCachePoint(message.providerOptions)) {
            system.push(BEDROCK_CACHE_POINT);
          }
        }
        break;
      }
      case "user": {
        const bedrockContent = [];
        for (const message of block.messages) {
          const { role, content, providerOptions } = message;
          switch (role) {
            case "user": {
              for (let j = 0; j < content.length; j++) {
                const part = content[j];
                switch (part.type) {
                  case "text": {
                    bedrockContent.push({
                      text: part.text
                    });
                    break;
                  }
                  case "file": {
                    if (part.data instanceof URL) {
                      throw new UnsupportedFunctionalityError$1({
                        functionality: "File URL data"
                      });
                    }
                    if (part.mediaType.startsWith("image/")) {
                      bedrockContent.push({
                        image: {
                          format: getBedrockImageFormat(part.mediaType),
                          source: { bytes: convertToBase64(part.data) }
                        }
                      });
                    } else {
                      if (!part.mediaType) {
                        throw new UnsupportedFunctionalityError$1({
                          functionality: "file without mime type",
                          message: "File mime type is required in user message part content"
                        });
                      }
                      const enableCitations = await shouldEnableCitations(
                        part.providerOptions
                      );
                      bedrockContent.push({
                        document: {
                          format: getBedrockDocumentFormat(part.mediaType),
                          name: (_a = part.filename) != null ? _a : generateDocumentName(),
                          source: { bytes: convertToBase64(part.data) },
                          ...enableCitations && {
                            citations: { enabled: true }
                          }
                        }
                      });
                    }
                    break;
                  }
                }
              }
              break;
            }
            case "tool": {
              for (const part of content) {
                let toolResultContent;
                const output = part.output;
                switch (output.type) {
                  case "content": {
                    toolResultContent = output.value.map((contentPart) => {
                      switch (contentPart.type) {
                        case "text":
                          return { text: contentPart.text };
                        case "media":
                          if (!contentPart.mediaType.startsWith("image/")) {
                            throw new UnsupportedFunctionalityError$1({
                              functionality: `media type: ${contentPart.mediaType}`
                            });
                          }
                          const format = getBedrockImageFormat(
                            contentPart.mediaType
                          );
                          return {
                            image: {
                              format,
                              source: { bytes: contentPart.data }
                            }
                          };
                      }
                    });
                    break;
                  }
                  case "text":
                  case "error-text":
                    toolResultContent = [{ text: output.value }];
                    break;
                  case "json":
                  case "error-json":
                  default:
                    toolResultContent = [
                      { text: JSON.stringify(output.value) }
                    ];
                    break;
                }
                bedrockContent.push({
                  toolResult: {
                    toolUseId: part.toolCallId,
                    content: toolResultContent
                  }
                });
              }
              break;
            }
            default: {
              const _exhaustiveCheck = role;
              throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
            }
          }
          if (getCachePoint(providerOptions)) {
            bedrockContent.push(BEDROCK_CACHE_POINT);
          }
        }
        messages.push({ role: "user", content: bedrockContent });
        break;
      }
      case "assistant": {
        const bedrockContent = [];
        for (let j = 0; j < block.messages.length; j++) {
          const message = block.messages[j];
          const isLastMessage = j === block.messages.length - 1;
          const { content } = message;
          for (let k = 0; k < content.length; k++) {
            const part = content[k];
            const isLastContentPart = k === content.length - 1;
            switch (part.type) {
              case "text": {
                if (!part.text.trim()) {
                  break;
                }
                bedrockContent.push({
                  text: (
                    // trim the last text part if it's the last message in the block
                    // because Bedrock does not allow trailing whitespace
                    // in pre-filled assistant responses
                    trimIfLast(
                      isLastBlock,
                      isLastMessage,
                      isLastContentPart,
                      part.text
                    )
                  )
                });
                break;
              }
              case "reasoning": {
                const reasoningMetadata = await parseProviderOptions({
                  provider: "bedrock",
                  providerOptions: part.providerOptions,
                  schema: bedrockReasoningMetadataSchema
                });
                if (reasoningMetadata != null) {
                  if (reasoningMetadata.signature != null) {
                    bedrockContent.push({
                      reasoningContent: {
                        reasoningText: {
                          // trim the last text part if it's the last message in the block
                          // because Bedrock does not allow trailing whitespace
                          // in pre-filled assistant responses
                          text: trimIfLast(
                            isLastBlock,
                            isLastMessage,
                            isLastContentPart,
                            part.text
                          ),
                          signature: reasoningMetadata.signature
                        }
                      }
                    });
                  } else if (reasoningMetadata.redactedData != null) {
                    bedrockContent.push({
                      reasoningContent: {
                        redactedReasoning: {
                          data: reasoningMetadata.redactedData
                        }
                      }
                    });
                  }
                }
                break;
              }
              case "tool-call": {
                bedrockContent.push({
                  toolUse: {
                    toolUseId: part.toolCallId,
                    name: part.toolName,
                    input: part.input
                  }
                });
                break;
              }
            }
          }
          if (getCachePoint(message.providerOptions)) {
            bedrockContent.push(BEDROCK_CACHE_POINT);
          }
        }
        messages.push({ role: "assistant", content: bedrockContent });
        break;
      }
      default: {
        const _exhaustiveCheck = type;
        throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
      }
    }
  }
  return { system, messages };
}
function getBedrockImageFormat(mimeType) {
  if (!mimeType) {
    throw new UnsupportedFunctionalityError$1({
      functionality: "image without mime type",
      message: "Image mime type is required in user message part content"
    });
  }
  const format = BEDROCK_IMAGE_MIME_TYPES[mimeType];
  if (!format) {
    throw new UnsupportedFunctionalityError$1({
      functionality: `image mime type: ${mimeType}`,
      message: `Unsupported image mime type: ${mimeType}, expected one of: ${Object.keys(BEDROCK_IMAGE_MIME_TYPES).join(", ")}`
    });
  }
  return format;
}
function getBedrockDocumentFormat(mimeType) {
  const format = BEDROCK_DOCUMENT_MIME_TYPES[mimeType];
  if (!format) {
    throw new UnsupportedFunctionalityError$1({
      functionality: `file mime type: ${mimeType}`,
      message: `Unsupported file mime type: ${mimeType}, expected one of: ${Object.keys(BEDROCK_DOCUMENT_MIME_TYPES).join(", ")}`
    });
  }
  return format;
}
function trimIfLast(isLastBlock, isLastMessage, isLastContentPart, text) {
  return isLastBlock && isLastMessage && isLastContentPart ? text.trim() : text;
}
function groupIntoBlocks(prompt) {
  const blocks = [];
  let currentBlock = void 0;
  for (const message of prompt) {
    const { role } = message;
    switch (role) {
      case "system": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "system") {
          currentBlock = { type: "system", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "assistant": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "assistant") {
          currentBlock = { type: "assistant", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "user": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      case "tool": {
        if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
          currentBlock = { type: "user", messages: [] };
          blocks.push(currentBlock);
        }
        currentBlock.messages.push(message);
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return blocks;
}

// src/map-bedrock-finish-reason.ts
function mapBedrockFinishReason(finishReason) {
  switch (finishReason) {
    case "stop_sequence":
    case "end_turn":
      return "stop";
    case "max_tokens":
      return "length";
    case "content_filtered":
    case "guardrail_intervened":
      return "content-filter";
    case "tool_use":
      return "tool-calls";
    default:
      return "unknown";
  }
}

// src/bedrock-chat-language-model.ts
var BedrockChatLanguageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.provider = "amazon-bedrock";
    this.supportedUrls = {
      // no supported urls for bedrock
    };
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences,
    responseFormat,
    seed,
    tools,
    toolChoice,
    providerOptions
  }) {
    var _a, _b, _c, _d, _e, _f;
    const bedrockOptions = (_a = await parseProviderOptions({
      provider: "bedrock",
      providerOptions,
      schema: bedrockProviderOptions
    })) != null ? _a : {};
    const warnings = [];
    if (frequencyPenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "frequencyPenalty"
      });
    }
    if (presencePenalty != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "presencePenalty"
      });
    }
    if (seed != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "seed"
      });
    }
    if (responseFormat != null && responseFormat.type !== "text" && responseFormat.type !== "json") {
      warnings.push({
        type: "unsupported-setting",
        setting: "responseFormat",
        details: "Only text and json response formats are supported."
      });
    }
    if (tools != null && (responseFormat == null ? void 0 : responseFormat.type) === "json") {
      if (tools.length > 0) {
        warnings.push({
          type: "other",
          message: "JSON response format does not support tools. The provided tools are ignored."
        });
      }
    }
    const jsonResponseTool = (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null ? {
      type: "function",
      name: "json",
      description: "Respond with a JSON object.",
      inputSchema: responseFormat.schema
    } : void 0;
    const { toolConfig, additionalTools, toolWarnings, betas } = await prepareTools$1({
      tools: jsonResponseTool ? [jsonResponseTool, ...tools != null ? tools : []] : tools,
      toolChoice: jsonResponseTool != null ? { type: "tool", toolName: jsonResponseTool.name } : toolChoice,
      modelId: this.modelId
    });
    warnings.push(...toolWarnings);
    if (additionalTools) {
      bedrockOptions.additionalModelRequestFields = {
        ...bedrockOptions.additionalModelRequestFields,
        ...additionalTools
      };
    }
    const isThinking = ((_b = bedrockOptions.reasoningConfig) == null ? void 0 : _b.type) === "enabled";
    const thinkingBudget = (_c = bedrockOptions.reasoningConfig) == null ? void 0 : _c.budgetTokens;
    const inferenceConfig = {
      ...maxOutputTokens != null && { maxTokens: maxOutputTokens },
      ...temperature != null && { temperature },
      ...topP != null && { topP },
      ...topK != null && { topK },
      ...stopSequences != null && { stopSequences }
    };
    if (isThinking && thinkingBudget != null) {
      if (inferenceConfig.maxTokens != null) {
        inferenceConfig.maxTokens += thinkingBudget;
      } else {
        inferenceConfig.maxTokens = thinkingBudget + 4096;
      }
      bedrockOptions.additionalModelRequestFields = {
        ...bedrockOptions.additionalModelRequestFields,
        thinking: {
          type: (_d = bedrockOptions.reasoningConfig) == null ? void 0 : _d.type,
          budget_tokens: thinkingBudget
        }
      };
    }
    if (isThinking && inferenceConfig.temperature != null) {
      delete inferenceConfig.temperature;
      warnings.push({
        type: "unsupported-setting",
        setting: "temperature",
        details: "temperature is not supported when thinking is enabled"
      });
    }
    if (isThinking && inferenceConfig.topP != null) {
      delete inferenceConfig.topP;
      warnings.push({
        type: "unsupported-setting",
        setting: "topP",
        details: "topP is not supported when thinking is enabled"
      });
    }
    if (isThinking && inferenceConfig.topK != null) {
      delete inferenceConfig.topK;
      warnings.push({
        type: "unsupported-setting",
        setting: "topK",
        details: "topK is not supported when thinking is enabled"
      });
    }
    const hasAnyTools = ((_f = (_e = toolConfig.tools) == null ? void 0 : _e.length) != null ? _f : 0) > 0 || additionalTools;
    let filteredPrompt = prompt;
    if (!hasAnyTools) {
      const hasToolContent = prompt.some(
        (message) => "content" in message && Array.isArray(message.content) && message.content.some(
          (part) => part.type === "tool-call" || part.type === "tool-result"
        )
      );
      if (hasToolContent) {
        filteredPrompt = prompt.map(
          (message) => message.role === "system" ? message : {
            ...message,
            content: message.content.filter(
              (part) => part.type !== "tool-call" && part.type !== "tool-result"
            )
          }
        ).filter(
          (message) => message.role === "system" || message.content.length > 0
        );
        warnings.push({
          type: "unsupported-setting",
          setting: "toolContent",
          details: "Tool calls and results removed from conversation because Bedrock does not support tool content without active tools."
        });
      }
    }
    const { system, messages } = await convertToBedrockChatMessages(filteredPrompt);
    const {
      reasoningConfig: _,
      additionalModelRequestFields: __,
      ...filteredBedrockOptions
    } = (providerOptions == null ? void 0 : providerOptions.bedrock) || {};
    return {
      command: {
        system,
        messages,
        additionalModelRequestFields: bedrockOptions.additionalModelRequestFields,
        ...Object.keys(inferenceConfig).length > 0 && {
          inferenceConfig
        },
        ...filteredBedrockOptions,
        ...toolConfig.tools !== void 0 && toolConfig.tools.length > 0 ? { toolConfig } : {}
      },
      warnings,
      usesJsonResponseTool: jsonResponseTool != null,
      betas
    };
  }
  async getHeaders({
    betas,
    headers
  }) {
    return combineHeaders$1(
      await resolve(this.config.headers),
      betas.size > 0 ? { "anthropic-beta": Array.from(betas).join(",") } : {},
      headers
    );
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    const {
      command: args,
      warnings,
      usesJsonResponseTool,
      betas
    } = await this.getArgs(options);
    const url = `${this.getUrl(this.modelId)}/converse`;
    const { value: response, responseHeaders } = await postJsonToApi$1({
      url,
      headers: await this.getHeaders({ betas, headers: options.headers }),
      body: args,
      failedResponseHandler: createJsonErrorResponseHandler$1({
        errorSchema: BedrockErrorSchema,
        errorToMessage: (error) => {
          var _a2;
          return `${(_a2 = error.message) != null ? _a2 : "Unknown error"}`;
        }
      }),
      successfulResponseHandler: createJsonResponseHandler$1(
        BedrockResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const content = [];
    for (const part of response.output.message.content) {
      if (part.text) {
        if (!usesJsonResponseTool) {
          content.push({ type: "text", text: part.text });
        }
      }
      if (part.reasoningContent) {
        if ("reasoningText" in part.reasoningContent) {
          const reasoning = {
            type: "reasoning",
            text: part.reasoningContent.reasoningText.text
          };
          if (part.reasoningContent.reasoningText.signature) {
            reasoning.providerMetadata = {
              bedrock: {
                signature: part.reasoningContent.reasoningText.signature
              }
            };
          }
          content.push(reasoning);
        } else if ("redactedReasoning" in part.reasoningContent) {
          content.push({
            type: "reasoning",
            text: "",
            providerMetadata: {
              bedrock: {
                redactedData: (_a = part.reasoningContent.redactedReasoning.data) != null ? _a : ""
              }
            }
          });
        }
      }
      if (part.toolUse) {
        content.push(
          // when a json response tool is used, the tool call becomes the text:
          usesJsonResponseTool ? {
            type: "text",
            text: JSON.stringify(part.toolUse.input)
          } : {
            type: "tool-call",
            toolCallId: (_c = (_b = part.toolUse) == null ? void 0 : _b.toolUseId) != null ? _c : this.config.generateId(),
            toolName: (_e = (_d = part.toolUse) == null ? void 0 : _d.name) != null ? _e : `tool-${this.config.generateId()}`,
            input: JSON.stringify((_g = (_f = part.toolUse) == null ? void 0 : _f.input) != null ? _g : "")
          }
        );
      }
    }
    const providerMetadata = response.trace || response.usage || usesJsonResponseTool ? {
      bedrock: {
        ...response.trace && typeof response.trace === "object" ? { trace: response.trace } : {},
        ...((_h = response.usage) == null ? void 0 : _h.cacheWriteInputTokens) != null && {
          usage: {
            cacheWriteInputTokens: response.usage.cacheWriteInputTokens
          }
        },
        ...usesJsonResponseTool && { isJsonResponseFromTool: true }
      }
    } : void 0;
    return {
      content,
      finishReason: mapBedrockFinishReason(
        response.stopReason
      ),
      usage: {
        inputTokens: (_i = response.usage) == null ? void 0 : _i.inputTokens,
        outputTokens: (_j = response.usage) == null ? void 0 : _j.outputTokens,
        totalTokens: ((_k = response.usage) == null ? void 0 : _k.inputTokens) + ((_l = response.usage) == null ? void 0 : _l.outputTokens),
        cachedInputTokens: (_n = (_m = response.usage) == null ? void 0 : _m.cacheReadInputTokens) != null ? _n : void 0
      },
      response: {
        // TODO add id, timestamp, etc
        headers: responseHeaders
      },
      warnings,
      ...providerMetadata && { providerMetadata }
    };
  }
  async doStream(options) {
    const {
      command: args,
      warnings,
      usesJsonResponseTool,
      betas
    } = await this.getArgs(options);
    const url = `${this.getUrl(this.modelId)}/converse-stream`;
    const { value: response, responseHeaders } = await postJsonToApi$1({
      url,
      headers: await this.getHeaders({ betas, headers: options.headers }),
      body: args,
      failedResponseHandler: createJsonErrorResponseHandler$1({
        errorSchema: BedrockErrorSchema,
        errorToMessage: (error) => `${error.type}: ${error.message}`
      }),
      successfulResponseHandler: createBedrockEventStreamResponseHandler(BedrockStreamSchema),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0
    };
    let providerMetadata = void 0;
    const contentBlocks = {};
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
            function enqueueError(bedrockError) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: bedrockError });
            }
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              enqueueError(chunk.error);
              return;
            }
            const value = chunk.value;
            if (value.internalServerException) {
              enqueueError(value.internalServerException);
              return;
            }
            if (value.modelStreamErrorException) {
              enqueueError(value.modelStreamErrorException);
              return;
            }
            if (value.throttlingException) {
              enqueueError(value.throttlingException);
              return;
            }
            if (value.validationException) {
              enqueueError(value.validationException);
              return;
            }
            if (value.messageStop) {
              finishReason = mapBedrockFinishReason(
                value.messageStop.stopReason
              );
            }
            if (value.metadata) {
              usage.inputTokens = (_b = (_a = value.metadata.usage) == null ? void 0 : _a.inputTokens) != null ? _b : usage.inputTokens;
              usage.outputTokens = (_d = (_c = value.metadata.usage) == null ? void 0 : _c.outputTokens) != null ? _d : usage.outputTokens;
              usage.totalTokens = ((_e = usage.inputTokens) != null ? _e : 0) + ((_f = usage.outputTokens) != null ? _f : 0);
              usage.cachedInputTokens = (_h = (_g = value.metadata.usage) == null ? void 0 : _g.cacheReadInputTokens) != null ? _h : usage.cachedInputTokens;
              const cacheUsage = ((_i = value.metadata.usage) == null ? void 0 : _i.cacheWriteInputTokens) != null ? {
                usage: {
                  cacheWriteInputTokens: value.metadata.usage.cacheWriteInputTokens
                }
              } : void 0;
              const trace = value.metadata.trace ? {
                trace: value.metadata.trace
              } : void 0;
              if (cacheUsage || trace || usesJsonResponseTool) {
                providerMetadata = {
                  bedrock: {
                    ...cacheUsage,
                    ...trace,
                    ...usesJsonResponseTool && {
                      isJsonResponseFromTool: true
                    }
                  }
                };
              }
            }
            if (((_j = value.contentBlockStart) == null ? void 0 : _j.contentBlockIndex) != null && !((_l = (_k = value.contentBlockStart) == null ? void 0 : _k.start) == null ? void 0 : _l.toolUse)) {
              const blockIndex = value.contentBlockStart.contentBlockIndex;
              contentBlocks[blockIndex] = { type: "text" };
              controller.enqueue({
                type: "text-start",
                id: String(blockIndex)
              });
            }
            if (((_m = value.contentBlockDelta) == null ? void 0 : _m.delta) && "text" in value.contentBlockDelta.delta && value.contentBlockDelta.delta.text) {
              const blockIndex = value.contentBlockDelta.contentBlockIndex || 0;
              if (contentBlocks[blockIndex] == null) {
                contentBlocks[blockIndex] = { type: "text" };
                if (!usesJsonResponseTool) {
                  controller.enqueue({
                    type: "text-start",
                    id: String(blockIndex)
                  });
                }
              }
              if (!usesJsonResponseTool) {
                controller.enqueue({
                  type: "text-delta",
                  id: String(blockIndex),
                  delta: value.contentBlockDelta.delta.text
                });
              }
            }
            if (((_n = value.contentBlockStop) == null ? void 0 : _n.contentBlockIndex) != null) {
              const blockIndex = value.contentBlockStop.contentBlockIndex;
              const contentBlock = contentBlocks[blockIndex];
              if (contentBlock != null) {
                if (contentBlock.type === "reasoning") {
                  controller.enqueue({
                    type: "reasoning-end",
                    id: String(blockIndex)
                  });
                } else if (contentBlock.type === "text") {
                  if (!usesJsonResponseTool) {
                    controller.enqueue({
                      type: "text-end",
                      id: String(blockIndex)
                    });
                  }
                } else if (contentBlock.type === "tool-call") {
                  if (usesJsonResponseTool) {
                    controller.enqueue({
                      type: "text-start",
                      id: String(blockIndex)
                    });
                    controller.enqueue({
                      type: "text-delta",
                      id: String(blockIndex),
                      delta: contentBlock.jsonText
                    });
                    controller.enqueue({
                      type: "text-end",
                      id: String(blockIndex)
                    });
                  } else {
                    controller.enqueue({
                      type: "tool-input-end",
                      id: contentBlock.toolCallId
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: contentBlock.toolCallId,
                      toolName: contentBlock.toolName,
                      input: contentBlock.jsonText
                    });
                  }
                }
                delete contentBlocks[blockIndex];
              }
            }
            if (((_o = value.contentBlockDelta) == null ? void 0 : _o.delta) && "reasoningContent" in value.contentBlockDelta.delta && value.contentBlockDelta.delta.reasoningContent) {
              const blockIndex = value.contentBlockDelta.contentBlockIndex || 0;
              const reasoningContent = value.contentBlockDelta.delta.reasoningContent;
              if ("text" in reasoningContent && reasoningContent.text) {
                if (contentBlocks[blockIndex] == null) {
                  contentBlocks[blockIndex] = { type: "reasoning" };
                  controller.enqueue({
                    type: "reasoning-start",
                    id: String(blockIndex)
                  });
                }
                controller.enqueue({
                  type: "reasoning-delta",
                  id: String(blockIndex),
                  delta: reasoningContent.text
                });
              } else if ("signature" in reasoningContent && reasoningContent.signature) {
                controller.enqueue({
                  type: "reasoning-delta",
                  id: String(blockIndex),
                  delta: "",
                  providerMetadata: {
                    bedrock: {
                      signature: reasoningContent.signature
                    }
                  }
                });
              } else if ("data" in reasoningContent && reasoningContent.data) {
                controller.enqueue({
                  type: "reasoning-delta",
                  id: String(blockIndex),
                  delta: "",
                  providerMetadata: {
                    bedrock: {
                      redactedData: reasoningContent.data
                    }
                  }
                });
              }
            }
            const contentBlockStart = value.contentBlockStart;
            if (((_p = contentBlockStart == null ? void 0 : contentBlockStart.start) == null ? void 0 : _p.toolUse) != null) {
              const toolUse = contentBlockStart.start.toolUse;
              const blockIndex = contentBlockStart.contentBlockIndex;
              contentBlocks[blockIndex] = {
                type: "tool-call",
                toolCallId: toolUse.toolUseId,
                toolName: toolUse.name,
                jsonText: ""
              };
              if (!usesJsonResponseTool) {
                controller.enqueue({
                  type: "tool-input-start",
                  id: toolUse.toolUseId,
                  toolName: toolUse.name
                });
              }
            }
            const contentBlockDelta = value.contentBlockDelta;
            if ((contentBlockDelta == null ? void 0 : contentBlockDelta.delta) && "toolUse" in contentBlockDelta.delta && contentBlockDelta.delta.toolUse) {
              const blockIndex = contentBlockDelta.contentBlockIndex;
              const contentBlock = contentBlocks[blockIndex];
              if ((contentBlock == null ? void 0 : contentBlock.type) === "tool-call") {
                const delta = (_q = contentBlockDelta.delta.toolUse.input) != null ? _q : "";
                if (!usesJsonResponseTool) {
                  controller.enqueue({
                    type: "tool-input-delta",
                    id: contentBlock.toolCallId,
                    delta
                  });
                }
                contentBlock.jsonText += delta;
              }
            }
          },
          flush(controller) {
            controller.enqueue({
              type: "finish",
              finishReason,
              usage,
              ...providerMetadata && { providerMetadata }
            });
          }
        })
      ),
      // TODO request?
      response: { headers: responseHeaders }
    };
  }
  getUrl(modelId) {
    const encodedModelId = encodeURIComponent(modelId);
    return `${this.config.baseUrl()}/model/${encodedModelId}`;
  }
};
var BedrockStopReasonSchema = union([
  _enum(BEDROCK_STOP_REASONS),
  string()
]);
var BedrockToolUseSchema = object({
  toolUseId: string(),
  name: string(),
  input: unknown()
});
var BedrockReasoningTextSchema = object({
  signature: string().nullish(),
  text: string()
});
var BedrockRedactedReasoningSchema = object({
  data: string()
});
var BedrockResponseSchema = object({
  metrics: object({
    latencyMs: number$1()
  }).nullish(),
  output: object({
    message: object({
      content: array(
        object({
          text: string().nullish(),
          toolUse: BedrockToolUseSchema.nullish(),
          reasoningContent: union([
            object({
              reasoningText: BedrockReasoningTextSchema
            }),
            object({
              redactedReasoning: BedrockRedactedReasoningSchema
            })
          ]).nullish()
        })
      ),
      role: string()
    })
  }),
  stopReason: BedrockStopReasonSchema,
  trace: unknown().nullish(),
  usage: object({
    inputTokens: number$1(),
    outputTokens: number$1(),
    totalTokens: number$1(),
    cacheReadInputTokens: number$1().nullish(),
    cacheWriteInputTokens: number$1().nullish()
  })
});
var BedrockStreamSchema = object({
  contentBlockDelta: object({
    contentBlockIndex: number$1(),
    delta: union([
      object({ text: string() }),
      object({ toolUse: object({ input: string() }) }),
      object({
        reasoningContent: object({ text: string() })
      }),
      object({
        reasoningContent: object({
          signature: string()
        })
      }),
      object({
        reasoningContent: object({ data: string() })
      })
    ]).nullish()
  }).nullish(),
  contentBlockStart: object({
    contentBlockIndex: number$1(),
    start: object({
      toolUse: BedrockToolUseSchema.nullish()
    }).nullish()
  }).nullish(),
  contentBlockStop: object({
    contentBlockIndex: number$1()
  }).nullish(),
  internalServerException: record(string(), unknown()).nullish(),
  messageStop: object({
    additionalModelResponseFields: record(string(), unknown()).nullish(),
    stopReason: BedrockStopReasonSchema
  }).nullish(),
  metadata: object({
    trace: unknown().nullish(),
    usage: object({
      cacheReadInputTokens: number$1().nullish(),
      cacheWriteInputTokens: number$1().nullish(),
      inputTokens: number$1(),
      outputTokens: number$1()
    }).nullish()
  }).nullish(),
  modelStreamErrorException: record(string(), unknown()).nullish(),
  throttlingException: record(string(), unknown()).nullish(),
  validationException: record(string(), unknown()).nullish()
});
var bedrockReasoningMetadataSchema = object({
  signature: string().optional(),
  redactedData: string().optional()
});
var bedrockEmbeddingProviderOptions = object({
  /**
  The number of dimensions the resulting output embeddings should have (defaults to 1024).
  Only supported in amazon.titan-embed-text-v2:0.
     */
  dimensions: union([literal(1024), literal(512), literal(256)]).optional(),
  /**
  Flag indicating whether or not to normalize the output embeddings. Defaults to true
  Only supported in amazon.titan-embed-text-v2:0.
   */
  normalize: boolean().optional()
});
var BedrockEmbeddingModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.provider = "amazon-bedrock";
    this.maxEmbeddingsPerCall = 1;
    this.supportsParallelCalls = true;
  }
  getUrl(modelId) {
    const encodedModelId = encodeURIComponent(modelId);
    return `${this.config.baseUrl()}/model/${encodedModelId}/invoke`;
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a;
    if (values.length > this.maxEmbeddingsPerCall) {
      throw new TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values
      });
    }
    const bedrockOptions = (_a = await parseProviderOptions({
      provider: "bedrock",
      providerOptions,
      schema: bedrockEmbeddingProviderOptions
    })) != null ? _a : {};
    const args = {
      inputText: values[0],
      dimensions: bedrockOptions.dimensions,
      normalize: bedrockOptions.normalize
    };
    const url = this.getUrl(this.modelId);
    const { value: response } = await postJsonToApi$1({
      url,
      headers: await resolve(
        combineHeaders$1(await resolve(this.config.headers), headers)
      ),
      body: args,
      failedResponseHandler: createJsonErrorResponseHandler$1({
        errorSchema: BedrockErrorSchema,
        errorToMessage: (error) => `${error.type}: ${error.message}`
      }),
      successfulResponseHandler: createJsonResponseHandler$1(
        BedrockEmbeddingResponseSchema
      ),
      fetch: this.config.fetch,
      abortSignal
    });
    return {
      embeddings: [response.embedding],
      usage: { tokens: response.inputTextTokenCount }
    };
  }
};
var BedrockEmbeddingResponseSchema = object({
  embedding: array(number$1()),
  inputTextTokenCount: number$1()
});

// src/bedrock-image-settings.ts
var modelMaxImagesPerCall = {
  "amazon.nova-canvas-v1:0": 5
};
var BedrockImageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.provider = "amazon-bedrock";
  }
  get maxImagesPerCall() {
    var _a;
    return (_a = modelMaxImagesPerCall[this.modelId]) != null ? _a : 1;
  }
  getUrl(modelId) {
    const encodedModelId = encodeURIComponent(modelId);
    return `${this.config.baseUrl()}/model/${encodedModelId}/invoke`;
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a, _b, _c, _d, _e, _f, _g;
    const warnings = [];
    const [width, height] = size ? size.split("x").map(Number) : [];
    const args = {
      taskType: "TEXT_IMAGE",
      textToImageParams: {
        text: prompt,
        ...((_a = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _a.negativeText) ? {
          negativeText: providerOptions.bedrock.negativeText
        } : {},
        ...((_b = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _b.style) ? {
          style: providerOptions.bedrock.style
        } : {}
      },
      imageGenerationConfig: {
        ...width ? { width } : {},
        ...height ? { height } : {},
        ...seed ? { seed } : {},
        ...n ? { numberOfImages: n } : {},
        ...((_c = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _c.quality) ? { quality: providerOptions.bedrock.quality } : {},
        ...((_d = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _d.cfgScale) ? { cfgScale: providerOptions.bedrock.cfgScale } : {}
      }
    };
    if (aspectRatio != void 0) {
      warnings.push({
        type: "unsupported-setting",
        setting: "aspectRatio",
        details: "This model does not support aspect ratio. Use `size` instead."
      });
    }
    const currentDate = (_g = (_f = (_e = this.config._internal) == null ? void 0 : _e.currentDate) == null ? void 0 : _f.call(_e)) != null ? _g : /* @__PURE__ */ new Date();
    const { value: response, responseHeaders } = await postJsonToApi$1({
      url: this.getUrl(this.modelId),
      headers: await resolve(
        combineHeaders$1(await resolve(this.config.headers), headers)
      ),
      body: args,
      failedResponseHandler: createJsonErrorResponseHandler$1({
        errorSchema: BedrockErrorSchema,
        errorToMessage: (error) => `${error.type}: ${error.message}`
      }),
      successfulResponseHandler: createJsonResponseHandler$1(
        bedrockImageResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      images: response.images,
      warnings,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders
      }
    };
  }
};
var bedrockImageResponseSchema = object({
  images: array(string())
});

// src/headers-utils.ts
function extractHeaders(headers) {
  let originalHeaders = {};
  if (headers) {
    if (headers instanceof Headers) {
      originalHeaders = convertHeadersToRecord(headers);
    } else if (Array.isArray(headers)) {
      for (const [k, v] of headers) {
        originalHeaders[k.toLowerCase()] = v;
      }
    } else {
      originalHeaders = Object.fromEntries(
        Object.entries(headers).map(([k, v]) => [k.toLowerCase(), v])
      );
    }
  }
  return originalHeaders;
}
function convertHeadersToRecord(headers) {
  return Object.fromEntries([...headers]);
}
function createSigV4FetchFunction(getCredentials, fetch = globalThis.fetch) {
  return async (input, init) => {
    var _a, _b;
    const request = input instanceof Request ? input : void 0;
    const originalHeaders = combineHeaders$1(
      extractHeaders(request == null ? void 0 : request.headers),
      extractHeaders(init == null ? void 0 : init.headers)
    );
    const headersWithUserAgent = withUserAgentSuffix(
      originalHeaders,
      `ai-sdk/amazon-bedrock/${VERSION$1}`,
      getRuntimeEnvironmentUserAgent()
    );
    let effectiveBody = (_a = init == null ? void 0 : init.body) != null ? _a : void 0;
    if (effectiveBody === void 0 && request && request.body !== null) {
      try {
        effectiveBody = await request.clone().text();
      } catch (e) {
      }
    }
    const effectiveMethod = (_b = init == null ? void 0 : init.method) != null ? _b : request == null ? void 0 : request.method;
    if ((effectiveMethod == null ? void 0 : effectiveMethod.toUpperCase()) !== "POST" || !effectiveBody) {
      return fetch(input, {
        ...init,
        headers: headersWithUserAgent
      });
    }
    const url = typeof input === "string" ? input : input instanceof URL ? input.href : input.url;
    const body = prepareBodyString(effectiveBody);
    const credentials = await getCredentials();
    const signer = new AwsV4Signer({
      url,
      method: "POST",
      headers: Object.entries(headersWithUserAgent),
      body,
      region: credentials.region,
      accessKeyId: credentials.accessKeyId,
      secretAccessKey: credentials.secretAccessKey,
      sessionToken: credentials.sessionToken,
      service: "bedrock"
    });
    const signingResult = await signer.sign();
    const signedHeaders = convertHeadersToRecord(signingResult.headers);
    const combinedHeaders = combineHeaders$1(headersWithUserAgent, signedHeaders);
    return fetch(input, {
      ...init,
      body,
      headers: combinedHeaders
    });
  };
}
function prepareBodyString(body) {
  if (typeof body === "string") {
    return body;
  } else if (body instanceof Uint8Array) {
    return new TextDecoder().decode(body);
  } else if (body instanceof ArrayBuffer) {
    return new TextDecoder().decode(new Uint8Array(body));
  } else {
    return JSON.stringify(body);
  }
}
function createApiKeyFetchFunction(apiKey, fetch = globalThis.fetch) {
  return async (input, init) => {
    const originalHeaders = extractHeaders(init == null ? void 0 : init.headers);
    const headersWithUserAgent = withUserAgentSuffix(
      originalHeaders,
      `ai-sdk/amazon-bedrock/${VERSION$1}`,
      getRuntimeEnvironmentUserAgent()
    );
    const finalHeaders = combineHeaders$1(headersWithUserAgent, {
      Authorization: `Bearer ${apiKey}`
    });
    return fetch(input, {
      ...init,
      headers: finalHeaders
    });
  };
}

// src/bedrock-provider.ts
function createAmazonBedrock(options = {}) {
  const rawApiKey = loadOptionalSetting({
    settingValue: options.apiKey,
    environmentVariableName: "AWS_BEARER_TOKEN_BEDROCK"
  });
  const apiKey = rawApiKey && rawApiKey.trim().length > 0 ? rawApiKey.trim() : void 0;
  const fetchFunction = apiKey ? createApiKeyFetchFunction(apiKey, options.fetch) : createSigV4FetchFunction(async () => {
    const region = loadSetting({
      settingValue: options.region,
      settingName: "region",
      environmentVariableName: "AWS_REGION",
      description: "AWS region"
    });
    if (options.credentialProvider) {
      try {
        return {
          ...await options.credentialProvider(),
          region
        };
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        throw new Error(
          `AWS credential provider failed: ${errorMessage}. Please ensure your credential provider returns valid AWS credentials with accessKeyId and secretAccessKey properties.`
        );
      }
    }
    try {
      return {
        region,
        accessKeyId: loadSetting({
          settingValue: options.accessKeyId,
          settingName: "accessKeyId",
          environmentVariableName: "AWS_ACCESS_KEY_ID",
          description: "AWS access key ID"
        }),
        secretAccessKey: loadSetting({
          settingValue: options.secretAccessKey,
          settingName: "secretAccessKey",
          environmentVariableName: "AWS_SECRET_ACCESS_KEY",
          description: "AWS secret access key"
        }),
        sessionToken: loadOptionalSetting({
          settingValue: options.sessionToken,
          environmentVariableName: "AWS_SESSION_TOKEN"
        })
      };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes("AWS_ACCESS_KEY_ID") || errorMessage.includes("accessKeyId")) {
        throw new Error(
          `AWS SigV4 authentication requires AWS credentials. Please provide either:
1. Set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables
2. Provide accessKeyId and secretAccessKey in options
3. Use a credentialProvider function
4. Use API key authentication with AWS_BEARER_TOKEN_BEDROCK or apiKey option
Original error: ${errorMessage}`
        );
      }
      if (errorMessage.includes("AWS_SECRET_ACCESS_KEY") || errorMessage.includes("secretAccessKey")) {
        throw new Error(
          `AWS SigV4 authentication requires both AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY. Please ensure both credentials are provided.
Original error: ${errorMessage}`
        );
      }
      throw error;
    }
  }, options.fetch);
  const getBaseUrl = () => {
    var _a, _b;
    return (_b = withoutTrailingSlash$1(
      (_a = options.baseURL) != null ? _a : `https://bedrock-runtime.${loadSetting({
        settingValue: options.region,
        settingName: "region",
        environmentVariableName: "AWS_REGION",
        description: "AWS region"
      })}.amazonaws.com`
    )) != null ? _b : `https://bedrock-runtime.us-east-1.amazonaws.com`;
  };
  const getHeaders = () => {
    var _a;
    const baseHeaders = (_a = options.headers) != null ? _a : {};
    return withUserAgentSuffix(baseHeaders, `ai-sdk/amazon-bedrock/${VERSION$1}`);
  };
  const createChatModel = (modelId) => new BedrockChatLanguageModel(modelId, {
    baseUrl: getBaseUrl,
    headers: getHeaders,
    fetch: fetchFunction,
    generateId: generateId$1
  });
  const provider = function(modelId) {
    if (new.target) {
      throw new Error(
        "The Amazon Bedrock model function cannot be called with the new keyword."
      );
    }
    return createChatModel(modelId);
  };
  const createEmbeddingModel = (modelId) => new BedrockEmbeddingModel(modelId, {
    baseUrl: getBaseUrl,
    headers: getHeaders,
    fetch: fetchFunction
  });
  const createImageModel = (modelId) => new BedrockImageModel(modelId, {
    baseUrl: getBaseUrl,
    headers: getHeaders,
    fetch: fetchFunction
  });
  provider.languageModel = createChatModel;
  provider.embedding = createEmbeddingModel;
  provider.textEmbedding = createEmbeddingModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.image = createImageModel;
  provider.imageModel = createImageModel;
  provider.tools = anthropicTools;
  return provider;
}
createAmazonBedrock();

var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

// node_modules/.pnpm/@ai-sdk+provider@2.0.0/node_modules/@ai-sdk/provider/dist/index.mjs
var marker = "vercel.ai.error";
var symbol = Symbol.for(marker);
var _a;
var _AISDKError = class _AISDKError2 extends Error {
  /**
   * Creates an AI SDK Error.
   *
   * @param {Object} params - The parameters for creating the error.
   * @param {string} params.name - The name of the error.
   * @param {string} params.message - The error message.
   * @param {unknown} [params.cause] - The underlying cause of the error.
   */
  constructor({
    name: name14,
    message,
    cause
  }) {
    super(message);
    this[_a] = true;
    this.name = name14;
    this.cause = cause;
  }
  /**
   * Checks if the given error is an AI SDK Error.
   * @param {unknown} error - The error to check.
   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
   */
  static isInstance(error) {
    return _AISDKError2.hasMarker(error, marker);
  }
  static hasMarker(error, marker15) {
    const markerSymbol = Symbol.for(marker15);
    return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
  }
};
_a = symbol;
var AISDKError = _AISDKError;
var name = "AI_APICallError";
var marker2 = `vercel.ai.error.${name}`;
var symbol2 = Symbol.for(marker2);
var _a2;
var APICallError = class extends AISDKError {
  constructor({
    message,
    url,
    requestBodyValues,
    statusCode,
    responseHeaders,
    responseBody,
    cause,
    isRetryable = statusCode != null && (statusCode === 408 || // request timeout
    statusCode === 409 || // conflict
    statusCode === 429 || // too many requests
    statusCode >= 500),
    // server error
    data
  }) {
    super({ name, message, cause });
    this[_a2] = true;
    this.url = url;
    this.requestBodyValues = requestBodyValues;
    this.statusCode = statusCode;
    this.responseHeaders = responseHeaders;
    this.responseBody = responseBody;
    this.isRetryable = isRetryable;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker2);
  }
};
_a2 = symbol2;
var name2 = "AI_EmptyResponseBodyError";
var marker3 = `vercel.ai.error.${name2}`;
var symbol3 = Symbol.for(marker3);
var _a3;
var EmptyResponseBodyError = class extends AISDKError {
  // used in isInstance
  constructor({ message = "Empty response body" } = {}) {
    super({ name: name2, message });
    this[_a3] = true;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker3);
  }
};
_a3 = symbol3;
function getErrorMessage(error) {
  if (error == null) {
    return "unknown error";
  }
  if (typeof error === "string") {
    return error;
  }
  if (error instanceof Error) {
    return error.message;
  }
  return JSON.stringify(error);
}
var name3 = "AI_InvalidArgumentError";
var marker4 = `vercel.ai.error.${name3}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var InvalidArgumentError = class extends AISDKError {
  constructor({
    message,
    cause,
    argument
  }) {
    super({ name: name3, message, cause });
    this[_a4] = true;
    this.argument = argument;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker4);
  }
};
_a4 = symbol4;
var name4 = "AI_InvalidPromptError";
var marker5 = `vercel.ai.error.${name4}`;
var symbol5 = Symbol.for(marker5);
var _a5;
var InvalidPromptError = class extends AISDKError {
  constructor({
    prompt,
    message,
    cause
  }) {
    super({ name: name4, message: `Invalid prompt: ${message}`, cause });
    this[_a5] = true;
    this.prompt = prompt;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker5);
  }
};
_a5 = symbol5;
var name5 = "AI_InvalidResponseDataError";
var marker6 = `vercel.ai.error.${name5}`;
var symbol6 = Symbol.for(marker6);
var _a6;
var InvalidResponseDataError = class extends AISDKError {
  constructor({
    data,
    message = `Invalid response data: ${JSON.stringify(data)}.`
  }) {
    super({ name: name5, message });
    this[_a6] = true;
    this.data = data;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker6);
  }
};
_a6 = symbol6;
var name6 = "AI_JSONParseError";
var marker7 = `vercel.ai.error.${name6}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var JSONParseError = class extends AISDKError {
  constructor({ text, cause }) {
    super({
      name: name6,
      message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a7] = true;
    this.text = text;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker7);
  }
};
_a7 = symbol7;
var name7 = "AI_LoadAPIKeyError";
var marker8 = `vercel.ai.error.${name7}`;
var symbol8 = Symbol.for(marker8);
var _a8;
var LoadAPIKeyError = class extends AISDKError {
  // used in isInstance
  constructor({ message }) {
    super({ name: name7, message });
    this[_a8] = true;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker8);
  }
};
_a8 = symbol8;
var name12 = "AI_TypeValidationError";
var marker13 = `vercel.ai.error.${name12}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
  constructor({ value, cause }) {
    super({
      name: name12,
      message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
      cause
    });
    this[_a13] = true;
    this.value = value;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker13);
  }
  /**
   * Wraps an error into a TypeValidationError.
   * If the cause is already a TypeValidationError with the same value, it returns the cause.
   * Otherwise, it creates a new TypeValidationError.
   *
   * @param {Object} params - The parameters for wrapping the error.
   * @param {unknown} params.value - The value that failed validation.
   * @param {unknown} params.cause - The original error or cause of the validation failure.
   * @returns {TypeValidationError} A TypeValidationError instance.
   */
  static wrap({
    value,
    cause
  }) {
    return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });
  }
};
_a13 = symbol13;
var TypeValidationError = _TypeValidationError;
var name13 = "AI_UnsupportedFunctionalityError";
var marker14 = `vercel.ai.error.${name13}`;
var symbol14 = Symbol.for(marker14);
var _a14;
var UnsupportedFunctionalityError = class extends AISDKError {
  constructor({
    functionality,
    message = `'${functionality}' functionality not supported.`
  }) {
    super({ name: name13, message });
    this[_a14] = true;
    this.functionality = functionality;
  }
  static isInstance(error) {
    return AISDKError.hasMarker(error, marker14);
  }
};
_a14 = symbol14;

// node_modules/.pnpm/eventsource-parser@3.0.3/node_modules/eventsource-parser/dist/index.js
var ParseError = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop(_arg) {
}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}

// node_modules/.pnpm/eventsource-parser@3.0.3/node_modules/eventsource-parser/dist/stream.js
var EventSourceParserStream = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};

// node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/string.js
new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

// node_modules/.pnpm/@ai-sdk+provider-utils@3.0.1_zod@3.25.76/node_modules/@ai-sdk/provider-utils/dist/index.mjs
function combineHeaders(...headers) {
  return headers.reduce(
    (combinedHeaders, currentHeaders) => __spreadValues(__spreadValues({}, combinedHeaders), currentHeaders != null ? currentHeaders : {}),
    {}
  );
}
function extractResponseHeaders(response) {
  return Object.fromEntries([...response.headers]);
}
var createIdGenerator = ({
  prefix,
  size = 16,
  alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
  separator = "-"
} = {}) => {
  const generator = () => {
    const alphabetLength = alphabet.length;
    const chars = new Array(size);
    for (let i = 0; i < size; i++) {
      chars[i] = alphabet[Math.random() * alphabetLength | 0];
    }
    return chars.join("");
  };
  if (prefix == null) {
    return generator;
  }
  if (alphabet.includes(separator)) {
    throw new InvalidArgumentError({
      argument: "separator",
      message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
    });
  }
  return () => `${prefix}${separator}${generator()}`;
};
var generateId = createIdGenerator();
function isAbortError(error) {
  return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
  error.name === "TimeoutError");
}
var FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"];
function handleFetchError({
  error,
  url,
  requestBodyValues
}) {
  if (isAbortError(error)) {
    return error;
  }
  if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {
    const cause = error.cause;
    if (cause != null) {
      return new APICallError({
        message: `Cannot connect to API: ${cause.message}`,
        cause,
        url,
        requestBodyValues,
        isRetryable: true
        // retry when network error
      });
    }
  }
  return error;
}
function removeUndefinedEntries(record) {
  return Object.fromEntries(
    Object.entries(record).filter(([_key, value]) => value != null)
  );
}
function loadApiKey({
  apiKey,
  environmentVariableName,
  apiKeyParameterName = "apiKey",
  description
}) {
  if (typeof apiKey === "string") {
    return apiKey;
  }
  if (apiKey != null) {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string.`
    });
  }
  if (typeof process === "undefined") {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
    });
  }
  apiKey = process.env[environmentVariableName];
  if (apiKey == null) {
    throw new LoadAPIKeyError({
      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
    });
  }
  if (typeof apiKey !== "string") {
    throw new LoadAPIKeyError({
      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
    });
  }
  return apiKey;
}
var suspectProtoRx = /"__proto__"\s*:/;
var suspectConstructorRx = /"constructor"\s*:/;
function _parse(text) {
  const obj = JSON.parse(text);
  if (obj === null || typeof obj !== "object") {
    return obj;
  }
  if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
    return obj;
  }
  return filter(obj);
}
function filter(obj) {
  let next = [obj];
  while (next.length) {
    const nodes = next;
    next = [];
    for (const node of nodes) {
      if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
        throw new SyntaxError("Object contains forbidden prototype property");
      }
      for (const key in node) {
        const value = node[key];
        if (value && typeof value === "object") {
          next.push(value);
        }
      }
    }
  }
  return obj;
}
function secureJsonParse(text) {
  const { stackTraceLimit } = Error;
  Error.stackTraceLimit = 0;
  try {
    return _parse(text);
  } finally {
    Error.stackTraceLimit = stackTraceLimit;
  }
}
var validatorSymbol = Symbol.for("vercel.ai.validator");
function validator(validate) {
  return { [validatorSymbol]: true, validate };
}
function isValidator(value) {
  return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
}
function asValidator(value) {
  return isValidator(value) ? value : standardSchemaValidator(value);
}
function standardSchemaValidator(standardSchema) {
  return validator(async (value) => {
    const result = await standardSchema["~standard"].validate(value);
    return result.issues == null ? { success: true, value: result.value } : {
      success: false,
      error: new TypeValidationError({
        value,
        cause: result.issues
      })
    };
  });
}
async function validateTypes({
  value,
  schema
}) {
  const result = await safeValidateTypes({ value, schema });
  if (!result.success) {
    throw TypeValidationError.wrap({ value, cause: result.error });
  }
  return result.value;
}
async function safeValidateTypes({
  value,
  schema
}) {
  const validator2 = asValidator(schema);
  try {
    if (validator2.validate == null) {
      return { success: true, value, rawValue: value };
    }
    const result = await validator2.validate(value);
    if (result.success) {
      return { success: true, value: result.value, rawValue: value };
    }
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: result.error }),
      rawValue: value
    };
  } catch (error) {
    return {
      success: false,
      error: TypeValidationError.wrap({ value, cause: error }),
      rawValue: value
    };
  }
}
async function parseJSON({
  text,
  schema
}) {
  try {
    const value = secureJsonParse(text);
    if (schema == null) {
      return value;
    }
    return validateTypes({ value, schema });
  } catch (error) {
    if (JSONParseError.isInstance(error) || TypeValidationError.isInstance(error)) {
      throw error;
    }
    throw new JSONParseError({ text, cause: error });
  }
}
async function safeParseJSON({
  text,
  schema
}) {
  try {
    const value = secureJsonParse(text);
    if (schema == null) {
      return { success: true, value, rawValue: value };
    }
    return await safeValidateTypes({ value, schema });
  } catch (error) {
    return {
      success: false,
      error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text, cause: error }),
      rawValue: void 0
    };
  }
}
function isParsableJson(input) {
  try {
    secureJsonParse(input);
    return true;
  } catch (e) {
    return false;
  }
}
function parseJsonEventStream({
  stream,
  schema
}) {
  return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
    new TransformStream({
      async transform({ data }, controller) {
        if (data === "[DONE]") {
          return;
        }
        controller.enqueue(await safeParseJSON({ text: data, schema }));
      }
    })
  );
}
var getOriginalFetch2 = () => globalThis.fetch;
var postJsonToApi = async ({
  url,
  headers,
  body,
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch
}) => postToApi({
  url,
  headers: __spreadValues({
    "Content-Type": "application/json"
  }, headers),
  body: {
    content: JSON.stringify(body),
    values: body
  },
  failedResponseHandler,
  successfulResponseHandler,
  abortSignal,
  fetch
});
var postToApi = async ({
  url,
  headers = {},
  body,
  successfulResponseHandler,
  failedResponseHandler,
  abortSignal,
  fetch = getOriginalFetch2()
}) => {
  try {
    const response = await fetch(url, {
      method: "POST",
      headers: removeUndefinedEntries(headers),
      body: body.content,
      signal: abortSignal
    });
    const responseHeaders = extractResponseHeaders(response);
    if (!response.ok) {
      let errorInformation;
      try {
        errorInformation = await failedResponseHandler({
          response,
          url,
          requestBodyValues: body.values
        });
      } catch (error) {
        if (isAbortError(error) || APICallError.isInstance(error)) {
          throw error;
        }
        throw new APICallError({
          message: "Failed to process error response",
          cause: error,
          statusCode: response.status,
          url,
          responseHeaders,
          requestBodyValues: body.values
        });
      }
      throw errorInformation.value;
    }
    try {
      return await successfulResponseHandler({
        response,
        url,
        requestBodyValues: body.values
      });
    } catch (error) {
      if (error instanceof Error) {
        if (isAbortError(error) || APICallError.isInstance(error)) {
          throw error;
        }
      }
      throw new APICallError({
        message: "Failed to process successful response",
        cause: error,
        statusCode: response.status,
        url,
        responseHeaders,
        requestBodyValues: body.values
      });
    }
  } catch (error) {
    throw handleFetchError({ error, url, requestBodyValues: body.values });
  }
};
var createJsonErrorResponseHandler = ({
  errorSchema,
  errorToMessage,
  isRetryable
}) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const responseHeaders = extractResponseHeaders(response);
  if (responseBody.trim() === "") {
    return {
      responseHeaders,
      value: new APICallError({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
  try {
    const parsedError = await parseJSON({
      text: responseBody,
      schema: errorSchema
    });
    return {
      responseHeaders,
      value: new APICallError({
        message: errorToMessage(parsedError),
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        data: parsedError,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
      })
    };
  } catch (parseError) {
    return {
      responseHeaders,
      value: new APICallError({
        message: response.statusText,
        url,
        requestBodyValues,
        statusCode: response.status,
        responseHeaders,
        responseBody,
        isRetryable: isRetryable == null ? void 0 : isRetryable(response)
      })
    };
  }
};
var createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {
  const responseHeaders = extractResponseHeaders(response);
  if (response.body == null) {
    throw new EmptyResponseBodyError({});
  }
  return {
    responseHeaders,
    value: parseJsonEventStream({
      stream: response.body,
      schema: chunkSchema
    })
  };
};
var createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {
  const responseBody = await response.text();
  const parsedResult = await safeParseJSON({
    text: responseBody,
    schema: responseSchema
  });
  const responseHeaders = extractResponseHeaders(response);
  if (!parsedResult.success) {
    throw new APICallError({
      message: "Invalid JSON response",
      cause: parsedResult.error,
      statusCode: response.status,
      responseHeaders,
      responseBody,
      url,
      requestBodyValues
    });
  }
  return {
    responseHeaders,
    value: parsedResult.value,
    rawValue: parsedResult.rawValue
  };
};
var { btoa} = globalThis;
function convertUint8ArrayToBase64(array) {
  let latin1string = "";
  for (let i = 0; i < array.length; i++) {
    latin1string += String.fromCodePoint(array[i]);
  }
  return btoa(latin1string);
}
function withoutTrailingSlash(url) {
  return url == null ? void 0 : url.replace(/\/$/, "");
}
var ReasoningDetailSummarySchema = object({
  type: literal("reasoning.summary" /* Summary */),
  summary: string()
});
var ReasoningDetailEncryptedSchema = object({
  type: literal("reasoning.encrypted" /* Encrypted */),
  data: string()
});
var ReasoningDetailTextSchema = object({
  type: literal("reasoning.text" /* Text */),
  text: string().nullish(),
  signature: string().nullish()
});
var ReasoningDetailUnionSchema = union([
  ReasoningDetailSummarySchema,
  ReasoningDetailEncryptedSchema,
  ReasoningDetailTextSchema
]);
var ReasoningDetailsWithUnknownSchema = union([
  ReasoningDetailUnionSchema,
  unknown().transform(() => null)
]);
var ReasoningDetailArraySchema = array(ReasoningDetailsWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));
var OpenRouterErrorResponseSchema = object({
  error: object({
    code: union([string(), number$1()]).nullable().optional().default(null),
    message: string(),
    type: string().nullable().optional().default(null),
    param: any().nullable().optional().default(null)
  })
});
var openrouterFailedResponseHandler = createJsonErrorResponseHandler({
  errorSchema: OpenRouterErrorResponseSchema,
  errorToMessage: (data) => data.error.message
});

// src/utils/map-finish-reason.ts
function mapOpenRouterFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}

// src/chat/is-url.ts
function isUrl({
  url,
  protocols
}) {
  try {
    const urlObj = new URL(url);
    return protocols.has(urlObj.protocol);
  } catch (_) {
    return false;
  }
}

// src/chat/file-url-utils.ts
function getFileUrl({
  part,
  defaultMediaType
}) {
  var _a15, _b;
  if (part.data instanceof Uint8Array) {
    const base64 = convertUint8ArrayToBase64(part.data);
    return `data:${(_a15 = part.mediaType) != null ? _a15 : defaultMediaType};base64,${base64}`;
  }
  const stringUrl = part.data.toString();
  if (isUrl({
    url: stringUrl,
    protocols: /* @__PURE__ */ new Set(["http:", "https:"])
  })) {
    return stringUrl;
  }
  return stringUrl.startsWith("data:") ? stringUrl : `data:${(_b = part.mediaType) != null ? _b : defaultMediaType};base64,${stringUrl}`;
}
function getMediaType(dataUrl, defaultMediaType) {
  var _a15;
  const match = dataUrl.match(/^data:([^;]+)/);
  return match ? (_a15 = match[1]) != null ? _a15 : defaultMediaType : defaultMediaType;
}
function getBase64FromDataUrl(dataUrl) {
  const match = dataUrl.match(/^data:[^;]*;base64,(.+)$/);
  return match ? match[1] : dataUrl;
}

// src/chat/convert-to-openrouter-chat-messages.ts
function getCacheControl(providerMetadata) {
  var _a15, _b, _c;
  const anthropic = providerMetadata == null ? void 0 : providerMetadata.anthropic;
  const openrouter2 = providerMetadata == null ? void 0 : providerMetadata.openrouter;
  return (_c = (_b = (_a15 = openrouter2 == null ? void 0 : openrouter2.cacheControl) != null ? _a15 : openrouter2 == null ? void 0 : openrouter2.cache_control) != null ? _b : anthropic == null ? void 0 : anthropic.cacheControl) != null ? _c : anthropic == null ? void 0 : anthropic.cache_control;
}
function convertToOpenRouterChatMessages(prompt) {
  var _a15, _b, _c;
  const messages = [];
  for (const { role, content, providerOptions } of prompt) {
    switch (role) {
      case "system": {
        messages.push({
          role: "system",
          content,
          cache_control: getCacheControl(providerOptions)
        });
        break;
      }
      case "user": {
        if (content.length === 1 && ((_a15 = content[0]) == null ? void 0 : _a15.type) === "text") {
          const cacheControl = (_b = getCacheControl(providerOptions)) != null ? _b : getCacheControl(content[0].providerOptions);
          const contentWithCacheControl = cacheControl ? [
            {
              type: "text",
              text: content[0].text,
              cache_control: cacheControl
            }
          ] : content[0].text;
          messages.push({
            role: "user",
            content: contentWithCacheControl
          });
          break;
        }
        const messageCacheControl = getCacheControl(providerOptions);
        const contentParts = content.map(
          (part) => {
            var _a16, _b2, _c2, _d, _e, _f;
            const cacheControl = (_a16 = getCacheControl(part.providerOptions)) != null ? _a16 : messageCacheControl;
            switch (part.type) {
              case "text":
                return {
                  type: "text",
                  text: part.text,
                  // For text parts, only use part-specific cache control
                  cache_control: cacheControl
                };
              case "file": {
                if ((_b2 = part.mediaType) == null ? void 0 : _b2.startsWith("image/")) {
                  const url = getFileUrl({
                    part,
                    defaultMediaType: "image/jpeg"
                  });
                  return {
                    type: "image_url",
                    image_url: {
                      url
                    },
                    // For image parts, use part-specific or message-level cache control
                    cache_control: cacheControl
                  };
                }
                const fileName = String(
                  (_f = (_e = (_d = (_c2 = part.providerOptions) == null ? void 0 : _c2.openrouter) == null ? void 0 : _d.filename) != null ? _e : part.filename) != null ? _f : ""
                );
                const fileData = getFileUrl({
                  part,
                  defaultMediaType: "application/pdf"
                });
                if (isUrl({
                  url: fileData,
                  protocols: /* @__PURE__ */ new Set(["http:", "https:"])
                })) {
                  return {
                    type: "file",
                    file: {
                      filename: fileName,
                      file_data: fileData
                    }
                  };
                }
                return {
                  type: "file",
                  file: {
                    filename: fileName,
                    file_data: fileData
                  },
                  cache_control: cacheControl
                };
              }
              default: {
                return {
                  type: "text",
                  text: "",
                  cache_control: cacheControl
                };
              }
            }
          }
        );
        messages.push({
          role: "user",
          content: contentParts
        });
        break;
      }
      case "assistant": {
        let text = "";
        let reasoning = "";
        const reasoningDetails = [];
        const toolCalls = [];
        for (const part of content) {
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                }
              });
              break;
            }
            case "reasoning": {
              reasoning += part.text;
              reasoningDetails.push({
                type: "reasoning.text" /* Text */,
                text: part.text
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
          reasoning: reasoning || void 0,
          reasoning_details: reasoningDetails.length > 0 ? reasoningDetails : void 0,
          cache_control: getCacheControl(providerOptions)
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const content2 = getToolResultContent(toolResponse);
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: content2,
            cache_control: (_c = getCacheControl(providerOptions)) != null ? _c : getCacheControl(toolResponse.providerOptions)
          });
        }
        break;
      }
    }
  }
  return messages;
}
function getToolResultContent(input) {
  return input.output.type === "text" ? input.output.value : JSON.stringify(input.output.value);
}
union([
  literal("auto"),
  literal("none"),
  literal("required"),
  object({
    type: literal("function"),
    function: object({
      name: string()
    })
  })
]);
function getChatCompletionToolChoice(toolChoice) {
  switch (toolChoice.type) {
    case "auto":
    case "none":
    case "required":
      return toolChoice.type;
    case "tool": {
      return {
        type: "function",
        function: { name: toolChoice.toolName }
      };
    }
    default: {
      throw new Error(`Invalid tool choice type: ${toolChoice}`);
    }
  }
}
var ImageResponseSchema = object({
  type: literal("image_url"),
  image_url: object({
    url: string()
  })
});
var ImageResponseWithUnknownSchema = union([
  ImageResponseSchema,
  unknown().transform(() => null)
]);
var ImageResponseArraySchema = array(ImageResponseWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));

// src/chat/schemas.ts
var OpenRouterChatCompletionBaseResponseSchema = object({
  id: string().optional(),
  model: string().optional(),
  provider: string().optional(),
  usage: object({
    prompt_tokens: number$1(),
    prompt_tokens_details: object({
      cached_tokens: number$1()
    }).nullish(),
    completion_tokens: number$1(),
    completion_tokens_details: object({
      reasoning_tokens: number$1()
    }).nullish(),
    total_tokens: number$1(),
    cost: number$1().optional(),
    cost_details: object({
      upstream_inference_cost: number$1().nullish()
    }).nullish()
  }).nullish()
});
var OpenRouterNonStreamChatCompletionResponseSchema = OpenRouterChatCompletionBaseResponseSchema.extend({
  choices: array(
    object({
      message: object({
        role: literal("assistant"),
        content: string().nullable().optional(),
        reasoning: string().nullable().optional(),
        reasoning_details: ReasoningDetailArraySchema.nullish(),
        images: ImageResponseArraySchema.nullish(),
        tool_calls: array(
          object({
            id: string().optional().nullable(),
            type: literal("function"),
            function: object({
              name: string(),
              arguments: string()
            })
          })
        ).optional(),
        annotations: array(
          object({
            type: _enum(["url_citation"]),
            url_citation: object({
              end_index: number$1(),
              start_index: number$1(),
              title: string(),
              url: string(),
              content: string().optional()
            })
          })
        ).nullish()
      }),
      index: number$1().nullish(),
      logprobs: object({
        content: array(
          object({
            token: string(),
            logprob: number$1(),
            top_logprobs: array(
              object({
                token: string(),
                logprob: number$1()
              })
            )
          })
        ).nullable()
      }).nullable().optional(),
      finish_reason: string().optional().nullable()
    })
  )
});
var OpenRouterStreamChatCompletionChunkSchema = union([
  OpenRouterChatCompletionBaseResponseSchema.extend({
    choices: array(
      object({
        delta: object({
          role: _enum(["assistant"]).optional(),
          content: string().nullish(),
          reasoning: string().nullish().optional(),
          reasoning_details: ReasoningDetailArraySchema.nullish(),
          images: ImageResponseArraySchema.nullish(),
          tool_calls: array(
            object({
              index: number$1().nullish(),
              id: string().nullish(),
              type: literal("function").optional(),
              function: object({
                name: string().nullish(),
                arguments: string().nullish()
              })
            })
          ).nullish(),
          annotations: array(
            object({
              type: _enum(["url_citation"]),
              url_citation: object({
                end_index: number$1(),
                start_index: number$1(),
                title: string(),
                url: string(),
                content: string().optional()
              })
            })
          ).nullish()
        }).nullish(),
        logprobs: object({
          content: array(
            object({
              token: string(),
              logprob: number$1(),
              top_logprobs: array(
                object({
                  token: string(),
                  logprob: number$1()
                })
              )
            })
          ).nullable()
        }).nullish(),
        finish_reason: string().nullable().optional(),
        index: number$1().nullish()
      })
    )
  }),
  OpenRouterErrorResponseSchema
]);

// src/chat/index.ts
var OpenRouterChatLanguageModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v2";
    this.provider = "openrouter";
    this.defaultObjectGenerationMode = "tool";
    this.supportedUrls = {
      "image/*": [
        /^data:image\/[a-zA-Z]+;base64,/,
        /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
      ],
      // 'text/*': [/^data:text\//, /^https?:\/\/.+$/],
      "application/*": [/^data:application\//, /^https?:\/\/.+$/]
    };
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    frequencyPenalty,
    presencePenalty,
    seed,
    stopSequences,
    responseFormat,
    topK,
    tools,
    toolChoice
  }) {
    var _a15;
    const baseArgs = __spreadValues(__spreadValues({
      // model id:
      model: this.modelId,
      models: this.settings.models,
      // model specific settings:
      logit_bias: this.settings.logitBias,
      logprobs: this.settings.logprobs === true || typeof this.settings.logprobs === "number" ? true : void 0,
      top_logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
      user: this.settings.user,
      parallel_tool_calls: this.settings.parallelToolCalls,
      // standardized settings:
      max_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      frequency_penalty: frequencyPenalty,
      presence_penalty: presencePenalty,
      seed,
      stop: stopSequences,
      response_format: responseFormat,
      top_k: topK,
      // messages:
      messages: convertToOpenRouterChatMessages(prompt),
      // OpenRouter specific settings:
      include_reasoning: this.settings.includeReasoning,
      reasoning: this.settings.reasoning,
      usage: this.settings.usage,
      // Web search settings:
      plugins: this.settings.plugins,
      web_search_options: this.settings.web_search_options,
      // Provider routing settings:
      provider: this.settings.provider
    }, this.config.extraBody), this.settings.extraBody);
    if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null) {
      return __spreadProps(__spreadValues({}, baseArgs), {
        response_format: {
          type: "json_schema",
          json_schema: __spreadValues({
            schema: responseFormat.schema,
            strict: true,
            name: (_a15 = responseFormat.name) != null ? _a15 : "response"
          }, responseFormat.description && {
            description: responseFormat.description
          })
        }
      });
    }
    if (tools && tools.length > 0) {
      const mappedTools = tools.filter((tool) => tool.type === "function").map((tool) => ({
        type: "function",
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.inputSchema
        }
      }));
      return __spreadProps(__spreadValues({}, baseArgs), {
        tools: mappedTools,
        tool_choice: toolChoice ? getChatCompletionToolChoice(toolChoice) : void 0
      });
    }
    return baseArgs;
  }
  async doGenerate(options) {
    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: response, responseHeaders } = await postJsonToApi({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(
        OpenRouterNonStreamChatCompletionResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const choice = response.choices[0];
    if (!choice) {
      throw new Error("No choice in response");
    }
    const usageInfo = response.usage ? {
      inputTokens: (_a15 = response.usage.prompt_tokens) != null ? _a15 : 0,
      outputTokens: (_b = response.usage.completion_tokens) != null ? _b : 0,
      totalTokens: ((_c = response.usage.prompt_tokens) != null ? _c : 0) + ((_d = response.usage.completion_tokens) != null ? _d : 0),
      reasoningTokens: (_f = (_e = response.usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : 0,
      cachedInputTokens: (_h = (_g = response.usage.prompt_tokens_details) == null ? void 0 : _g.cached_tokens) != null ? _h : 0
    } : {
      inputTokens: 0,
      outputTokens: 0,
      totalTokens: 0,
      reasoningTokens: 0,
      cachedInputTokens: 0
    };
    const reasoningDetails = (_i = choice.message.reasoning_details) != null ? _i : [];
    const reasoning = reasoningDetails.length > 0 ? reasoningDetails.map((detail) => {
      switch (detail.type) {
        case "reasoning.text" /* Text */: {
          if (detail.text) {
            return {
              type: "reasoning",
              text: detail.text
            };
          }
          break;
        }
        case "reasoning.summary" /* Summary */: {
          if (detail.summary) {
            return {
              type: "reasoning",
              text: detail.summary
            };
          }
          break;
        }
        case "reasoning.encrypted" /* Encrypted */: {
          if (detail.data) {
            return {
              type: "reasoning",
              text: "[REDACTED]"
            };
          }
          break;
        }
      }
      return null;
    }).filter((p) => p !== null) : choice.message.reasoning ? [
      {
        type: "reasoning",
        text: choice.message.reasoning
      }
    ] : [];
    const content = [];
    content.push(...reasoning);
    if (choice.message.content) {
      content.push({
        type: "text",
        text: choice.message.content
      });
    }
    if (choice.message.tool_calls) {
      for (const toolCall of choice.message.tool_calls) {
        content.push({
          type: "tool-call",
          toolCallId: (_j = toolCall.id) != null ? _j : generateId(),
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
      }
    }
    if (choice.message.images) {
      for (const image of choice.message.images) {
        content.push({
          type: "file",
          mediaType: getMediaType(image.image_url.url, "image/jpeg"),
          data: getBase64FromDataUrl(image.image_url.url)
        });
      }
    }
    if (choice.message.annotations) {
      for (const annotation of choice.message.annotations) {
        if (annotation.type === "url_citation") {
          content.push({
            type: "source",
            sourceType: "url",
            id: annotation.url_citation.url,
            url: annotation.url_citation.url,
            title: annotation.url_citation.title,
            providerMetadata: {
              openrouter: {
                content: annotation.url_citation.content || ""
              }
            }
          });
        }
      }
    }
    return {
      content,
      finishReason: mapOpenRouterFinishReason(choice.finish_reason),
      usage: usageInfo,
      warnings: [],
      providerMetadata: {
        openrouter: {
          provider: (_k = response.provider) != null ? _k : "",
          usage: {
            promptTokens: (_l = usageInfo.inputTokens) != null ? _l : 0,
            completionTokens: (_m = usageInfo.outputTokens) != null ? _m : 0,
            totalTokens: (_n = usageInfo.totalTokens) != null ? _n : 0,
            cost: (_o = response.usage) == null ? void 0 : _o.cost,
            promptTokensDetails: {
              cachedTokens: (_r = (_q = (_p = response.usage) == null ? void 0 : _p.prompt_tokens_details) == null ? void 0 : _q.cached_tokens) != null ? _r : 0
            },
            completionTokensDetails: {
              reasoningTokens: (_u = (_t = (_s = response.usage) == null ? void 0 : _s.completion_tokens_details) == null ? void 0 : _t.reasoning_tokens) != null ? _u : 0
            },
            costDetails: {
              upstreamInferenceCost: (_x = (_w = (_v = response.usage) == null ? void 0 : _v.cost_details) == null ? void 0 : _w.upstream_inference_cost) != null ? _x : 0
            }
          }
        }
      },
      request: { body: args },
      response: {
        id: response.id,
        modelId: response.model,
        headers: responseHeaders
      }
    };
  }
  async doStream(options) {
    var _a15;
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: response, responseHeaders } = await postJsonToApi({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: __spreadProps(__spreadValues({}, args), {
        stream: true,
        // only include stream_options when in strict compatibility mode:
        stream_options: this.config.compatibility === "strict" ? __spreadValues({
          include_usage: true
        }, ((_a15 = this.settings.usage) == null ? void 0 : _a15.include) ? { include_usage: true } : {}) : void 0
      }),
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(
        OpenRouterStreamChatCompletionChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const toolCalls = [];
    let finishReason = "other";
    const usage = {
      inputTokens: Number.NaN,
      outputTokens: Number.NaN,
      totalTokens: Number.NaN,
      reasoningTokens: Number.NaN,
      cachedInputTokens: Number.NaN
    };
    const openrouterUsage = {};
    let textStarted = false;
    let reasoningStarted = false;
    let textId;
    let reasoningId;
    let openrouterResponseId;
    let provider;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            var _a16, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if ("error" in value) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: value.error });
              return;
            }
            if (value.provider) {
              provider = value.provider;
            }
            if (value.id) {
              openrouterResponseId = value.id;
              controller.enqueue({
                type: "response-metadata",
                id: value.id
              });
            }
            if (value.model) {
              controller.enqueue({
                type: "response-metadata",
                modelId: value.model
              });
            }
            if (value.usage != null) {
              usage.inputTokens = value.usage.prompt_tokens;
              usage.outputTokens = value.usage.completion_tokens;
              usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;
              openrouterUsage.promptTokens = value.usage.prompt_tokens;
              if (value.usage.prompt_tokens_details) {
                const cachedInputTokens = (_a16 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a16 : 0;
                usage.cachedInputTokens = cachedInputTokens;
                openrouterUsage.promptTokensDetails = {
                  cachedTokens: cachedInputTokens
                };
              }
              openrouterUsage.completionTokens = value.usage.completion_tokens;
              if (value.usage.completion_tokens_details) {
                const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;
                usage.reasoningTokens = reasoningTokens;
                openrouterUsage.completionTokensDetails = {
                  reasoningTokens
                };
              }
              openrouterUsage.cost = value.usage.cost;
              openrouterUsage.totalTokens = value.usage.total_tokens;
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapOpenRouterFinishReason(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.delta) == null) {
              return;
            }
            const delta = choice.delta;
            const emitReasoningChunk = (chunkText) => {
              if (!reasoningStarted) {
                reasoningId = openrouterResponseId || generateId();
                controller.enqueue({
                  type: "reasoning-start",
                  id: reasoningId
                });
                reasoningStarted = true;
              }
              controller.enqueue({
                type: "reasoning-delta",
                delta: chunkText,
                id: reasoningId || generateId()
              });
            };
            if (delta.reasoning_details && delta.reasoning_details.length > 0) {
              for (const detail of delta.reasoning_details) {
                switch (detail.type) {
                  case "reasoning.text" /* Text */: {
                    if (detail.text) {
                      emitReasoningChunk(detail.text);
                    }
                    break;
                  }
                  case "reasoning.encrypted" /* Encrypted */: {
                    if (detail.data) {
                      emitReasoningChunk("[REDACTED]");
                    }
                    break;
                  }
                  case "reasoning.summary" /* Summary */: {
                    if (detail.summary) {
                      emitReasoningChunk(detail.summary);
                    }
                    break;
                  }
                }
              }
            } else if (delta.reasoning) {
              emitReasoningChunk(delta.reasoning);
            }
            if (delta.content) {
              if (reasoningStarted && !textStarted) {
                controller.enqueue({
                  type: "reasoning-end",
                  id: reasoningId || generateId()
                });
                reasoningStarted = false;
              }
              if (!textStarted) {
                textId = openrouterResponseId || generateId();
                controller.enqueue({
                  type: "text-start",
                  id: textId
                });
                textStarted = true;
              }
              controller.enqueue({
                type: "text-delta",
                delta: delta.content,
                id: textId || generateId()
              });
            }
            if (delta.annotations) {
              for (const annotation of delta.annotations) {
                if (annotation.type === "url_citation") {
                  controller.enqueue({
                    type: "source",
                    sourceType: "url",
                    id: annotation.url_citation.url,
                    url: annotation.url_citation.url,
                    title: annotation.url_citation.title,
                    providerMetadata: {
                      openrouter: {
                        content: annotation.url_citation.content || ""
                      }
                    }
                  });
                }
              }
            }
            if (delta.tool_calls != null) {
              for (const toolCallDelta of delta.tool_calls) {
                const index = (_c = toolCallDelta.index) != null ? _c : toolCalls.length - 1;
                if (toolCalls[index] == null) {
                  if (toolCallDelta.type !== "function") {
                    throw new InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'function' type.`
                    });
                  }
                  if (toolCallDelta.id == null) {
                    throw new InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'id' to be a string.`
                    });
                  }
                  if (((_d = toolCallDelta.function) == null ? void 0 : _d.name) == null) {
                    throw new InvalidResponseDataError({
                      data: toolCallDelta,
                      message: `Expected 'function.name' to be a string.`
                    });
                  }
                  toolCalls[index] = {
                    id: toolCallDelta.id,
                    type: "function",
                    function: {
                      name: toolCallDelta.function.name,
                      arguments: (_e = toolCallDelta.function.arguments) != null ? _e : ""
                    },
                    inputStarted: false,
                    sent: false
                  };
                  const toolCall2 = toolCalls[index];
                  if (toolCall2 == null) {
                    throw new Error("Tool call is missing");
                  }
                  if (((_f = toolCall2.function) == null ? void 0 : _f.name) != null && ((_g = toolCall2.function) == null ? void 0 : _g.arguments) != null && isParsableJson(toolCall2.function.arguments)) {
                    toolCall2.inputStarted = true;
                    controller.enqueue({
                      type: "tool-input-start",
                      id: toolCall2.id,
                      toolName: toolCall2.function.name
                    });
                    controller.enqueue({
                      type: "tool-input-delta",
                      id: toolCall2.id,
                      delta: toolCall2.function.arguments
                    });
                    controller.enqueue({
                      type: "tool-input-end",
                      id: toolCall2.id
                    });
                    controller.enqueue({
                      type: "tool-call",
                      toolCallId: toolCall2.id,
                      toolName: toolCall2.function.name,
                      input: toolCall2.function.arguments
                    });
                    toolCall2.sent = true;
                  }
                  continue;
                }
                const toolCall = toolCalls[index];
                if (toolCall == null) {
                  throw new Error("Tool call is missing");
                }
                if (!toolCall.inputStarted) {
                  toolCall.inputStarted = true;
                  controller.enqueue({
                    type: "tool-input-start",
                    id: toolCall.id,
                    toolName: toolCall.function.name
                  });
                }
                if (((_h = toolCallDelta.function) == null ? void 0 : _h.arguments) != null) {
                  toolCall.function.arguments += (_j = (_i = toolCallDelta.function) == null ? void 0 : _i.arguments) != null ? _j : "";
                }
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCall.id,
                  delta: (_k = toolCallDelta.function.arguments) != null ? _k : ""
                });
                if (((_l = toolCall.function) == null ? void 0 : _l.name) != null && ((_m = toolCall.function) == null ? void 0 : _m.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: (_n = toolCall.id) != null ? _n : generateId(),
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments
                  });
                  toolCall.sent = true;
                }
              }
            }
            if (delta.images != null) {
              for (const image of delta.images) {
                controller.enqueue({
                  type: "file",
                  mediaType: getMediaType(image.image_url.url, "image/jpeg"),
                  data: getBase64FromDataUrl(image.image_url.url)
                });
              }
            }
          },
          flush(controller) {
            var _a16;
            if (finishReason === "tool-calls") {
              for (const toolCall of toolCalls) {
                if (toolCall && !toolCall.sent) {
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: (_a16 = toolCall.id) != null ? _a16 : generateId(),
                    toolName: toolCall.function.name,
                    // Coerce invalid arguments to an empty JSON object
                    input: isParsableJson(toolCall.function.arguments) ? toolCall.function.arguments : "{}"
                  });
                  toolCall.sent = true;
                }
              }
            }
            if (reasoningStarted) {
              controller.enqueue({
                type: "reasoning-end",
                id: reasoningId || generateId()
              });
            }
            if (textStarted) {
              controller.enqueue({
                type: "text-end",
                id: textId || generateId()
              });
            }
            const openrouterMetadata = {
              usage: openrouterUsage
            };
            if (provider !== void 0) {
              openrouterMetadata.provider = provider;
            }
            controller.enqueue({
              type: "finish",
              finishReason,
              usage,
              providerMetadata: {
                openrouter: openrouterMetadata
              }
            });
          }
        })
      ),
      warnings: [],
      request: { body: args },
      response: { headers: responseHeaders }
    };
  }
};

// src/completion/convert-to-openrouter-completion-prompt.ts
function convertToOpenRouterCompletionPrompt({
  prompt,
  inputFormat,
  user = "user",
  assistant = "assistant"
}) {
  if (prompt.length === 1 && prompt[0] && prompt[0].role === "user" && prompt[0].content.length === 1 && prompt[0].content[0] && prompt[0].content[0].type === "text") {
    return { prompt: prompt[0].content[0].text };
  }
  let text = "";
  if (prompt[0] && prompt[0].role === "system") {
    text += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError({
          message: `Unexpected system message in prompt: ${content}`,
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "file": {
              throw new UnsupportedFunctionalityError({
                functionality: "file attachments"
              });
            }
            default: {
              return "";
            }
          }
        }).join("");
        text += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map(
          (part) => {
            switch (part.type) {
              case "text": {
                return part.text;
              }
              case "tool-call": {
                throw new UnsupportedFunctionalityError({
                  functionality: "tool-call messages"
                });
              }
              case "tool-result": {
                throw new UnsupportedFunctionalityError({
                  functionality: "tool-result messages"
                });
              }
              case "reasoning": {
                throw new UnsupportedFunctionalityError({
                  functionality: "reasoning messages"
                });
              }
              case "file": {
                throw new UnsupportedFunctionalityError({
                  functionality: "file attachments"
                });
              }
              default: {
                return "";
              }
            }
          }
        ).join("");
        text += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError({
          functionality: "tool messages"
        });
      }
    }
  }
  text += `${assistant}:
`;
  return {
    prompt: text
  };
}
var OpenRouterCompletionChunkSchema = union([
  object({
    id: string().optional(),
    model: string().optional(),
    choices: array(
      object({
        text: string(),
        reasoning: string().nullish().optional(),
        reasoning_details: ReasoningDetailArraySchema.nullish(),
        finish_reason: string().nullish(),
        index: number$1().nullish(),
        logprobs: object({
          tokens: array(string()),
          token_logprobs: array(number$1()),
          top_logprobs: array(record(string(), number$1())).nullable()
        }).nullable().optional()
      })
    ),
    usage: object({
      prompt_tokens: number$1(),
      prompt_tokens_details: object({
        cached_tokens: number$1()
      }).nullish(),
      completion_tokens: number$1(),
      completion_tokens_details: object({
        reasoning_tokens: number$1()
      }).nullish(),
      total_tokens: number$1(),
      cost: number$1().optional()
    }).nullish()
  }),
  OpenRouterErrorResponseSchema
]);

// src/completion/index.ts
var OpenRouterCompletionLanguageModel = class {
  constructor(modelId, settings, config) {
    this.specificationVersion = "v2";
    this.provider = "openrouter";
    this.supportedUrls = {
      "image/*": [
        /^data:image\/[a-zA-Z]+;base64,/,
        /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
      ],
      "text/*": [/^data:text\//, /^https?:\/\/.+$/],
      "application/*": [/^data:application\//, /^https?:\/\/.+$/]
    };
    this.defaultObjectGenerationMode = void 0;
    this.modelId = modelId;
    this.settings = settings;
    this.config = config;
  }
  getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    frequencyPenalty,
    presencePenalty,
    seed,
    responseFormat,
    topK,
    stopSequences,
    tools,
    toolChoice
  }) {
    const { prompt: completionPrompt } = convertToOpenRouterCompletionPrompt({
      prompt,
      inputFormat: "prompt"
    });
    if (tools == null ? void 0 : tools.length) {
      throw new UnsupportedFunctionalityError({
        functionality: "tools"
      });
    }
    if (toolChoice) {
      throw new UnsupportedFunctionalityError({
        functionality: "toolChoice"
      });
    }
    return __spreadValues(__spreadValues({
      // model id:
      model: this.modelId,
      models: this.settings.models,
      // model specific settings:
      logit_bias: this.settings.logitBias,
      logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
      suffix: this.settings.suffix,
      user: this.settings.user,
      // standardized settings:
      max_tokens: maxOutputTokens,
      temperature,
      top_p: topP,
      frequency_penalty: frequencyPenalty,
      presence_penalty: presencePenalty,
      seed,
      stop: stopSequences,
      response_format: responseFormat,
      top_k: topK,
      // prompt:
      prompt: completionPrompt,
      // OpenRouter specific settings:
      include_reasoning: this.settings.includeReasoning,
      reasoning: this.settings.reasoning
    }, this.config.extraBody), this.settings.extraBody);
  }
  async doGenerate(options) {
    var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: response, responseHeaders } = await postJsonToApi({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler(
        OpenRouterCompletionChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    if ("error" in response) {
      throw new Error(`${response.error.message}`);
    }
    const choice = response.choices[0];
    if (!choice) {
      throw new Error("No choice in OpenRouter completion response");
    }
    return {
      content: [
        {
          type: "text",
          text: (_a15 = choice.text) != null ? _a15 : ""
        }
      ],
      finishReason: mapOpenRouterFinishReason(choice.finish_reason),
      usage: {
        inputTokens: (_c = (_b = response.usage) == null ? void 0 : _b.prompt_tokens) != null ? _c : 0,
        outputTokens: (_e = (_d = response.usage) == null ? void 0 : _d.completion_tokens) != null ? _e : 0,
        totalTokens: ((_g = (_f = response.usage) == null ? void 0 : _f.prompt_tokens) != null ? _g : 0) + ((_i = (_h = response.usage) == null ? void 0 : _h.completion_tokens) != null ? _i : 0),
        reasoningTokens: (_l = (_k = (_j = response.usage) == null ? void 0 : _j.completion_tokens_details) == null ? void 0 : _k.reasoning_tokens) != null ? _l : 0,
        cachedInputTokens: (_o = (_n = (_m = response.usage) == null ? void 0 : _m.prompt_tokens_details) == null ? void 0 : _n.cached_tokens) != null ? _o : 0
      },
      warnings: [],
      response: {
        headers: responseHeaders
      }
    };
  }
  async doStream(options) {
    const providerOptions = options.providerOptions || {};
    const openrouterOptions = providerOptions.openrouter || {};
    const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
    const { value: response, responseHeaders } = await postJsonToApi({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders(this.config.headers(), options.headers),
      body: __spreadProps(__spreadValues({}, args), {
        stream: true,
        // only include stream_options when in strict compatibility mode:
        stream_options: this.config.compatibility === "strict" ? { include_usage: true } : void 0
      }),
      failedResponseHandler: openrouterFailedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler(
        OpenRouterCompletionChunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "other";
    const usage = {
      inputTokens: Number.NaN,
      outputTokens: Number.NaN,
      totalTokens: Number.NaN,
      reasoningTokens: Number.NaN,
      cachedInputTokens: Number.NaN
    };
    const openrouterUsage = {};
    return {
      stream: response.pipeThrough(
        new TransformStream({
          transform(chunk, controller) {
            var _a15, _b;
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if ("error" in value) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: value.error });
              return;
            }
            if (value.usage != null) {
              usage.inputTokens = value.usage.prompt_tokens;
              usage.outputTokens = value.usage.completion_tokens;
              usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;
              openrouterUsage.promptTokens = value.usage.prompt_tokens;
              if (value.usage.prompt_tokens_details) {
                const cachedInputTokens = (_a15 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a15 : 0;
                usage.cachedInputTokens = cachedInputTokens;
                openrouterUsage.promptTokensDetails = {
                  cachedTokens: cachedInputTokens
                };
              }
              openrouterUsage.completionTokens = value.usage.completion_tokens;
              if (value.usage.completion_tokens_details) {
                const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;
                usage.reasoningTokens = reasoningTokens;
                openrouterUsage.completionTokensDetails = {
                  reasoningTokens
                };
              }
              openrouterUsage.cost = value.usage.cost;
              openrouterUsage.totalTokens = value.usage.total_tokens;
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapOpenRouterFinishReason(choice.finish_reason);
            }
            if ((choice == null ? void 0 : choice.text) != null) {
              controller.enqueue({
                type: "text-delta",
                delta: choice.text,
                id: generateId()
              });
            }
          },
          flush(controller) {
            controller.enqueue({
              type: "finish",
              finishReason,
              usage,
              providerMetadata: {
                openrouter: {
                  usage: openrouterUsage
                }
              }
            });
          }
        })
      ),
      response: {
        headers: responseHeaders
      }
    };
  }
};

// src/provider.ts
function createOpenRouter(options = {}) {
  var _a15, _b, _c;
  const baseURL = (_b = withoutTrailingSlash((_a15 = options.baseURL) != null ? _a15 : options.baseUrl)) != null ? _b : "https://openrouter.ai/api/v1";
  const compatibility = (_c = options.compatibility) != null ? _c : "compatible";
  const getHeaders = () => __spreadValues({
    Authorization: `Bearer ${loadApiKey({
      apiKey: options.apiKey,
      environmentVariableName: "OPENROUTER_API_KEY",
      description: "OpenRouter"
    })}`
  }, options.headers);
  const createChatModel = (modelId, settings = {}) => new OpenRouterChatLanguageModel(modelId, settings, {
    provider: "openrouter.chat",
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    compatibility,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createCompletionModel = (modelId, settings = {}) => new OpenRouterCompletionLanguageModel(modelId, settings, {
    provider: "openrouter.completion",
    url: ({ path }) => `${baseURL}${path}`,
    headers: getHeaders,
    compatibility,
    fetch: options.fetch,
    extraBody: options.extraBody
  });
  const createLanguageModel = (modelId, settings) => {
    if (new.target) {
      throw new Error(
        "The OpenRouter model function cannot be called with the new keyword."
      );
    }
    if (modelId === "openai/gpt-3.5-turbo-instruct") {
      return createCompletionModel(
        modelId,
        settings
      );
    }
    return createChatModel(modelId, settings);
  };
  const provider = (modelId, settings) => createLanguageModel(modelId, settings);
  provider.languageModel = createLanguageModel;
  provider.chat = createChatModel;
  provider.completion = createCompletionModel;
  return provider;
}
createOpenRouter({
  compatibility: "strict"
  // strict for OpenRouter API
});

// src/chat/openai-compatible-chat-language-model.ts
function getOpenAIMetadata(message) {
  var _a, _b;
  return (_b = (_a = message == null ? void 0 : message.providerOptions) == null ? void 0 : _a.openaiCompatible) != null ? _b : {};
}
function convertToOpenAICompatibleChatMessages(prompt) {
  const messages = [];
  for (const { role, content, ...message } of prompt) {
    const metadata = getOpenAIMetadata({ ...message });
    switch (role) {
      case "system": {
        messages.push({ role: "system", content, ...metadata });
        break;
      }
      case "user": {
        if (content.length === 1 && content[0].type === "text") {
          messages.push({
            role: "user",
            content: content[0].text,
            ...getOpenAIMetadata(content[0])
          });
          break;
        }
        messages.push({
          role: "user",
          content: content.map((part) => {
            const partMetadata = getOpenAIMetadata(part);
            switch (part.type) {
              case "text": {
                return { type: "text", text: part.text, ...partMetadata };
              }
              case "file": {
                if (part.mediaType.startsWith("image/")) {
                  const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                  return {
                    type: "image_url",
                    image_url: {
                      url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                    },
                    ...partMetadata
                  };
                } else {
                  throw new UnsupportedFunctionalityError$1({
                    functionality: `file part media type ${part.mediaType}`
                  });
                }
              }
            }
          }),
          ...metadata
        });
        break;
      }
      case "assistant": {
        let text = "";
        const toolCalls = [];
        for (const part of content) {
          const partMetadata = getOpenAIMetadata(part);
          switch (part.type) {
            case "text": {
              text += part.text;
              break;
            }
            case "tool-call": {
              toolCalls.push({
                id: part.toolCallId,
                type: "function",
                function: {
                  name: part.toolName,
                  arguments: JSON.stringify(part.input)
                },
                ...partMetadata
              });
              break;
            }
          }
        }
        messages.push({
          role: "assistant",
          content: text,
          tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
          ...metadata
        });
        break;
      }
      case "tool": {
        for (const toolResponse of content) {
          const output = toolResponse.output;
          let contentValue;
          switch (output.type) {
            case "text":
            case "error-text":
              contentValue = output.value;
              break;
            case "content":
            case "json":
            case "error-json":
              contentValue = JSON.stringify(output.value);
              break;
          }
          const toolResponseMetadata = getOpenAIMetadata(toolResponse);
          messages.push({
            role: "tool",
            tool_call_id: toolResponse.toolCallId,
            content: contentValue,
            ...toolResponseMetadata
          });
        }
        break;
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  return messages;
}

// src/chat/get-response-metadata.ts
function getResponseMetadata({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}

// src/chat/map-openai-compatible-finish-reason.ts
function mapOpenAICompatibleFinishReason(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var openaiCompatibleProviderOptions = object({
  /**
   * A unique identifier representing your end-user, which can help the provider to
   * monitor and detect abuse.
   */
  user: string().optional(),
  /**
   * Reasoning effort for reasoning models. Defaults to `medium`.
   */
  reasoningEffort: string().optional(),
  /**
   * Controls the verbosity of the generated text. Defaults to `medium`.
   */
  textVerbosity: string().optional()
});
var openaiCompatibleErrorDataSchema = object({
  error: object({
    message: string(),
    // The additional information below is handled loosely to support
    // OpenAI-compatible providers that have slightly different error
    // responses:
    type: string().nullish(),
    param: any().nullish(),
    code: union([string(), number$1()]).nullish()
  })
});
var defaultOpenAICompatibleErrorStructure = {
  errorSchema: openaiCompatibleErrorDataSchema,
  errorToMessage: (data) => data.error.message
};
function prepareTools({
  tools,
  toolChoice
}) {
  tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
  const toolWarnings = [];
  if (tools == null) {
    return { tools: void 0, toolChoice: void 0, toolWarnings };
  }
  const openaiCompatTools = [];
  for (const tool of tools) {
    if (tool.type === "provider-defined") {
      toolWarnings.push({ type: "unsupported-tool", tool });
    } else {
      openaiCompatTools.push({
        type: "function",
        function: {
          name: tool.name,
          description: tool.description,
          parameters: tool.inputSchema
        }
      });
    }
  }
  if (toolChoice == null) {
    return { tools: openaiCompatTools, toolChoice: void 0, toolWarnings };
  }
  const type = toolChoice.type;
  switch (type) {
    case "auto":
    case "none":
    case "required":
      return { tools: openaiCompatTools, toolChoice: type, toolWarnings };
    case "tool":
      return {
        tools: openaiCompatTools,
        toolChoice: {
          type: "function",
          function: { name: toolChoice.toolName }
        },
        toolWarnings
      };
    default: {
      const _exhaustiveCheck = type;
      throw new UnsupportedFunctionalityError$1({
        functionality: `tool choice type: ${_exhaustiveCheck}`
      });
    }
  }
}

// src/chat/openai-compatible-chat-language-model.ts
var OpenAICompatibleChatLanguageModel = class {
  // type inferred via constructor
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    var _a, _b;
    this.modelId = modelId;
    this.config = config;
    const errorStructure = (_a = config.errorStructure) != null ? _a : defaultOpenAICompatibleErrorStructure;
    this.chunkSchema = createOpenAICompatibleChatChunkSchema(
      errorStructure.errorSchema
    );
    this.failedResponseHandler = createJsonErrorResponseHandler$1(errorStructure);
    this.supportsStructuredOutputs = (_b = config.supportsStructuredOutputs) != null ? _b : false;
  }
  get provider() {
    return this.config.provider;
  }
  get providerOptionsName() {
    return this.config.provider.split(".")[0].trim();
  }
  get supportedUrls() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    providerOptions,
    stopSequences,
    responseFormat,
    seed,
    toolChoice,
    tools
  }) {
    var _a, _b, _c, _d;
    const warnings = [];
    const compatibleOptions = Object.assign(
      (_a = await parseProviderOptions({
        provider: "openai-compatible",
        providerOptions,
        schema: openaiCompatibleProviderOptions
      })) != null ? _a : {},
      (_b = await parseProviderOptions({
        provider: this.providerOptionsName,
        providerOptions,
        schema: openaiCompatibleProviderOptions
      })) != null ? _b : {}
    );
    if (topK != null) {
      warnings.push({ type: "unsupported-setting", setting: "topK" });
    }
    if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !this.supportsStructuredOutputs) {
      warnings.push({
        type: "unsupported-setting",
        setting: "responseFormat",
        details: "JSON response format schema is only supported with structuredOutputs"
      });
    }
    const {
      tools: openaiTools,
      toolChoice: openaiToolChoice,
      toolWarnings
    } = prepareTools({
      tools,
      toolChoice
    });
    return {
      args: {
        // model id:
        model: this.modelId,
        // model specific settings:
        user: compatibleOptions.user,
        // standardized settings:
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        frequency_penalty: frequencyPenalty,
        presence_penalty: presencePenalty,
        response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? this.supportsStructuredOutputs === true && responseFormat.schema != null ? {
          type: "json_schema",
          json_schema: {
            schema: responseFormat.schema,
            name: (_c = responseFormat.name) != null ? _c : "response",
            description: responseFormat.description
          }
        } : { type: "json_object" } : void 0,
        stop: stopSequences,
        seed,
        ...Object.fromEntries(
          Object.entries(
            (_d = providerOptions == null ? void 0 : providerOptions[this.providerOptionsName]) != null ? _d : {}
          ).filter(
            ([key]) => !Object.keys(openaiCompatibleProviderOptions.shape).includes(key)
          )
        ),
        reasoning_effort: compatibleOptions.reasoningEffort,
        verbosity: compatibleOptions.textVerbosity,
        // messages:
        messages: convertToOpenAICompatibleChatMessages(prompt),
        // tools:
        tools: openaiTools,
        tool_choice: openaiToolChoice
      },
      warnings: [...warnings, ...toolWarnings]
    };
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
    const { args, warnings } = await this.getArgs({ ...options });
    const body = JSON.stringify(args);
    const {
      responseHeaders,
      value: responseBody,
      rawValue: rawResponse
    } = await postJsonToApi$1({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: this.failedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        OpenAICompatibleChatResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const choice = responseBody.choices[0];
    const content = [];
    const text = choice.message.content;
    if (text != null && text.length > 0) {
      content.push({ type: "text", text });
    }
    const reasoning = (_a = choice.message.reasoning_content) != null ? _a : choice.message.reasoning;
    if (reasoning != null && reasoning.length > 0) {
      content.push({
        type: "reasoning",
        text: reasoning
      });
    }
    if (choice.message.tool_calls != null) {
      for (const toolCall of choice.message.tool_calls) {
        content.push({
          type: "tool-call",
          toolCallId: (_b = toolCall.id) != null ? _b : generateId$1(),
          toolName: toolCall.function.name,
          input: toolCall.function.arguments
        });
      }
    }
    const providerMetadata = {
      [this.providerOptionsName]: {},
      ...await ((_d = (_c = this.config.metadataExtractor) == null ? void 0 : _c.extractMetadata) == null ? void 0 : _d.call(_c, {
        parsedBody: rawResponse
      }))
    };
    const completionTokenDetails = (_e = responseBody.usage) == null ? void 0 : _e.completion_tokens_details;
    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
      providerMetadata[this.providerOptionsName].acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
    }
    if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
      providerMetadata[this.providerOptionsName].rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
    }
    return {
      content,
      finishReason: mapOpenAICompatibleFinishReason(choice.finish_reason),
      usage: {
        inputTokens: (_g = (_f = responseBody.usage) == null ? void 0 : _f.prompt_tokens) != null ? _g : void 0,
        outputTokens: (_i = (_h = responseBody.usage) == null ? void 0 : _h.completion_tokens) != null ? _i : void 0,
        totalTokens: (_k = (_j = responseBody.usage) == null ? void 0 : _j.total_tokens) != null ? _k : void 0,
        reasoningTokens: (_n = (_m = (_l = responseBody.usage) == null ? void 0 : _l.completion_tokens_details) == null ? void 0 : _m.reasoning_tokens) != null ? _n : void 0,
        cachedInputTokens: (_q = (_p = (_o = responseBody.usage) == null ? void 0 : _o.prompt_tokens_details) == null ? void 0 : _p.cached_tokens) != null ? _q : void 0
      },
      providerMetadata,
      request: { body },
      response: {
        ...getResponseMetadata(responseBody),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    var _a;
    const { args, warnings } = await this.getArgs({ ...options });
    const body = {
      ...args,
      stream: true,
      // only include stream_options when in strict compatibility mode:
      stream_options: this.config.includeUsage ? { include_usage: true } : void 0
    };
    const metadataExtractor = (_a = this.config.metadataExtractor) == null ? void 0 : _a.createStreamExtractor();
    const { responseHeaders, value: response } = await postJsonToApi$1({
      url: this.config.url({
        path: "/chat/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body,
      failedResponseHandler: this.failedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler$1(
        this.chunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const toolCalls = [];
    let finishReason = "unknown";
    const usage = {
      completionTokens: void 0,
      completionTokensDetails: {
        reasoningTokens: void 0,
        acceptedPredictionTokens: void 0,
        rejectedPredictionTokens: void 0
      },
      promptTokens: void 0,
      promptTokensDetails: {
        cachedTokens: void 0
      },
      totalTokens: void 0
    };
    let isFirstChunk = true;
    const providerOptionsName = this.providerOptionsName;
    let isActiveReasoning = false;
    let isActiveText = false;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          // TODO we lost type safety on Chunk, most likely due to the error schema. MUST FIX
          transform(chunk, controller) {
            var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            metadataExtractor == null ? void 0 : metadataExtractor.processChunk(chunk.rawValue);
            if ("error" in value) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: value.error.message });
              return;
            }
            if (isFirstChunk) {
              isFirstChunk = false;
              controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata(value)
              });
            }
            if (value.usage != null) {
              const {
                prompt_tokens,
                completion_tokens,
                total_tokens,
                prompt_tokens_details,
                completion_tokens_details
              } = value.usage;
              usage.promptTokens = prompt_tokens != null ? prompt_tokens : void 0;
              usage.completionTokens = completion_tokens != null ? completion_tokens : void 0;
              usage.totalTokens = total_tokens != null ? total_tokens : void 0;
              if ((completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens) != null) {
                usage.completionTokensDetails.reasoningTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens;
              }
              if ((completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens) != null) {
                usage.completionTokensDetails.acceptedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens;
              }
              if ((completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens) != null) {
                usage.completionTokensDetails.rejectedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens;
              }
              if ((prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens) != null) {
                usage.promptTokensDetails.cachedTokens = prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens;
              }
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapOpenAICompatibleFinishReason(
                choice.finish_reason
              );
            }
            if ((choice == null ? void 0 : choice.delta) == null) {
              return;
            }
            const delta = choice.delta;
            const reasoningContent = (_a2 = delta.reasoning_content) != null ? _a2 : delta.reasoning;
            if (reasoningContent) {
              if (!isActiveReasoning) {
                controller.enqueue({
                  type: "reasoning-start",
                  id: "reasoning-0"
                });
                isActiveReasoning = true;
              }
              controller.enqueue({
                type: "reasoning-delta",
                id: "reasoning-0",
                delta: reasoningContent
              });
            }
            if (delta.content) {
              if (!isActiveText) {
                controller.enqueue({ type: "text-start", id: "txt-0" });
                isActiveText = true;
              }
              controller.enqueue({
                type: "text-delta",
                id: "txt-0",
                delta: delta.content
              });
            }
            if (delta.tool_calls != null) {
              for (const toolCallDelta of delta.tool_calls) {
                const index = toolCallDelta.index;
                if (toolCalls[index] == null) {
                  if (toolCallDelta.id == null) {
                    throw new InvalidResponseDataError$1({
                      data: toolCallDelta,
                      message: `Expected 'id' to be a string.`
                    });
                  }
                  if (((_b = toolCallDelta.function) == null ? void 0 : _b.name) == null) {
                    throw new InvalidResponseDataError$1({
                      data: toolCallDelta,
                      message: `Expected 'function.name' to be a string.`
                    });
                  }
                  controller.enqueue({
                    type: "tool-input-start",
                    id: toolCallDelta.id,
                    toolName: toolCallDelta.function.name
                  });
                  toolCalls[index] = {
                    id: toolCallDelta.id,
                    type: "function",
                    function: {
                      name: toolCallDelta.function.name,
                      arguments: (_c = toolCallDelta.function.arguments) != null ? _c : ""
                    },
                    hasFinished: false
                  };
                  const toolCall2 = toolCalls[index];
                  if (((_d = toolCall2.function) == null ? void 0 : _d.name) != null && ((_e = toolCall2.function) == null ? void 0 : _e.arguments) != null) {
                    if (toolCall2.function.arguments.length > 0) {
                      controller.enqueue({
                        type: "tool-input-delta",
                        id: toolCall2.id,
                        delta: toolCall2.function.arguments
                      });
                    }
                    if (isParsableJson$1(toolCall2.function.arguments)) {
                      controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall2.id
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_f = toolCall2.id) != null ? _f : generateId$1(),
                        toolName: toolCall2.function.name,
                        input: toolCall2.function.arguments
                      });
                      toolCall2.hasFinished = true;
                    }
                  }
                  continue;
                }
                const toolCall = toolCalls[index];
                if (toolCall.hasFinished) {
                  continue;
                }
                if (((_g = toolCallDelta.function) == null ? void 0 : _g.arguments) != null) {
                  toolCall.function.arguments += (_i = (_h = toolCallDelta.function) == null ? void 0 : _h.arguments) != null ? _i : "";
                }
                controller.enqueue({
                  type: "tool-input-delta",
                  id: toolCall.id,
                  delta: (_j = toolCallDelta.function.arguments) != null ? _j : ""
                });
                if (((_k = toolCall.function) == null ? void 0 : _k.name) != null && ((_l = toolCall.function) == null ? void 0 : _l.arguments) != null && isParsableJson$1(toolCall.function.arguments)) {
                  controller.enqueue({
                    type: "tool-input-end",
                    id: toolCall.id
                  });
                  controller.enqueue({
                    type: "tool-call",
                    toolCallId: (_m = toolCall.id) != null ? _m : generateId$1(),
                    toolName: toolCall.function.name,
                    input: toolCall.function.arguments
                  });
                  toolCall.hasFinished = true;
                }
              }
            }
          },
          flush(controller) {
            var _a2, _b, _c, _d, _e, _f;
            if (isActiveReasoning) {
              controller.enqueue({ type: "reasoning-end", id: "reasoning-0" });
            }
            if (isActiveText) {
              controller.enqueue({ type: "text-end", id: "txt-0" });
            }
            for (const toolCall of toolCalls.filter(
              (toolCall2) => !toolCall2.hasFinished
            )) {
              controller.enqueue({
                type: "tool-input-end",
                id: toolCall.id
              });
              controller.enqueue({
                type: "tool-call",
                toolCallId: (_a2 = toolCall.id) != null ? _a2 : generateId$1(),
                toolName: toolCall.function.name,
                input: toolCall.function.arguments
              });
            }
            const providerMetadata = {
              [providerOptionsName]: {},
              ...metadataExtractor == null ? void 0 : metadataExtractor.buildMetadata()
            };
            if (usage.completionTokensDetails.acceptedPredictionTokens != null) {
              providerMetadata[providerOptionsName].acceptedPredictionTokens = usage.completionTokensDetails.acceptedPredictionTokens;
            }
            if (usage.completionTokensDetails.rejectedPredictionTokens != null) {
              providerMetadata[providerOptionsName].rejectedPredictionTokens = usage.completionTokensDetails.rejectedPredictionTokens;
            }
            controller.enqueue({
              type: "finish",
              finishReason,
              usage: {
                inputTokens: (_b = usage.promptTokens) != null ? _b : void 0,
                outputTokens: (_c = usage.completionTokens) != null ? _c : void 0,
                totalTokens: (_d = usage.totalTokens) != null ? _d : void 0,
                reasoningTokens: (_e = usage.completionTokensDetails.reasoningTokens) != null ? _e : void 0,
                cachedInputTokens: (_f = usage.promptTokensDetails.cachedTokens) != null ? _f : void 0
              },
              providerMetadata
            });
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
var openaiCompatibleTokenUsageSchema = object({
  prompt_tokens: number$1().nullish(),
  completion_tokens: number$1().nullish(),
  total_tokens: number$1().nullish(),
  prompt_tokens_details: object({
    cached_tokens: number$1().nullish()
  }).nullish(),
  completion_tokens_details: object({
    reasoning_tokens: number$1().nullish(),
    accepted_prediction_tokens: number$1().nullish(),
    rejected_prediction_tokens: number$1().nullish()
  }).nullish()
}).nullish();
var OpenAICompatibleChatResponseSchema = object({
  id: string().nullish(),
  created: number$1().nullish(),
  model: string().nullish(),
  choices: array(
    object({
      message: object({
        role: literal("assistant").nullish(),
        content: string().nullish(),
        reasoning_content: string().nullish(),
        reasoning: string().nullish(),
        tool_calls: array(
          object({
            id: string().nullish(),
            function: object({
              name: string(),
              arguments: string()
            })
          })
        ).nullish()
      }),
      finish_reason: string().nullish()
    })
  ),
  usage: openaiCompatibleTokenUsageSchema
});
var createOpenAICompatibleChatChunkSchema = (errorSchema) => union([
  object({
    id: string().nullish(),
    created: number$1().nullish(),
    model: string().nullish(),
    choices: array(
      object({
        delta: object({
          role: _enum(["assistant"]).nullish(),
          content: string().nullish(),
          // Most openai-compatible models set `reasoning_content`, but some
          // providers serving `gpt-oss` set `reasoning`. See #7866
          reasoning_content: string().nullish(),
          reasoning: string().nullish(),
          tool_calls: array(
            object({
              index: number$1(),
              id: string().nullish(),
              function: object({
                name: string().nullish(),
                arguments: string().nullish()
              })
            })
          ).nullish()
        }).nullish(),
        finish_reason: string().nullish()
      })
    ),
    usage: openaiCompatibleTokenUsageSchema
  }),
  errorSchema
]);
function convertToOpenAICompatibleCompletionPrompt({
  prompt,
  user = "user",
  assistant = "assistant"
}) {
  let text = "";
  if (prompt[0].role === "system") {
    text += `${prompt[0].content}

`;
    prompt = prompt.slice(1);
  }
  for (const { role, content } of prompt) {
    switch (role) {
      case "system": {
        throw new InvalidPromptError$1({
          message: "Unexpected system message in prompt: ${content}",
          prompt
        });
      }
      case "user": {
        const userMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
          }
        }).filter(Boolean).join("");
        text += `${user}:
${userMessage}

`;
        break;
      }
      case "assistant": {
        const assistantMessage = content.map((part) => {
          switch (part.type) {
            case "text": {
              return part.text;
            }
            case "tool-call": {
              throw new UnsupportedFunctionalityError$1({
                functionality: "tool-call messages"
              });
            }
          }
        }).join("");
        text += `${assistant}:
${assistantMessage}

`;
        break;
      }
      case "tool": {
        throw new UnsupportedFunctionalityError$1({
          functionality: "tool messages"
        });
      }
      default: {
        const _exhaustiveCheck = role;
        throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
      }
    }
  }
  text += `${assistant}:
`;
  return {
    prompt: text,
    stopSequences: [`
${user}:`]
  };
}

// src/completion/get-response-metadata.ts
function getResponseMetadata2({
  id,
  model,
  created
}) {
  return {
    id: id != null ? id : void 0,
    modelId: model != null ? model : void 0,
    timestamp: created != null ? new Date(created * 1e3) : void 0
  };
}

// src/completion/map-openai-compatible-finish-reason.ts
function mapOpenAICompatibleFinishReason2(finishReason) {
  switch (finishReason) {
    case "stop":
      return "stop";
    case "length":
      return "length";
    case "content_filter":
      return "content-filter";
    case "function_call":
    case "tool_calls":
      return "tool-calls";
    default:
      return "unknown";
  }
}
var openaiCompatibleCompletionProviderOptions = object({
  /**
   * Echo back the prompt in addition to the completion.
   */
  echo: boolean().optional(),
  /**
   * Modify the likelihood of specified tokens appearing in the completion.
   *
   * Accepts a JSON object that maps tokens (specified by their token ID in
   * the GPT tokenizer) to an associated bias value from -100 to 100.
   */
  logitBias: record(string(), number$1()).optional(),
  /**
   * The suffix that comes after a completion of inserted text.
   */
  suffix: string().optional(),
  /**
   * A unique identifier representing your end-user, which can help providers to
   * monitor and detect abuse.
   */
  user: string().optional()
});

// src/completion/openai-compatible-completion-language-model.ts
var OpenAICompatibleCompletionLanguageModel = class {
  // type inferred via constructor
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    var _a;
    this.modelId = modelId;
    this.config = config;
    const errorStructure = (_a = config.errorStructure) != null ? _a : defaultOpenAICompatibleErrorStructure;
    this.chunkSchema = createOpenAICompatibleCompletionChunkSchema(
      errorStructure.errorSchema
    );
    this.failedResponseHandler = createJsonErrorResponseHandler$1(errorStructure);
  }
  get provider() {
    return this.config.provider;
  }
  get providerOptionsName() {
    return this.config.provider.split(".")[0].trim();
  }
  get supportedUrls() {
    var _a, _b, _c;
    return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
  }
  async getArgs({
    prompt,
    maxOutputTokens,
    temperature,
    topP,
    topK,
    frequencyPenalty,
    presencePenalty,
    stopSequences: userStopSequences,
    responseFormat,
    seed,
    providerOptions,
    tools,
    toolChoice
  }) {
    var _a;
    const warnings = [];
    const completionOptions = (_a = await parseProviderOptions({
      provider: this.providerOptionsName,
      providerOptions,
      schema: openaiCompatibleCompletionProviderOptions
    })) != null ? _a : {};
    if (topK != null) {
      warnings.push({ type: "unsupported-setting", setting: "topK" });
    }
    if (tools == null ? void 0 : tools.length) {
      warnings.push({ type: "unsupported-setting", setting: "tools" });
    }
    if (toolChoice != null) {
      warnings.push({ type: "unsupported-setting", setting: "toolChoice" });
    }
    if (responseFormat != null && responseFormat.type !== "text") {
      warnings.push({
        type: "unsupported-setting",
        setting: "responseFormat",
        details: "JSON response format is not supported."
      });
    }
    const { prompt: completionPrompt, stopSequences } = convertToOpenAICompatibleCompletionPrompt({ prompt });
    const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
    return {
      args: {
        // model id:
        model: this.modelId,
        // model specific settings:
        echo: completionOptions.echo,
        logit_bias: completionOptions.logitBias,
        suffix: completionOptions.suffix,
        user: completionOptions.user,
        // standardized settings:
        max_tokens: maxOutputTokens,
        temperature,
        top_p: topP,
        frequency_penalty: frequencyPenalty,
        presence_penalty: presencePenalty,
        seed,
        ...providerOptions == null ? void 0 : providerOptions[this.providerOptionsName],
        // prompt:
        prompt: completionPrompt,
        // stop sequences:
        stop: stop.length > 0 ? stop : void 0
      },
      warnings
    };
  }
  async doGenerate(options) {
    var _a, _b, _c, _d, _e, _f;
    const { args, warnings } = await this.getArgs(options);
    const {
      responseHeaders,
      value: response,
      rawValue: rawResponse
    } = await postJsonToApi$1({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body: args,
      failedResponseHandler: this.failedResponseHandler,
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiCompatibleCompletionResponseSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    const choice = response.choices[0];
    const content = [];
    if (choice.text != null && choice.text.length > 0) {
      content.push({ type: "text", text: choice.text });
    }
    return {
      content,
      usage: {
        inputTokens: (_b = (_a = response.usage) == null ? void 0 : _a.prompt_tokens) != null ? _b : void 0,
        outputTokens: (_d = (_c = response.usage) == null ? void 0 : _c.completion_tokens) != null ? _d : void 0,
        totalTokens: (_f = (_e = response.usage) == null ? void 0 : _e.total_tokens) != null ? _f : void 0
      },
      finishReason: mapOpenAICompatibleFinishReason2(choice.finish_reason),
      request: { body: args },
      response: {
        ...getResponseMetadata2(response),
        headers: responseHeaders,
        body: rawResponse
      },
      warnings
    };
  }
  async doStream(options) {
    const { args, warnings } = await this.getArgs(options);
    const body = {
      ...args,
      stream: true,
      // only include stream_options when in strict compatibility mode:
      stream_options: this.config.includeUsage ? { include_usage: true } : void 0
    };
    const { responseHeaders, value: response } = await postJsonToApi$1({
      url: this.config.url({
        path: "/completions",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), options.headers),
      body,
      failedResponseHandler: this.failedResponseHandler,
      successfulResponseHandler: createEventSourceResponseHandler$1(
        this.chunkSchema
      ),
      abortSignal: options.abortSignal,
      fetch: this.config.fetch
    });
    let finishReason = "unknown";
    const usage = {
      inputTokens: void 0,
      outputTokens: void 0,
      totalTokens: void 0
    };
    let isFirstChunk = true;
    return {
      stream: response.pipeThrough(
        new TransformStream({
          start(controller) {
            controller.enqueue({ type: "stream-start", warnings });
          },
          transform(chunk, controller) {
            var _a, _b, _c;
            if (options.includeRawChunks) {
              controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
            }
            if (!chunk.success) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: chunk.error });
              return;
            }
            const value = chunk.value;
            if ("error" in value) {
              finishReason = "error";
              controller.enqueue({ type: "error", error: value.error });
              return;
            }
            if (isFirstChunk) {
              isFirstChunk = false;
              controller.enqueue({
                type: "response-metadata",
                ...getResponseMetadata2(value)
              });
              controller.enqueue({
                type: "text-start",
                id: "0"
              });
            }
            if (value.usage != null) {
              usage.inputTokens = (_a = value.usage.prompt_tokens) != null ? _a : void 0;
              usage.outputTokens = (_b = value.usage.completion_tokens) != null ? _b : void 0;
              usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;
            }
            const choice = value.choices[0];
            if ((choice == null ? void 0 : choice.finish_reason) != null) {
              finishReason = mapOpenAICompatibleFinishReason2(
                choice.finish_reason
              );
            }
            if ((choice == null ? void 0 : choice.text) != null) {
              controller.enqueue({
                type: "text-delta",
                id: "0",
                delta: choice.text
              });
            }
          },
          flush(controller) {
            if (!isFirstChunk) {
              controller.enqueue({ type: "text-end", id: "0" });
            }
            controller.enqueue({
              type: "finish",
              finishReason,
              usage
            });
          }
        })
      ),
      request: { body },
      response: { headers: responseHeaders }
    };
  }
};
var usageSchema = object({
  prompt_tokens: number$1(),
  completion_tokens: number$1(),
  total_tokens: number$1()
});
var openaiCompatibleCompletionResponseSchema = object({
  id: string().nullish(),
  created: number$1().nullish(),
  model: string().nullish(),
  choices: array(
    object({
      text: string(),
      finish_reason: string()
    })
  ),
  usage: usageSchema.nullish()
});
var createOpenAICompatibleCompletionChunkSchema = (errorSchema) => union([
  object({
    id: string().nullish(),
    created: number$1().nullish(),
    model: string().nullish(),
    choices: array(
      object({
        text: string(),
        finish_reason: string().nullish(),
        index: number$1()
      })
    ),
    usage: usageSchema.nullish()
  }),
  errorSchema
]);
var openaiCompatibleEmbeddingProviderOptions = object({
  /**
   * The number of dimensions the resulting output embeddings should have.
   * Only supported in text-embedding-3 and later models.
   */
  dimensions: number$1().optional(),
  /**
   * A unique identifier representing your end-user, which can help providers to
   * monitor and detect abuse.
   */
  user: string().optional()
});

// src/embedding/openai-compatible-embedding-model.ts
var OpenAICompatibleEmbeddingModel = class {
  constructor(modelId, config) {
    this.specificationVersion = "v2";
    this.modelId = modelId;
    this.config = config;
  }
  get provider() {
    return this.config.provider;
  }
  get maxEmbeddingsPerCall() {
    var _a;
    return (_a = this.config.maxEmbeddingsPerCall) != null ? _a : 2048;
  }
  get supportsParallelCalls() {
    var _a;
    return (_a = this.config.supportsParallelCalls) != null ? _a : true;
  }
  get providerOptionsName() {
    return this.config.provider.split(".")[0].trim();
  }
  async doEmbed({
    values,
    headers,
    abortSignal,
    providerOptions
  }) {
    var _a, _b, _c;
    const compatibleOptions = Object.assign(
      (_a = await parseProviderOptions({
        provider: "openai-compatible",
        providerOptions,
        schema: openaiCompatibleEmbeddingProviderOptions
      })) != null ? _a : {},
      (_b = await parseProviderOptions({
        provider: this.providerOptionsName,
        providerOptions,
        schema: openaiCompatibleEmbeddingProviderOptions
      })) != null ? _b : {}
    );
    if (values.length > this.maxEmbeddingsPerCall) {
      throw new TooManyEmbeddingValuesForCallError({
        provider: this.provider,
        modelId: this.modelId,
        maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
        values
      });
    }
    const {
      responseHeaders,
      value: response,
      rawValue
    } = await postJsonToApi$1({
      url: this.config.url({
        path: "/embeddings",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), headers),
      body: {
        model: this.modelId,
        input: values,
        encoding_format: "float",
        dimensions: compatibleOptions.dimensions,
        user: compatibleOptions.user
      },
      failedResponseHandler: createJsonErrorResponseHandler$1(
        (_c = this.config.errorStructure) != null ? _c : defaultOpenAICompatibleErrorStructure
      ),
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiTextEmbeddingResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      embeddings: response.data.map((item) => item.embedding),
      usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
      providerMetadata: response.providerMetadata,
      response: { headers: responseHeaders, body: rawValue }
    };
  }
};
var openaiTextEmbeddingResponseSchema = object({
  data: array(object({ embedding: array(number$1()) })),
  usage: object({ prompt_tokens: number$1() }).nullish(),
  providerMetadata: record(string(), record(string(), any())).optional()
});
var OpenAICompatibleImageModel = class {
  constructor(modelId, config) {
    this.modelId = modelId;
    this.config = config;
    this.specificationVersion = "v2";
    this.maxImagesPerCall = 10;
  }
  get provider() {
    return this.config.provider;
  }
  async doGenerate({
    prompt,
    n,
    size,
    aspectRatio,
    seed,
    providerOptions,
    headers,
    abortSignal
  }) {
    var _a, _b, _c, _d, _e;
    const warnings = [];
    if (aspectRatio != null) {
      warnings.push({
        type: "unsupported-setting",
        setting: "aspectRatio",
        details: "This model does not support aspect ratio. Use `size` instead."
      });
    }
    if (seed != null) {
      warnings.push({ type: "unsupported-setting", setting: "seed" });
    }
    const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
    const { value: response, responseHeaders } = await postJsonToApi$1({
      url: this.config.url({
        path: "/images/generations",
        modelId: this.modelId
      }),
      headers: combineHeaders$1(this.config.headers(), headers),
      body: {
        model: this.modelId,
        prompt,
        n,
        size,
        ...(_d = providerOptions.openai) != null ? _d : {},
        response_format: "b64_json"
      },
      failedResponseHandler: createJsonErrorResponseHandler$1(
        (_e = this.config.errorStructure) != null ? _e : defaultOpenAICompatibleErrorStructure
      ),
      successfulResponseHandler: createJsonResponseHandler$1(
        openaiCompatibleImageResponseSchema
      ),
      abortSignal,
      fetch: this.config.fetch
    });
    return {
      images: response.data.map((item) => item.b64_json),
      warnings,
      response: {
        timestamp: currentDate,
        modelId: this.modelId,
        headers: responseHeaders
      }
    };
  }
};
var openaiCompatibleImageResponseSchema = object({
  data: array(object({ b64_json: string() }))
});

// src/version.ts
var VERSION = "1.0.22" ;

// src/openai-compatible-provider.ts
function createOpenAICompatible(options) {
  const baseURL = withoutTrailingSlash$1(options.baseURL);
  const providerName = options.name;
  const headers = {
    ...options.apiKey && { Authorization: `Bearer ${options.apiKey}` },
    ...options.headers
  };
  const getHeaders = () => withUserAgentSuffix(headers, `ai-sdk/openai-compatible/${VERSION}`);
  const getCommonModelConfig = (modelType) => ({
    provider: `${providerName}.${modelType}`,
    url: ({ path }) => {
      const url = new URL(`${baseURL}${path}`);
      if (options.queryParams) {
        url.search = new URLSearchParams(options.queryParams).toString();
      }
      return url.toString();
    },
    headers: getHeaders,
    fetch: options.fetch
  });
  const createLanguageModel = (modelId) => createChatModel(modelId);
  const createChatModel = (modelId) => new OpenAICompatibleChatLanguageModel(modelId, {
    ...getCommonModelConfig("chat"),
    includeUsage: options.includeUsage,
    supportsStructuredOutputs: options.supportsStructuredOutputs
  });
  const createCompletionModel = (modelId) => new OpenAICompatibleCompletionLanguageModel(modelId, {
    ...getCommonModelConfig("completion"),
    includeUsage: options.includeUsage
  });
  const createEmbeddingModel = (modelId) => new OpenAICompatibleEmbeddingModel(modelId, {
    ...getCommonModelConfig("embedding")
  });
  const createImageModel = (modelId) => new OpenAICompatibleImageModel(modelId, getCommonModelConfig("image"));
  const provider = (modelId) => createLanguageModel(modelId);
  provider.languageModel = createLanguageModel;
  provider.chatModel = createChatModel;
  provider.completionModel = createCompletionModel;
  provider.textEmbeddingModel = createEmbeddingModel;
  provider.imageModel = createImageModel;
  return provider;
}

function buildAgentTree(agents) {
    // Detect and handle circular dependencies
    const safeAgents = detectAndBreakCycles(agents);
    if (safeAgents.length === 0) {
        throw new Error("No executable agent");
    }
    // Establish dependency relationship mapping
    const agentMap = new Map();
    const dependents = new Map();
    for (const agent of safeAgents) {
        agentMap.set(agent.id, agent);
        dependents.set(agent.id, []);
    }
    for (const agent of safeAgents) {
        for (const depId of agent.dependsOn) {
            if (dependents.has(depId)) {
                dependents.get(depId).push(agent);
            }
        }
    }
    let entryAgents = safeAgents.filter((agent) => agent.dependsOn.length === 0);
    if (entryAgents.length === 0) {
        entryAgents = safeAgents.filter((agent) => agent.dependsOn.length == 1 && agent.dependsOn[0].endsWith("00"));
    }
    const processedAgents = new Set();
    function buildNodeRecursive(currentAgents) {
        if (currentAgents.length === 0) {
            return undefined;
        }
        for (const agent of currentAgents) {
            processedAgents.add(agent.id);
        }
        const nextLevelAgents = [];
        const nextLevelSet = new Set();
        for (const agent of currentAgents) {
            const dependentAgents = dependents.get(agent.id) || [];
            for (const dependentAgent of dependentAgents) {
                const allDependenciesProcessed = dependentAgent.dependsOn.every((depId) => processedAgents.has(depId));
                if (allDependenciesProcessed && !nextLevelSet.has(dependentAgent.id)) {
                    nextLevelAgents.push(dependentAgent);
                    nextLevelSet.add(dependentAgent.id);
                }
            }
        }
        const nextNode = buildNodeRecursive(nextLevelAgents);
        if (currentAgents.length === 1) {
            return {
                type: "normal",
                agent: currentAgents[0],
                nextAgent: nextNode,
            };
        }
        else {
            const parallelNodes = currentAgents.map((agent) => ({
                type: "normal",
                agent: agent,
                nextAgent: undefined,
            }));
            return {
                type: "parallel",
                agents: parallelNodes,
                nextAgent: nextNode,
            };
        }
    }
    const rootNode = buildNodeRecursive(entryAgents);
    if (!rootNode) {
        throw new Error("Unable to build execution tree");
    }
    return rootNode;
}
function detectAndBreakCycles(agents) {
    // Detect cyclic dependencies and return a safe dependency relationship
    // Use topological sorting algorithm to detect cycles, if a cycle is found, break some dependencies.
    const agentMap = new Map();
    const inDegree = new Map();
    const adjList = new Map();
    for (const agent of agents) {
        agentMap.set(agent.id, agent);
        inDegree.set(agent.id, 0);
        adjList.set(agent.id, []);
    }
    for (const agent of agents) {
        for (const depId of agent.dependsOn) {
            if (agentMap.has(depId)) {
                // depId -> agent.id indicates that the agent depends on depId.
                adjList.get(depId).push(agent.id);
                inDegree.set(agent.id, inDegree.get(agent.id) + 1);
            }
        }
    }
    // Topological Sorting Detects Cycles
    const queue = [];
    const processedCount = new Map();
    for (const [agentId, degree] of inDegree.entries()) {
        if (degree === 0) {
            queue.push(agentId);
        }
        processedCount.set(agentId, 0);
    }
    let processedNodes = 0;
    while (queue.length > 0) {
        const currentId = queue.shift();
        processedNodes++;
        for (const neighborId of adjList.get(currentId)) {
            const newInDegree = inDegree.get(neighborId) - 1;
            inDegree.set(neighborId, newInDegree);
            if (newInDegree === 0) {
                queue.push(neighborId);
            }
        }
    }
    if (processedNodes < agents.length) {
        console.warn("Detected a circular dependency, automatically disconnecting the circular link...");
        const cyclicNodes = new Set();
        for (const [agentId, degree] of inDegree.entries()) {
            if (degree > 0) {
                cyclicNodes.add(agentId);
            }
        }
        const fixedAgents = [];
        for (const agent of agents) {
            if (cyclicNodes.has(agent.id)) {
                const filteredDependsOn = agent.dependsOn.filter((depId) => !cyclicNodes.has(depId) || !agentMap.has(depId));
                // Preserve the shortest path dependency
                if (filteredDependsOn.length === 0 && agent.dependsOn.length > 0) {
                    const firstValidDep = agent.dependsOn.find((depId) => agentMap.has(depId));
                    if (firstValidDep && !cyclicNodes.has(firstValidDep)) {
                        filteredDependsOn.push(firstValidDep);
                    }
                }
                agent.dependsOn = filteredDependsOn;
                fixedAgents.push(agent);
                if (filteredDependsOn.length !== agent.dependsOn.length) {
                    console.warn(`The partial cyclic dependency of agent ${agent.id} has been disconnected.`);
                }
            }
            else {
                // Non-cyclic node, filter out non-existent dependencies
                const validDependsOn = agent.dependsOn.filter((depId) => agentMap.has(depId));
                agent.dependsOn = validDependsOn;
                fixedAgents.push(agent);
            }
        }
        return fixedAgents;
    }
    // No loops, just need to filter out non-existent dependencies
    return agents.map((agent) => {
        agent.dependsOn = agent.dependsOn.filter((depId) => agentMap.has(depId));
        return agent;
    });
}

var lib = {};

var dom = {};

var conventions = {};

var hasRequiredConventions;

function requireConventions () {
	if (hasRequiredConventions) return conventions;
	hasRequiredConventions = 1;

	/**
	 * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.
	 *
	 * Works with anything that has a `length` property and index access properties, including NodeList.
	 *
	 * @template {unknown} T
	 * @param {Array<T> | ({length:number, [number]: T})} list
	 * @param {function (item: T, index: number, list:Array<T> | ({length:number, [number]: T})):boolean} predicate
	 * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac `Array.prototype` by default,
	 * 				allows injecting a custom implementation in tests
	 * @returns {T | undefined}
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
	 * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find
	 */
	function find(list, predicate, ac) {
		if (ac === undefined) {
			ac = Array.prototype;
		}
		if (list && typeof ac.find === 'function') {
			return ac.find.call(list, predicate);
		}
		for (var i = 0; i < list.length; i++) {
			if (Object.prototype.hasOwnProperty.call(list, i)) {
				var item = list[i];
				if (predicate.call(undefined, item, i, list)) {
					return item;
				}
			}
		}
	}

	/**
	 * "Shallow freezes" an object to render it immutable.
	 * Uses `Object.freeze` if available,
	 * otherwise the immutability is only in the type.
	 *
	 * Is used to create "enum like" objects.
	 *
	 * @template T
	 * @param {T} object the object to freeze
	 * @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,
	 * 				allows to inject custom object constructor for tests
	 * @returns {Readonly<T>}
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
	 */
	function freeze(object, oc) {
		if (oc === undefined) {
			oc = Object;
		}
		return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object
	}

	/**
	 * Since we can not rely on `Object.assign` we provide a simplified version
	 * that is sufficient for our needs.
	 *
	 * @param {Object} target
	 * @param {Object | null | undefined} source
	 *
	 * @returns {Object} target
	 * @throws TypeError if target is not an object
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	 * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign
	 */
	function assign(target, source) {
		if (target === null || typeof target !== 'object') {
			throw new TypeError('target is not an object')
		}
		for (var key in source) {
			if (Object.prototype.hasOwnProperty.call(source, key)) {
				target[key] = source[key];
			}
		}
		return target
	}

	/**
	 * All mime types that are allowed as input to `DOMParser.parseFromString`
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN
	 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec
	 * @see DOMParser.prototype.parseFromString
	 */
	var MIME_TYPE = freeze({
		/**
		 * `text/html`, the only mime type that triggers treating an XML document as HTML.
		 *
		 * @see DOMParser.SupportedType.isHTML
		 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
		 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
		 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
		 */
		HTML: 'text/html',

		/**
		 * Helper method to check a mime type if it indicates an HTML document
		 *
		 * @param {string} [value]
		 * @returns {boolean}
		 *
		 * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
		 * @see https://en.wikipedia.org/wiki/HTML Wikipedia
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
		 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
		isHTML: function (value) {
			return value === MIME_TYPE.HTML
		},

		/**
		 * `application/xml`, the standard mime type for XML documents.
		 *
		 * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
		 * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
		 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
		 */
		XML_APPLICATION: 'application/xml',

		/**
		 * `text/html`, an alias for `application/xml`.
		 *
		 * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
		 * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
		 * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
		 */
		XML_TEXT: 'text/xml',

		/**
		 * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
		 * but is parsed as an XML document.
		 *
		 * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
		 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
		 * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
		 */
		XML_XHTML_APPLICATION: 'application/xhtml+xml',

		/**
		 * `image/svg+xml`,
		 *
		 * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
		 * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
		 * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
		 */
		XML_SVG_IMAGE: 'image/svg+xml',
	});

	/**
	 * Namespaces that are used in this code base.
	 *
	 * @see http://www.w3.org/TR/REC-xml-names
	 */
	var NAMESPACE = freeze({
		/**
		 * The XHTML namespace.
		 *
		 * @see http://www.w3.org/1999/xhtml
		 */
		HTML: 'http://www.w3.org/1999/xhtml',

		/**
		 * Checks if `uri` equals `NAMESPACE.HTML`.
		 *
		 * @param {string} [uri]
		 *
		 * @see NAMESPACE.HTML
		 */
		isHTML: function (uri) {
			return uri === NAMESPACE.HTML
		},

		/**
		 * The SVG namespace.
		 *
		 * @see http://www.w3.org/2000/svg
		 */
		SVG: 'http://www.w3.org/2000/svg',

		/**
		 * The `xml:` namespace.
		 *
		 * @see http://www.w3.org/XML/1998/namespace
		 */
		XML: 'http://www.w3.org/XML/1998/namespace',

		/**
		 * The `xmlns:` namespace
		 *
		 * @see https://www.w3.org/2000/xmlns/
		 */
		XMLNS: 'http://www.w3.org/2000/xmlns/',
	});

	conventions.assign = assign;
	conventions.find = find;
	conventions.freeze = freeze;
	conventions.MIME_TYPE = MIME_TYPE;
	conventions.NAMESPACE = NAMESPACE;
	return conventions;
}

var hasRequiredDom;

function requireDom () {
	if (hasRequiredDom) return dom;
	hasRequiredDom = 1;
	var conventions = requireConventions();

	var find = conventions.find;
	var NAMESPACE = conventions.NAMESPACE;

	/**
	 * A prerequisite for `[].filter`, to drop elements that are empty
	 * @param {string} input
	 * @returns {boolean}
	 */
	function notEmptyString (input) {
		return input !== ''
	}
	/**
	 * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
	 * @see https://infra.spec.whatwg.org/#ascii-whitespace
	 *
	 * @param {string} input
	 * @returns {string[]} (can be empty)
	 */
	function splitOnASCIIWhitespace(input) {
		// U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE
		return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : []
	}

	/**
	 * Adds element as a key to current if it is not already present.
	 *
	 * @param {Record<string, boolean | undefined>} current
	 * @param {string} element
	 * @returns {Record<string, boolean | undefined>}
	 */
	function orderedSetReducer (current, element) {
		if (!current.hasOwnProperty(element)) {
			current[element] = true;
		}
		return current;
	}

	/**
	 * @see https://infra.spec.whatwg.org/#ordered-set
	 * @param {string} input
	 * @returns {string[]}
	 */
	function toOrderedSet(input) {
		if (!input) return [];
		var list = splitOnASCIIWhitespace(input);
		return Object.keys(list.reduce(orderedSetReducer, {}))
	}

	/**
	 * Uses `list.indexOf` to implement something like `Array.prototype.includes`,
	 * which we can not rely on being available.
	 *
	 * @param {any[]} list
	 * @returns {function(any): boolean}
	 */
	function arrayIncludes (list) {
		return function(element) {
			return list && list.indexOf(element) !== -1;
		}
	}

	function copy(src,dest){
		for(var p in src){
			if (Object.prototype.hasOwnProperty.call(src, p)) {
				dest[p] = src[p];
			}
		}
	}

	/**
	^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
	^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
	 */
	function _extends(Class,Super){
		var pt = Class.prototype;
		if(!(pt instanceof Super)){
			function t(){}			t.prototype = Super.prototype;
			t = new t();
			copy(pt,t);
			Class.prototype = pt = t;
		}
		if(pt.constructor != Class){
			if(typeof Class != 'function'){
				console.error("unknown Class:"+Class);
			}
			pt.constructor = Class;
		}
	}

	// Node Types
	var NodeType = {};
	var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
	var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
	var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
	var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
	var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
	var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
	var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
	var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
	var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
	var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
	var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
	var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

	// ExceptionCode
	var ExceptionCode = {};
	var ExceptionMessage = {};
	ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
	ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
	var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
	ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
	ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
	ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
	ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
	var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
	ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
	var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
	//level2
	ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
	ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
	ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
	ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
	ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);

	/**
	 * DOM Level 2
	 * Object DOMException
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
	 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
	 */
	function DOMException(code, message) {
		if(message instanceof Error){
			var error = message;
		}else {
			error = this;
			Error.call(this, ExceptionMessage[code]);
			this.message = ExceptionMessage[code];
			if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
		}
		error.code = code;
		if(message) this.message = this.message + ": " + message;
		return error;
	}	DOMException.prototype = Error.prototype;
	copy(ExceptionCode,DOMException);

	/**
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
	 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
	 * The items in the NodeList are accessible via an integral index, starting from 0.
	 */
	function NodeList() {
	}	NodeList.prototype = {
		/**
		 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
		 * @standard level1
		 */
		length:0,
		/**
		 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
		 * @standard level1
		 * @param index  unsigned long
		 *   Index into the collection.
		 * @return Node
		 * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
		 */
		item: function(index) {
			return index >= 0 && index < this.length ? this[index] : null;
		},
		toString:function(isHTML,nodeFilter){
			for(var buf = [], i = 0;i<this.length;i++){
				serializeToString(this[i],buf,isHTML,nodeFilter);
			}
			return buf.join('');
		},
		/**
		 * @private
		 * @param {function (Node):boolean} predicate
		 * @returns {Node[]}
		 */
		filter: function (predicate) {
			return Array.prototype.filter.call(this, predicate);
		},
		/**
		 * @private
		 * @param {Node} item
		 * @returns {number}
		 */
		indexOf: function (item) {
			return Array.prototype.indexOf.call(this, item);
		},
	};

	function LiveNodeList(node,refresh){
		this._node = node;
		this._refresh = refresh;
		_updateLiveList(this);
	}
	function _updateLiveList(list){
		var inc = list._node._inc || list._node.ownerDocument._inc;
		if (list._inc !== inc) {
			var ls = list._refresh(list._node);
			__set__(list,'length',ls.length);
			if (!list.$$length || ls.length < list.$$length) {
				for (var i = ls.length; i in list; i++) {
					if (Object.prototype.hasOwnProperty.call(list, i)) {
						delete list[i];
					}
				}
			}
			copy(ls,list);
			list._inc = inc;
		}
	}
	LiveNodeList.prototype.item = function(i){
		_updateLiveList(this);
		return this[i] || null;
	};

	_extends(LiveNodeList,NodeList);

	/**
	 * Objects implementing the NamedNodeMap interface are used
	 * to represent collections of nodes that can be accessed by name.
	 * Note that NamedNodeMap does not inherit from NodeList;
	 * NamedNodeMaps are not maintained in any particular order.
	 * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,
	 * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,
	 * and does not imply that the DOM specifies an order to these Nodes.
	 * NamedNodeMap objects in the DOM are live.
	 * used for attributes or DocumentType entities
	 */
	function NamedNodeMap() {
	}
	function _findNodeIndex(list,node){
		var i = list.length;
		while(i--){
			if(list[i] === node){return i}
		}
	}

	function _addNamedNode(el,list,newAttr,oldAttr){
		if(oldAttr){
			list[_findNodeIndex(list,oldAttr)] = newAttr;
		}else {
			list[list.length++] = newAttr;
		}
		if(el){
			newAttr.ownerElement = el;
			var doc = el.ownerDocument;
			if(doc){
				oldAttr && _onRemoveAttribute(doc,el,oldAttr);
				_onAddAttribute(doc,el,newAttr);
			}
		}
	}
	function _removeNamedNode(el,list,attr){
		//console.log('remove attr:'+attr)
		var i = _findNodeIndex(list,attr);
		if(i>=0){
			var lastIndex = list.length-1;
			while(i<lastIndex){
				list[i] = list[++i];
			}
			list.length = lastIndex;
			if(el){
				var doc = el.ownerDocument;
				if(doc){
					_onRemoveAttribute(doc,el,attr);
					attr.ownerElement = null;
				}
			}
		}else {
			throw new DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
		}
	}
	NamedNodeMap.prototype = {
		length:0,
		item:NodeList.prototype.item,
		getNamedItem: function(key) {
	//		if(key.indexOf(':')>0 || key == 'xmlns'){
	//			return null;
	//		}
			//console.log()
			var i = this.length;
			while(i--){
				var attr = this[i];
				//console.log(attr.nodeName,key)
				if(attr.nodeName == key){
					return attr;
				}
			}
		},
		setNamedItem: function(attr) {
			var el = attr.ownerElement;
			if(el && el!=this._ownerElement){
				throw new DOMException(INUSE_ATTRIBUTE_ERR);
			}
			var oldAttr = this.getNamedItem(attr.nodeName);
			_addNamedNode(this._ownerElement,this,attr,oldAttr);
			return oldAttr;
		},
		/* returns Node */
		setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
			var el = attr.ownerElement, oldAttr;
			if(el && el!=this._ownerElement){
				throw new DOMException(INUSE_ATTRIBUTE_ERR);
			}
			oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
			_addNamedNode(this._ownerElement,this,attr,oldAttr);
			return oldAttr;
		},

		/* returns Node */
		removeNamedItem: function(key) {
			var attr = this.getNamedItem(key);
			_removeNamedNode(this._ownerElement,this,attr);
			return attr;


		},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR

		//for level2
		removeNamedItemNS:function(namespaceURI,localName){
			var attr = this.getNamedItemNS(namespaceURI,localName);
			_removeNamedNode(this._ownerElement,this,attr);
			return attr;
		},
		getNamedItemNS: function(namespaceURI, localName) {
			var i = this.length;
			while(i--){
				var node = this[i];
				if(node.localName == localName && node.namespaceURI == namespaceURI){
					return node;
				}
			}
			return null;
		}
	};

	/**
	 * The DOMImplementation interface represents an object providing methods
	 * which are not dependent on any particular document.
	 * Such an object is returned by the `Document.implementation` property.
	 *
	 * __The individual methods describe the differences compared to the specs.__
	 *
	 * @constructor
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN
	 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)
	 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core
	 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core
	 * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard
	 */
	function DOMImplementation() {
	}

	DOMImplementation.prototype = {
		/**
		 * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
		 * The different implementations fairly diverged in what kind of features were reported.
		 * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
		 *
		 * @deprecated It is deprecated and modern browsers return true in all cases.
		 *
		 * @param {string} feature
		 * @param {string} [version]
		 * @returns {boolean} always true
		 *
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
		 * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
		 * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
		 */
		hasFeature: function(feature, version) {
				return true;
		},
		/**
		 * Creates an XML Document object of the specified type with its document element.
		 *
		 * __It behaves slightly different from the description in the living standard__:
		 * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
		 * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
		 * - this implementation is not validating names or qualified names
		 *   (when parsing XML strings, the SAX parser takes care of that)
		 *
		 * @param {string|null} namespaceURI
		 * @param {string} qualifiedName
		 * @param {DocumentType=null} doctype
		 * @returns {Document}
		 *
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
		 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
		 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
		 *
		 * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
		 * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
		 * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
		 */
		createDocument: function(namespaceURI,  qualifiedName, doctype){
			var doc = new Document();
			doc.implementation = this;
			doc.childNodes = new NodeList();
			doc.doctype = doctype || null;
			if (doctype){
				doc.appendChild(doctype);
			}
			if (qualifiedName){
				var root = doc.createElementNS(namespaceURI, qualifiedName);
				doc.appendChild(root);
			}
			return doc;
		},
		/**
		 * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
		 *
		 * __This behavior is slightly different from the in the specs__:
		 * - this implementation is not validating names or qualified names
		 *   (when parsing XML strings, the SAX parser takes care of that)
		 *
		 * @param {string} qualifiedName
		 * @param {string} [publicId]
		 * @param {string} [systemId]
		 * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
		 * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
		 *
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
		 * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
		 * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
		 *
		 * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
		 * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
		 * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
		 */
		createDocumentType: function(qualifiedName, publicId, systemId){
			var node = new DocumentType();
			node.name = qualifiedName;
			node.nodeName = qualifiedName;
			node.publicId = publicId || '';
			node.systemId = systemId || '';

			return node;
		}
	};


	/**
	 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
	 */

	function Node() {
	}
	Node.prototype = {
		firstChild : null,
		lastChild : null,
		previousSibling : null,
		nextSibling : null,
		attributes : null,
		parentNode : null,
		childNodes : null,
		ownerDocument : null,
		nodeValue : null,
		namespaceURI : null,
		prefix : null,
		localName : null,
		// Modified in DOM Level 2:
		insertBefore:function(newChild, refChild){//raises
			return _insertBefore(this,newChild,refChild);
		},
		replaceChild:function(newChild, oldChild){//raises
			_insertBefore(this, newChild,oldChild, assertPreReplacementValidityInDocument);
			if(oldChild){
				this.removeChild(oldChild);
			}
		},
		removeChild:function(oldChild){
			return _removeChild(this,oldChild);
		},
		appendChild:function(newChild){
			return this.insertBefore(newChild,null);
		},
		hasChildNodes:function(){
			return this.firstChild != null;
		},
		cloneNode:function(deep){
			return cloneNode(this.ownerDocument||this,this,deep);
		},
		// Modified in DOM Level 2:
		normalize:function(){
			var child = this.firstChild;
			while(child){
				var next = child.nextSibling;
				if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
					this.removeChild(next);
					child.appendData(next.data);
				}else {
					child.normalize();
					child = next;
				}
			}
		},
	  	// Introduced in DOM Level 2:
		isSupported:function(feature, version){
			return this.ownerDocument.implementation.hasFeature(feature,version);
		},
	    // Introduced in DOM Level 2:
	    hasAttributes:function(){
	    	return this.attributes.length>0;
	    },
		/**
		 * Look up the prefix associated to the given namespace URI, starting from this node.
		 * **The default namespace declarations are ignored by this method.**
		 * See Namespace Prefix Lookup for details on the algorithm used by this method.
		 *
		 * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
		 *
		 * @param {string | null} namespaceURI
		 * @returns {string | null}
		 * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
		 * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
		 * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
		 * @see https://github.com/xmldom/xmldom/issues/322
		 */
	    lookupPrefix:function(namespaceURI){
	    	var el = this;
	    	while(el){
	    		var map = el._nsMap;
	    		//console.dir(map)
	    		if(map){
	    			for(var n in map){
							if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
								return n;
							}
	    			}
	    		}
	    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
	    	}
	    	return null;
	    },
	    // Introduced in DOM Level 3:
	    lookupNamespaceURI:function(prefix){
	    	var el = this;
	    	while(el){
	    		var map = el._nsMap;
	    		//console.dir(map)
	    		if(map){
	    			if(Object.prototype.hasOwnProperty.call(map, prefix)){
	    				return map[prefix] ;
	    			}
	    		}
	    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
	    	}
	    	return null;
	    },
	    // Introduced in DOM Level 3:
	    isDefaultNamespace:function(namespaceURI){
	    	var prefix = this.lookupPrefix(namespaceURI);
	    	return prefix == null;
	    }
	};


	function _xmlEncoder(c){
		return c == '<' && '&lt;' ||
	         c == '>' && '&gt;' ||
	         c == '&' && '&amp;' ||
	         c == '"' && '&quot;' ||
	         '&#'+c.charCodeAt()+';'
	}


	copy(NodeType,Node);
	copy(NodeType,Node.prototype);

	/**
	 * @param callback return true for continue,false for break
	 * @return boolean true: break visit;
	 */
	function _visitNode(node,callback){
		if(callback(node)){
			return true;
		}
		if(node = node.firstChild){
			do{
				if(_visitNode(node,callback)){return true}
	        }while(node=node.nextSibling)
	    }
	}



	function Document(){
		this.ownerDocument = this;
	}

	function _onAddAttribute(doc,el,newAttr){
		doc && doc._inc++;
		var ns = newAttr.namespaceURI ;
		if(ns === NAMESPACE.XMLNS){
			//update namespace
			el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value;
		}
	}

	function _onRemoveAttribute(doc,el,newAttr,remove){
		doc && doc._inc++;
		var ns = newAttr.namespaceURI ;
		if(ns === NAMESPACE.XMLNS){
			//update namespace
			delete el._nsMap[newAttr.prefix?newAttr.localName:''];
		}
	}

	/**
	 * Updates `el.childNodes`, updating the indexed items and it's `length`.
	 * Passing `newChild` means it will be appended.
	 * Otherwise it's assumed that an item has been removed,
	 * and `el.firstNode` and it's `.nextSibling` are used
	 * to walk the current list of child nodes.
	 *
	 * @param {Document} doc
	 * @param {Node} el
	 * @param {Node} [newChild]
	 * @private
	 */
	function _onUpdateChild (doc, el, newChild) {
		if(doc && doc._inc){
			doc._inc++;
			//update childNodes
			var cs = el.childNodes;
			if (newChild) {
				cs[cs.length++] = newChild;
			} else {
				var child = el.firstChild;
				var i = 0;
				while (child) {
					cs[i++] = child;
					child = child.nextSibling;
				}
				cs.length = i;
				delete cs[cs.length];
			}
		}
	}

	/**
	 * Removes the connections between `parentNode` and `child`
	 * and any existing `child.previousSibling` or `child.nextSibling`.
	 *
	 * @see https://github.com/xmldom/xmldom/issues/135
	 * @see https://github.com/xmldom/xmldom/issues/145
	 *
	 * @param {Node} parentNode
	 * @param {Node} child
	 * @returns {Node} the child that was removed.
	 * @private
	 */
	function _removeChild (parentNode, child) {
		var previous = child.previousSibling;
		var next = child.nextSibling;
		if (previous) {
			previous.nextSibling = next;
		} else {
			parentNode.firstChild = next;
		}
		if (next) {
			next.previousSibling = previous;
		} else {
			parentNode.lastChild = previous;
		}
		child.parentNode = null;
		child.previousSibling = null;
		child.nextSibling = null;
		_onUpdateChild(parentNode.ownerDocument, parentNode);
		return child;
	}

	/**
	 * Returns `true` if `node` can be a parent for insertion.
	 * @param {Node} node
	 * @returns {boolean}
	 */
	function hasValidParentNodeType(node) {
		return (
			node &&
			(node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE)
		);
	}

	/**
	 * Returns `true` if `node` can be inserted according to it's `nodeType`.
	 * @param {Node} node
	 * @returns {boolean}
	 */
	function hasInsertableNodeType(node) {
		return (
			node &&
			(isElementNode(node) ||
				isTextNode(node) ||
				isDocTypeNode(node) ||
				node.nodeType === Node.DOCUMENT_FRAGMENT_NODE ||
				node.nodeType === Node.COMMENT_NODE ||
				node.nodeType === Node.PROCESSING_INSTRUCTION_NODE)
		);
	}

	/**
	 * Returns true if `node` is a DOCTYPE node
	 * @param {Node} node
	 * @returns {boolean}
	 */
	function isDocTypeNode(node) {
		return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
	}

	/**
	 * Returns true if the node is an element
	 * @param {Node} node
	 * @returns {boolean}
	 */
	function isElementNode(node) {
		return node && node.nodeType === Node.ELEMENT_NODE;
	}
	/**
	 * Returns true if `node` is a text node
	 * @param {Node} node
	 * @returns {boolean}
	 */
	function isTextNode(node) {
		return node && node.nodeType === Node.TEXT_NODE;
	}

	/**
	 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
	 * according to the presence and position of a doctype node on the same level.
	 *
	 * @param {Document} doc The document node
	 * @param {Node} child the node that would become the nextSibling if the element would be inserted
	 * @returns {boolean} `true` if an element can be inserted before child
	 * @private
	 * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
	 */
	function isElementInsertionPossible(doc, child) {
		var parentChildNodes = doc.childNodes || [];
		if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
			return false;
		}
		var docTypeNode = find(parentChildNodes, isDocTypeNode);
		return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
	}

	/**
	 * Check if en element node can be inserted before `child`, or at the end if child is falsy,
	 * according to the presence and position of a doctype node on the same level.
	 *
	 * @param {Node} doc The document node
	 * @param {Node} child the node that would become the nextSibling if the element would be inserted
	 * @returns {boolean} `true` if an element can be inserted before child
	 * @private
	 * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
	 */
	function isElementReplacementPossible(doc, child) {
		var parentChildNodes = doc.childNodes || [];

		function hasElementChildThatIsNotChild(node) {
			return isElementNode(node) && node !== child;
		}

		if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
			return false;
		}
		var docTypeNode = find(parentChildNodes, isDocTypeNode);
		return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
	}

	/**
	 * @private
	 * Steps 1-5 of the checks before inserting and before replacing a child are the same.
	 *
	 * @param {Node} parent the parent node to insert `node` into
	 * @param {Node} node the node to insert
	 * @param {Node=} child the node that should become the `nextSibling` of `node`
	 * @returns {Node}
	 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
	 * @throws DOMException if `child` is provided but is not a child of `parent`.
	 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
	 * @see https://dom.spec.whatwg.org/#concept-node-replace
	 */
	function assertPreInsertionValidity1to5(parent, node, child) {
		// 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a "HierarchyRequestError" DOMException.
		if (!hasValidParentNodeType(parent)) {
			throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);
		}
		// 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a "HierarchyRequestError" DOMException.
		// not implemented!
		// 3. If `child` is non-null and its parent is not `parent`, then throw a "NotFoundError" DOMException.
		if (child && child.parentNode !== parent) {
			throw new DOMException(NOT_FOUND_ERR, 'child not in parent');
		}
		if (
			// 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
			!hasInsertableNodeType(node) ||
			// 5. If either `node` is a Text node and `parent` is a document,
			// the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
			// || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
			// or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
			(isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE)
		) {
			throw new DOMException(
				HIERARCHY_REQUEST_ERR,
				'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType
			);
		}
	}

	/**
	 * @private
	 * Step 6 of the checks before inserting and before replacing a child are different.
	 *
	 * @param {Document} parent the parent node to insert `node` into
	 * @param {Node} node the node to insert
	 * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
	 * @returns {Node}
	 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
	 * @throws DOMException if `child` is provided but is not a child of `parent`.
	 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
	 * @see https://dom.spec.whatwg.org/#concept-node-replace
	 */
	function assertPreInsertionValidityInDocument(parent, node, child) {
		var parentChildNodes = parent.childNodes || [];
		var nodeChildNodes = node.childNodes || [];

		// DocumentFragment
		if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
			var nodeChildElements = nodeChildNodes.filter(isElementNode);
			// If node has more than one element child or has a Text node child.
			if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
				throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
			}
			// Otherwise, if `node` has one element child and either `parent` has an element child,
			// `child` is a doctype, or `child` is non-null and a doctype is following `child`.
			if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
			}
		}
		// Element
		if (isElementNode(node)) {
			// `parent` has an element child, `child` is a doctype,
			// or `child` is non-null and a doctype is following `child`.
			if (!isElementInsertionPossible(parent, child)) {
				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
			}
		}
		// DocumentType
		if (isDocTypeNode(node)) {
			// `parent` has a doctype child,
			if (find(parentChildNodes, isDocTypeNode)) {
				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
			}
			var parentElementChild = find(parentChildNodes, isElementNode);
			// `child` is non-null and an element is preceding `child`,
			if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
			}
			// or `child` is null and `parent` has an element child.
			if (!child && parentElementChild) {
				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');
			}
		}
	}

	/**
	 * @private
	 * Step 6 of the checks before inserting and before replacing a child are different.
	 *
	 * @param {Document} parent the parent node to insert `node` into
	 * @param {Node} node the node to insert
	 * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
	 * @returns {Node}
	 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
	 * @throws DOMException if `child` is provided but is not a child of `parent`.
	 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
	 * @see https://dom.spec.whatwg.org/#concept-node-replace
	 */
	function assertPreReplacementValidityInDocument(parent, node, child) {
		var parentChildNodes = parent.childNodes || [];
		var nodeChildNodes = node.childNodes || [];

		// DocumentFragment
		if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
			var nodeChildElements = nodeChildNodes.filter(isElementNode);
			// If `node` has more than one element child or has a Text node child.
			if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
				throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
			}
			// Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.
			if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
			}
		}
		// Element
		if (isElementNode(node)) {
			// `parent` has an element child that is not `child` or a doctype is following `child`.
			if (!isElementReplacementPossible(parent, child)) {
				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
			}
		}
		// DocumentType
		if (isDocTypeNode(node)) {
			function hasDoctypeChildThatIsNotChild(node) {
				return isDocTypeNode(node) && node !== child;
			}

			// `parent` has a doctype child that is not `child`,
			if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
			}
			var parentElementChild = find(parentChildNodes, isElementNode);
			// or an element is preceding `child`.
			if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
				throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
			}
		}
	}

	/**
	 * @private
	 * @param {Node} parent the parent node to insert `node` into
	 * @param {Node} node the node to insert
	 * @param {Node=} child the node that should become the `nextSibling` of `node`
	 * @returns {Node}
	 * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
	 * @throws DOMException if `child` is provided but is not a child of `parent`.
	 * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
	 */
	function _insertBefore(parent, node, child, _inDocumentAssertion) {
		// To ensure pre-insertion validity of a node into a parent before a child, run these steps:
		assertPreInsertionValidity1to5(parent, node, child);

		// If parent is a document, and any of the statements below, switched on the interface node implements,
		// are true, then throw a "HierarchyRequestError" DOMException.
		if (parent.nodeType === Node.DOCUMENT_NODE) {
			(_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
		}

		var cp = node.parentNode;
		if(cp){
			cp.removeChild(node);//remove and update
		}
		if(node.nodeType === DOCUMENT_FRAGMENT_NODE){
			var newFirst = node.firstChild;
			if (newFirst == null) {
				return node;
			}
			var newLast = node.lastChild;
		}else {
			newFirst = newLast = node;
		}
		var pre = child ? child.previousSibling : parent.lastChild;

		newFirst.previousSibling = pre;
		newLast.nextSibling = child;


		if(pre){
			pre.nextSibling = newFirst;
		}else {
			parent.firstChild = newFirst;
		}
		if(child == null){
			parent.lastChild = newLast;
		}else {
			child.previousSibling = newLast;
		}
		do{
			newFirst.parentNode = parent;
			// Update ownerDocument for each node being inserted
			var targetDoc = parent.ownerDocument || parent;
			_updateOwnerDocument(newFirst, targetDoc);
		}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
		_onUpdateChild(parent.ownerDocument||parent, parent);
		//console.log(parent.lastChild.nextSibling == null)
		if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
			node.firstChild = node.lastChild = null;
		}
		return node;
	}

	/**
	 * Recursively updates the ownerDocument property for a node and all its descendants
	 * @param {Node} node
	 * @param {Document} newOwnerDocument
	 * @private
	 */
	function _updateOwnerDocument(node, newOwnerDocument) {
		if (node.ownerDocument === newOwnerDocument) {
			return;
		}
		
		node.ownerDocument = newOwnerDocument;
		
		// Update attributes if this is an element
		if (node.nodeType === ELEMENT_NODE && node.attributes) {
			for (var i = 0; i < node.attributes.length; i++) {
				var attr = node.attributes.item(i);
				if (attr) {
					attr.ownerDocument = newOwnerDocument;
				}
			}
		}
		
		// Recursively update child nodes
		var child = node.firstChild;
		while (child) {
			_updateOwnerDocument(child, newOwnerDocument);
			child = child.nextSibling;
		}
	}

	/**
	 * Appends `newChild` to `parentNode`.
	 * If `newChild` is already connected to a `parentNode` it is first removed from it.
	 *
	 * @see https://github.com/xmldom/xmldom/issues/135
	 * @see https://github.com/xmldom/xmldom/issues/145
	 * @param {Node} parentNode
	 * @param {Node} newChild
	 * @returns {Node}
	 * @private
	 */
	function _appendSingleChild (parentNode, newChild) {
		if (newChild.parentNode) {
			newChild.parentNode.removeChild(newChild);
		}
		newChild.parentNode = parentNode;
		newChild.previousSibling = parentNode.lastChild;
		newChild.nextSibling = null;
		if (newChild.previousSibling) {
			newChild.previousSibling.nextSibling = newChild;
		} else {
			parentNode.firstChild = newChild;
		}
		parentNode.lastChild = newChild;
		_onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
		
		// Update ownerDocument for the new child and all its descendants
		var targetDoc = parentNode.ownerDocument || parentNode;
		_updateOwnerDocument(newChild, targetDoc);
		
		return newChild;
	}

	Document.prototype = {
		//implementation : null,
		nodeName :  '#document',
		nodeType :  DOCUMENT_NODE,
		/**
		 * The DocumentType node of the document.
		 *
		 * @readonly
		 * @type DocumentType
		 */
		doctype :  null,
		documentElement :  null,
		_inc : 1,

		insertBefore :  function(newChild, refChild){//raises
			if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
				var child = newChild.firstChild;
				while(child){
					var next = child.nextSibling;
					this.insertBefore(child,refChild);
					child = next;
				}
				return newChild;
			}
			_insertBefore(this, newChild, refChild);
			_updateOwnerDocument(newChild, this);
			if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
				this.documentElement = newChild;
			}

			return newChild;
		},
		removeChild :  function(oldChild){
			if(this.documentElement == oldChild){
				this.documentElement = null;
			}
			return _removeChild(this,oldChild);
		},
		replaceChild: function (newChild, oldChild) {
			//raises
			_insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
			_updateOwnerDocument(newChild, this);
			if (oldChild) {
				this.removeChild(oldChild);
			}
			if (isElementNode(newChild)) {
				this.documentElement = newChild;
			}
		},
		// Introduced in DOM Level 2:
		importNode : function(importedNode,deep){
			return importNode(this,importedNode,deep);
		},
		// Introduced in DOM Level 2:
		getElementById :	function(id){
			var rtv = null;
			_visitNode(this.documentElement,function(node){
				if(node.nodeType == ELEMENT_NODE){
					if(node.getAttribute('id') == id){
						rtv = node;
						return true;
					}
				}
			});
			return rtv;
		},

		/**
		 * The `getElementsByClassName` method of `Document` interface returns an array-like object
		 * of all child elements which have **all** of the given class name(s).
		 *
		 * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
		 *
		 *
		 * Warning: This is a live LiveNodeList.
		 * Changes in the DOM will reflect in the array as the changes occur.
		 * If an element selected by this array no longer qualifies for the selector,
		 * it will automatically be removed. Be aware of this for iteration purposes.
		 *
		 * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
		 *
		 * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
		 * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
		 */
		getElementsByClassName: function(classNames) {
			var classNamesSet = toOrderedSet(classNames);
			return new LiveNodeList(this, function(base) {
				var ls = [];
				if (classNamesSet.length > 0) {
					_visitNode(base.documentElement, function(node) {
						if(node !== base && node.nodeType === ELEMENT_NODE) {
							var nodeClassNames = node.getAttribute('class');
							// can be null if the attribute does not exist
							if (nodeClassNames) {
								// before splitting and iterating just compare them for the most common case
								var matches = classNames === nodeClassNames;
								if (!matches) {
									var nodeClassNamesSet = toOrderedSet(nodeClassNames);
									matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
								}
								if(matches) {
									ls.push(node);
								}
							}
						}
					});
				}
				return ls;
			});
		},

		//document factory method:
		createElement :	function(tagName){
			var node = new Element();
			node.ownerDocument = this;
			node.nodeName = tagName;
			node.tagName = tagName;
			node.localName = tagName;
			node.childNodes = new NodeList();
			var attrs	= node.attributes = new NamedNodeMap();
			attrs._ownerElement = node;
			return node;
		},
		createDocumentFragment :	function(){
			var node = new DocumentFragment();
			node.ownerDocument = this;
			node.childNodes = new NodeList();
			return node;
		},
		createTextNode :	function(data){
			var node = new Text();
			node.ownerDocument = this;
			node.appendData(data);
			return node;
		},
		createComment :	function(data){
			var node = new Comment();
			node.ownerDocument = this;
			node.appendData(data);
			return node;
		},
		createCDATASection :	function(data){
			var node = new CDATASection();
			node.ownerDocument = this;
			node.appendData(data);
			return node;
		},
		createProcessingInstruction :	function(target,data){
			var node = new ProcessingInstruction();
			node.ownerDocument = this;
			node.tagName = node.nodeName = node.target = target;
			node.nodeValue = node.data = data;
			return node;
		},
		createAttribute :	function(name){
			var node = new Attr();
			node.ownerDocument	= this;
			node.name = name;
			node.nodeName	= name;
			node.localName = name;
			node.specified = true;
			return node;
		},
		createEntityReference :	function(name){
			var node = new EntityReference();
			node.ownerDocument	= this;
			node.nodeName	= name;
			return node;
		},
		// Introduced in DOM Level 2:
		createElementNS :	function(namespaceURI,qualifiedName){
			var node = new Element();
			var pl = qualifiedName.split(':');
			var attrs	= node.attributes = new NamedNodeMap();
			node.childNodes = new NodeList();
			node.ownerDocument = this;
			node.nodeName = qualifiedName;
			node.tagName = qualifiedName;
			node.namespaceURI = namespaceURI;
			if(pl.length == 2){
				node.prefix = pl[0];
				node.localName = pl[1];
			}else {
				//el.prefix = null;
				node.localName = qualifiedName;
			}
			attrs._ownerElement = node;
			return node;
		},
		// Introduced in DOM Level 2:
		createAttributeNS :	function(namespaceURI,qualifiedName){
			var node = new Attr();
			var pl = qualifiedName.split(':');
			node.ownerDocument = this;
			node.nodeName = qualifiedName;
			node.name = qualifiedName;
			node.namespaceURI = namespaceURI;
			node.specified = true;
			if(pl.length == 2){
				node.prefix = pl[0];
				node.localName = pl[1];
			}else {
				//el.prefix = null;
				node.localName = qualifiedName;
			}
			return node;
		}
	};
	_extends(Document,Node);


	function Element() {
		this._nsMap = {};
	}	Element.prototype = {
		nodeType : ELEMENT_NODE,
		hasAttribute : function(name){
			return this.getAttributeNode(name)!=null;
		},
		getAttribute : function(name){
			var attr = this.getAttributeNode(name);
			return attr && attr.value || '';
		},
		getAttributeNode : function(name){
			return this.attributes.getNamedItem(name);
		},
		setAttribute : function(name, value){
			var attr = this.ownerDocument.createAttribute(name);
			attr.value = attr.nodeValue = "" + value;
			this.setAttributeNode(attr);
		},
		removeAttribute : function(name){
			var attr = this.getAttributeNode(name);
			attr && this.removeAttributeNode(attr);
		},

		//four real opeartion method
		appendChild:function(newChild){
			if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
				return this.insertBefore(newChild,null);
			}else {
				return _appendSingleChild(this,newChild);
			}
		},
		setAttributeNode : function(newAttr){
			return this.attributes.setNamedItem(newAttr);
		},
		setAttributeNodeNS : function(newAttr){
			return this.attributes.setNamedItemNS(newAttr);
		},
		removeAttributeNode : function(oldAttr){
			//console.log(this == oldAttr.ownerElement)
			return this.attributes.removeNamedItem(oldAttr.nodeName);
		},
		//get real attribute name,and remove it by removeAttributeNode
		removeAttributeNS : function(namespaceURI, localName){
			var old = this.getAttributeNodeNS(namespaceURI, localName);
			old && this.removeAttributeNode(old);
		},

		hasAttributeNS : function(namespaceURI, localName){
			return this.getAttributeNodeNS(namespaceURI, localName)!=null;
		},
		getAttributeNS : function(namespaceURI, localName){
			var attr = this.getAttributeNodeNS(namespaceURI, localName);
			return attr && attr.value || '';
		},
		setAttributeNS : function(namespaceURI, qualifiedName, value){
			var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
			attr.value = attr.nodeValue = "" + value;
			this.setAttributeNode(attr);
		},
		getAttributeNodeNS : function(namespaceURI, localName){
			return this.attributes.getNamedItemNS(namespaceURI, localName);
		},

		getElementsByTagName : function(tagName){
			return new LiveNodeList(this,function(base){
				var ls = [];
				_visitNode(base,function(node){
					if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
						ls.push(node);
					}
				});
				return ls;
			});
		},
		getElementsByTagNameNS : function(namespaceURI, localName){
			return new LiveNodeList(this,function(base){
				var ls = [];
				_visitNode(base,function(node){
					if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
						ls.push(node);
					}
				});
				return ls;

			});
		}
	};
	Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
	Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


	_extends(Element,Node);
	function Attr() {
	}	Attr.prototype.nodeType = ATTRIBUTE_NODE;
	_extends(Attr,Node);


	function CharacterData() {
	}	CharacterData.prototype = {
		data : '',
		substringData : function(offset, count) {
			return this.data.substring(offset, offset+count);
		},
		appendData: function(text) {
			text = this.data+text;
			this.nodeValue = this.data = text;
			this.length = text.length;
		},
		insertData: function(offset,text) {
			this.replaceData(offset,0,text);

		},
		appendChild:function(newChild){
			throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
		},
		deleteData: function(offset, count) {
			this.replaceData(offset,count,"");
		},
		replaceData: function(offset, count, text) {
			var start = this.data.substring(0,offset);
			var end = this.data.substring(offset+count);
			text = start + text + end;
			this.nodeValue = this.data = text;
			this.length = text.length;
		}
	};
	_extends(CharacterData,Node);
	function Text() {
	}	Text.prototype = {
		nodeName : "#text",
		nodeType : TEXT_NODE,
		splitText : function(offset) {
			var text = this.data;
			var newText = text.substring(offset);
			text = text.substring(0, offset);
			this.data = this.nodeValue = text;
			this.length = text.length;
			var newNode = this.ownerDocument.createTextNode(newText);
			if(this.parentNode){
				this.parentNode.insertBefore(newNode, this.nextSibling);
			}
			return newNode;
		}
	};
	_extends(Text,CharacterData);
	function Comment() {
	}	Comment.prototype = {
		nodeName : "#comment",
		nodeType : COMMENT_NODE
	};
	_extends(Comment,CharacterData);

	function CDATASection() {
	}	CDATASection.prototype = {
		nodeName : "#cdata-section",
		nodeType : CDATA_SECTION_NODE
	};
	_extends(CDATASection,CharacterData);


	function DocumentType() {
	}	DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
	_extends(DocumentType,Node);

	function Notation() {
	}	Notation.prototype.nodeType = NOTATION_NODE;
	_extends(Notation,Node);

	function Entity() {
	}	Entity.prototype.nodeType = ENTITY_NODE;
	_extends(Entity,Node);

	function EntityReference() {
	}	EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
	_extends(EntityReference,Node);

	function DocumentFragment() {
	}	DocumentFragment.prototype.nodeName =	"#document-fragment";
	DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
	_extends(DocumentFragment,Node);


	function ProcessingInstruction() {
	}
	ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
	_extends(ProcessingInstruction,Node);
	function XMLSerializer(){}
	XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
		return nodeSerializeToString.call(node,isHtml,nodeFilter);
	};
	Node.prototype.toString = nodeSerializeToString;
	function nodeSerializeToString(isHtml,nodeFilter){
		var buf = [];
		var refNode = this.nodeType == 9 && this.documentElement || this;
		var prefix = refNode.prefix;
		var uri = refNode.namespaceURI;

		if(uri && prefix == null){
			//console.log(prefix)
			var prefix = refNode.lookupPrefix(uri);
			if(prefix == null){
				//isHTML = true;
				var visibleNamespaces=[
				{namespace:uri,prefix:null}
				//{namespace:uri,prefix:''}
				];
			}
		}
		serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
		//console.log('###',this.nodeType,uri,prefix,buf.join(''))
		return buf.join('');
	}

	function needNamespaceDefine(node, isHTML, visibleNamespaces) {
		var prefix = node.prefix || '';
		var uri = node.namespaceURI;
		// According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,
		// and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :
		// > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.
		// in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)
		// and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :
		// > [...] Furthermore, the attribute value [...] must not be an empty string.
		// so serializing empty namespace value like xmlns:ds="" would produce an invalid XML document.
		if (!uri) {
			return false;
		}
		if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
			return false;
		}

		var i = visibleNamespaces.length;
		while (i--) {
			var ns = visibleNamespaces[i];
			// get namespace prefix
			if (ns.prefix === prefix) {
				return ns.namespace !== uri;
			}
		}
		return true;
	}
	/**
	 * Well-formed constraint: No < in Attribute Values
	 * > The replacement text of any entity referred to directly or indirectly
	 * > in an attribute value must not contain a <.
	 * @see https://www.w3.org/TR/xml11/#CleanAttrVals
	 * @see https://www.w3.org/TR/xml11/#NT-AttValue
	 *
	 * Literal whitespace other than space that appear in attribute values
	 * are serialized as their entity references, so they will be preserved.
	 * (In contrast to whitespace literals in the input which are normalized to spaces)
	 * @see https://www.w3.org/TR/xml11/#AVNormalize
	 * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes
	 */
	function addSerializedAttribute(buf, qualifiedName, value) {
		buf.push(' ', qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
	}

	function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
		if (!visibleNamespaces) {
			visibleNamespaces = [];
		}

		if(nodeFilter){
			node = nodeFilter(node);
			if(node){
				if(typeof node == 'string'){
					buf.push(node);
					return;
				}
			}else {
				return;
			}
			//buf.sort.apply(attrs, attributeSorter);
		}

		switch(node.nodeType){
		case ELEMENT_NODE:
			var attrs = node.attributes;
			var len = attrs.length;
			var child = node.firstChild;
			var nodeName = node.tagName;

			isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;

			var prefixedNodeName = nodeName;
			if (!isHTML && !node.prefix && node.namespaceURI) {
				var defaultNS;
				// lookup current default ns from `xmlns` attribute
				for (var ai = 0; ai < attrs.length; ai++) {
					if (attrs.item(ai).name === 'xmlns') {
						defaultNS = attrs.item(ai).value;
						break
					}
				}
				if (!defaultNS) {
					// lookup current default ns in visibleNamespaces
					for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
						var namespace = visibleNamespaces[nsi];
						if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {
							defaultNS = namespace.namespace;
							break
						}
					}
				}
				if (defaultNS !== node.namespaceURI) {
					for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
						var namespace = visibleNamespaces[nsi];
						if (namespace.namespace === node.namespaceURI) {
							if (namespace.prefix) {
								prefixedNodeName = namespace.prefix + ':' + nodeName;
							}
							break
						}
					}
				}
			}

			buf.push('<', prefixedNodeName);

			for(var i=0;i<len;i++){
				// add namespaces for attributes
				var attr = attrs.item(i);
				if (attr.prefix == 'xmlns') {
					visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
				}else if(attr.nodeName == 'xmlns'){
					visibleNamespaces.push({ prefix: '', namespace: attr.value });
				}
			}

			for(var i=0;i<len;i++){
				var attr = attrs.item(i);
				if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
					var prefix = attr.prefix||'';
					var uri = attr.namespaceURI;
					addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
					visibleNamespaces.push({ prefix: prefix, namespace:uri });
				}
				serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
			}

			// add namespace for current node
			if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
				var prefix = node.prefix||'';
				var uri = node.namespaceURI;
				addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
				visibleNamespaces.push({ prefix: prefix, namespace:uri });
			}

			if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
				buf.push('>');
				//if is cdata child node
				if(isHTML && /^script$/i.test(nodeName)){
					while(child){
						if(child.data){
							buf.push(child.data);
						}else {
							serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
						}
						child = child.nextSibling;
					}
				}else
				{
					while(child){
						serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
						child = child.nextSibling;
					}
				}
				buf.push('</',prefixedNodeName,'>');
			}else {
				buf.push('/>');
			}
			// remove added visible namespaces
			//visibleNamespaces.length = startVisibleNamespaces;
			return;
		case DOCUMENT_NODE:
		case DOCUMENT_FRAGMENT_NODE:
			var child = node.firstChild;
			while(child){
				serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
				child = child.nextSibling;
			}
			return;
		case ATTRIBUTE_NODE:
			return addSerializedAttribute(buf, node.name, node.value);
		case TEXT_NODE:
			/**
			 * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,
			 * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.
			 * If they are needed elsewhere, they must be escaped using either numeric character references or the strings
			 * `&amp;` and `&lt;` respectively.
			 * The right angle bracket (>) may be represented using the string " &gt; ", and must, for compatibility,
			 * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,
			 * when that string is not marking the end of a CDATA section.
			 *
			 * In the content of elements, character data is any string of characters
			 * which does not contain the start-delimiter of any markup
			 * and does not include the CDATA-section-close delimiter, `]]>`.
			 *
			 * @see https://www.w3.org/TR/xml/#NT-CharData
			 * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node
			 */
			return buf.push(node.data
				.replace(/[<&>]/g,_xmlEncoder)
			);
		case CDATA_SECTION_NODE:
			return buf.push( '<![CDATA[',node.data,']]>');
		case COMMENT_NODE:
			return buf.push( "<!--",node.data,"-->");
		case DOCUMENT_TYPE_NODE:
			var pubid = node.publicId;
			var sysid = node.systemId;
			buf.push('<!DOCTYPE ',node.name);
			if(pubid){
				buf.push(' PUBLIC ', pubid);
				if (sysid && sysid!='.') {
					buf.push(' ', sysid);
				}
				buf.push('>');
			}else if(sysid && sysid!='.'){
				buf.push(' SYSTEM ', sysid, '>');
			}else {
				var sub = node.internalSubset;
				if(sub){
					buf.push(" [",sub,"]");
				}
				buf.push(">");
			}
			return;
		case PROCESSING_INSTRUCTION_NODE:
			return buf.push( "<?",node.target," ",node.data,"?>");
		case ENTITY_REFERENCE_NODE:
			return buf.push( '&',node.nodeName,';');
		//case ENTITY_NODE:
		//case NOTATION_NODE:
		default:
			buf.push('??',node.nodeName);
		}
	}
	function importNode(doc,node,deep){
		var node2;
		switch (node.nodeType) {
		case ELEMENT_NODE:
			node2 = node.cloneNode(false);
			node2.ownerDocument = doc;
			//var attrs = node2.attributes;
			//var len = attrs.length;
			//for(var i=0;i<len;i++){
				//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
			//}
		case DOCUMENT_FRAGMENT_NODE:
			break;
		case ATTRIBUTE_NODE:
			deep = true;
			break;
		//case ENTITY_REFERENCE_NODE:
		//case PROCESSING_INSTRUCTION_NODE:
		////case TEXT_NODE:
		//case CDATA_SECTION_NODE:
		//case COMMENT_NODE:
		//	deep = false;
		//	break;
		//case DOCUMENT_NODE:
		//case DOCUMENT_TYPE_NODE:
		//cannot be imported.
		//case ENTITY_NODE:
		//case NOTATION_NODE
		//can not hit in level3
		//default:throw e;
		}
		if(!node2){
			node2 = node.cloneNode(false);//false
		}
		node2.ownerDocument = doc;
		node2.parentNode = null;
		if(deep){
			var child = node.firstChild;
			while(child){
				node2.appendChild(importNode(doc,child,deep));
				child = child.nextSibling;
			}
		}
		return node2;
	}
	//
	//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
	//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
	function cloneNode(doc,node,deep){
		var node2 = new node.constructor();
		for (var n in node) {
			if (Object.prototype.hasOwnProperty.call(node, n)) {
				var v = node[n];
				if (typeof v != "object") {
					if (v != node2[n]) {
						node2[n] = v;
					}
				}
			}
		}
		if(node.childNodes){
			node2.childNodes = new NodeList();
		}
		node2.ownerDocument = doc;
		switch (node2.nodeType) {
		case ELEMENT_NODE:
			var attrs	= node.attributes;
			var attrs2	= node2.attributes = new NamedNodeMap();
			var len = attrs.length;
			attrs2._ownerElement = node2;
			for(var i=0;i<len;i++){
				node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
			}
			break;		case ATTRIBUTE_NODE:
			deep = true;
		}
		if(deep){
			var child = node.firstChild;
			while(child){
				node2.appendChild(cloneNode(doc,child,deep));
				child = child.nextSibling;
			}
		}
		return node2;
	}

	function __set__(object,key,value){
		object[key] = value;
	}
	//do dynamic
	try{
		if(Object.defineProperty){
			Object.defineProperty(LiveNodeList.prototype,'length',{
				get:function(){
					_updateLiveList(this);
					return this.$$length;
				}
			});

			Object.defineProperty(Node.prototype,'textContent',{
				get:function(){
					return getTextContent(this);
				},

				set:function(data){
					switch(this.nodeType){
					case ELEMENT_NODE:
					case DOCUMENT_FRAGMENT_NODE:
						while(this.firstChild){
							this.removeChild(this.firstChild);
						}
						if(data || String(data)){
							this.appendChild(this.ownerDocument.createTextNode(data));
						}
						break;

					default:
						this.data = data;
						this.value = data;
						this.nodeValue = data;
					}
				}
			});

			function getTextContent(node){
				switch(node.nodeType){
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					var buf = [];
					node = node.firstChild;
					while(node){
						if(node.nodeType!==7 && node.nodeType !==8){
							buf.push(getTextContent(node));
						}
						node = node.nextSibling;
					}
					return buf.join('');
				default:
					return node.nodeValue;
				}
			}

			__set__ = function(object,key,value){
				//console.log(value)
				object['$$'+key] = value;
			};
		}
	}catch(e){//ie8
	}

	//if(typeof require == 'function'){
		dom.DocumentType = DocumentType;
		dom.DOMException = DOMException;
		dom.DOMImplementation = DOMImplementation;
		dom.Element = Element;
		dom.Node = Node;
		dom.NodeList = NodeList;
		dom.XMLSerializer = XMLSerializer;
	//}
	return dom;
}

var domParser = {};

var entities = {};

var hasRequiredEntities;

function requireEntities () {
	if (hasRequiredEntities) return entities;
	hasRequiredEntities = 1;
	(function (exports) {

		var freeze = requireConventions().freeze;

		/**
		 * The entities that are predefined in every XML document.
		 *
		 * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1
		 * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0
		 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia
		 */
		exports.XML_ENTITIES = freeze({
			amp: '&',
			apos: "'",
			gt: '>',
			lt: '<',
			quot: '"',
		});

		/**
		 * A map of all entities that are detected in an HTML document.
		 * They contain all entries from `XML_ENTITIES`.
		 *
		 * @see XML_ENTITIES
		 * @see DOMParser.parseFromString
		 * @see DOMImplementation.prototype.createHTMLDocument
		 * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec
		 * @see https://html.spec.whatwg.org/entities.json JSON
		 * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names
		 * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML
		 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)
		 * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)
		 */
		exports.HTML_ENTITIES = freeze({
			Aacute: '\u00C1',
			aacute: '\u00E1',
			Abreve: '\u0102',
			abreve: '\u0103',
			ac: '\u223E',
			acd: '\u223F',
			acE: '\u223E\u0333',
			Acirc: '\u00C2',
			acirc: '\u00E2',
			acute: '\u00B4',
			Acy: '\u0410',
			acy: '\u0430',
			AElig: '\u00C6',
			aelig: '\u00E6',
			af: '\u2061',
			Afr: '\uD835\uDD04',
			afr: '\uD835\uDD1E',
			Agrave: '\u00C0',
			agrave: '\u00E0',
			alefsym: '\u2135',
			aleph: '\u2135',
			Alpha: '\u0391',
			alpha: '\u03B1',
			Amacr: '\u0100',
			amacr: '\u0101',
			amalg: '\u2A3F',
			AMP: '\u0026',
			amp: '\u0026',
			And: '\u2A53',
			and: '\u2227',
			andand: '\u2A55',
			andd: '\u2A5C',
			andslope: '\u2A58',
			andv: '\u2A5A',
			ang: '\u2220',
			ange: '\u29A4',
			angle: '\u2220',
			angmsd: '\u2221',
			angmsdaa: '\u29A8',
			angmsdab: '\u29A9',
			angmsdac: '\u29AA',
			angmsdad: '\u29AB',
			angmsdae: '\u29AC',
			angmsdaf: '\u29AD',
			angmsdag: '\u29AE',
			angmsdah: '\u29AF',
			angrt: '\u221F',
			angrtvb: '\u22BE',
			angrtvbd: '\u299D',
			angsph: '\u2222',
			angst: '\u00C5',
			angzarr: '\u237C',
			Aogon: '\u0104',
			aogon: '\u0105',
			Aopf: '\uD835\uDD38',
			aopf: '\uD835\uDD52',
			ap: '\u2248',
			apacir: '\u2A6F',
			apE: '\u2A70',
			ape: '\u224A',
			apid: '\u224B',
			apos: '\u0027',
			ApplyFunction: '\u2061',
			approx: '\u2248',
			approxeq: '\u224A',
			Aring: '\u00C5',
			aring: '\u00E5',
			Ascr: '\uD835\uDC9C',
			ascr: '\uD835\uDCB6',
			Assign: '\u2254',
			ast: '\u002A',
			asymp: '\u2248',
			asympeq: '\u224D',
			Atilde: '\u00C3',
			atilde: '\u00E3',
			Auml: '\u00C4',
			auml: '\u00E4',
			awconint: '\u2233',
			awint: '\u2A11',
			backcong: '\u224C',
			backepsilon: '\u03F6',
			backprime: '\u2035',
			backsim: '\u223D',
			backsimeq: '\u22CD',
			Backslash: '\u2216',
			Barv: '\u2AE7',
			barvee: '\u22BD',
			Barwed: '\u2306',
			barwed: '\u2305',
			barwedge: '\u2305',
			bbrk: '\u23B5',
			bbrktbrk: '\u23B6',
			bcong: '\u224C',
			Bcy: '\u0411',
			bcy: '\u0431',
			bdquo: '\u201E',
			becaus: '\u2235',
			Because: '\u2235',
			because: '\u2235',
			bemptyv: '\u29B0',
			bepsi: '\u03F6',
			bernou: '\u212C',
			Bernoullis: '\u212C',
			Beta: '\u0392',
			beta: '\u03B2',
			beth: '\u2136',
			between: '\u226C',
			Bfr: '\uD835\uDD05',
			bfr: '\uD835\uDD1F',
			bigcap: '\u22C2',
			bigcirc: '\u25EF',
			bigcup: '\u22C3',
			bigodot: '\u2A00',
			bigoplus: '\u2A01',
			bigotimes: '\u2A02',
			bigsqcup: '\u2A06',
			bigstar: '\u2605',
			bigtriangledown: '\u25BD',
			bigtriangleup: '\u25B3',
			biguplus: '\u2A04',
			bigvee: '\u22C1',
			bigwedge: '\u22C0',
			bkarow: '\u290D',
			blacklozenge: '\u29EB',
			blacksquare: '\u25AA',
			blacktriangle: '\u25B4',
			blacktriangledown: '\u25BE',
			blacktriangleleft: '\u25C2',
			blacktriangleright: '\u25B8',
			blank: '\u2423',
			blk12: '\u2592',
			blk14: '\u2591',
			blk34: '\u2593',
			block: '\u2588',
			bne: '\u003D\u20E5',
			bnequiv: '\u2261\u20E5',
			bNot: '\u2AED',
			bnot: '\u2310',
			Bopf: '\uD835\uDD39',
			bopf: '\uD835\uDD53',
			bot: '\u22A5',
			bottom: '\u22A5',
			bowtie: '\u22C8',
			boxbox: '\u29C9',
			boxDL: '\u2557',
			boxDl: '\u2556',
			boxdL: '\u2555',
			boxdl: '\u2510',
			boxDR: '\u2554',
			boxDr: '\u2553',
			boxdR: '\u2552',
			boxdr: '\u250C',
			boxH: '\u2550',
			boxh: '\u2500',
			boxHD: '\u2566',
			boxHd: '\u2564',
			boxhD: '\u2565',
			boxhd: '\u252C',
			boxHU: '\u2569',
			boxHu: '\u2567',
			boxhU: '\u2568',
			boxhu: '\u2534',
			boxminus: '\u229F',
			boxplus: '\u229E',
			boxtimes: '\u22A0',
			boxUL: '\u255D',
			boxUl: '\u255C',
			boxuL: '\u255B',
			boxul: '\u2518',
			boxUR: '\u255A',
			boxUr: '\u2559',
			boxuR: '\u2558',
			boxur: '\u2514',
			boxV: '\u2551',
			boxv: '\u2502',
			boxVH: '\u256C',
			boxVh: '\u256B',
			boxvH: '\u256A',
			boxvh: '\u253C',
			boxVL: '\u2563',
			boxVl: '\u2562',
			boxvL: '\u2561',
			boxvl: '\u2524',
			boxVR: '\u2560',
			boxVr: '\u255F',
			boxvR: '\u255E',
			boxvr: '\u251C',
			bprime: '\u2035',
			Breve: '\u02D8',
			breve: '\u02D8',
			brvbar: '\u00A6',
			Bscr: '\u212C',
			bscr: '\uD835\uDCB7',
			bsemi: '\u204F',
			bsim: '\u223D',
			bsime: '\u22CD',
			bsol: '\u005C',
			bsolb: '\u29C5',
			bsolhsub: '\u27C8',
			bull: '\u2022',
			bullet: '\u2022',
			bump: '\u224E',
			bumpE: '\u2AAE',
			bumpe: '\u224F',
			Bumpeq: '\u224E',
			bumpeq: '\u224F',
			Cacute: '\u0106',
			cacute: '\u0107',
			Cap: '\u22D2',
			cap: '\u2229',
			capand: '\u2A44',
			capbrcup: '\u2A49',
			capcap: '\u2A4B',
			capcup: '\u2A47',
			capdot: '\u2A40',
			CapitalDifferentialD: '\u2145',
			caps: '\u2229\uFE00',
			caret: '\u2041',
			caron: '\u02C7',
			Cayleys: '\u212D',
			ccaps: '\u2A4D',
			Ccaron: '\u010C',
			ccaron: '\u010D',
			Ccedil: '\u00C7',
			ccedil: '\u00E7',
			Ccirc: '\u0108',
			ccirc: '\u0109',
			Cconint: '\u2230',
			ccups: '\u2A4C',
			ccupssm: '\u2A50',
			Cdot: '\u010A',
			cdot: '\u010B',
			cedil: '\u00B8',
			Cedilla: '\u00B8',
			cemptyv: '\u29B2',
			cent: '\u00A2',
			CenterDot: '\u00B7',
			centerdot: '\u00B7',
			Cfr: '\u212D',
			cfr: '\uD835\uDD20',
			CHcy: '\u0427',
			chcy: '\u0447',
			check: '\u2713',
			checkmark: '\u2713',
			Chi: '\u03A7',
			chi: '\u03C7',
			cir: '\u25CB',
			circ: '\u02C6',
			circeq: '\u2257',
			circlearrowleft: '\u21BA',
			circlearrowright: '\u21BB',
			circledast: '\u229B',
			circledcirc: '\u229A',
			circleddash: '\u229D',
			CircleDot: '\u2299',
			circledR: '\u00AE',
			circledS: '\u24C8',
			CircleMinus: '\u2296',
			CirclePlus: '\u2295',
			CircleTimes: '\u2297',
			cirE: '\u29C3',
			cire: '\u2257',
			cirfnint: '\u2A10',
			cirmid: '\u2AEF',
			cirscir: '\u29C2',
			ClockwiseContourIntegral: '\u2232',
			CloseCurlyDoubleQuote: '\u201D',
			CloseCurlyQuote: '\u2019',
			clubs: '\u2663',
			clubsuit: '\u2663',
			Colon: '\u2237',
			colon: '\u003A',
			Colone: '\u2A74',
			colone: '\u2254',
			coloneq: '\u2254',
			comma: '\u002C',
			commat: '\u0040',
			comp: '\u2201',
			compfn: '\u2218',
			complement: '\u2201',
			complexes: '\u2102',
			cong: '\u2245',
			congdot: '\u2A6D',
			Congruent: '\u2261',
			Conint: '\u222F',
			conint: '\u222E',
			ContourIntegral: '\u222E',
			Copf: '\u2102',
			copf: '\uD835\uDD54',
			coprod: '\u2210',
			Coproduct: '\u2210',
			COPY: '\u00A9',
			copy: '\u00A9',
			copysr: '\u2117',
			CounterClockwiseContourIntegral: '\u2233',
			crarr: '\u21B5',
			Cross: '\u2A2F',
			cross: '\u2717',
			Cscr: '\uD835\uDC9E',
			cscr: '\uD835\uDCB8',
			csub: '\u2ACF',
			csube: '\u2AD1',
			csup: '\u2AD0',
			csupe: '\u2AD2',
			ctdot: '\u22EF',
			cudarrl: '\u2938',
			cudarrr: '\u2935',
			cuepr: '\u22DE',
			cuesc: '\u22DF',
			cularr: '\u21B6',
			cularrp: '\u293D',
			Cup: '\u22D3',
			cup: '\u222A',
			cupbrcap: '\u2A48',
			CupCap: '\u224D',
			cupcap: '\u2A46',
			cupcup: '\u2A4A',
			cupdot: '\u228D',
			cupor: '\u2A45',
			cups: '\u222A\uFE00',
			curarr: '\u21B7',
			curarrm: '\u293C',
			curlyeqprec: '\u22DE',
			curlyeqsucc: '\u22DF',
			curlyvee: '\u22CE',
			curlywedge: '\u22CF',
			curren: '\u00A4',
			curvearrowleft: '\u21B6',
			curvearrowright: '\u21B7',
			cuvee: '\u22CE',
			cuwed: '\u22CF',
			cwconint: '\u2232',
			cwint: '\u2231',
			cylcty: '\u232D',
			Dagger: '\u2021',
			dagger: '\u2020',
			daleth: '\u2138',
			Darr: '\u21A1',
			dArr: '\u21D3',
			darr: '\u2193',
			dash: '\u2010',
			Dashv: '\u2AE4',
			dashv: '\u22A3',
			dbkarow: '\u290F',
			dblac: '\u02DD',
			Dcaron: '\u010E',
			dcaron: '\u010F',
			Dcy: '\u0414',
			dcy: '\u0434',
			DD: '\u2145',
			dd: '\u2146',
			ddagger: '\u2021',
			ddarr: '\u21CA',
			DDotrahd: '\u2911',
			ddotseq: '\u2A77',
			deg: '\u00B0',
			Del: '\u2207',
			Delta: '\u0394',
			delta: '\u03B4',
			demptyv: '\u29B1',
			dfisht: '\u297F',
			Dfr: '\uD835\uDD07',
			dfr: '\uD835\uDD21',
			dHar: '\u2965',
			dharl: '\u21C3',
			dharr: '\u21C2',
			DiacriticalAcute: '\u00B4',
			DiacriticalDot: '\u02D9',
			DiacriticalDoubleAcute: '\u02DD',
			DiacriticalGrave: '\u0060',
			DiacriticalTilde: '\u02DC',
			diam: '\u22C4',
			Diamond: '\u22C4',
			diamond: '\u22C4',
			diamondsuit: '\u2666',
			diams: '\u2666',
			die: '\u00A8',
			DifferentialD: '\u2146',
			digamma: '\u03DD',
			disin: '\u22F2',
			div: '\u00F7',
			divide: '\u00F7',
			divideontimes: '\u22C7',
			divonx: '\u22C7',
			DJcy: '\u0402',
			djcy: '\u0452',
			dlcorn: '\u231E',
			dlcrop: '\u230D',
			dollar: '\u0024',
			Dopf: '\uD835\uDD3B',
			dopf: '\uD835\uDD55',
			Dot: '\u00A8',
			dot: '\u02D9',
			DotDot: '\u20DC',
			doteq: '\u2250',
			doteqdot: '\u2251',
			DotEqual: '\u2250',
			dotminus: '\u2238',
			dotplus: '\u2214',
			dotsquare: '\u22A1',
			doublebarwedge: '\u2306',
			DoubleContourIntegral: '\u222F',
			DoubleDot: '\u00A8',
			DoubleDownArrow: '\u21D3',
			DoubleLeftArrow: '\u21D0',
			DoubleLeftRightArrow: '\u21D4',
			DoubleLeftTee: '\u2AE4',
			DoubleLongLeftArrow: '\u27F8',
			DoubleLongLeftRightArrow: '\u27FA',
			DoubleLongRightArrow: '\u27F9',
			DoubleRightArrow: '\u21D2',
			DoubleRightTee: '\u22A8',
			DoubleUpArrow: '\u21D1',
			DoubleUpDownArrow: '\u21D5',
			DoubleVerticalBar: '\u2225',
			DownArrow: '\u2193',
			Downarrow: '\u21D3',
			downarrow: '\u2193',
			DownArrowBar: '\u2913',
			DownArrowUpArrow: '\u21F5',
			DownBreve: '\u0311',
			downdownarrows: '\u21CA',
			downharpoonleft: '\u21C3',
			downharpoonright: '\u21C2',
			DownLeftRightVector: '\u2950',
			DownLeftTeeVector: '\u295E',
			DownLeftVector: '\u21BD',
			DownLeftVectorBar: '\u2956',
			DownRightTeeVector: '\u295F',
			DownRightVector: '\u21C1',
			DownRightVectorBar: '\u2957',
			DownTee: '\u22A4',
			DownTeeArrow: '\u21A7',
			drbkarow: '\u2910',
			drcorn: '\u231F',
			drcrop: '\u230C',
			Dscr: '\uD835\uDC9F',
			dscr: '\uD835\uDCB9',
			DScy: '\u0405',
			dscy: '\u0455',
			dsol: '\u29F6',
			Dstrok: '\u0110',
			dstrok: '\u0111',
			dtdot: '\u22F1',
			dtri: '\u25BF',
			dtrif: '\u25BE',
			duarr: '\u21F5',
			duhar: '\u296F',
			dwangle: '\u29A6',
			DZcy: '\u040F',
			dzcy: '\u045F',
			dzigrarr: '\u27FF',
			Eacute: '\u00C9',
			eacute: '\u00E9',
			easter: '\u2A6E',
			Ecaron: '\u011A',
			ecaron: '\u011B',
			ecir: '\u2256',
			Ecirc: '\u00CA',
			ecirc: '\u00EA',
			ecolon: '\u2255',
			Ecy: '\u042D',
			ecy: '\u044D',
			eDDot: '\u2A77',
			Edot: '\u0116',
			eDot: '\u2251',
			edot: '\u0117',
			ee: '\u2147',
			efDot: '\u2252',
			Efr: '\uD835\uDD08',
			efr: '\uD835\uDD22',
			eg: '\u2A9A',
			Egrave: '\u00C8',
			egrave: '\u00E8',
			egs: '\u2A96',
			egsdot: '\u2A98',
			el: '\u2A99',
			Element: '\u2208',
			elinters: '\u23E7',
			ell: '\u2113',
			els: '\u2A95',
			elsdot: '\u2A97',
			Emacr: '\u0112',
			emacr: '\u0113',
			empty: '\u2205',
			emptyset: '\u2205',
			EmptySmallSquare: '\u25FB',
			emptyv: '\u2205',
			EmptyVerySmallSquare: '\u25AB',
			emsp: '\u2003',
			emsp13: '\u2004',
			emsp14: '\u2005',
			ENG: '\u014A',
			eng: '\u014B',
			ensp: '\u2002',
			Eogon: '\u0118',
			eogon: '\u0119',
			Eopf: '\uD835\uDD3C',
			eopf: '\uD835\uDD56',
			epar: '\u22D5',
			eparsl: '\u29E3',
			eplus: '\u2A71',
			epsi: '\u03B5',
			Epsilon: '\u0395',
			epsilon: '\u03B5',
			epsiv: '\u03F5',
			eqcirc: '\u2256',
			eqcolon: '\u2255',
			eqsim: '\u2242',
			eqslantgtr: '\u2A96',
			eqslantless: '\u2A95',
			Equal: '\u2A75',
			equals: '\u003D',
			EqualTilde: '\u2242',
			equest: '\u225F',
			Equilibrium: '\u21CC',
			equiv: '\u2261',
			equivDD: '\u2A78',
			eqvparsl: '\u29E5',
			erarr: '\u2971',
			erDot: '\u2253',
			Escr: '\u2130',
			escr: '\u212F',
			esdot: '\u2250',
			Esim: '\u2A73',
			esim: '\u2242',
			Eta: '\u0397',
			eta: '\u03B7',
			ETH: '\u00D0',
			eth: '\u00F0',
			Euml: '\u00CB',
			euml: '\u00EB',
			euro: '\u20AC',
			excl: '\u0021',
			exist: '\u2203',
			Exists: '\u2203',
			expectation: '\u2130',
			ExponentialE: '\u2147',
			exponentiale: '\u2147',
			fallingdotseq: '\u2252',
			Fcy: '\u0424',
			fcy: '\u0444',
			female: '\u2640',
			ffilig: '\uFB03',
			fflig: '\uFB00',
			ffllig: '\uFB04',
			Ffr: '\uD835\uDD09',
			ffr: '\uD835\uDD23',
			filig: '\uFB01',
			FilledSmallSquare: '\u25FC',
			FilledVerySmallSquare: '\u25AA',
			fjlig: '\u0066\u006A',
			flat: '\u266D',
			fllig: '\uFB02',
			fltns: '\u25B1',
			fnof: '\u0192',
			Fopf: '\uD835\uDD3D',
			fopf: '\uD835\uDD57',
			ForAll: '\u2200',
			forall: '\u2200',
			fork: '\u22D4',
			forkv: '\u2AD9',
			Fouriertrf: '\u2131',
			fpartint: '\u2A0D',
			frac12: '\u00BD',
			frac13: '\u2153',
			frac14: '\u00BC',
			frac15: '\u2155',
			frac16: '\u2159',
			frac18: '\u215B',
			frac23: '\u2154',
			frac25: '\u2156',
			frac34: '\u00BE',
			frac35: '\u2157',
			frac38: '\u215C',
			frac45: '\u2158',
			frac56: '\u215A',
			frac58: '\u215D',
			frac78: '\u215E',
			frasl: '\u2044',
			frown: '\u2322',
			Fscr: '\u2131',
			fscr: '\uD835\uDCBB',
			gacute: '\u01F5',
			Gamma: '\u0393',
			gamma: '\u03B3',
			Gammad: '\u03DC',
			gammad: '\u03DD',
			gap: '\u2A86',
			Gbreve: '\u011E',
			gbreve: '\u011F',
			Gcedil: '\u0122',
			Gcirc: '\u011C',
			gcirc: '\u011D',
			Gcy: '\u0413',
			gcy: '\u0433',
			Gdot: '\u0120',
			gdot: '\u0121',
			gE: '\u2267',
			ge: '\u2265',
			gEl: '\u2A8C',
			gel: '\u22DB',
			geq: '\u2265',
			geqq: '\u2267',
			geqslant: '\u2A7E',
			ges: '\u2A7E',
			gescc: '\u2AA9',
			gesdot: '\u2A80',
			gesdoto: '\u2A82',
			gesdotol: '\u2A84',
			gesl: '\u22DB\uFE00',
			gesles: '\u2A94',
			Gfr: '\uD835\uDD0A',
			gfr: '\uD835\uDD24',
			Gg: '\u22D9',
			gg: '\u226B',
			ggg: '\u22D9',
			gimel: '\u2137',
			GJcy: '\u0403',
			gjcy: '\u0453',
			gl: '\u2277',
			gla: '\u2AA5',
			glE: '\u2A92',
			glj: '\u2AA4',
			gnap: '\u2A8A',
			gnapprox: '\u2A8A',
			gnE: '\u2269',
			gne: '\u2A88',
			gneq: '\u2A88',
			gneqq: '\u2269',
			gnsim: '\u22E7',
			Gopf: '\uD835\uDD3E',
			gopf: '\uD835\uDD58',
			grave: '\u0060',
			GreaterEqual: '\u2265',
			GreaterEqualLess: '\u22DB',
			GreaterFullEqual: '\u2267',
			GreaterGreater: '\u2AA2',
			GreaterLess: '\u2277',
			GreaterSlantEqual: '\u2A7E',
			GreaterTilde: '\u2273',
			Gscr: '\uD835\uDCA2',
			gscr: '\u210A',
			gsim: '\u2273',
			gsime: '\u2A8E',
			gsiml: '\u2A90',
			Gt: '\u226B',
			GT: '\u003E',
			gt: '\u003E',
			gtcc: '\u2AA7',
			gtcir: '\u2A7A',
			gtdot: '\u22D7',
			gtlPar: '\u2995',
			gtquest: '\u2A7C',
			gtrapprox: '\u2A86',
			gtrarr: '\u2978',
			gtrdot: '\u22D7',
			gtreqless: '\u22DB',
			gtreqqless: '\u2A8C',
			gtrless: '\u2277',
			gtrsim: '\u2273',
			gvertneqq: '\u2269\uFE00',
			gvnE: '\u2269\uFE00',
			Hacek: '\u02C7',
			hairsp: '\u200A',
			half: '\u00BD',
			hamilt: '\u210B',
			HARDcy: '\u042A',
			hardcy: '\u044A',
			hArr: '\u21D4',
			harr: '\u2194',
			harrcir: '\u2948',
			harrw: '\u21AD',
			Hat: '\u005E',
			hbar: '\u210F',
			Hcirc: '\u0124',
			hcirc: '\u0125',
			hearts: '\u2665',
			heartsuit: '\u2665',
			hellip: '\u2026',
			hercon: '\u22B9',
			Hfr: '\u210C',
			hfr: '\uD835\uDD25',
			HilbertSpace: '\u210B',
			hksearow: '\u2925',
			hkswarow: '\u2926',
			hoarr: '\u21FF',
			homtht: '\u223B',
			hookleftarrow: '\u21A9',
			hookrightarrow: '\u21AA',
			Hopf: '\u210D',
			hopf: '\uD835\uDD59',
			horbar: '\u2015',
			HorizontalLine: '\u2500',
			Hscr: '\u210B',
			hscr: '\uD835\uDCBD',
			hslash: '\u210F',
			Hstrok: '\u0126',
			hstrok: '\u0127',
			HumpDownHump: '\u224E',
			HumpEqual: '\u224F',
			hybull: '\u2043',
			hyphen: '\u2010',
			Iacute: '\u00CD',
			iacute: '\u00ED',
			ic: '\u2063',
			Icirc: '\u00CE',
			icirc: '\u00EE',
			Icy: '\u0418',
			icy: '\u0438',
			Idot: '\u0130',
			IEcy: '\u0415',
			iecy: '\u0435',
			iexcl: '\u00A1',
			iff: '\u21D4',
			Ifr: '\u2111',
			ifr: '\uD835\uDD26',
			Igrave: '\u00CC',
			igrave: '\u00EC',
			ii: '\u2148',
			iiiint: '\u2A0C',
			iiint: '\u222D',
			iinfin: '\u29DC',
			iiota: '\u2129',
			IJlig: '\u0132',
			ijlig: '\u0133',
			Im: '\u2111',
			Imacr: '\u012A',
			imacr: '\u012B',
			image: '\u2111',
			ImaginaryI: '\u2148',
			imagline: '\u2110',
			imagpart: '\u2111',
			imath: '\u0131',
			imof: '\u22B7',
			imped: '\u01B5',
			Implies: '\u21D2',
			in: '\u2208',
			incare: '\u2105',
			infin: '\u221E',
			infintie: '\u29DD',
			inodot: '\u0131',
			Int: '\u222C',
			int: '\u222B',
			intcal: '\u22BA',
			integers: '\u2124',
			Integral: '\u222B',
			intercal: '\u22BA',
			Intersection: '\u22C2',
			intlarhk: '\u2A17',
			intprod: '\u2A3C',
			InvisibleComma: '\u2063',
			InvisibleTimes: '\u2062',
			IOcy: '\u0401',
			iocy: '\u0451',
			Iogon: '\u012E',
			iogon: '\u012F',
			Iopf: '\uD835\uDD40',
			iopf: '\uD835\uDD5A',
			Iota: '\u0399',
			iota: '\u03B9',
			iprod: '\u2A3C',
			iquest: '\u00BF',
			Iscr: '\u2110',
			iscr: '\uD835\uDCBE',
			isin: '\u2208',
			isindot: '\u22F5',
			isinE: '\u22F9',
			isins: '\u22F4',
			isinsv: '\u22F3',
			isinv: '\u2208',
			it: '\u2062',
			Itilde: '\u0128',
			itilde: '\u0129',
			Iukcy: '\u0406',
			iukcy: '\u0456',
			Iuml: '\u00CF',
			iuml: '\u00EF',
			Jcirc: '\u0134',
			jcirc: '\u0135',
			Jcy: '\u0419',
			jcy: '\u0439',
			Jfr: '\uD835\uDD0D',
			jfr: '\uD835\uDD27',
			jmath: '\u0237',
			Jopf: '\uD835\uDD41',
			jopf: '\uD835\uDD5B',
			Jscr: '\uD835\uDCA5',
			jscr: '\uD835\uDCBF',
			Jsercy: '\u0408',
			jsercy: '\u0458',
			Jukcy: '\u0404',
			jukcy: '\u0454',
			Kappa: '\u039A',
			kappa: '\u03BA',
			kappav: '\u03F0',
			Kcedil: '\u0136',
			kcedil: '\u0137',
			Kcy: '\u041A',
			kcy: '\u043A',
			Kfr: '\uD835\uDD0E',
			kfr: '\uD835\uDD28',
			kgreen: '\u0138',
			KHcy: '\u0425',
			khcy: '\u0445',
			KJcy: '\u040C',
			kjcy: '\u045C',
			Kopf: '\uD835\uDD42',
			kopf: '\uD835\uDD5C',
			Kscr: '\uD835\uDCA6',
			kscr: '\uD835\uDCC0',
			lAarr: '\u21DA',
			Lacute: '\u0139',
			lacute: '\u013A',
			laemptyv: '\u29B4',
			lagran: '\u2112',
			Lambda: '\u039B',
			lambda: '\u03BB',
			Lang: '\u27EA',
			lang: '\u27E8',
			langd: '\u2991',
			langle: '\u27E8',
			lap: '\u2A85',
			Laplacetrf: '\u2112',
			laquo: '\u00AB',
			Larr: '\u219E',
			lArr: '\u21D0',
			larr: '\u2190',
			larrb: '\u21E4',
			larrbfs: '\u291F',
			larrfs: '\u291D',
			larrhk: '\u21A9',
			larrlp: '\u21AB',
			larrpl: '\u2939',
			larrsim: '\u2973',
			larrtl: '\u21A2',
			lat: '\u2AAB',
			lAtail: '\u291B',
			latail: '\u2919',
			late: '\u2AAD',
			lates: '\u2AAD\uFE00',
			lBarr: '\u290E',
			lbarr: '\u290C',
			lbbrk: '\u2772',
			lbrace: '\u007B',
			lbrack: '\u005B',
			lbrke: '\u298B',
			lbrksld: '\u298F',
			lbrkslu: '\u298D',
			Lcaron: '\u013D',
			lcaron: '\u013E',
			Lcedil: '\u013B',
			lcedil: '\u013C',
			lceil: '\u2308',
			lcub: '\u007B',
			Lcy: '\u041B',
			lcy: '\u043B',
			ldca: '\u2936',
			ldquo: '\u201C',
			ldquor: '\u201E',
			ldrdhar: '\u2967',
			ldrushar: '\u294B',
			ldsh: '\u21B2',
			lE: '\u2266',
			le: '\u2264',
			LeftAngleBracket: '\u27E8',
			LeftArrow: '\u2190',
			Leftarrow: '\u21D0',
			leftarrow: '\u2190',
			LeftArrowBar: '\u21E4',
			LeftArrowRightArrow: '\u21C6',
			leftarrowtail: '\u21A2',
			LeftCeiling: '\u2308',
			LeftDoubleBracket: '\u27E6',
			LeftDownTeeVector: '\u2961',
			LeftDownVector: '\u21C3',
			LeftDownVectorBar: '\u2959',
			LeftFloor: '\u230A',
			leftharpoondown: '\u21BD',
			leftharpoonup: '\u21BC',
			leftleftarrows: '\u21C7',
			LeftRightArrow: '\u2194',
			Leftrightarrow: '\u21D4',
			leftrightarrow: '\u2194',
			leftrightarrows: '\u21C6',
			leftrightharpoons: '\u21CB',
			leftrightsquigarrow: '\u21AD',
			LeftRightVector: '\u294E',
			LeftTee: '\u22A3',
			LeftTeeArrow: '\u21A4',
			LeftTeeVector: '\u295A',
			leftthreetimes: '\u22CB',
			LeftTriangle: '\u22B2',
			LeftTriangleBar: '\u29CF',
			LeftTriangleEqual: '\u22B4',
			LeftUpDownVector: '\u2951',
			LeftUpTeeVector: '\u2960',
			LeftUpVector: '\u21BF',
			LeftUpVectorBar: '\u2958',
			LeftVector: '\u21BC',
			LeftVectorBar: '\u2952',
			lEg: '\u2A8B',
			leg: '\u22DA',
			leq: '\u2264',
			leqq: '\u2266',
			leqslant: '\u2A7D',
			les: '\u2A7D',
			lescc: '\u2AA8',
			lesdot: '\u2A7F',
			lesdoto: '\u2A81',
			lesdotor: '\u2A83',
			lesg: '\u22DA\uFE00',
			lesges: '\u2A93',
			lessapprox: '\u2A85',
			lessdot: '\u22D6',
			lesseqgtr: '\u22DA',
			lesseqqgtr: '\u2A8B',
			LessEqualGreater: '\u22DA',
			LessFullEqual: '\u2266',
			LessGreater: '\u2276',
			lessgtr: '\u2276',
			LessLess: '\u2AA1',
			lesssim: '\u2272',
			LessSlantEqual: '\u2A7D',
			LessTilde: '\u2272',
			lfisht: '\u297C',
			lfloor: '\u230A',
			Lfr: '\uD835\uDD0F',
			lfr: '\uD835\uDD29',
			lg: '\u2276',
			lgE: '\u2A91',
			lHar: '\u2962',
			lhard: '\u21BD',
			lharu: '\u21BC',
			lharul: '\u296A',
			lhblk: '\u2584',
			LJcy: '\u0409',
			ljcy: '\u0459',
			Ll: '\u22D8',
			ll: '\u226A',
			llarr: '\u21C7',
			llcorner: '\u231E',
			Lleftarrow: '\u21DA',
			llhard: '\u296B',
			lltri: '\u25FA',
			Lmidot: '\u013F',
			lmidot: '\u0140',
			lmoust: '\u23B0',
			lmoustache: '\u23B0',
			lnap: '\u2A89',
			lnapprox: '\u2A89',
			lnE: '\u2268',
			lne: '\u2A87',
			lneq: '\u2A87',
			lneqq: '\u2268',
			lnsim: '\u22E6',
			loang: '\u27EC',
			loarr: '\u21FD',
			lobrk: '\u27E6',
			LongLeftArrow: '\u27F5',
			Longleftarrow: '\u27F8',
			longleftarrow: '\u27F5',
			LongLeftRightArrow: '\u27F7',
			Longleftrightarrow: '\u27FA',
			longleftrightarrow: '\u27F7',
			longmapsto: '\u27FC',
			LongRightArrow: '\u27F6',
			Longrightarrow: '\u27F9',
			longrightarrow: '\u27F6',
			looparrowleft: '\u21AB',
			looparrowright: '\u21AC',
			lopar: '\u2985',
			Lopf: '\uD835\uDD43',
			lopf: '\uD835\uDD5D',
			loplus: '\u2A2D',
			lotimes: '\u2A34',
			lowast: '\u2217',
			lowbar: '\u005F',
			LowerLeftArrow: '\u2199',
			LowerRightArrow: '\u2198',
			loz: '\u25CA',
			lozenge: '\u25CA',
			lozf: '\u29EB',
			lpar: '\u0028',
			lparlt: '\u2993',
			lrarr: '\u21C6',
			lrcorner: '\u231F',
			lrhar: '\u21CB',
			lrhard: '\u296D',
			lrm: '\u200E',
			lrtri: '\u22BF',
			lsaquo: '\u2039',
			Lscr: '\u2112',
			lscr: '\uD835\uDCC1',
			Lsh: '\u21B0',
			lsh: '\u21B0',
			lsim: '\u2272',
			lsime: '\u2A8D',
			lsimg: '\u2A8F',
			lsqb: '\u005B',
			lsquo: '\u2018',
			lsquor: '\u201A',
			Lstrok: '\u0141',
			lstrok: '\u0142',
			Lt: '\u226A',
			LT: '\u003C',
			lt: '\u003C',
			ltcc: '\u2AA6',
			ltcir: '\u2A79',
			ltdot: '\u22D6',
			lthree: '\u22CB',
			ltimes: '\u22C9',
			ltlarr: '\u2976',
			ltquest: '\u2A7B',
			ltri: '\u25C3',
			ltrie: '\u22B4',
			ltrif: '\u25C2',
			ltrPar: '\u2996',
			lurdshar: '\u294A',
			luruhar: '\u2966',
			lvertneqq: '\u2268\uFE00',
			lvnE: '\u2268\uFE00',
			macr: '\u00AF',
			male: '\u2642',
			malt: '\u2720',
			maltese: '\u2720',
			Map: '\u2905',
			map: '\u21A6',
			mapsto: '\u21A6',
			mapstodown: '\u21A7',
			mapstoleft: '\u21A4',
			mapstoup: '\u21A5',
			marker: '\u25AE',
			mcomma: '\u2A29',
			Mcy: '\u041C',
			mcy: '\u043C',
			mdash: '\u2014',
			mDDot: '\u223A',
			measuredangle: '\u2221',
			MediumSpace: '\u205F',
			Mellintrf: '\u2133',
			Mfr: '\uD835\uDD10',
			mfr: '\uD835\uDD2A',
			mho: '\u2127',
			micro: '\u00B5',
			mid: '\u2223',
			midast: '\u002A',
			midcir: '\u2AF0',
			middot: '\u00B7',
			minus: '\u2212',
			minusb: '\u229F',
			minusd: '\u2238',
			minusdu: '\u2A2A',
			MinusPlus: '\u2213',
			mlcp: '\u2ADB',
			mldr: '\u2026',
			mnplus: '\u2213',
			models: '\u22A7',
			Mopf: '\uD835\uDD44',
			mopf: '\uD835\uDD5E',
			mp: '\u2213',
			Mscr: '\u2133',
			mscr: '\uD835\uDCC2',
			mstpos: '\u223E',
			Mu: '\u039C',
			mu: '\u03BC',
			multimap: '\u22B8',
			mumap: '\u22B8',
			nabla: '\u2207',
			Nacute: '\u0143',
			nacute: '\u0144',
			nang: '\u2220\u20D2',
			nap: '\u2249',
			napE: '\u2A70\u0338',
			napid: '\u224B\u0338',
			napos: '\u0149',
			napprox: '\u2249',
			natur: '\u266E',
			natural: '\u266E',
			naturals: '\u2115',
			nbsp: '\u00A0',
			nbump: '\u224E\u0338',
			nbumpe: '\u224F\u0338',
			ncap: '\u2A43',
			Ncaron: '\u0147',
			ncaron: '\u0148',
			Ncedil: '\u0145',
			ncedil: '\u0146',
			ncong: '\u2247',
			ncongdot: '\u2A6D\u0338',
			ncup: '\u2A42',
			Ncy: '\u041D',
			ncy: '\u043D',
			ndash: '\u2013',
			ne: '\u2260',
			nearhk: '\u2924',
			neArr: '\u21D7',
			nearr: '\u2197',
			nearrow: '\u2197',
			nedot: '\u2250\u0338',
			NegativeMediumSpace: '\u200B',
			NegativeThickSpace: '\u200B',
			NegativeThinSpace: '\u200B',
			NegativeVeryThinSpace: '\u200B',
			nequiv: '\u2262',
			nesear: '\u2928',
			nesim: '\u2242\u0338',
			NestedGreaterGreater: '\u226B',
			NestedLessLess: '\u226A',
			NewLine: '\u000A',
			nexist: '\u2204',
			nexists: '\u2204',
			Nfr: '\uD835\uDD11',
			nfr: '\uD835\uDD2B',
			ngE: '\u2267\u0338',
			nge: '\u2271',
			ngeq: '\u2271',
			ngeqq: '\u2267\u0338',
			ngeqslant: '\u2A7E\u0338',
			nges: '\u2A7E\u0338',
			nGg: '\u22D9\u0338',
			ngsim: '\u2275',
			nGt: '\u226B\u20D2',
			ngt: '\u226F',
			ngtr: '\u226F',
			nGtv: '\u226B\u0338',
			nhArr: '\u21CE',
			nharr: '\u21AE',
			nhpar: '\u2AF2',
			ni: '\u220B',
			nis: '\u22FC',
			nisd: '\u22FA',
			niv: '\u220B',
			NJcy: '\u040A',
			njcy: '\u045A',
			nlArr: '\u21CD',
			nlarr: '\u219A',
			nldr: '\u2025',
			nlE: '\u2266\u0338',
			nle: '\u2270',
			nLeftarrow: '\u21CD',
			nleftarrow: '\u219A',
			nLeftrightarrow: '\u21CE',
			nleftrightarrow: '\u21AE',
			nleq: '\u2270',
			nleqq: '\u2266\u0338',
			nleqslant: '\u2A7D\u0338',
			nles: '\u2A7D\u0338',
			nless: '\u226E',
			nLl: '\u22D8\u0338',
			nlsim: '\u2274',
			nLt: '\u226A\u20D2',
			nlt: '\u226E',
			nltri: '\u22EA',
			nltrie: '\u22EC',
			nLtv: '\u226A\u0338',
			nmid: '\u2224',
			NoBreak: '\u2060',
			NonBreakingSpace: '\u00A0',
			Nopf: '\u2115',
			nopf: '\uD835\uDD5F',
			Not: '\u2AEC',
			not: '\u00AC',
			NotCongruent: '\u2262',
			NotCupCap: '\u226D',
			NotDoubleVerticalBar: '\u2226',
			NotElement: '\u2209',
			NotEqual: '\u2260',
			NotEqualTilde: '\u2242\u0338',
			NotExists: '\u2204',
			NotGreater: '\u226F',
			NotGreaterEqual: '\u2271',
			NotGreaterFullEqual: '\u2267\u0338',
			NotGreaterGreater: '\u226B\u0338',
			NotGreaterLess: '\u2279',
			NotGreaterSlantEqual: '\u2A7E\u0338',
			NotGreaterTilde: '\u2275',
			NotHumpDownHump: '\u224E\u0338',
			NotHumpEqual: '\u224F\u0338',
			notin: '\u2209',
			notindot: '\u22F5\u0338',
			notinE: '\u22F9\u0338',
			notinva: '\u2209',
			notinvb: '\u22F7',
			notinvc: '\u22F6',
			NotLeftTriangle: '\u22EA',
			NotLeftTriangleBar: '\u29CF\u0338',
			NotLeftTriangleEqual: '\u22EC',
			NotLess: '\u226E',
			NotLessEqual: '\u2270',
			NotLessGreater: '\u2278',
			NotLessLess: '\u226A\u0338',
			NotLessSlantEqual: '\u2A7D\u0338',
			NotLessTilde: '\u2274',
			NotNestedGreaterGreater: '\u2AA2\u0338',
			NotNestedLessLess: '\u2AA1\u0338',
			notni: '\u220C',
			notniva: '\u220C',
			notnivb: '\u22FE',
			notnivc: '\u22FD',
			NotPrecedes: '\u2280',
			NotPrecedesEqual: '\u2AAF\u0338',
			NotPrecedesSlantEqual: '\u22E0',
			NotReverseElement: '\u220C',
			NotRightTriangle: '\u22EB',
			NotRightTriangleBar: '\u29D0\u0338',
			NotRightTriangleEqual: '\u22ED',
			NotSquareSubset: '\u228F\u0338',
			NotSquareSubsetEqual: '\u22E2',
			NotSquareSuperset: '\u2290\u0338',
			NotSquareSupersetEqual: '\u22E3',
			NotSubset: '\u2282\u20D2',
			NotSubsetEqual: '\u2288',
			NotSucceeds: '\u2281',
			NotSucceedsEqual: '\u2AB0\u0338',
			NotSucceedsSlantEqual: '\u22E1',
			NotSucceedsTilde: '\u227F\u0338',
			NotSuperset: '\u2283\u20D2',
			NotSupersetEqual: '\u2289',
			NotTilde: '\u2241',
			NotTildeEqual: '\u2244',
			NotTildeFullEqual: '\u2247',
			NotTildeTilde: '\u2249',
			NotVerticalBar: '\u2224',
			npar: '\u2226',
			nparallel: '\u2226',
			nparsl: '\u2AFD\u20E5',
			npart: '\u2202\u0338',
			npolint: '\u2A14',
			npr: '\u2280',
			nprcue: '\u22E0',
			npre: '\u2AAF\u0338',
			nprec: '\u2280',
			npreceq: '\u2AAF\u0338',
			nrArr: '\u21CF',
			nrarr: '\u219B',
			nrarrc: '\u2933\u0338',
			nrarrw: '\u219D\u0338',
			nRightarrow: '\u21CF',
			nrightarrow: '\u219B',
			nrtri: '\u22EB',
			nrtrie: '\u22ED',
			nsc: '\u2281',
			nsccue: '\u22E1',
			nsce: '\u2AB0\u0338',
			Nscr: '\uD835\uDCA9',
			nscr: '\uD835\uDCC3',
			nshortmid: '\u2224',
			nshortparallel: '\u2226',
			nsim: '\u2241',
			nsime: '\u2244',
			nsimeq: '\u2244',
			nsmid: '\u2224',
			nspar: '\u2226',
			nsqsube: '\u22E2',
			nsqsupe: '\u22E3',
			nsub: '\u2284',
			nsubE: '\u2AC5\u0338',
			nsube: '\u2288',
			nsubset: '\u2282\u20D2',
			nsubseteq: '\u2288',
			nsubseteqq: '\u2AC5\u0338',
			nsucc: '\u2281',
			nsucceq: '\u2AB0\u0338',
			nsup: '\u2285',
			nsupE: '\u2AC6\u0338',
			nsupe: '\u2289',
			nsupset: '\u2283\u20D2',
			nsupseteq: '\u2289',
			nsupseteqq: '\u2AC6\u0338',
			ntgl: '\u2279',
			Ntilde: '\u00D1',
			ntilde: '\u00F1',
			ntlg: '\u2278',
			ntriangleleft: '\u22EA',
			ntrianglelefteq: '\u22EC',
			ntriangleright: '\u22EB',
			ntrianglerighteq: '\u22ED',
			Nu: '\u039D',
			nu: '\u03BD',
			num: '\u0023',
			numero: '\u2116',
			numsp: '\u2007',
			nvap: '\u224D\u20D2',
			nVDash: '\u22AF',
			nVdash: '\u22AE',
			nvDash: '\u22AD',
			nvdash: '\u22AC',
			nvge: '\u2265\u20D2',
			nvgt: '\u003E\u20D2',
			nvHarr: '\u2904',
			nvinfin: '\u29DE',
			nvlArr: '\u2902',
			nvle: '\u2264\u20D2',
			nvlt: '\u003C\u20D2',
			nvltrie: '\u22B4\u20D2',
			nvrArr: '\u2903',
			nvrtrie: '\u22B5\u20D2',
			nvsim: '\u223C\u20D2',
			nwarhk: '\u2923',
			nwArr: '\u21D6',
			nwarr: '\u2196',
			nwarrow: '\u2196',
			nwnear: '\u2927',
			Oacute: '\u00D3',
			oacute: '\u00F3',
			oast: '\u229B',
			ocir: '\u229A',
			Ocirc: '\u00D4',
			ocirc: '\u00F4',
			Ocy: '\u041E',
			ocy: '\u043E',
			odash: '\u229D',
			Odblac: '\u0150',
			odblac: '\u0151',
			odiv: '\u2A38',
			odot: '\u2299',
			odsold: '\u29BC',
			OElig: '\u0152',
			oelig: '\u0153',
			ofcir: '\u29BF',
			Ofr: '\uD835\uDD12',
			ofr: '\uD835\uDD2C',
			ogon: '\u02DB',
			Ograve: '\u00D2',
			ograve: '\u00F2',
			ogt: '\u29C1',
			ohbar: '\u29B5',
			ohm: '\u03A9',
			oint: '\u222E',
			olarr: '\u21BA',
			olcir: '\u29BE',
			olcross: '\u29BB',
			oline: '\u203E',
			olt: '\u29C0',
			Omacr: '\u014C',
			omacr: '\u014D',
			Omega: '\u03A9',
			omega: '\u03C9',
			Omicron: '\u039F',
			omicron: '\u03BF',
			omid: '\u29B6',
			ominus: '\u2296',
			Oopf: '\uD835\uDD46',
			oopf: '\uD835\uDD60',
			opar: '\u29B7',
			OpenCurlyDoubleQuote: '\u201C',
			OpenCurlyQuote: '\u2018',
			operp: '\u29B9',
			oplus: '\u2295',
			Or: '\u2A54',
			or: '\u2228',
			orarr: '\u21BB',
			ord: '\u2A5D',
			order: '\u2134',
			orderof: '\u2134',
			ordf: '\u00AA',
			ordm: '\u00BA',
			origof: '\u22B6',
			oror: '\u2A56',
			orslope: '\u2A57',
			orv: '\u2A5B',
			oS: '\u24C8',
			Oscr: '\uD835\uDCAA',
			oscr: '\u2134',
			Oslash: '\u00D8',
			oslash: '\u00F8',
			osol: '\u2298',
			Otilde: '\u00D5',
			otilde: '\u00F5',
			Otimes: '\u2A37',
			otimes: '\u2297',
			otimesas: '\u2A36',
			Ouml: '\u00D6',
			ouml: '\u00F6',
			ovbar: '\u233D',
			OverBar: '\u203E',
			OverBrace: '\u23DE',
			OverBracket: '\u23B4',
			OverParenthesis: '\u23DC',
			par: '\u2225',
			para: '\u00B6',
			parallel: '\u2225',
			parsim: '\u2AF3',
			parsl: '\u2AFD',
			part: '\u2202',
			PartialD: '\u2202',
			Pcy: '\u041F',
			pcy: '\u043F',
			percnt: '\u0025',
			period: '\u002E',
			permil: '\u2030',
			perp: '\u22A5',
			pertenk: '\u2031',
			Pfr: '\uD835\uDD13',
			pfr: '\uD835\uDD2D',
			Phi: '\u03A6',
			phi: '\u03C6',
			phiv: '\u03D5',
			phmmat: '\u2133',
			phone: '\u260E',
			Pi: '\u03A0',
			pi: '\u03C0',
			pitchfork: '\u22D4',
			piv: '\u03D6',
			planck: '\u210F',
			planckh: '\u210E',
			plankv: '\u210F',
			plus: '\u002B',
			plusacir: '\u2A23',
			plusb: '\u229E',
			pluscir: '\u2A22',
			plusdo: '\u2214',
			plusdu: '\u2A25',
			pluse: '\u2A72',
			PlusMinus: '\u00B1',
			plusmn: '\u00B1',
			plussim: '\u2A26',
			plustwo: '\u2A27',
			pm: '\u00B1',
			Poincareplane: '\u210C',
			pointint: '\u2A15',
			Popf: '\u2119',
			popf: '\uD835\uDD61',
			pound: '\u00A3',
			Pr: '\u2ABB',
			pr: '\u227A',
			prap: '\u2AB7',
			prcue: '\u227C',
			prE: '\u2AB3',
			pre: '\u2AAF',
			prec: '\u227A',
			precapprox: '\u2AB7',
			preccurlyeq: '\u227C',
			Precedes: '\u227A',
			PrecedesEqual: '\u2AAF',
			PrecedesSlantEqual: '\u227C',
			PrecedesTilde: '\u227E',
			preceq: '\u2AAF',
			precnapprox: '\u2AB9',
			precneqq: '\u2AB5',
			precnsim: '\u22E8',
			precsim: '\u227E',
			Prime: '\u2033',
			prime: '\u2032',
			primes: '\u2119',
			prnap: '\u2AB9',
			prnE: '\u2AB5',
			prnsim: '\u22E8',
			prod: '\u220F',
			Product: '\u220F',
			profalar: '\u232E',
			profline: '\u2312',
			profsurf: '\u2313',
			prop: '\u221D',
			Proportion: '\u2237',
			Proportional: '\u221D',
			propto: '\u221D',
			prsim: '\u227E',
			prurel: '\u22B0',
			Pscr: '\uD835\uDCAB',
			pscr: '\uD835\uDCC5',
			Psi: '\u03A8',
			psi: '\u03C8',
			puncsp: '\u2008',
			Qfr: '\uD835\uDD14',
			qfr: '\uD835\uDD2E',
			qint: '\u2A0C',
			Qopf: '\u211A',
			qopf: '\uD835\uDD62',
			qprime: '\u2057',
			Qscr: '\uD835\uDCAC',
			qscr: '\uD835\uDCC6',
			quaternions: '\u210D',
			quatint: '\u2A16',
			quest: '\u003F',
			questeq: '\u225F',
			QUOT: '\u0022',
			quot: '\u0022',
			rAarr: '\u21DB',
			race: '\u223D\u0331',
			Racute: '\u0154',
			racute: '\u0155',
			radic: '\u221A',
			raemptyv: '\u29B3',
			Rang: '\u27EB',
			rang: '\u27E9',
			rangd: '\u2992',
			range: '\u29A5',
			rangle: '\u27E9',
			raquo: '\u00BB',
			Rarr: '\u21A0',
			rArr: '\u21D2',
			rarr: '\u2192',
			rarrap: '\u2975',
			rarrb: '\u21E5',
			rarrbfs: '\u2920',
			rarrc: '\u2933',
			rarrfs: '\u291E',
			rarrhk: '\u21AA',
			rarrlp: '\u21AC',
			rarrpl: '\u2945',
			rarrsim: '\u2974',
			Rarrtl: '\u2916',
			rarrtl: '\u21A3',
			rarrw: '\u219D',
			rAtail: '\u291C',
			ratail: '\u291A',
			ratio: '\u2236',
			rationals: '\u211A',
			RBarr: '\u2910',
			rBarr: '\u290F',
			rbarr: '\u290D',
			rbbrk: '\u2773',
			rbrace: '\u007D',
			rbrack: '\u005D',
			rbrke: '\u298C',
			rbrksld: '\u298E',
			rbrkslu: '\u2990',
			Rcaron: '\u0158',
			rcaron: '\u0159',
			Rcedil: '\u0156',
			rcedil: '\u0157',
			rceil: '\u2309',
			rcub: '\u007D',
			Rcy: '\u0420',
			rcy: '\u0440',
			rdca: '\u2937',
			rdldhar: '\u2969',
			rdquo: '\u201D',
			rdquor: '\u201D',
			rdsh: '\u21B3',
			Re: '\u211C',
			real: '\u211C',
			realine: '\u211B',
			realpart: '\u211C',
			reals: '\u211D',
			rect: '\u25AD',
			REG: '\u00AE',
			reg: '\u00AE',
			ReverseElement: '\u220B',
			ReverseEquilibrium: '\u21CB',
			ReverseUpEquilibrium: '\u296F',
			rfisht: '\u297D',
			rfloor: '\u230B',
			Rfr: '\u211C',
			rfr: '\uD835\uDD2F',
			rHar: '\u2964',
			rhard: '\u21C1',
			rharu: '\u21C0',
			rharul: '\u296C',
			Rho: '\u03A1',
			rho: '\u03C1',
			rhov: '\u03F1',
			RightAngleBracket: '\u27E9',
			RightArrow: '\u2192',
			Rightarrow: '\u21D2',
			rightarrow: '\u2192',
			RightArrowBar: '\u21E5',
			RightArrowLeftArrow: '\u21C4',
			rightarrowtail: '\u21A3',
			RightCeiling: '\u2309',
			RightDoubleBracket: '\u27E7',
			RightDownTeeVector: '\u295D',
			RightDownVector: '\u21C2',
			RightDownVectorBar: '\u2955',
			RightFloor: '\u230B',
			rightharpoondown: '\u21C1',
			rightharpoonup: '\u21C0',
			rightleftarrows: '\u21C4',
			rightleftharpoons: '\u21CC',
			rightrightarrows: '\u21C9',
			rightsquigarrow: '\u219D',
			RightTee: '\u22A2',
			RightTeeArrow: '\u21A6',
			RightTeeVector: '\u295B',
			rightthreetimes: '\u22CC',
			RightTriangle: '\u22B3',
			RightTriangleBar: '\u29D0',
			RightTriangleEqual: '\u22B5',
			RightUpDownVector: '\u294F',
			RightUpTeeVector: '\u295C',
			RightUpVector: '\u21BE',
			RightUpVectorBar: '\u2954',
			RightVector: '\u21C0',
			RightVectorBar: '\u2953',
			ring: '\u02DA',
			risingdotseq: '\u2253',
			rlarr: '\u21C4',
			rlhar: '\u21CC',
			rlm: '\u200F',
			rmoust: '\u23B1',
			rmoustache: '\u23B1',
			rnmid: '\u2AEE',
			roang: '\u27ED',
			roarr: '\u21FE',
			robrk: '\u27E7',
			ropar: '\u2986',
			Ropf: '\u211D',
			ropf: '\uD835\uDD63',
			roplus: '\u2A2E',
			rotimes: '\u2A35',
			RoundImplies: '\u2970',
			rpar: '\u0029',
			rpargt: '\u2994',
			rppolint: '\u2A12',
			rrarr: '\u21C9',
			Rrightarrow: '\u21DB',
			rsaquo: '\u203A',
			Rscr: '\u211B',
			rscr: '\uD835\uDCC7',
			Rsh: '\u21B1',
			rsh: '\u21B1',
			rsqb: '\u005D',
			rsquo: '\u2019',
			rsquor: '\u2019',
			rthree: '\u22CC',
			rtimes: '\u22CA',
			rtri: '\u25B9',
			rtrie: '\u22B5',
			rtrif: '\u25B8',
			rtriltri: '\u29CE',
			RuleDelayed: '\u29F4',
			ruluhar: '\u2968',
			rx: '\u211E',
			Sacute: '\u015A',
			sacute: '\u015B',
			sbquo: '\u201A',
			Sc: '\u2ABC',
			sc: '\u227B',
			scap: '\u2AB8',
			Scaron: '\u0160',
			scaron: '\u0161',
			sccue: '\u227D',
			scE: '\u2AB4',
			sce: '\u2AB0',
			Scedil: '\u015E',
			scedil: '\u015F',
			Scirc: '\u015C',
			scirc: '\u015D',
			scnap: '\u2ABA',
			scnE: '\u2AB6',
			scnsim: '\u22E9',
			scpolint: '\u2A13',
			scsim: '\u227F',
			Scy: '\u0421',
			scy: '\u0441',
			sdot: '\u22C5',
			sdotb: '\u22A1',
			sdote: '\u2A66',
			searhk: '\u2925',
			seArr: '\u21D8',
			searr: '\u2198',
			searrow: '\u2198',
			sect: '\u00A7',
			semi: '\u003B',
			seswar: '\u2929',
			setminus: '\u2216',
			setmn: '\u2216',
			sext: '\u2736',
			Sfr: '\uD835\uDD16',
			sfr: '\uD835\uDD30',
			sfrown: '\u2322',
			sharp: '\u266F',
			SHCHcy: '\u0429',
			shchcy: '\u0449',
			SHcy: '\u0428',
			shcy: '\u0448',
			ShortDownArrow: '\u2193',
			ShortLeftArrow: '\u2190',
			shortmid: '\u2223',
			shortparallel: '\u2225',
			ShortRightArrow: '\u2192',
			ShortUpArrow: '\u2191',
			shy: '\u00AD',
			Sigma: '\u03A3',
			sigma: '\u03C3',
			sigmaf: '\u03C2',
			sigmav: '\u03C2',
			sim: '\u223C',
			simdot: '\u2A6A',
			sime: '\u2243',
			simeq: '\u2243',
			simg: '\u2A9E',
			simgE: '\u2AA0',
			siml: '\u2A9D',
			simlE: '\u2A9F',
			simne: '\u2246',
			simplus: '\u2A24',
			simrarr: '\u2972',
			slarr: '\u2190',
			SmallCircle: '\u2218',
			smallsetminus: '\u2216',
			smashp: '\u2A33',
			smeparsl: '\u29E4',
			smid: '\u2223',
			smile: '\u2323',
			smt: '\u2AAA',
			smte: '\u2AAC',
			smtes: '\u2AAC\uFE00',
			SOFTcy: '\u042C',
			softcy: '\u044C',
			sol: '\u002F',
			solb: '\u29C4',
			solbar: '\u233F',
			Sopf: '\uD835\uDD4A',
			sopf: '\uD835\uDD64',
			spades: '\u2660',
			spadesuit: '\u2660',
			spar: '\u2225',
			sqcap: '\u2293',
			sqcaps: '\u2293\uFE00',
			sqcup: '\u2294',
			sqcups: '\u2294\uFE00',
			Sqrt: '\u221A',
			sqsub: '\u228F',
			sqsube: '\u2291',
			sqsubset: '\u228F',
			sqsubseteq: '\u2291',
			sqsup: '\u2290',
			sqsupe: '\u2292',
			sqsupset: '\u2290',
			sqsupseteq: '\u2292',
			squ: '\u25A1',
			Square: '\u25A1',
			square: '\u25A1',
			SquareIntersection: '\u2293',
			SquareSubset: '\u228F',
			SquareSubsetEqual: '\u2291',
			SquareSuperset: '\u2290',
			SquareSupersetEqual: '\u2292',
			SquareUnion: '\u2294',
			squarf: '\u25AA',
			squf: '\u25AA',
			srarr: '\u2192',
			Sscr: '\uD835\uDCAE',
			sscr: '\uD835\uDCC8',
			ssetmn: '\u2216',
			ssmile: '\u2323',
			sstarf: '\u22C6',
			Star: '\u22C6',
			star: '\u2606',
			starf: '\u2605',
			straightepsilon: '\u03F5',
			straightphi: '\u03D5',
			strns: '\u00AF',
			Sub: '\u22D0',
			sub: '\u2282',
			subdot: '\u2ABD',
			subE: '\u2AC5',
			sube: '\u2286',
			subedot: '\u2AC3',
			submult: '\u2AC1',
			subnE: '\u2ACB',
			subne: '\u228A',
			subplus: '\u2ABF',
			subrarr: '\u2979',
			Subset: '\u22D0',
			subset: '\u2282',
			subseteq: '\u2286',
			subseteqq: '\u2AC5',
			SubsetEqual: '\u2286',
			subsetneq: '\u228A',
			subsetneqq: '\u2ACB',
			subsim: '\u2AC7',
			subsub: '\u2AD5',
			subsup: '\u2AD3',
			succ: '\u227B',
			succapprox: '\u2AB8',
			succcurlyeq: '\u227D',
			Succeeds: '\u227B',
			SucceedsEqual: '\u2AB0',
			SucceedsSlantEqual: '\u227D',
			SucceedsTilde: '\u227F',
			succeq: '\u2AB0',
			succnapprox: '\u2ABA',
			succneqq: '\u2AB6',
			succnsim: '\u22E9',
			succsim: '\u227F',
			SuchThat: '\u220B',
			Sum: '\u2211',
			sum: '\u2211',
			sung: '\u266A',
			Sup: '\u22D1',
			sup: '\u2283',
			sup1: '\u00B9',
			sup2: '\u00B2',
			sup3: '\u00B3',
			supdot: '\u2ABE',
			supdsub: '\u2AD8',
			supE: '\u2AC6',
			supe: '\u2287',
			supedot: '\u2AC4',
			Superset: '\u2283',
			SupersetEqual: '\u2287',
			suphsol: '\u27C9',
			suphsub: '\u2AD7',
			suplarr: '\u297B',
			supmult: '\u2AC2',
			supnE: '\u2ACC',
			supne: '\u228B',
			supplus: '\u2AC0',
			Supset: '\u22D1',
			supset: '\u2283',
			supseteq: '\u2287',
			supseteqq: '\u2AC6',
			supsetneq: '\u228B',
			supsetneqq: '\u2ACC',
			supsim: '\u2AC8',
			supsub: '\u2AD4',
			supsup: '\u2AD6',
			swarhk: '\u2926',
			swArr: '\u21D9',
			swarr: '\u2199',
			swarrow: '\u2199',
			swnwar: '\u292A',
			szlig: '\u00DF',
			Tab: '\u0009',
			target: '\u2316',
			Tau: '\u03A4',
			tau: '\u03C4',
			tbrk: '\u23B4',
			Tcaron: '\u0164',
			tcaron: '\u0165',
			Tcedil: '\u0162',
			tcedil: '\u0163',
			Tcy: '\u0422',
			tcy: '\u0442',
			tdot: '\u20DB',
			telrec: '\u2315',
			Tfr: '\uD835\uDD17',
			tfr: '\uD835\uDD31',
			there4: '\u2234',
			Therefore: '\u2234',
			therefore: '\u2234',
			Theta: '\u0398',
			theta: '\u03B8',
			thetasym: '\u03D1',
			thetav: '\u03D1',
			thickapprox: '\u2248',
			thicksim: '\u223C',
			ThickSpace: '\u205F\u200A',
			thinsp: '\u2009',
			ThinSpace: '\u2009',
			thkap: '\u2248',
			thksim: '\u223C',
			THORN: '\u00DE',
			thorn: '\u00FE',
			Tilde: '\u223C',
			tilde: '\u02DC',
			TildeEqual: '\u2243',
			TildeFullEqual: '\u2245',
			TildeTilde: '\u2248',
			times: '\u00D7',
			timesb: '\u22A0',
			timesbar: '\u2A31',
			timesd: '\u2A30',
			tint: '\u222D',
			toea: '\u2928',
			top: '\u22A4',
			topbot: '\u2336',
			topcir: '\u2AF1',
			Topf: '\uD835\uDD4B',
			topf: '\uD835\uDD65',
			topfork: '\u2ADA',
			tosa: '\u2929',
			tprime: '\u2034',
			TRADE: '\u2122',
			trade: '\u2122',
			triangle: '\u25B5',
			triangledown: '\u25BF',
			triangleleft: '\u25C3',
			trianglelefteq: '\u22B4',
			triangleq: '\u225C',
			triangleright: '\u25B9',
			trianglerighteq: '\u22B5',
			tridot: '\u25EC',
			trie: '\u225C',
			triminus: '\u2A3A',
			TripleDot: '\u20DB',
			triplus: '\u2A39',
			trisb: '\u29CD',
			tritime: '\u2A3B',
			trpezium: '\u23E2',
			Tscr: '\uD835\uDCAF',
			tscr: '\uD835\uDCC9',
			TScy: '\u0426',
			tscy: '\u0446',
			TSHcy: '\u040B',
			tshcy: '\u045B',
			Tstrok: '\u0166',
			tstrok: '\u0167',
			twixt: '\u226C',
			twoheadleftarrow: '\u219E',
			twoheadrightarrow: '\u21A0',
			Uacute: '\u00DA',
			uacute: '\u00FA',
			Uarr: '\u219F',
			uArr: '\u21D1',
			uarr: '\u2191',
			Uarrocir: '\u2949',
			Ubrcy: '\u040E',
			ubrcy: '\u045E',
			Ubreve: '\u016C',
			ubreve: '\u016D',
			Ucirc: '\u00DB',
			ucirc: '\u00FB',
			Ucy: '\u0423',
			ucy: '\u0443',
			udarr: '\u21C5',
			Udblac: '\u0170',
			udblac: '\u0171',
			udhar: '\u296E',
			ufisht: '\u297E',
			Ufr: '\uD835\uDD18',
			ufr: '\uD835\uDD32',
			Ugrave: '\u00D9',
			ugrave: '\u00F9',
			uHar: '\u2963',
			uharl: '\u21BF',
			uharr: '\u21BE',
			uhblk: '\u2580',
			ulcorn: '\u231C',
			ulcorner: '\u231C',
			ulcrop: '\u230F',
			ultri: '\u25F8',
			Umacr: '\u016A',
			umacr: '\u016B',
			uml: '\u00A8',
			UnderBar: '\u005F',
			UnderBrace: '\u23DF',
			UnderBracket: '\u23B5',
			UnderParenthesis: '\u23DD',
			Union: '\u22C3',
			UnionPlus: '\u228E',
			Uogon: '\u0172',
			uogon: '\u0173',
			Uopf: '\uD835\uDD4C',
			uopf: '\uD835\uDD66',
			UpArrow: '\u2191',
			Uparrow: '\u21D1',
			uparrow: '\u2191',
			UpArrowBar: '\u2912',
			UpArrowDownArrow: '\u21C5',
			UpDownArrow: '\u2195',
			Updownarrow: '\u21D5',
			updownarrow: '\u2195',
			UpEquilibrium: '\u296E',
			upharpoonleft: '\u21BF',
			upharpoonright: '\u21BE',
			uplus: '\u228E',
			UpperLeftArrow: '\u2196',
			UpperRightArrow: '\u2197',
			Upsi: '\u03D2',
			upsi: '\u03C5',
			upsih: '\u03D2',
			Upsilon: '\u03A5',
			upsilon: '\u03C5',
			UpTee: '\u22A5',
			UpTeeArrow: '\u21A5',
			upuparrows: '\u21C8',
			urcorn: '\u231D',
			urcorner: '\u231D',
			urcrop: '\u230E',
			Uring: '\u016E',
			uring: '\u016F',
			urtri: '\u25F9',
			Uscr: '\uD835\uDCB0',
			uscr: '\uD835\uDCCA',
			utdot: '\u22F0',
			Utilde: '\u0168',
			utilde: '\u0169',
			utri: '\u25B5',
			utrif: '\u25B4',
			uuarr: '\u21C8',
			Uuml: '\u00DC',
			uuml: '\u00FC',
			uwangle: '\u29A7',
			vangrt: '\u299C',
			varepsilon: '\u03F5',
			varkappa: '\u03F0',
			varnothing: '\u2205',
			varphi: '\u03D5',
			varpi: '\u03D6',
			varpropto: '\u221D',
			vArr: '\u21D5',
			varr: '\u2195',
			varrho: '\u03F1',
			varsigma: '\u03C2',
			varsubsetneq: '\u228A\uFE00',
			varsubsetneqq: '\u2ACB\uFE00',
			varsupsetneq: '\u228B\uFE00',
			varsupsetneqq: '\u2ACC\uFE00',
			vartheta: '\u03D1',
			vartriangleleft: '\u22B2',
			vartriangleright: '\u22B3',
			Vbar: '\u2AEB',
			vBar: '\u2AE8',
			vBarv: '\u2AE9',
			Vcy: '\u0412',
			vcy: '\u0432',
			VDash: '\u22AB',
			Vdash: '\u22A9',
			vDash: '\u22A8',
			vdash: '\u22A2',
			Vdashl: '\u2AE6',
			Vee: '\u22C1',
			vee: '\u2228',
			veebar: '\u22BB',
			veeeq: '\u225A',
			vellip: '\u22EE',
			Verbar: '\u2016',
			verbar: '\u007C',
			Vert: '\u2016',
			vert: '\u007C',
			VerticalBar: '\u2223',
			VerticalLine: '\u007C',
			VerticalSeparator: '\u2758',
			VerticalTilde: '\u2240',
			VeryThinSpace: '\u200A',
			Vfr: '\uD835\uDD19',
			vfr: '\uD835\uDD33',
			vltri: '\u22B2',
			vnsub: '\u2282\u20D2',
			vnsup: '\u2283\u20D2',
			Vopf: '\uD835\uDD4D',
			vopf: '\uD835\uDD67',
			vprop: '\u221D',
			vrtri: '\u22B3',
			Vscr: '\uD835\uDCB1',
			vscr: '\uD835\uDCCB',
			vsubnE: '\u2ACB\uFE00',
			vsubne: '\u228A\uFE00',
			vsupnE: '\u2ACC\uFE00',
			vsupne: '\u228B\uFE00',
			Vvdash: '\u22AA',
			vzigzag: '\u299A',
			Wcirc: '\u0174',
			wcirc: '\u0175',
			wedbar: '\u2A5F',
			Wedge: '\u22C0',
			wedge: '\u2227',
			wedgeq: '\u2259',
			weierp: '\u2118',
			Wfr: '\uD835\uDD1A',
			wfr: '\uD835\uDD34',
			Wopf: '\uD835\uDD4E',
			wopf: '\uD835\uDD68',
			wp: '\u2118',
			wr: '\u2240',
			wreath: '\u2240',
			Wscr: '\uD835\uDCB2',
			wscr: '\uD835\uDCCC',
			xcap: '\u22C2',
			xcirc: '\u25EF',
			xcup: '\u22C3',
			xdtri: '\u25BD',
			Xfr: '\uD835\uDD1B',
			xfr: '\uD835\uDD35',
			xhArr: '\u27FA',
			xharr: '\u27F7',
			Xi: '\u039E',
			xi: '\u03BE',
			xlArr: '\u27F8',
			xlarr: '\u27F5',
			xmap: '\u27FC',
			xnis: '\u22FB',
			xodot: '\u2A00',
			Xopf: '\uD835\uDD4F',
			xopf: '\uD835\uDD69',
			xoplus: '\u2A01',
			xotime: '\u2A02',
			xrArr: '\u27F9',
			xrarr: '\u27F6',
			Xscr: '\uD835\uDCB3',
			xscr: '\uD835\uDCCD',
			xsqcup: '\u2A06',
			xuplus: '\u2A04',
			xutri: '\u25B3',
			xvee: '\u22C1',
			xwedge: '\u22C0',
			Yacute: '\u00DD',
			yacute: '\u00FD',
			YAcy: '\u042F',
			yacy: '\u044F',
			Ycirc: '\u0176',
			ycirc: '\u0177',
			Ycy: '\u042B',
			ycy: '\u044B',
			yen: '\u00A5',
			Yfr: '\uD835\uDD1C',
			yfr: '\uD835\uDD36',
			YIcy: '\u0407',
			yicy: '\u0457',
			Yopf: '\uD835\uDD50',
			yopf: '\uD835\uDD6A',
			Yscr: '\uD835\uDCB4',
			yscr: '\uD835\uDCCE',
			YUcy: '\u042E',
			yucy: '\u044E',
			Yuml: '\u0178',
			yuml: '\u00FF',
			Zacute: '\u0179',
			zacute: '\u017A',
			Zcaron: '\u017D',
			zcaron: '\u017E',
			Zcy: '\u0417',
			zcy: '\u0437',
			Zdot: '\u017B',
			zdot: '\u017C',
			zeetrf: '\u2128',
			ZeroWidthSpace: '\u200B',
			Zeta: '\u0396',
			zeta: '\u03B6',
			Zfr: '\u2128',
			zfr: '\uD835\uDD37',
			ZHcy: '\u0416',
			zhcy: '\u0436',
			zigrarr: '\u21DD',
			Zopf: '\u2124',
			zopf: '\uD835\uDD6B',
			Zscr: '\uD835\uDCB5',
			zscr: '\uD835\uDCCF',
			zwj: '\u200D',
			zwnj: '\u200C',
		});

		/**
		 * @deprecated use `HTML_ENTITIES` instead
		 * @see HTML_ENTITIES
		 */
		exports.entityMap = exports.HTML_ENTITIES; 
	} (entities));
	return entities;
}

var sax = {};

var hasRequiredSax;

function requireSax () {
	if (hasRequiredSax) return sax;
	hasRequiredSax = 1;
	var NAMESPACE = requireConventions().NAMESPACE;

	//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
	//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
	//[5]   	Name	   ::=   	NameStartChar (NameChar)*
	var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;//\u10000-\uEFFFF
	var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
	var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
	//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
	//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

	//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
	//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
	var S_TAG = 0;//tag name offerring
	var S_ATTR = 1;//attr name offerring
	var S_ATTR_SPACE=2;//attr name end and space offer
	var S_EQ = 3;//=space?
	var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
	var S_ATTR_END = 5;//attr value end and no space(quot end)
	var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
	var S_TAG_CLOSE = 7;//closed el<el />

	/**
	 * Creates an error that will not be caught by XMLReader aka the SAX parser.
	 *
	 * @param {string} message
	 * @param {any?} locator Optional, can provide details about the location in the source
	 * @constructor
	 */
	function ParseError(message, locator) {
		this.message = message;
		this.locator = locator;
		if(Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
	}
	ParseError.prototype = new Error();
	ParseError.prototype.name = ParseError.name;

	function XMLReader(){

	}

	XMLReader.prototype = {
		parse:function(source,defaultNSMap,entityMap){
			var domBuilder = this.domBuilder;
			domBuilder.startDocument();
			_copy(defaultNSMap ,defaultNSMap = {});
			parse(source,defaultNSMap,entityMap,
					domBuilder,this.errorHandler);
			domBuilder.endDocument();
		}
	};
	function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
		function fixedFromCharCode(code) {
			// String.prototype.fromCharCode does not supports
			// > 2 bytes unicode chars directly
			if (code > 0xffff) {
				code -= 0x10000;
				var surrogate1 = 0xd800 + (code >> 10)
					, surrogate2 = 0xdc00 + (code & 0x3ff);

				return String.fromCharCode(surrogate1, surrogate2);
			} else {
				return String.fromCharCode(code);
			}
		}
		function entityReplacer(a){
			var k = a.slice(1,-1);
			if (Object.hasOwnProperty.call(entityMap, k)) {
				return entityMap[k];
			}else if(k.charAt(0) === '#'){
				return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
			}else {
				errorHandler.error('entity not found:'+a);
				return a;
			}
		}
		function appendText(end){//has some bugs
			if(end>start){
				var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
				locator&&position(start);
				domBuilder.characters(xt,0,end-start);
				start = end;
			}
		}
		function position(p,m){
			while(p>=lineEnd && (m = linePattern.exec(source))){
				lineStart = m.index;
				lineEnd = lineStart + m[0].length;
				locator.lineNumber++;
				//console.log('line++:',locator,startPos,endPos)
			}
			locator.columnNumber = p-lineStart+1;
		}
		var lineStart = 0;
		var lineEnd = 0;
		var linePattern = /.*(?:\r\n?|\n)|.*$/g;
		var locator = domBuilder.locator;

		var parseStack = [{currentNSMap:defaultNSMapCopy}];
		var closeMap = {};
		var start = 0;
		while(true){
			try{
				var tagStart = source.indexOf('<',start);
				if(tagStart<0){
					if(!source.substr(start).match(/^\s*$/)){
						var doc = domBuilder.doc;
		    			var text = doc.createTextNode(source.substr(start));
		    			doc.appendChild(text);
		    			domBuilder.currentElement = text;
					}
					return;
				}
				if(tagStart>start){
					appendText(tagStart);
				}
				switch(source.charAt(tagStart+1)){
				case '/':
					var end = source.indexOf('>',tagStart+3);
					var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, '');
					var config = parseStack.pop();
					if(end<0){

		        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
		        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
		        		end = tagStart+1+tagName.length;
		        	}else if(tagName.match(/\s</)){
		        		tagName = tagName.replace(/[\s<].*/,'');
		        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
		        		end = tagStart+1+tagName.length;
					}
					var localNSMap = config.localNSMap;
					var endMatch = config.tagName == tagName;
					var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase();
			        if(endIgnoreCaseMach){
			        	domBuilder.endElement(config.uri,config.localName,tagName);
						if(localNSMap){
							for (var prefix in localNSMap) {
								if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
									domBuilder.endPrefixMapping(prefix);
								}
							}
						}
						if(!endMatch){
			            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName ); // No known test case
						}
			        }else {
			        	parseStack.push(config);
			        }

					end++;
					break;
					// end elment
				case '?':// <?...?>
					locator&&position(tagStart);
					end = parseInstruction(source,tagStart,domBuilder);
					break;
				case '!':// <!doctype,<![CDATA,<!--
					locator&&position(tagStart);
					end = parseDCC(source,tagStart,domBuilder,errorHandler);
					break;
				default:
					locator&&position(tagStart);
					var el = new ElementAttributes();
					var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
					//elStartEnd
					var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
					var len = el.length;


					if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
						el.closed = true;
						if(!entityMap.nbsp){
							errorHandler.warning('unclosed xml attribute');
						}
					}
					if(locator && len){
						var locator2 = copyLocator(locator,{});
						//try{//attribute position fixed
						for(var i = 0;i<len;i++){
							var a = el[i];
							position(a.offset);
							a.locator = copyLocator(locator,{});
						}
						domBuilder.locator = locator2;
						if(appendElement(el,domBuilder,currentNSMap)){
							parseStack.push(el);
						}
						domBuilder.locator = locator;
					}else {
						if(appendElement(el,domBuilder,currentNSMap)){
							parseStack.push(el);
						}
					}

					if (NAMESPACE.isHTML(el.uri) && !el.closed) {
						end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder);
					} else {
						end++;
					}
				}
			}catch(e){
				if (e instanceof ParseError) {
					throw e;
				}
				errorHandler.error('element parse error: '+e);
				end = -1;
			}
			if(end>start){
				start = end;
			}else {
				//TODO: sax
				appendText(Math.max(tagStart,start)+1);
			}
		}
	}
	function copyLocator(f,t){
		t.lineNumber = f.lineNumber;
		t.columnNumber = f.columnNumber;
		return t;
	}

	/**
	 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
	 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
	 */
	function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){

		/**
		 * @param {string} qname
		 * @param {string} value
		 * @param {number} startIndex
		 */
		function addAttribute(qname, value, startIndex) {
			if (el.attributeNames.hasOwnProperty(qname)) {
				errorHandler.fatalError('Attribute ' + qname + ' redefined');
			}
			el.addValue(
				qname,
				// @see https://www.w3.org/TR/xml/#AVNormalize
				// since the xmldom sax parser does not "interpret" DTD the following is not implemented:
				// - recursive replacement of (DTD) entity references
				// - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
				value.replace(/[\t\n\r]/g, ' ').replace(/&#?\w+;/g, entityReplacer),
				startIndex
			);
		}
		var attrName;
		var value;
		var p = ++start;
		var s = S_TAG;//status
		while(true){
			var c = source.charAt(p);
			switch(c){
			case '=':
				if(s === S_ATTR){//attrName
					attrName = source.slice(start,p);
					s = S_EQ;
				}else if(s === S_ATTR_SPACE){
					s = S_EQ;
				}else {
					//fatalError: equal must after attrName or space after attrName
					throw new Error('attribute equal must after attrName'); // No known test case
				}
				break;
			case '\'':
			case '"':
				if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
					){//equal
					if(s === S_ATTR){
						errorHandler.warning('attribute value must after "="');
						attrName = source.slice(start,p);
					}
					start = p+1;
					p = source.indexOf(c,start);
					if(p>0){
						value = source.slice(start, p);
						addAttribute(attrName, value, start-1);
						s = S_ATTR_END;
					}else {
						//fatalError: no end quot match
						throw new Error('attribute value no end \''+c+'\' match');
					}
				}else if(s == S_ATTR_NOQUOT_VALUE){
					value = source.slice(start, p);
					addAttribute(attrName, value, start);
					errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
					start = p+1;
					s = S_ATTR_END;
				}else {
					//fatalError: no equal before
					throw new Error('attribute value must after "="'); // No known test case
				}
				break;
			case '/':
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));
				case S_ATTR_END:
				case S_TAG_SPACE:
				case S_TAG_CLOSE:
					s =S_TAG_CLOSE;
					el.closed = true;
				case S_ATTR_NOQUOT_VALUE:
				case S_ATTR:
					break;
					case S_ATTR_SPACE:
						el.closed = true;
					break;
				//case S_EQ:
				default:
					throw new Error("attribute invalid close char('/')") // No known test case
				}
				break;
			case ''://end document
				errorHandler.error('unexpected end of input');
				if(s == S_TAG){
					el.setTagName(source.slice(start,p));
				}
				return p;
			case '>':
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));
				case S_ATTR_END:
				case S_TAG_SPACE:
				case S_TAG_CLOSE:
					break;//normal
				case S_ATTR_NOQUOT_VALUE://Compatible state
				case S_ATTR:
					value = source.slice(start,p);
					if(value.slice(-1) === '/'){
						el.closed  = true;
						value = value.slice(0,-1);
					}
				case S_ATTR_SPACE:
					if(s === S_ATTR_SPACE){
						value = attrName;
					}
					if(s == S_ATTR_NOQUOT_VALUE){
						errorHandler.warning('attribute "'+value+'" missed quot(")!');
						addAttribute(attrName, value, start);
					}else {
						if(!NAMESPACE.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)){
							errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!');
						}
						addAttribute(value, value, start);
					}
					break;
				case S_EQ:
					throw new Error('attribute value missed!!');
				}
	//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
				return p;
			/*xml space '\x20' | #x9 | #xD | #xA; */
			case '\u0080':
				c = ' ';
			default:
				if(c<= ' '){//space
					switch(s){
					case S_TAG:
						el.setTagName(source.slice(start,p));//tagName
						s = S_TAG_SPACE;
						break;
					case S_ATTR:
						attrName = source.slice(start,p);
						s = S_ATTR_SPACE;
						break;
					case S_ATTR_NOQUOT_VALUE:
						var value = source.slice(start, p);
						errorHandler.warning('attribute "'+value+'" missed quot(")!!');
						addAttribute(attrName, value, start);
					case S_ATTR_END:
						s = S_TAG_SPACE;
						break;
					//case S_TAG_SPACE:
					//case S_EQ:
					//case S_ATTR_SPACE:
					//	void();break;
					//case S_TAG_CLOSE:
						//ignore warning
					}
				}else {//not space
	//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
	//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
					switch(s){
					//case S_TAG:void();break;
					//case S_ATTR:void();break;
					//case S_ATTR_NOQUOT_VALUE:void();break;
					case S_ATTR_SPACE:
						el.tagName;
						if (!NAMESPACE.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
							errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!');
						}
						addAttribute(attrName, attrName, start);
						start = p;
						s = S_ATTR;
						break;
					case S_ATTR_END:
						errorHandler.warning('attribute space is required"'+attrName+'"!!');
					case S_TAG_SPACE:
						s = S_ATTR;
						start = p;
						break;
					case S_EQ:
						s = S_ATTR_NOQUOT_VALUE;
						start = p;
						break;
					case S_TAG_CLOSE:
						throw new Error("elements closed character '/' and '>' must be connected to");
					}
				}
			}//end outer switch
			//console.log('p++',p)
			p++;
		}
	}
	/**
	 * @return true if has new namespace define
	 */
	function appendElement(el,domBuilder,currentNSMap){
		var tagName = el.tagName;
		var localNSMap = null;
		//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
		var i = el.length;
		while(i--){
			var a = el[i];
			var qName = a.qName;
			var value = a.value;
			var nsp = qName.indexOf(':');
			if(nsp>0){
				var prefix = a.prefix = qName.slice(0,nsp);
				var localName = qName.slice(nsp+1);
				var nsPrefix = prefix === 'xmlns' && localName;
			}else {
				localName = qName;
				prefix = null;
				nsPrefix = qName === 'xmlns' && '';
			}
			//can not set prefix,because prefix !== ''
			a.localName = localName ;
			//prefix == null for no ns prefix attribute
			if(nsPrefix !== false){//hack!!
				if(localNSMap == null){
					localNSMap = {};
					//console.log(currentNSMap,0)
					_copy(currentNSMap,currentNSMap={});
					//console.log(currentNSMap,1)
				}
				currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
				a.uri = NAMESPACE.XMLNS;
				domBuilder.startPrefixMapping(nsPrefix, value);
			}
		}
		var i = el.length;
		while(i--){
			a = el[i];
			var prefix = a.prefix;
			if(prefix){//no prefix attribute has no namespace
				if(prefix === 'xml'){
					a.uri = NAMESPACE.XML;
				}if(prefix !== 'xmlns'){
					a.uri = currentNSMap[prefix || ''];

					//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
				}
			}
		}
		var nsp = tagName.indexOf(':');
		if(nsp>0){
			prefix = el.prefix = tagName.slice(0,nsp);
			localName = el.localName = tagName.slice(nsp+1);
		}else {
			prefix = null;//important!!
			localName = el.localName = tagName;
		}
		//no prefix element has default namespace
		var ns = el.uri = currentNSMap[prefix || ''];
		domBuilder.startElement(ns,localName,tagName,el);
		//endPrefixMapping and startPrefixMapping have not any help for dom builder
		//localNSMap = null
		if(el.closed){
			domBuilder.endElement(ns,localName,tagName);
			if(localNSMap){
				for (prefix in localNSMap) {
					if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
						domBuilder.endPrefixMapping(prefix);
					}
				}
			}
		}else {
			el.currentNSMap = currentNSMap;
			el.localNSMap = localNSMap;
			//parseStack.push(el);
			return true;
		}
	}
	function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
		if(/^(?:script|textarea)$/i.test(tagName)){
			var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
			var text = source.substring(elStartEnd+1,elEndStart);
			if(/[&<]/.test(text)){
				if(/^script$/i.test(tagName)){
					//if(!/\]\]>/.test(text)){
						//lexHandler.startCDATA();
						domBuilder.characters(text,0,text.length);
						//lexHandler.endCDATA();
						return elEndStart;
					//}
				}//}else{//text area
					text = text.replace(/&#?\w+;/g,entityReplacer);
					domBuilder.characters(text,0,text.length);
					return elEndStart;
				//}

			}
		}
		return elStartEnd+1;
	}
	function fixSelfClosed(source,elStartEnd,tagName,closeMap){
		//if(tagName in closeMap){
		var pos = closeMap[tagName];
		if(pos == null){
			//console.log(tagName)
			pos =  source.lastIndexOf('</'+tagName+'>');
			if(pos<elStartEnd){//
				pos = source.lastIndexOf('</'+tagName);
			}
			closeMap[tagName] =pos;
		}
		return pos<elStartEnd;
		//}
	}

	function _copy (source, target) {
		for (var n in source) {
			if (Object.prototype.hasOwnProperty.call(source, n)) {
				target[n] = source[n];
			}
		}
	}

	function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
		var next= source.charAt(start+2);
		switch(next){
		case '-':
			if(source.charAt(start + 3) === '-'){
				var end = source.indexOf('-->',start+4);
				//append comment source.substring(4,end)//<!--
				if(end>start){
					domBuilder.comment(source,start+4,end-start-4);
					return end+3;
				}else {
					errorHandler.error("Unclosed comment");
					return -1;
				}
			}else {
				//error
				return -1;
			}
		default:
			if(source.substr(start+3,6) == 'CDATA['){
				var end = source.indexOf(']]>',start+9);
				domBuilder.startCDATA();
				domBuilder.characters(source,start+9,end-start-9);
				domBuilder.endCDATA();
				return end+3;
			}
			//<!DOCTYPE
			//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)
			var matchs = split(source,start);
			var len = matchs.length;
			if(len>1 && /!doctype/i.test(matchs[0][0])){
				var name = matchs[1][0];
				var pubid = false;
				var sysid = false;
				if(len>3){
					if(/^public$/i.test(matchs[2][0])){
						pubid = matchs[3][0];
						sysid = len>4 && matchs[4][0];
					}else if(/^system$/i.test(matchs[2][0])){
						sysid = matchs[3][0];
					}
				}
				var lastMatch = matchs[len-1];
				domBuilder.startDTD(name, pubid, sysid);
				domBuilder.endDTD();

				return lastMatch.index+lastMatch[0].length
			}
		}
		return -1;
	}



	function parseInstruction(source,start,domBuilder){
		var end = source.indexOf('?>',start);
		if(end){
			var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
			if(match){
				match[0].length;
				domBuilder.processingInstruction(match[1], match[2]) ;
				return end+2;
			}else {//error
				return -1;
			}
		}
		return -1;
	}

	function ElementAttributes(){
		this.attributeNames = {};
	}
	ElementAttributes.prototype = {
		setTagName:function(tagName){
			if(!tagNamePattern.test(tagName)){
				throw new Error('invalid tagName:'+tagName)
			}
			this.tagName = tagName;
		},
		addValue:function(qName, value, offset) {
			if(!tagNamePattern.test(qName)){
				throw new Error('invalid attribute:'+qName)
			}
			this.attributeNames[qName] = this.length;
			this[this.length++] = {qName:qName,value:value,offset:offset};
		},
		length:0,
		getLocalName:function(i){return this[i].localName},
		getLocator:function(i){return this[i].locator},
		getQName:function(i){return this[i].qName},
		getURI:function(i){return this[i].uri},
		getValue:function(i){return this[i].value}
	//	,getIndex:function(uri, localName)){
	//		if(localName){
	//
	//		}else{
	//			var qName = uri
	//		}
	//	},
	//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
	//	getType:function(uri,localName){}
	//	getType:function(i){},
	};



	function split(source,start){
		var match;
		var buf = [];
		var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
		reg.lastIndex = start;
		reg.exec(source);//skip <
		while(match = reg.exec(source)){
			buf.push(match);
			if(match[1])return buf;
		}
	}

	sax.XMLReader = XMLReader;
	sax.ParseError = ParseError;
	return sax;
}

var hasRequiredDomParser;

function requireDomParser () {
	if (hasRequiredDomParser) return domParser;
	hasRequiredDomParser = 1;
	var conventions = requireConventions();
	var dom = requireDom();
	var entities = requireEntities();
	var sax = requireSax();

	var DOMImplementation = dom.DOMImplementation;

	var NAMESPACE = conventions.NAMESPACE;

	var ParseError = sax.ParseError;
	var XMLReader = sax.XMLReader;

	/**
	 * Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:
	 *
	 * > XML parsed entities are often stored in computer files which,
	 * > for editing convenience, are organized into lines.
	 * > These lines are typically separated by some combination
	 * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).
	 * >
	 * > To simplify the tasks of applications, the XML processor must behave
	 * > as if it normalized all line breaks in external parsed entities (including the document entity)
	 * > on input, before parsing, by translating all of the following to a single #xA character:
	 * >
	 * > 1. the two-character sequence #xD #xA
	 * > 2. the two-character sequence #xD #x85
	 * > 3. the single character #x85
	 * > 4. the single character #x2028
	 * > 5. any #xD character that is not immediately followed by #xA or #x85.
	 *
	 * @param {string} input
	 * @returns {string}
	 */
	function normalizeLineEndings(input) {
		return input
			.replace(/\r[\n\u0085]/g, '\n')
			.replace(/[\r\u0085\u2028]/g, '\n')
	}

	/**
	 * @typedef Locator
	 * @property {number} [columnNumber]
	 * @property {number} [lineNumber]
	 */

	/**
	 * @typedef DOMParserOptions
	 * @property {DOMHandler} [domBuilder]
	 * @property {Function} [errorHandler]
	 * @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing
	 * 						defaults to `normalizeLineEndings`
	 * @property {Locator} [locator]
	 * @property {Record<string, string>} [xmlns]
	 *
	 * @see normalizeLineEndings
	 */

	/**
	 * The DOMParser interface provides the ability to parse XML or HTML source code
	 * from a string into a DOM `Document`.
	 *
	 * _xmldom is different from the spec in that it allows an `options` parameter,
	 * to override the default behavior._
	 *
	 * @param {DOMParserOptions} [options]
	 * @constructor
	 *
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
	 * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization
	 */
	function DOMParser(options){
		this.options = options ||{locator:{}};
	}

	DOMParser.prototype.parseFromString = function(source,mimeType){
		var options = this.options;
		var sax =  new XMLReader();
		var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
		var errorHandler = options.errorHandler;
		var locator = options.locator;
		var defaultNSMap = options.xmlns||{};
		var isHTML = /\/x?html?$/.test(mimeType);//mimeType.toLowerCase().indexOf('html') > -1;
	  	var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
		if(locator){
			domBuilder.setDocumentLocator(locator);
		}

		sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
		sax.domBuilder = options.domBuilder || domBuilder;
		if(isHTML){
			defaultNSMap[''] = NAMESPACE.HTML;
		}
		defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
		var normalize = options.normalizeLineEndings || normalizeLineEndings;
		if (source && typeof source === 'string') {
			sax.parse(
				normalize(source),
				defaultNSMap,
				entityMap
			);
		} else {
			sax.errorHandler.error('invalid doc source');
		}
		return domBuilder.doc;
	};
	function buildErrorHandler(errorImpl,domBuilder,locator){
		if(!errorImpl){
			if(domBuilder instanceof DOMHandler){
				return domBuilder;
			}
			errorImpl = domBuilder ;
		}
		var errorHandler = {};
		var isCallback = errorImpl instanceof Function;
		locator = locator||{};
		function build(key){
			var fn = errorImpl[key];
			if(!fn && isCallback){
				fn = errorImpl.length == 2?function(msg){errorImpl(key,msg);}:errorImpl;
			}
			errorHandler[key] = fn && function(msg){
				fn('[xmldom '+key+']\t'+msg+_locator(locator));
			}||function(){};
		}
		build('warning');
		build('error');
		build('fatalError');
		return errorHandler;
	}

	//console.log('#\n\n\n\n\n\n\n####')
	/**
	 * +ContentHandler+ErrorHandler
	 * +LexicalHandler+EntityResolver2
	 * -DeclHandler-DTDHandler
	 *
	 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
	 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
	 */
	function DOMHandler() {
	    this.cdata = false;
	}
	function position(locator,node){
		node.lineNumber = locator.lineNumber;
		node.columnNumber = locator.columnNumber;
	}
	/**
	 * @see org.xml.sax.ContentHandler#startDocument
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
	 */
	DOMHandler.prototype = {
		startDocument : function() {
	    	this.doc = new DOMImplementation().createDocument(null, null, null);
	    	if (this.locator) {
	        	this.doc.documentURI = this.locator.systemId;
	    	}
		},
		startElement:function(namespaceURI, localName, qName, attrs) {
			var doc = this.doc;
		    var el = doc.createElementNS(namespaceURI, qName||localName);
		    var len = attrs.length;
		    appendElement(this, el);
		    this.currentElement = el;

			this.locator && position(this.locator,el);
		    for (var i = 0 ; i < len; i++) {
		        var namespaceURI = attrs.getURI(i);
		        var value = attrs.getValue(i);
		        var qName = attrs.getQName(i);
				var attr = doc.createAttributeNS(namespaceURI, qName);
				this.locator &&position(attrs.getLocator(i),attr);
				attr.value = attr.nodeValue = value;
				el.setAttributeNode(attr);
		    }
		},
		endElement:function(namespaceURI, localName, qName) {
			var current = this.currentElement;
			current.tagName;
			this.currentElement = current.parentNode;
		},
		startPrefixMapping:function(prefix, uri) {
		},
		endPrefixMapping:function(prefix) {
		},
		processingInstruction:function(target, data) {
		    var ins = this.doc.createProcessingInstruction(target, data);
		    this.locator && position(this.locator,ins);
		    appendElement(this, ins);
		},
		ignorableWhitespace:function(ch, start, length) {
		},
		characters:function(chars, start, length) {
			chars = _toString.apply(this,arguments);
			//console.log(chars)
			if(chars){
				if (this.cdata) {
					var charNode = this.doc.createCDATASection(chars);
				} else {
					var charNode = this.doc.createTextNode(chars);
				}
				if(this.currentElement){
					this.currentElement.appendChild(charNode);
				}else if(/^\s*$/.test(chars)){
					this.doc.appendChild(charNode);
					//process xml
				}
				this.locator && position(this.locator,charNode);
			}
		},
		skippedEntity:function(name) {
		},
		endDocument:function() {
			this.doc.normalize();
		},
		setDocumentLocator:function (locator) {
		    if(this.locator = locator){// && !('lineNumber' in locator)){
		    	locator.lineNumber = 0;
		    }
		},
		//LexicalHandler
		comment:function(chars, start, length) {
			chars = _toString.apply(this,arguments);
		    var comm = this.doc.createComment(chars);
		    this.locator && position(this.locator,comm);
		    appendElement(this, comm);
		},

		startCDATA:function() {
		    //used in characters() methods
		    this.cdata = true;
		},
		endCDATA:function() {
		    this.cdata = false;
		},

		startDTD:function(name, publicId, systemId) {
			var impl = this.doc.implementation;
		    if (impl && impl.createDocumentType) {
		        var dt = impl.createDocumentType(name, publicId, systemId);
		        this.locator && position(this.locator,dt);
		        appendElement(this, dt);
						this.doc.doctype = dt;
		    }
		},
		/**
		 * @see org.xml.sax.ErrorHandler
		 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
		 */
		warning:function(error) {
			console.warn('[xmldom warning]\t'+error,_locator(this.locator));
		},
		error:function(error) {
			console.error('[xmldom error]\t'+error,_locator(this.locator));
		},
		fatalError:function(error) {
			throw new ParseError(error, this.locator);
		}
	};
	function _locator(l){
		if(l){
			return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
		}
	}
	function _toString(chars,start,length){
		if(typeof chars == 'string'){
			return chars.substr(start,length)
		}else {//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
			if(chars.length >= start+length || start){
				return new java.lang.String(chars,start,length)+'';
			}
			return chars;
		}
	}

	/*
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
	 * used method of org.xml.sax.ext.LexicalHandler:
	 *  #comment(chars, start, length)
	 *  #startCDATA()
	 *  #endCDATA()
	 *  #startDTD(name, publicId, systemId)
	 *
	 *
	 * IGNORED method of org.xml.sax.ext.LexicalHandler:
	 *  #endDTD()
	 *  #startEntity(name)
	 *  #endEntity(name)
	 *
	 *
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
	 * IGNORED method of org.xml.sax.ext.DeclHandler
	 * 	#attributeDecl(eName, aName, type, mode, value)
	 *  #elementDecl(name, model)
	 *  #externalEntityDecl(name, publicId, systemId)
	 *  #internalEntityDecl(name, value)
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
	 * IGNORED method of org.xml.sax.EntityResolver2
	 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
	 *  #resolveEntity(publicId, systemId)
	 *  #getExternalSubset(name, baseURI)
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
	 * IGNORED method of org.xml.sax.DTDHandler
	 *  #notationDecl(name, publicId, systemId) {};
	 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
	 */
	"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
		DOMHandler.prototype[key] = function(){return null};
	});

	/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
	function appendElement (hander,node) {
	    if (!hander.currentElement) {
	        hander.doc.appendChild(node);
	    } else {
	        hander.currentElement.appendChild(node);
	    }
	}//appendChild and setAttributeNS are preformance key

	domParser.__DOMHandler = DOMHandler;
	domParser.normalizeLineEndings = normalizeLineEndings;
	domParser.DOMParser = DOMParser;
	return domParser;
}

var hasRequiredLib;

function requireLib () {
	if (hasRequiredLib) return lib;
	hasRequiredLib = 1;
	var dom = requireDom();
	lib.DOMImplementation = dom.DOMImplementation;
	lib.XMLSerializer = dom.XMLSerializer;
	lib.DOMParser = requireDomParser().DOMParser;
	return lib;
}

var libExports = requireLib();

function parseWorkflow(taskId, xml, done, thinking) {
    let _workflow = null;
    try {
        if (thinking) {
            _workflow = {
                taskId: taskId,
                name: "",
                thought: thinking,
                agents: [],
                xml: xml,
            };
        }
        let sIdx = xml.indexOf("<root>");
        if (sIdx == -1) {
            return _workflow;
        }
        xml = xml.substring(sIdx);
        let eIdx = xml.indexOf("</root>");
        if (eIdx > -1) {
            xml = xml.substring(0, eIdx + 7);
        }
        if (!done) {
            xml = fixXmlTag(xml);
        }
        const parser = new libExports.DOMParser();
        const doc = parser.parseFromString(xml, "text/xml");
        let root = doc.documentElement;
        if (root.tagName !== "root") {
            return _workflow;
        }
        const agents = [];
        const thought = root.getElementsByTagName("thought")[0]?.textContent || "";
        const workflow = {
            taskId: taskId,
            name: root.getElementsByTagName("name")[0]?.textContent || "",
            thought: thinking ? thinking + "\n" + thought : thought,
            agents: agents,
            xml: xml,
        };
        let agentsNode = root.getElementsByTagName("agents");
        let agentsNodes = agentsNode.length > 0 ? agentsNode[0].getElementsByTagName("agent") : [];
        for (let i = 0; i < agentsNodes.length; i++) {
            let agentNode = agentsNodes[i];
            let name = agentNode.getAttribute("name");
            if (!name) {
                break;
            }
            let index = agentNode.getAttribute("id") || i;
            let dependsOn = agentNode.getAttribute("dependsOn") || "";
            let nodes = [];
            let agent = {
                name: name,
                id: getAgentId(taskId, index),
                dependsOn: dependsOn.split(",").filter(idx => idx.trim() != "").map(idx => getAgentId(taskId, idx)),
                task: agentNode.getElementsByTagName("task")[0]?.textContent || "",
                nodes: nodes,
                status: "init",
                parallel: undefined,
                xml: agentNode.toString(),
            };
            let xmlNodes = agentNode.getElementsByTagName("nodes");
            if (xmlNodes.length > 0) {
                parseWorkflowNodes(nodes, xmlNodes[0].childNodes);
            }
            agents.push(agent);
        }
        if (done) {
            let agentTree = buildAgentTree(workflow.agents);
            while (true) {
                if (agentTree.type === "normal") {
                    agentTree.agent.parallel = false;
                }
                else {
                    const parallelAgents = agentTree.agents;
                    for (let i = 0; i < parallelAgents.length; i++) {
                        const agentNode = parallelAgents[i];
                        agentNode.agent.parallel = true;
                    }
                }
                if (!agentTree.nextAgent) {
                    break;
                }
                agentTree = agentTree.nextAgent;
            }
        }
        return workflow;
    }
    catch (e) {
        if (done) {
            throw e;
        }
        else {
            return _workflow;
        }
    }
}
function getAgentId(taskId, index) {
    return taskId + "-" + (+index < 10 ? "0" + index : index);
}
function parseWorkflowNodes(nodes, xmlNodes) {
    for (let i = 0; i < xmlNodes.length; i++) {
        if (xmlNodes[i].nodeType !== 1) {
            continue;
        }
        let xmlNode = xmlNodes[i];
        switch (xmlNode.tagName) {
            case "node": {
                let node = {
                    type: "normal",
                    text: xmlNode.textContent || "",
                    input: xmlNode.getAttribute("input"),
                    output: xmlNode.getAttribute("output"),
                };
                nodes.push(node);
                break;
            }
            case "forEach": {
                let _nodes = [];
                let node = {
                    type: "forEach",
                    items: (xmlNode.getAttribute("items") || "list"),
                    nodes: _nodes,
                };
                let _xmlNodes = xmlNode.getElementsByTagName("node");
                if (_xmlNodes.length > 0) {
                    parseWorkflowNodes(_nodes, _xmlNodes);
                }
                nodes.push(node);
                break;
            }
            case "watch": {
                let _nodes = [];
                let node = {
                    type: "watch",
                    event: (xmlNode.getAttribute("event") || ""),
                    loop: xmlNode.getAttribute("loop") == "true",
                    description: xmlNode.getElementsByTagName("description")[0]?.textContent || "",
                    triggerNodes: _nodes,
                };
                let triggerNode = xmlNode.getElementsByTagName("trigger");
                if (triggerNode.length > 0) {
                    parseWorkflowNodes(_nodes, triggerNode[0].childNodes);
                }
                nodes.push(node);
                break;
            }
        }
    }
}
function buildAgentRootXml(agentXml, mainTaskPrompt, nodeCallback) {
    const parser = new libExports.DOMParser();
    const doc = parser.parseFromString(agentXml, "text/xml");
    let agentNode = doc.getElementsByTagName("agent");
    let nodesNode = doc.getElementsByTagName("nodes");
    if (nodesNode.length > 0) {
        let nodes = nodesNode[0].childNodes;
        let nodeId = 0;
        for (let i = 0; i < nodes.length; i++) {
            let node = nodes[i];
            if (node.nodeType == 1) {
                node.setAttribute("id", nodeId + "");
                nodeCallback && nodeCallback(nodeId, node);
                nodeId++;
            }
        }
    }
    // <root><mainTask></mainTask><currentTask></currentTask><nodes><node id="0"></node></nodes></root>
    let agentInnerHTML = getInnerXML(agentNode[0]);
    let prefix = agentInnerHTML.substring(0, agentInnerHTML.indexOf("<task>"));
    agentInnerHTML = agentInnerHTML
        .replace("<task>", "<currentTask>")
        .replace("</task>", "</currentTask>");
    const xmlPrompt = `<root>${prefix}<mainTask>${mainTaskPrompt}</mainTask>${agentInnerHTML}</root>`;
    return xmlPrompt.replace(/      /g, "  ").replace("    </root>", "</root>");
}
function extractAgentXmlNode(agentXml, nodeId) {
    const parser = new libExports.DOMParser();
    const doc = parser.parseFromString(agentXml, "text/xml");
    let nodesNode = doc.getElementsByTagName("nodes");
    if (nodesNode.length > 0) {
        let nodes = nodesNode[0].childNodes;
        let _nodeId = 0;
        for (let i = 0; i < nodes.length; i++) {
            let node = nodes[i];
            if (node.nodeType == 1) {
                if (node.getAttribute("id") == null || node.getAttribute("id") == "") {
                    node.setAttribute("id", _nodeId + "");
                }
                _nodeId++;
                if (node.getAttribute("id") == nodeId + "") {
                    return node;
                }
            }
        }
    }
    return null;
}
function getInnerXML(node) {
    let result = "";
    const serializer = new libExports.XMLSerializer();
    for (let i = 0; i < node.childNodes.length; i++) {
        result += serializer.serializeToString(node.childNodes[i]);
    }
    return result;
}
function buildSimpleAgentWorkflow({ taskId, name, agentName, task, taskNodes, }) {
    if (!taskNodes || taskNodes.length == 0) {
        taskNodes = [task];
    }
    const workflow = {
        taskId: taskId,
        name: name,
        thought: "",
        agents: [
            {
                id: taskId + "-00",
                dependsOn: [],
                name: agentName,
                task: task,
                nodes: taskNodes.map((node) => {
                    return {
                        type: "normal",
                        text: node,
                    };
                }),
                status: "init",
                parallel: false,
                xml: "",
            },
        ],
        xml: "",
    };
    workflow.taskPrompt = task;
    resetWorkflowXml(workflow);
    return workflow;
}
function resetWorkflowXml(workflow) {
    const agents = [];
    for (let i = 0; i < workflow.agents.length; i++) {
        const agent = workflow.agents[i];
        const agentDependsAttr = ` id="${i}" dependsOn="${(agent.dependsOn || []).filter(s => parseInt(s.split("-")[s.split("-").length - 1])).join(",")}"`;
        const nodes = agent.nodes
            .map((node) => {
            if (node.type == "forEach") {
                const forEachNodes = [];
                for (let j = 0; j < node.nodes.length; j++) {
                    const _node = node.nodes[j];
                    const input = _node.input ? ` input="${_node.input}"` : "";
                    const output = _node.output ? ` output="${_node.output}"` : "";
                    forEachNodes.push(`          <node${input}${output}>${_node.text}</node>`);
                }
                return `        <forEach items="${node.items || ""}">
${forEachNodes.join("\n")}
        </forEach>`;
            }
            else if (node.type == "watch") {
                const watchNodes = [];
                for (let j = 0; j < node.triggerNodes.length; j++) {
                    const _node = node.triggerNodes[j];
                    const input = _node.input ? ` input="${_node.input}"` : "";
                    const output = _node.output ? ` output="${_node.output}"` : "";
                    watchNodes.push(`            <node${input}${output}>${_node.text}</node>`);
                }
                return `        <watch event="${node.event || "dom"}" loop="${node.loop ? "true" : "false"}">
          <description>${node.description}</description>
          <trigger>
${watchNodes.join("\n")}
          </trigger>
        </watch>`;
            }
            else {
                const input = node.input ? ` input="${node.input}"` : "";
                const output = node.output ? ` output="${node.output}"` : "";
                return `        <node${input}${output}>${node.text}</node>`;
            }
        })
            .join("\n");
        const agentXml = `    <agent name="${agent.name}"${agentDependsAttr}>
      <task>${agent.task}</task>
      <nodes>
${nodes}
      </nodes>
    </agent>`;
        agent.xml = agentXml;
        agents.push(agentXml);
    }
    const xml = `<root>
  <name>${workflow.name}</name>
  <thought>${workflow.thought}</thought>
  <agents>
${agents.join("\n")}
  </agents>
</root>`;
    workflow.xml = xml;
}

const TOOL_NAME$b = "task_snapshot";
class TaskSnapshotTool {
    constructor() {
        this.name = TOOL_NAME$b;
        this.description = `Task snapshot archive, recording key information of the current task, updating task node status, facilitating subsequent continuation of operation.`;
        this.parameters = {
            type: "object",
            properties: {
                doneIds: {
                    type: "array",
                    description: "Update task node completion status, list of completed node IDs.",
                    items: {
                        type: "number",
                    },
                },
                taskSnapshot: {
                    type: "string",
                    description: "Current task important information, as detailed as possible, ensure that the task progress can be restored through this information later, output records of completed task information, contextual information, variables used, pending tasks information, etc.",
                },
            },
            required: ["doneIds", "taskSnapshot"],
        };
    }
    async execute(args, agentContext) {
        let doneIds = args.doneIds;
        let taskSnapshot = args.taskSnapshot;
        let agentNode = agentContext.agentChain.agent;
        let taskPrompt = agentContext.context.chain.taskPrompt;
        let agentXml = buildAgentRootXml(agentNode.xml, taskPrompt, (nodeId, node) => {
            let done = doneIds.indexOf(nodeId) > -1;
            node.setAttribute("status", done ? "done" : "todo");
        });
        let text = "The current task has been interrupted. Below is a snapshot of the task execution history.\n" +
            "# Task Snapshot\n" +
            taskSnapshot.trim() +
            "\n\n# Task\n" +
            agentXml;
        return {
            content: [
                {
                    type: "text",
                    text: text,
                },
            ],
        };
    }
}

function extractUsedTool(messages, agentTools) {
    let tools = [];
    let toolNames = [];
    for (let i = 0; i < messages.length; i++) {
        let message = messages[i];
        if (message.role == "tool") {
            for (let j = 0; j < message.content.length; j++) {
                let toolName = message.content[j].toolName;
                if (toolNames.indexOf(toolName) > -1) {
                    continue;
                }
                toolNames.push(toolName);
                let tool = agentTools.filter((tool) => tool.name === toolName)[0];
                if (tool) {
                    tools.push(tool);
                }
            }
        }
    }
    return tools;
}
async function compressAgentMessages(agentContext, messages, tools) {
    if (messages.length < 5) {
        return;
    }
    try {
        await doCompressAgentMessages(agentContext, messages, tools);
    }
    catch (e) {
        Log.error("Error compressing agent messages:", e);
    }
}
async function doCompressAgentMessages(agentContext, messages, tools) {
    const ekoConfig = agentContext.context.config;
    const rlm = new RetryLanguageModel(ekoConfig.llms, ekoConfig.compressLlms);
    rlm.setContext(agentContext);
    // extract used tool
    const usedTools = extractUsedTool(messages, tools);
    const snapshotTool = new TaskSnapshotTool();
    const newTools = mergeTools(usedTools, [
        {
            type: "function",
            name: snapshotTool.name,
            description: snapshotTool.description,
            inputSchema: snapshotTool.parameters,
        },
    ]);
    // handle messages
    let lastToolIndex = messages.length - 1;
    let newMessages = messages;
    for (let r = newMessages.length - 1; r > 3; r--) {
        if (newMessages[r].role == "tool") {
            newMessages = newMessages.slice(0, r + 1);
            lastToolIndex = r;
            break;
        }
    }
    compressLargeContextMessages(newMessages);
    newMessages.push({
        role: "user",
        content: [
            {
                type: "text",
                text: "Please create a snapshot backup of the current task, keeping only key important information and node completion status.",
            },
        ],
    });
    // compress snapshot
    const result = await callAgentLLM(agentContext, rlm, newMessages, newTools, true, {
        type: "tool",
        toolName: snapshotTool.name,
    });
    const toolCall = result.filter((s) => s.type == "tool-call")[0];
    const args = typeof toolCall.input == "string"
        ? JSON.parse(toolCall.input || "{}")
        : toolCall.input || {};
    const toolResult = await snapshotTool.execute(args, agentContext);
    const callback = agentContext.context.config.callback;
    if (callback) {
        await callback.onMessage({
            streamType: "agent",
            chatId: agentContext.context.chatId,
            taskId: agentContext.context.taskId,
            agentName: agentContext.agent.Name,
            nodeId: agentContext.agentChain.agent.id,
            type: "tool_result",
            toolCallId: toolCall.toolCallId,
            toolName: toolCall.toolName,
            params: args,
            toolResult: toolResult,
        }, agentContext);
    }
    // handle original messages
    let firstToolIndex = 3;
    for (let i = 0; i < messages.length; i++) {
        if (messages[0].role == "tool") {
            firstToolIndex = i;
            break;
        }
    }
    // system, user, assistant, tool(first), [...], <user>, assistant, tool(last), ...
    messages.splice(firstToolIndex + 1, lastToolIndex - firstToolIndex - 2, {
        role: "user",
        content: toolResult.content.filter((s) => s.type == "text"),
    });
}
function compressLargeContextMessages(messages) {
    for (let r = 2; r < messages.length; r++) {
        const message = messages[r];
        if (message.role == "assistant") {
            message.content = message.content.map((c) => {
                if (c.type == "text" && c.text.length > config$1.largeTextLength) {
                    return {
                        ...c,
                        text: sub(c.text, config$1.largeTextLength, true),
                    };
                }
                return c;
            });
        }
        else if (message.role == "user") {
            message.content = message.content.map((c) => {
                if (c.type == "text" && c.text.length > config$1.largeTextLength) {
                    return {
                        ...c,
                        text: sub(c.text, config$1.largeTextLength, true),
                    };
                }
                return c;
            });
        }
        else if (message.role == "tool") {
            message.content = message.content.map((c) => {
                if (c.type == "tool-result" && c.output) {
                    const output = c.output;
                    if ((output.type == "text" || output.type == "error-text") &&
                        output.value.length > config$1.largeTextLength) {
                        return {
                            ...c,
                            output: {
                                ...output,
                                value: sub(output.value, config$1.largeTextLength, true),
                            },
                        };
                    }
                    else if ((output.type == "json" || output.type == "error-json") &&
                        JSON.stringify(output.value).length > config$1.largeTextLength) {
                        const json_str = sub(JSON.stringify(output.value), config$1.largeTextLength, false);
                        const json_obj = fixJson(json_str);
                        if (JSON.stringify(json_obj).length < 10) {
                            return {
                                ...c,
                                output: {
                                    ...output,
                                    value: json_str,
                                    type: output.type == "error-json" ? "error-text" : "text",
                                },
                            };
                        }
                        else {
                            return {
                                ...c,
                                output: {
                                    ...output,
                                    value: json_obj,
                                },
                            };
                        }
                    }
                    else if (output.type == "content") {
                        for (let i = 0; i < output.value.length; i++) {
                            const content = output.value[i];
                            if (content.type == "text" &&
                                content.text.length > config$1.largeTextLength) {
                                content.text = sub(content.text, config$1.largeTextLength, true);
                            }
                        }
                    }
                }
                return c;
            });
        }
    }
}
function handleLargeContextMessages(messages) {
    let imageNum = 0;
    let fileNum = 0;
    let maxNum = config$1.maxDialogueImgFileNum;
    let longTextTools = {};
    for (let i = messages.length - 1; i >= 0; i--) {
        let message = messages[i];
        if (message.role == "user") {
            for (let j = 0; j < message.content.length; j++) {
                let content = message.content[j];
                if (content.type == "file" && content.mediaType.startsWith("image/")) {
                    if (++imageNum <= maxNum) {
                        break;
                    }
                    content = {
                        type: "text",
                        text: "[image]",
                    };
                    message.content[j] = content;
                }
                else if (content.type == "file") {
                    if (++fileNum <= maxNum) {
                        break;
                    }
                    content = {
                        type: "text",
                        text: "[file]",
                    };
                    message.content[j] = content;
                }
            }
        }
        else if (message.role == "tool") {
            for (let j = 0; j < message.content.length; j++) {
                let toolResult = message.content[j];
                let toolContent = toolResult.output;
                if (!toolContent || toolContent.type != "content") {
                    continue;
                }
                for (let r = 0; r < toolContent.value.length; r++) {
                    let _content = toolContent.value[r];
                    if (_content.type == "media" &&
                        _content.mediaType.startsWith("image/")) {
                        if (++imageNum <= maxNum) {
                            break;
                        }
                        _content = {
                            type: "text",
                            text: "[image]",
                        };
                        toolContent.value[r] = _content;
                    }
                }
                for (let r = 0; r < toolContent.value.length; r++) {
                    let _content = toolContent.value[r];
                    if (_content.type == "text" &&
                        _content.text?.length > config$1.largeTextLength) {
                        if (!longTextTools[toolResult.toolName]) {
                            longTextTools[toolResult.toolName] = 1;
                            break;
                        }
                        else {
                            longTextTools[toolResult.toolName]++;
                        }
                        _content = {
                            type: "text",
                            text: sub(_content.text, config$1.largeTextLength, true),
                        };
                        toolContent.value[r] = _content;
                    }
                }
            }
        }
    }
}

function defaultLLMProviderOptions() {
    return {
        openai: {
            stream_options: {
                include_usage: true,
            },
        },
        openrouter: {
            reasoning: {
                max_tokens: 10,
            },
        },
    };
}
function defaultMessageProviderOptions() {
    return {
        anthropic: {
            cacheControl: { type: "ephemeral" },
        },
        bedrock: {
            cachePoint: { type: "default" },
        },
        openrouter: {
            cacheControl: { type: "ephemeral" },
        },
    };
}
function convertTools(tools) {
    return tools.map((tool) => ({
        type: "function",
        name: tool.name,
        description: tool.description,
        inputSchema: tool.parameters,
        // providerOptions: defaultMessageProviderOptions()
    }));
}
function getTool(tools, name) {
    for (let i = 0; i < tools.length; i++) {
        if (tools[i].name == name) {
            return tools[i];
        }
    }
    return null;
}
function convertToolResult(toolUse, toolResult, user_messages) {
    let result;
    if (!toolResult || !toolResult.content) {
        result = {
            type: "error-text",
            value: "Error",
        };
    }
    else if (toolResult.content.length == 1 &&
        toolResult.content[0].type == "text") {
        let text = toolResult.content[0].text;
        result = {
            type: "text",
            value: text,
        };
        let isError = toolResult.isError == true;
        if (isError && !text.startsWith("Error")) {
            text = "Error: " + text;
            result = {
                type: "error-text",
                value: text,
            };
        }
        else if (!isError && text.length == 0) {
            text = "Successful";
            result = {
                type: "text",
                value: text,
            };
        }
        if (text &&
            ((text.startsWith("{") && text.endsWith("}")) ||
                (text.startsWith("[") && text.endsWith("]")))) {
            try {
                result = JSON.parse(text);
                result = {
                    type: "json",
                    value: result,
                };
            }
            catch (e) { }
        }
    }
    else {
        result = {
            type: "content",
            value: [],
        };
        for (let i = 0; i < toolResult.content.length; i++) {
            let content = toolResult.content[i];
            if (content.type == "text") {
                result.value.push({
                    type: "text",
                    text: content.text,
                });
            }
            else {
                if (config$1.toolResultMultimodal) {
                    // Support returning images from tool results
                    let mediaData = content.data;
                    if (mediaData.startsWith("data:")) {
                        mediaData = mediaData.substring(mediaData.indexOf(",") + 1);
                    }
                    result.value.push({
                        type: "media",
                        data: mediaData,
                        mediaType: content.mimeType || "image/png",
                    });
                }
                else {
                    // Only the claude model supports returning images from tool results, while openai only supports text,
                    // Compatible with other AI models that do not support tool results as images.
                    if (user_messages) {
                        user_messages.push({
                            role: "user",
                            content: [
                                {
                                    type: "file",
                                    data: toFile(content.data),
                                    mediaType: content.mimeType || getMimeType(content.data),
                                },
                                {
                                    type: "text",
                                    text: `call \`${toolUse.toolName}\` tool result`,
                                },
                            ],
                        });
                    }
                    else {
                        result.value.push({
                            type: "text",
                            text: "[image]",
                        });
                    }
                }
            }
        }
    }
    return {
        type: "tool-result",
        toolCallId: toolUse.toolCallId,
        toolName: toolUse.toolName,
        output: result,
    };
}
async function callAgentLLM(agentContext, rlm, messages, tools, noCompress, toolChoice, retryNum = 0, callback, requestHandler) {
    await agentContext.context.checkAborted();
    if (!noCompress &&
        (messages.length >= config$1.compressThreshold ||
            (messages.length >= 10 &&
                estimatePromptTokens(messages, tools) >=
                    config$1.compressTokensThreshold))) {
        // Compress messages
        await compressAgentMessages(agentContext, messages, tools);
    }
    if (!toolChoice) {
        // Append user dialogue
        appendUserConversation(agentContext, messages);
    }
    const context = agentContext.context;
    const agentChain = agentContext.agentChain;
    const agentNode = agentChain.agent;
    const streamCallback = callback ||
        context.config.callback || {
        onMessage: async () => { },
    };
    const stepController = new AbortController();
    const signal = AbortSignal.any([
        context.controller.signal,
        stepController.signal,
    ]);
    const request = {
        tools: tools,
        toolChoice,
        messages: messages,
        abortSignal: signal,
    };
    requestHandler && requestHandler(request);
    let streamText = "";
    let thinkText = "";
    let toolArgsText = "";
    let textStreamId = uuidv4();
    let thinkStreamId = uuidv4();
    let textStreamDone = false;
    const toolParts = [];
    let reader = null;
    try {
        agentChain.agentRequest = request;
        context.currentStepControllers.add(stepController);
        const result = await rlm.callStream(request);
        reader = result.stream.getReader();
        let toolPart = null;
        while (true) {
            await context.checkAborted();
            const { done, value } = await reader.read();
            if (done) {
                break;
            }
            const chunk = value;
            switch (chunk.type) {
                case "text-start": {
                    textStreamId = uuidv4();
                    break;
                }
                case "text-delta": {
                    if (toolPart && !chunk.delta) {
                        continue;
                    }
                    streamText += chunk.delta || "";
                    await streamCallback.onMessage({
                        streamType: "agent",
                        chatId: context.chatId,
                        taskId: context.taskId,
                        agentName: agentNode.name,
                        nodeId: agentNode.id,
                        type: "text",
                        streamId: textStreamId,
                        streamDone: false,
                        text: streamText,
                    }, agentContext);
                    if (toolPart) {
                        await streamCallback.onMessage({
                            streamType: "agent",
                            chatId: context.chatId,
                            taskId: context.taskId,
                            agentName: agentNode.name,
                            nodeId: agentNode.id,
                            type: "tool_use",
                            toolCallId: toolPart.toolCallId,
                            toolName: toolPart.toolName,
                            params: toolPart.input || {},
                        }, agentContext);
                        toolPart = null;
                    }
                    break;
                }
                case "text-end": {
                    textStreamDone = true;
                    if (streamText) {
                        await streamCallback.onMessage({
                            streamType: "agent",
                            chatId: context.chatId,
                            taskId: context.taskId,
                            agentName: agentNode.name,
                            nodeId: agentNode.id,
                            type: "text",
                            streamId: textStreamId,
                            streamDone: true,
                            text: streamText,
                        }, agentContext);
                    }
                    break;
                }
                case "reasoning-start": {
                    thinkStreamId = uuidv4();
                    break;
                }
                case "reasoning-delta": {
                    thinkText += chunk.delta || "";
                    await streamCallback.onMessage({
                        streamType: "agent",
                        chatId: context.chatId,
                        taskId: context.taskId,
                        agentName: agentNode.name,
                        nodeId: agentNode.id,
                        type: "thinking",
                        streamId: thinkStreamId,
                        streamDone: false,
                        text: thinkText,
                    }, agentContext);
                    break;
                }
                case "reasoning-end": {
                    if (thinkText) {
                        await streamCallback.onMessage({
                            streamType: "agent",
                            chatId: context.chatId,
                            taskId: context.taskId,
                            agentName: agentNode.name,
                            nodeId: agentNode.id,
                            type: "thinking",
                            streamId: thinkStreamId,
                            streamDone: true,
                            text: thinkText,
                        }, agentContext);
                    }
                    break;
                }
                case "tool-input-start": {
                    if (toolPart && toolPart.toolCallId == chunk.id) {
                        toolPart.toolName = chunk.toolName;
                    }
                    else {
                        toolPart = {
                            type: "tool-call",
                            toolCallId: chunk.id,
                            toolName: chunk.toolName,
                            input: {},
                        };
                        toolParts.push(toolPart);
                    }
                    break;
                }
                case "tool-input-delta": {
                    if (!textStreamDone) {
                        textStreamDone = true;
                        await streamCallback.onMessage({
                            streamType: "agent",
                            chatId: context.chatId,
                            taskId: context.taskId,
                            agentName: agentNode.name,
                            nodeId: agentNode.id,
                            type: "text",
                            streamId: textStreamId,
                            streamDone: true,
                            text: streamText,
                        }, agentContext);
                    }
                    toolArgsText += chunk.delta || "";
                    await streamCallback.onMessage({
                        streamType: "agent",
                        chatId: context.chatId,
                        taskId: context.taskId,
                        agentName: agentNode.name,
                        nodeId: agentNode.id,
                        type: "tool_streaming",
                        toolCallId: chunk.id,
                        toolName: toolPart?.toolName || "",
                        paramsText: toolArgsText,
                    }, agentContext);
                    break;
                }
                case "tool-call": {
                    toolArgsText = "";
                    const args = chunk.input ? JSON.parse(chunk.input) : {};
                    const message = {
                        streamType: "agent",
                        chatId: context.chatId,
                        taskId: context.taskId,
                        agentName: agentNode.name,
                        nodeId: agentNode.id,
                        type: "tool_use",
                        toolCallId: chunk.toolCallId,
                        toolName: chunk.toolName,
                        params: args,
                    };
                    await streamCallback.onMessage(message, agentContext);
                    if (toolPart == null) {
                        toolParts.push({
                            type: "tool-call",
                            toolCallId: chunk.toolCallId,
                            toolName: chunk.toolName,
                            input: message.params || args,
                        });
                    }
                    else {
                        toolPart.input = message.params || args;
                        toolPart = null;
                    }
                    break;
                }
                case "file": {
                    await streamCallback.onMessage({
                        streamType: "agent",
                        chatId: context.chatId,
                        taskId: context.taskId,
                        agentName: agentNode.name,
                        nodeId: agentNode.id,
                        type: "file",
                        mimeType: chunk.mediaType,
                        data: chunk.data,
                    }, agentContext);
                    break;
                }
                case "error": {
                    Log.error(`${agentNode.name} agent error: `, chunk);
                    await streamCallback.onMessage({
                        streamType: "agent",
                        chatId: context.chatId,
                        taskId: context.taskId,
                        agentName: agentNode.name,
                        nodeId: agentNode.id,
                        type: "error",
                        error: chunk.error,
                    }, agentContext);
                    throw new Error("LLM Error: " + chunk.error);
                }
                case "finish": {
                    if (!textStreamDone) {
                        textStreamDone = true;
                        await streamCallback.onMessage({
                            streamType: "agent",
                            chatId: context.chatId,
                            taskId: context.taskId,
                            agentName: agentNode.name,
                            nodeId: agentNode.id,
                            type: "text",
                            streamId: textStreamId,
                            streamDone: true,
                            text: streamText,
                        }, agentContext);
                    }
                    if (chunk.finishReason === "content-filter") {
                        throw new Error("LLM error: trigger content filtering violation");
                    }
                    else if (chunk.finishReason === "other") {
                        throw new Error("LLM error: terminated due to other reasons");
                    }
                    else if (chunk.finishReason === "length" &&
                        messages.length >= 3 &&
                        !noCompress &&
                        retryNum < config$1.maxRetryNum) {
                        await compressAgentMessages(agentContext, messages, tools);
                        return callAgentLLM(agentContext, rlm, messages, tools, noCompress, toolChoice, ++retryNum, streamCallback);
                    }
                    if (toolPart) {
                        await streamCallback.onMessage({
                            streamType: "agent",
                            chatId: context.chatId,
                            taskId: context.taskId,
                            agentName: agentNode.name,
                            nodeId: agentNode.id,
                            type: "tool_use",
                            toolCallId: toolPart.toolCallId,
                            toolName: toolPart.toolName,
                            params: toolPart.input || {},
                        }, agentContext);
                        toolPart = null;
                    }
                    await streamCallback.onMessage({
                        streamType: "agent",
                        chatId: context.chatId,
                        taskId: context.taskId,
                        agentName: agentNode.name,
                        nodeId: agentNode.id,
                        type: "finish",
                        finishReason: chunk.finishReason,
                        usage: {
                            promptTokens: chunk.usage.inputTokens || 0,
                            completionTokens: chunk.usage.outputTokens || 0,
                            totalTokens: chunk.usage.totalTokens ||
                                (chunk.usage.inputTokens || 0) +
                                    (chunk.usage.outputTokens || 0),
                        },
                    }, agentContext);
                    break;
                }
            }
        }
    }
    catch (e) {
        await context.checkAborted();
        if (retryNum < config$1.maxRetryNum) {
            await sleep(300 * (retryNum + 1) * (retryNum + 1));
            if ((e + "").indexOf("is too long") > -1) {
                await compressAgentMessages(agentContext, messages, tools);
            }
            return callAgentLLM(agentContext, rlm, messages, tools, noCompress, toolChoice, ++retryNum, streamCallback);
        }
        throw e;
    }
    finally {
        reader && reader.releaseLock();
        context.currentStepControllers.delete(stepController);
    }
    agentChain.agentResult = streamText;
    return streamText
        ? [
            { type: "text", text: streamText },
            ...toolParts,
        ]
        : toolParts;
}
function estimatePromptTokens(messages, tools) {
    let tokens = messages.reduce((total, message) => {
        if (message.role == "system") {
            return total + estimateTokens(message.content);
        }
        else if (message.role == "user") {
            return (total +
                estimateTokens(message.content
                    .filter((part) => part.type == "text")
                    .map((part) => part.text)
                    .join("\n")));
        }
        else if (message.role == "assistant") {
            return (total +
                estimateTokens(message.content
                    .map((part) => {
                    if (part.type == "text") {
                        return part.text;
                    }
                    else if (part.type == "reasoning") {
                        return part.text;
                    }
                    else if (part.type == "tool-call") {
                        return part.toolName + JSON.stringify(part.input || {});
                    }
                    else if (part.type == "tool-result") {
                        return part.toolName + JSON.stringify(part.output || {});
                    }
                    return "";
                })
                    .join("")));
        }
        else if (message.role == "tool") {
            return (total +
                estimateTokens(message.content
                    .map((part) => part.toolName + JSON.stringify(part.output || {}))
                    .join("")));
        }
        return total;
    }, 0);
    if (tools) {
        tokens += tools.reduce((total, tool) => {
            return total + estimateTokens(JSON.stringify(tool));
        }, 0);
    }
    return tokens;
}
function estimateTokens(text) {
    if (!text) {
        return 0;
    }
    let tokenCount = 0;
    for (let i = 0; i < text.length; i++) {
        const char = text[i];
        const code = char.charCodeAt(0);
        if ((code >= 0x4e00 && code <= 0x9fff) ||
            (code >= 0x3400 && code <= 0x4dbf) ||
            (code >= 0x3040 && code <= 0x309f) ||
            (code >= 0x30a0 && code <= 0x30ff) ||
            (code >= 0xac00 && code <= 0xd7af)) {
            tokenCount += 2;
        }
        else if (/\s/.test(char)) {
            continue;
        }
        else if (/[a-zA-Z]/.test(char)) {
            let word = "";
            while (i < text.length && /[a-zA-Z]/.test(text[i])) {
                word += text[i];
                i++;
            }
            i--;
            if (word.length <= 4) {
                tokenCount += 1;
            }
            else {
                tokenCount += Math.ceil(word.length / 4);
            }
        }
        else if (/\d/.test(char)) {
            let number = "";
            while (i < text.length && /\d/.test(text[i])) {
                number += text[i];
                i++;
            }
            i--;
            tokenCount += Math.max(1, Math.ceil(number.length / 3));
        }
        else {
            tokenCount += 1;
        }
    }
    return Math.max(1, tokenCount);
}
function appendUserConversation(agentContext, messages) {
    const userPrompts = agentContext.context.conversation
        .splice(0, agentContext.context.conversation.length)
        .filter((s) => !!s);
    if (userPrompts.length > 0) {
        const prompt = "The user is intervening in the current task, please replan and execute according to the following instructions:\n" +
            userPrompts.map((s) => `- ${s.trim()}`).join("\n");
        messages.push({
            role: "user",
            content: [{ type: "text", text: prompt }],
        });
    }
}

class TaskContext {
    constructor(chatId, taskId, config, agents, chain) {
        this.conversation = [];
        this.pauseStatus = 0;
        this.currentStepControllers = new Set();
        this.chatId = chatId;
        this.taskId = taskId;
        this.config = config;
        this.agents = agents;
        this.chain = chain;
        this.variables = new Map();
        this.controller = new AbortController();
    }
    async checkAborted(noCheckPause) {
        if (this.controller.signal.aborted) {
            const error = new Error("Operation was interrupted");
            error.name = "AbortError";
            throw error;
        }
        while (this.pauseStatus > 0 && !noCheckPause) {
            await sleep(500);
            if (this.pauseStatus == 2) {
                this.currentStepControllers.forEach((c) => {
                    c.abort("Pause");
                });
                this.currentStepControllers.clear();
            }
            if (this.controller.signal.aborted) {
                const error = new Error("Operation was interrupted");
                error.name = "AbortError";
                throw error;
            }
        }
    }
    currentAgent() {
        const agentNode = this.chain.agents[this.chain.agents.length - 1];
        if (!agentNode) {
            return null;
        }
        const agent = this.agents.filter((agent) => agent.Name == agentNode.agent.name)[0];
        if (!agent) {
            return null;
        }
        const agentContext = agent.AgentContext;
        return [agent, agentNode.agent, agentContext];
    }
    get pause() {
        return this.pauseStatus > 0;
    }
    setPause(pause, abortCurrentStep) {
        this.pauseStatus = pause ? (abortCurrentStep ? 2 : 1) : 0;
        if (this.pauseStatus == 2) {
            this.currentStepControllers.forEach((c) => {
                c.abort("Pause");
            });
            this.currentStepControllers.clear();
        }
    }
    reset() {
        this.pauseStatus = 0;
        if (!this.controller.signal.aborted) {
            this.controller.abort();
        }
        this.currentStepControllers.forEach((c) => {
            c.abort("reset");
        });
        this.currentStepControllers.clear();
        this.controller = new AbortController();
    }
}
class AgentContext {
    constructor(context, agent, agentChain) {
        this.context = context;
        this.agent = agent;
        this.agentChain = agentChain;
        this.variables = new Map();
        this.consecutiveErrorNum = 0;
    }
}

class RetryLanguageModel {
    constructor(llms, names, stream_first_timeout, stream_token_timeout, context) {
        this.llms = llms;
        this.names = names || [];
        context && this.setContext(context);
        this.stream_first_timeout = stream_first_timeout || 30000;
        this.stream_token_timeout = stream_token_timeout || 180000;
        if (this.names.indexOf("default") == -1) {
            this.names.push("default");
        }
    }
    setContext(context) {
        if (!context) {
            this.context = undefined;
            this.agentContext = undefined;
            return;
        }
        this.context = context instanceof TaskContext ? context : context.context;
        this.agentContext = context instanceof AgentContext ? context : undefined;
    }
    async call(request) {
        return await this.doGenerate({
            prompt: request.messages,
            tools: request.tools,
            toolChoice: request.toolChoice,
            maxOutputTokens: request.maxOutputTokens,
            temperature: request.temperature,
            topP: request.topP,
            topK: request.topK,
            stopSequences: request.stopSequences,
            abortSignal: request.abortSignal,
        });
    }
    async doGenerate(options) {
        const maxOutputTokens = options.maxOutputTokens;
        const providerOptions = options.providerOptions;
        const names = [...this.names, ...this.names];
        let lastError;
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            const llmConfig = this.llms[name];
            const llm = await this.getLLM(name);
            if (!llm) {
                continue;
            }
            if (!maxOutputTokens) {
                options.maxOutputTokens =
                    llmConfig.config?.maxOutputTokens || config$1.maxOutputTokens;
            }
            if (!providerOptions) {
                options.providerOptions = defaultLLMProviderOptions();
                options.providerOptions[llm.provider] = llmConfig.options || {};
            }
            let _options = options;
            if (llmConfig.handler) {
                _options = await llmConfig.handler(_options, this.context, this.agentContext);
            }
            try {
                let result = (await llm.doGenerate(_options));
                if (Log.isEnableDebug()) {
                    Log.debug(`LLM nonstream body, name: ${name} => `, result.request?.body);
                }
                result.llm = name;
                result.llmConfig = llmConfig;
                result.text = result.content.find((c) => c.type === "text")?.text;
                return result;
            }
            catch (e) {
                if (e?.name === "AbortError") {
                    throw e;
                }
                lastError = e;
                if (Log.isEnableInfo()) {
                    Log.info(`LLM nonstream request, name: ${name} => `, {
                        tools: _options.tools,
                        messages: _options.prompt,
                    });
                }
                Log.error(`LLM error, name: ${name} => `, e);
            }
        }
        return Promise.reject(lastError ? lastError : new Error("No LLM available"));
    }
    async callStream(request) {
        return await this.doStream({
            prompt: request.messages,
            tools: request.tools,
            toolChoice: request.toolChoice,
            maxOutputTokens: request.maxOutputTokens,
            temperature: request.temperature,
            topP: request.topP,
            topK: request.topK,
            stopSequences: request.stopSequences,
            abortSignal: request.abortSignal,
        });
    }
    async doStream(options) {
        const maxOutputTokens = options.maxOutputTokens;
        const providerOptions = options.providerOptions;
        const names = [...this.names, ...this.names];
        let lastError;
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            const llmConfig = this.llms[name];
            const llm = await this.getLLM(name);
            if (!llm) {
                continue;
            }
            if (!maxOutputTokens) {
                options.maxOutputTokens =
                    llmConfig.config?.maxOutputTokens || config$1.maxOutputTokens;
            }
            if (!providerOptions) {
                options.providerOptions = defaultLLMProviderOptions();
                options.providerOptions[llm.provider] = llmConfig.options || {};
            }
            let _options = options;
            if (llmConfig.handler) {
                _options = await llmConfig.handler(_options, this.context, this.agentContext);
            }
            try {
                const controller = new AbortController();
                const signal = _options.abortSignal
                    ? AbortSignal.any([_options.abortSignal, controller.signal])
                    : controller.signal;
                const result = (await call_timeout(async () => await llm.doStream({ ..._options, abortSignal: signal }), this.stream_first_timeout, (e) => {
                    controller.abort();
                }));
                const stream = result.stream;
                const reader = stream.getReader();
                const { done, value } = await call_timeout(async () => await reader.read(), this.stream_first_timeout, (e) => {
                    reader.cancel();
                    reader.releaseLock();
                    controller.abort();
                });
                if (done) {
                    Log.warn(`LLM stream done, name: ${name} => `, { done, value });
                    reader.releaseLock();
                    continue;
                }
                if (Log.isEnableDebug()) {
                    Log.debug(`LLM stream body, name: ${name} => `, result.request?.body);
                }
                let chunk = value;
                if (chunk.type == "error") {
                    Log.error(`LLM stream error, name: ${name}`, chunk);
                    reader.releaseLock();
                    continue;
                }
                result.llm = name;
                result.llmConfig = llmConfig;
                result.stream = this.streamWrapper([chunk], reader, controller);
                return result;
            }
            catch (e) {
                if (e?.name === "AbortError") {
                    throw e;
                }
                lastError = e;
                if (Log.isEnableInfo()) {
                    Log.info(`LLM stream request, name: ${name} => `, {
                        tools: _options.tools,
                        messages: _options.prompt,
                    });
                }
                Log.error(`LLM error, name: ${name} => `, e);
            }
        }
        return Promise.reject(lastError ? lastError : new Error("No LLM available"));
    }
    async getLLM(name) {
        const llm = this.llms[name];
        if (!llm) {
            return null;
        }
        let apiKey;
        if (typeof llm.apiKey === "string") {
            apiKey = llm.apiKey;
        }
        else {
            apiKey = await llm.apiKey();
        }
        let baseURL = undefined;
        if (llm.config?.baseURL) {
            if (typeof llm.config.baseURL === "string") {
                baseURL = llm.config.baseURL;
            }
            else {
                baseURL = await llm.config.baseURL();
            }
        }
        if (llm.provider == "openai") {
            if (!baseURL ||
                baseURL.indexOf("openai.com") > -1 ||
                llm.config?.organization ||
                llm.config?.openai) {
                return createOpenAI({
                    apiKey: apiKey,
                    baseURL: baseURL,
                    fetch: llm.fetch,
                    organization: llm.config?.organization,
                    project: llm.config?.project,
                    headers: llm.config?.headers,
                }).languageModel(llm.model);
            }
            else {
                return createOpenAICompatible({
                    name: llm.model,
                    apiKey: apiKey,
                    baseURL: baseURL,
                    fetch: llm.fetch,
                    headers: llm.config?.headers,
                }).languageModel(llm.model);
            }
        }
        else if (llm.provider == "anthropic") {
            return createAnthropic({
                apiKey: apiKey,
                baseURL: baseURL,
                fetch: llm.fetch,
                headers: llm.config?.headers,
            }).languageModel(llm.model);
        }
        else if (llm.provider == "google") {
            return createGoogleGenerativeAI({
                apiKey: apiKey,
                baseURL: baseURL,
                fetch: llm.fetch,
                headers: llm.config?.headers,
            }).languageModel(llm.model);
        }
        else if (llm.provider == "aws") {
            let keys = apiKey.split("=");
            return createAmazonBedrock({
                accessKeyId: keys[0],
                secretAccessKey: keys[1],
                baseURL: baseURL,
                region: llm.config?.region || "us-west-1",
                fetch: llm.fetch,
                headers: llm.config?.headers,
                sessionToken: llm.config?.sessionToken,
            }).languageModel(llm.model);
        }
        else if (llm.provider == "openai-compatible") {
            return createOpenAICompatible({
                name: llm.config?.name || llm.model.split("/")[0],
                apiKey: apiKey,
                baseURL: baseURL || "https://openrouter.ai/api/v1",
                fetch: llm.fetch,
                headers: llm.config?.headers,
            }).languageModel(llm.model);
        }
        else if (llm.provider == "openrouter") {
            return createOpenRouter({
                apiKey: apiKey,
                baseURL: baseURL || "https://openrouter.ai/api/v1",
                fetch: llm.fetch,
                headers: llm.config?.headers,
                compatibility: llm.config?.compatibility,
            }).languageModel(llm.model);
        }
        else if (llm.provider == "modelscope") {
            return createOpenAICompatible({
                name: llm.config?.name || llm.model.split("/")[0],
                apiKey: apiKey,
                baseURL: baseURL || "https://api-inference.modelscope.cn/v1",
                fetch: llm.fetch,
                headers: llm.config?.headers,
            }).languageModel(llm.model);
        }
        else {
            return llm.provider.languageModel(llm.model);
        }
    }
    streamWrapper(parts, reader, abortController) {
        let timer = null;
        return new ReadableStream({
            start: (controller) => {
                if (parts != null && parts.length > 0) {
                    for (let i = 0; i < parts.length; i++) {
                        controller.enqueue(parts[i]);
                    }
                }
            },
            pull: async (controller) => {
                timer = setTimeout(() => {
                    abortController.abort("Streaming request timeout");
                }, this.stream_token_timeout);
                const { done, value } = await reader.read();
                clearTimeout(timer);
                if (done) {
                    controller.close();
                    reader.releaseLock();
                    return;
                }
                controller.enqueue(value);
            },
            cancel: (reason) => {
                timer && clearTimeout(timer);
                reader.cancel(reason);
            },
        });
    }
    get Llms() {
        return this.llms;
    }
    get Names() {
        return this.names;
    }
}

const global = {
    chatMap: new Map(),
    taskMap: new Map(),
    prompts: new Map(),
};

const GlobalPromptKey = {
    planner_system: "planner_system",
    planner_example: "planner_example",
    planner_user: "planner_user",
    agent_system: "agent_system",
    chat_system: "chat_system",
    webpage_qa_prompt: "webpage_qa_prompt",
    deep_action_description: "deep_action_description",
    deep_action_param_task_description: "deep_action_param_task_description",
};

class PromptTemplate {
    /**
     * Simple template rendering method, does not support nesting.
     *
     * @param template - The prompt template to render.
     * Example:
     * ```
     * <if param1>
     * param1: {{param1}}
     * </if>
     * ----param2: {{param2}}
     * <if param3>
     * param3: {{param3}}
     * </if>
     * ```
     * @param data - The data to render the prompt template with.
     * Example:
     * ```
     * {
     *   param1: "value1",
     *   param2: "value2",
     *   param3: "value3",
     * }
     * ```
     * @returns The rendered prompt template.
     */
    static render(template, data) {
        let result = template;
        result = result.replace(/\n?<if\s+(\w+)>([\s\S]*?)<\/if>\n?/g, (match, varName, content) => {
            const value = data[varName];
            let hasValue = value !== undefined && value !== null && value !== "";
            if (hasValue && Array.isArray(value) && value.length == 0) {
                hasValue = false;
            }
            if (content.startsWith("\n")) {
                content = content.substring(1);
            }
            if (content.endsWith("\n")) {
                content = content.substring(0, content.length - 1);
            }
            if (!hasValue) {
                return "";
            }
            let result = this.replaceVars(content, data);
            if (match.startsWith("\n")) {
                result = "\n" + result;
            }
            if (match.endsWith("\n")) {
                result = result + "\n";
            }
            return result;
        });
        result = this.replaceVars(result, data);
        return result;
    }
    static replaceVars(text, data) {
        return text.replace(/\{\{([\w]+)\}\}/g, (match, varName) => {
            if (!(varName in data)) {
                return match;
            }
            const value = data[varName] ?? "";
            return typeof value == "string" ? value : JSON.stringify(value);
        });
    }
}

const PLAN_SYSTEM_TEMPLATE = `
You are {{name}}, an autonomous AI Agent Planner.

## Task Description
Your task is to understand the user's requirements, dynamically plan the user's tasks based on the Agent list, and please follow the steps below:
- Analyze the Agents that need to be used based on the user's requirements.
- Generate the Agent calling plan based on the analysis results.
- About agent name, please do not arbitrarily fabricate non-existent agent names.
- You only need to provide the steps to complete the user's task, key steps only, no need to be too detailed.
- Try to break down tasks into independently completable subtasks, and for maximum efficiency, run multiple independent subtasks in parallel whenever possible.
- Please strictly follow the output format and example output.
- The output language should follow the language corresponding to the user's task.

## Agent list
{{agents}}

## Output Rules and Format
<root>
  <!-- Task Name (Short) -->
  <name>Task Name</name>
  <!-- Need to break down the task into multi-agent collaboration. Please think step by step and output a detailed thought process. -->
  <thought>Your thought process on user demand planning</thought>
  <!-- Multiple Agents work together to complete the task -->
  <agents>
    <!--
    Multi-Agent supports parallelism, coordinating parallel tasks through dependencies, and passing dependent context information through node variables.
    name: The name of the Agent, where the name can only be an available name in the Agent list.
    id: Use subscript order as ID for dependency relationships between multiple agents.
    dependsOn: The IDs of agents that the current agent depends on, separated by commas when there are multiple dependencies.
    -->
    <agent name="Agent name" id="0" dependsOn="">
      <!-- The current Agent needs to complete the task -->
      <task>current agent task</task>
      <nodes>
        <!-- Nodes support input/output variables for parameter passing and dependency handling in multi-agent collaboration. -->
        <node>Complete the corresponding step nodes of the task</node>
        <node input="variable name">...</node>
        <node output="variable name">...</node>
        <!-- When including duplicate tasks, \`forEach\` can be used -->
        <forEach items="list or variable name">
          <node>forEach step node</node>
        </forEach>
        <!-- When you need to monitor changes in webpage DOM elements, you can use \`Watch\`, the loop attribute specifies whether to listen in a loop or listen once. -->
        <watch event="dom" loop="true">
          <description>Monitor task description</description>
          <trigger>
            <node>Trigger step node</node>
            <node>...</node>
          </trigger>
        </watch>
      </nodes>
    </agent>
    <!--
    Multi-agent Collaboration Dependency Example:

    Execution Flow:
    1. Agent 0: Initial agent with no dependencies (executes first)
    2. Agent 1: Depends on Agent 0 completion (executes after Agent 0)
    3. Agent 2 & 3: Both depend on Agent 1 completion (execute in parallel after Agent 1)
    4. Agent 4: Depends on both Agent 2 and Agent 3 completion (executes last)

    Dependency Chain: Agent 0  Agent 1  (Agent 2  Agent 3)  Agent 4
    -->
    <agent name="Agent name" id="0" dependsOn="">...</agent>
    <agent name="Agent name" id="1" dependsOn="0">...</agent>
    <agent name="Agent name" id="2" dependsOn="1">...</agent>
    <agent name="Agent name" id="3" dependsOn="1">...</agent>
    <agent name="Agent name" id="4" dependsOn="2,3">...</agent>
  </agents>
</root>

{{examples}}
`;
const EXAMPLE_TEMPLATE = `
## Example 1
User: Open Boss Zhipin, find 10 operation positions in Chengdu, and send a personal introduction to the recruiters based on the page information.
Output result:
<root>
  <name>Submit resume</name>
  <thought>OK, now the user requests me to create a workflow that involves opening the Boss Zhipin website, finding 10 operation positions in Chengdu, and sending personal resumes to the recruiters based on the job information.</thought>
  <agents>
    <agent name="Browser" id="0" dependsOn="">
      <task>Open Boss Zhipin, find 10 operation positions in Chengdu, and send a personal introduction to the recruiters based on the page information.</task>
      <nodes>
        <node>Open Boss Zhipin, enter the job search page</node>
        <node>Set the regional filter to Chengdu and search for operational positions.</node>
        <node>Brows the job list and filter out 10 suitable operation positions.</node>
        <forEach items="list">
          <node>Analyze job requirements</node>
          <node>Send a self-introduction to the recruiter</node>
        </forEach>
      </nodes>
    </agent>
  </agents>
</root>

## Example 2
User: Help me collect the latest AI news, summarize it, and send it to the "AI news information" group chat on WeChat.
Output result:
<root>
  <name>Latest AI News</name>
  <thought>OK, users need to collect the latest AI news, summarize it, and send it to a WeChat group named "AI news information" This requires automation, including the steps of data collection, processing, and distribution.</thought>
  <agents>
    <agent name="Browser" id="0" dependsOn="">
      <task>Search for the latest updates on AI</task>
      <nodes>
        <node>Open Google</node>
        <node>Search for the latest updates on AI</node>
        <forEach items="list">
          <node>View Details</node>
        </forEach>
        <node output="summaryInfo">Summarize search information</node>
      </nodes>
    </agent>
    <agent name="Computer" id="1" dependsOn="0">
      <task>Send a message to the WeChat group chat "AI news information"</task>
      <nodes>
        <node>Open WeChat</node>
        <node>Search for the "AI news information" chat group</node>
        <node input="summaryInfo">Send summary message</node>
      </nodes>
    </agent>
  </agents>
</root>

## Example 3
User: Access the Google team's organization page on GitHub, extract all developer accounts from the team, and compile statistics on the countries and regions where these developers are located.
Output result:
<root>
  <name>Statistics of Google Team Developers' Geographic Distribution</name>
  <thought>Okay, I need to first visit GitHub, then find Google's organization page on GitHub, extract the team member list, and individually visit each developer's homepage to obtain location information for each developer. This requires using a browser to complete all operations.</thought>
  <agents>
    <agent name="Browser" id="0" dependsOn="">
      <task>Visit Google GitHub Organization Page and Analyze Developer Geographic Distribution</task>
      <nodes>
        <node>Visit https://github.com/google</node>
        <node>Click "People" tab to view team members</node>
        <node>Scroll the page to load all developer information</node>
        <node output="developers">Extract all developer account information</node>
        <forEach items="developers">
          <node>Visit developer's homepage</node>
          <node>Extract developer's location information</node>
        </forEach>
        <node>Compile and analyze the geographic distribution data of all developers</node>
      </nodes>
    </agent>
  </agents>
</root>

## Example 4
User: Open Discord to monitor messages in Group A, and automatically reply when new messages are received.
Output result:
<root>
  <name>Automatic reply to Discord messages</name>
  <thought>OK, monitor the chat messages in Discord group A and automatically reply.</thought>
  <agents>
    <agent name="Browser" id="0" dependsOn="">
      <task>Open Group A in Discord</task>
      <nodes>
        <node>Open Discord page</node>
        <node>Find and open Group A</node>
        <watch event="dom" loop="true">
          <description>Monitor new messages in group chat</description>
          <trigger>
            <node>Analyze message content</node>
            <node>Automatic reply to new messages</node>
          </trigger>
        </watch>
      </nodes>
    </agent>
  </agents>
</root>

## Example 5
User: Search for information about "fellou" compile the results into a summary profile, then share it across social media platforms including Twitter, Facebook, and Reddit. Finally, export the platform sharing operation results to an Excel file.
Output result:
<root>
<name>Fellou Research and Social Media Campaign</name>
<thought>The user wants me to research information about 'Fellou', create a summary profile, share it on multiple social media platforms (Twitter, Facebook, Reddit), and then compile the results into an Excel file. This requires multiple agents working together: Browser for research, Browser for social media posting (Twitter, Facebook, and Reddit in parallel), and File for creating the Excel export. I need to break this down into sequential steps with proper variable passing between agents.</thought>
<agents>
  <agent name="Browser" id="0" dependsOn="">
      <task>Research comprehensive information about 'Fellou'</task>
      <nodes>
        <node>Search for the latest information about 'Fellou' - its identity, purpose, and core features</node>
        <node>Search for Fellou's functionalities, capabilities, and technical specifications</node>
        <node>Search for recent news, updates, announcements, and developments related to Fellou</node>
        <node>Search for user reviews, feedback, and community discussions about Fellou</node>
        <node>Search for Fellou's market position, competitors, and industry context</node>
        <node output="researchData">Compile all research findings into a comprehensive summary profile</node>
      </nodes>
    </agent>
    <agent name="Browser" id="1" dependsOn="0">
      <task>Share Fellou's summary and collected interaction data on Twitter/X</task>
      <nodes>
        <node>Navigate to Twitter/X platform</node>
        <node input="researchData">Create and post Twitter-optimized content about Fellou (within character limits, using hashtags)</node>
        <node output="twitterResults">Capture Twitter post URL and initial engagement metrics</node>
      </nodes>
    </agent>
    <agent name="Browser" id="2" dependsOn="0">
      <task>Share Fellou's summary and collected interaction data on Facebook</task>
      <nodes>
        <node>Navigate to Facebook platform</node>
        <node input="researchData">Create and post Facebook-optimized content about Fellou (longer format, engaging description)</node>
        <node output="facebookResults">Capture Facebook post URL and initial engagement metrics</node>
      </nodes>
    </agent>
    <agent name="Browser" id="3" dependsOn="0">
      <task>Share Fellou's summary and collected interaction data on Reddit</task>
      <nodes>
        <node>Navigate to Reddit platform</node>
        <node input="researchData">Find appropriate subreddit and create Reddit-optimized post about Fellou (community-focused, informative)</node>
        <node output="redditResults">Capture Reddit post URL and initial engagement metrics</node>
      </nodes>
    </agent>
    <agent name="File" id="4" dependsOn="1,2,3">
      <task>Compile social media results into Excel file</task>
      <nodes>
        <node input="twitterResults,facebookResults,redditResults">Create Excel file with social media campaign results</node>
        <node>Include columns for Platform, Post URL, Content Summary, Timestamp, Initial Likes/Shares/Comments</node>
        <node>Format the Excel file with proper headers and styling</node>
        <node>Save the file as 'Fellou_Social_Media_Campaign_Results.xlsx'</node>
      </nodes>
    </agent>
  </agents>
</agents>
</root>
`;
const PLAN_USER_TEMPLATE = `
<if language>
Language: {{language}}
</if>
User Platform: {{platform}}
<if taskWebsite>
Task Websites:
{{taskWebsite}}
</if>
<if dependentVariables>
Dependent Variables: {{dependentVariables}}
</if>
Current datetime: {{datetime}}
User Task Description: {{taskPrompt}}
<if attachments>
Attachments:
{{attachments}}
</if>
<if extPrompt>
{{extPrompt}}
</if>
`;
async function getPlanSystemPrompt(context) {
    const agents_prompt = await buildAgentsPrompt(context.agents, context);
    const planSysPrompt = global.prompts.get(GlobalPromptKey.planner_system) || PLAN_SYSTEM_TEMPLATE;
    const planExamplePrompt = global.prompts.get(GlobalPromptKey.planner_example) || EXAMPLE_TEMPLATE;
    return PromptTemplate.render(planSysPrompt, {
        name: config$1.name,
        agents: agents_prompt.trim(),
        examples: planExamplePrompt.trim(),
    }).trim();
}
function getPlanUserPrompt(context, taskPrompt) {
    const planUserPrompt = global.prompts.get(GlobalPromptKey.planner_user) || PLAN_USER_TEMPLATE;
    return PromptTemplate.render(planUserPrompt, {
        taskPrompt: taskPrompt,
        platform: config$1.platform,
        taskWebsite: context.variables.get("taskWebsite"),
        language: context.variables.get("language"),
        attachments: context.variables.get("attachments"),
        dependentVariables: context.variables.get("dependentVariables"),
        datetime: context.variables.get("datetime") || new Date().toLocaleString(),
        extPrompt: context.variables.get("planExtPrompt"),
    }).trim();
}
async function buildAgentsPrompt(agents, context) {
    let agents_prompt = "";
    for (let i = 0; i < agents.length; i++) {
        let agent = agents[i];
        let tools = await agent.loadTools(context);
        if (agent.ignorePlan) {
            continue;
        }
        agents_prompt +=
            `<agent name="${agent.Name}">\n` +
                `Description: ${sub(agent.PlanDescription || agent.Description, 4000, true)}\n` +
                "Tools:\n" +
                tools
                    .filter((tool) => !tool.noPlan)
                    .map((tool) => `  - ${tool.name}: ${sub(tool.planDescription || tool.description || "", 500, true)}`)
                    .join("\n") +
                "\n</agent>\n\n";
    }
    return agents_prompt.trim();
}

class Planner {
    constructor(context, callback) {
        this.context = context;
        this.taskId = context.taskId;
        this.callback = callback || context.config.callback;
    }
    async plan(taskPrompt, saveHistory, datetime) {
        let taskPromptStr;
        let userPrompt;
        if (typeof taskPrompt === "string") {
            taskPromptStr = taskPrompt;
            userPrompt = {
                type: "text",
                text: getPlanUserPrompt(this.context, taskPrompt),
            };
        }
        else {
            userPrompt = taskPrompt;
            taskPromptStr = taskPrompt.text || "";
        }
        const messages = [
            {
                role: "system",
                content: await getPlanSystemPrompt(this.context),
            },
            {
                role: "user",
                content: [userPrompt],
            },
        ];
        return await this.doPlan(taskPromptStr, messages, saveHistory ?? true);
    }
    async replan(taskPrompt, saveHistory = true, datetime) {
        const chain = this.context.chain;
        if (chain.planRequest && chain.planResult) {
            const messages = [
                ...chain.planRequest.messages,
                {
                    role: "assistant",
                    content: [{ type: "text", text: chain.planResult }],
                },
                {
                    role: "user",
                    content: [{ type: "text", text: taskPrompt }],
                },
            ];
            return await this.doPlan(taskPrompt, messages, saveHistory);
        }
        else {
            return this.plan(taskPrompt, saveHistory, datetime);
        }
    }
    async doPlan(taskPrompt, messages, saveHistory, retryNum = 0) {
        const config = this.context.config;
        const rlm = new RetryLanguageModel(config.llms, config.planLlms);
        rlm.setContext(this.context);
        const request = {
            maxOutputTokens: 8192,
            temperature: 0.7,
            messages: messages,
            abortSignal: this.context.controller.signal,
        };
        const result = await rlm.callStream(request);
        const reader = result.stream.getReader();
        let streamText = "";
        let thinkingText = "";
        try {
            while (true) {
                await this.context.checkAborted(true);
                const { done, value } = await reader.read();
                if (done) {
                    break;
                }
                let chunk = value;
                if (chunk.type == "error") {
                    Log.error("Plan, LLM Error: ", chunk);
                    throw new Error("LLM Error: " + chunk.error);
                }
                if (chunk.type == "reasoning-delta") {
                    thinkingText += chunk.delta || "";
                }
                if (chunk.type == "text-delta") {
                    streamText += chunk.delta || "";
                }
                if (chunk.type == "finish") {
                    if (chunk.finishReason == "content-filter") {
                        throw new Error("LLM error: trigger content filtering violation");
                    }
                    if (chunk.finishReason == "other") {
                        throw new Error("LLM error: terminated due to other reasons");
                    }
                }
                if (this.callback) {
                    let workflow = parseWorkflow(this.taskId, streamText, false, thinkingText);
                    if (workflow) {
                        await this.callback.onMessage({
                            streamType: "agent",
                            chatId: this.context.chatId,
                            taskId: this.taskId,
                            agentName: "Planer",
                            type: "workflow",
                            streamDone: false,
                            workflow: workflow,
                        });
                    }
                }
            }
        }
        catch (e) {
            if (retryNum < 3) {
                await sleep(1000);
                return await this.doPlan(taskPrompt, messages, saveHistory, ++retryNum);
            }
            throw e;
        }
        finally {
            reader.releaseLock();
            if (Log.isEnableInfo()) {
                Log.info("Planner result: \n" + streamText);
            }
        }
        if (saveHistory) {
            const chain = this.context.chain;
            chain.planRequest = request;
            chain.planResult = streamText;
        }
        let workflow = parseWorkflow(this.taskId, streamText, true, thinkingText);
        if (this.callback) {
            await this.callback.onMessage({
                streamType: "agent",
                chatId: this.context.chatId,
                taskId: this.taskId,
                agentName: "Planer",
                type: "workflow",
                streamDone: true,
                workflow: workflow,
            });
        }
        if (workflow.taskPrompt) {
            workflow.taskPrompt += "\n" + taskPrompt;
        }
        else {
            workflow.taskPrompt = taskPrompt;
        }
        workflow.taskPrompt = workflow.taskPrompt.trim();
        return workflow;
    }
}

class ToolChain {
    constructor(toolUse, request) {
        this.toolName = toolUse.toolName;
        this.toolCallId = toolUse.toolCallId;
        this.request = JSON.parse(JSON.stringify(request));
    }
    updateParams(params) {
        this.params = params;
        this.onUpdate && this.onUpdate();
    }
    updateToolResult(toolResult) {
        this.toolResult = toolResult;
        this.onUpdate && this.onUpdate();
    }
}
class AgentChain {
    constructor(agent) {
        this.tools = [];
        this.agent = agent;
    }
    push(tool) {
        tool.onUpdate = () => {
            this.onUpdate &&
                this.onUpdate({
                    type: "update",
                    target: tool,
                });
        };
        this.tools.push(tool);
        this.onUpdate &&
            this.onUpdate({
                type: "update",
                target: this,
            });
    }
}
class Chain {
    constructor(taskPrompt) {
        this.agents = [];
        this.listeners = [];
        this.taskPrompt = taskPrompt;
    }
    push(agent) {
        agent.onUpdate = (event) => {
            this.pub(event);
        };
        this.agents.push(agent);
        this.pub({
            type: "update",
            target: agent,
        });
    }
    pub(event) {
        this.listeners.forEach((listener) => listener(this, event));
    }
    addListener(callback) {
        this.listeners.push(callback);
    }
    removeListener(callback) {
        this.listeners = this.listeners.filter((listener) => listener !== callback);
    }
}

async function checkTaskReplan(agentContext) {
    try {
        const context = agentContext.context;
        const chain = agentContext.context.chain;
        if (!chain.planRequest || !chain.planResult) {
            return false;
        }
        const rlm = new RetryLanguageModel(context.config.llms, context.config.planLlms);
        rlm.setContext(agentContext);
        const agentExecution = getAgentExecutionPrompt(agentContext);
        const prompt = `# Task Execution Status
${agentExecution}

# Task Replan Check
Please review the plan for unexecuted tasks based on the results of partially executed tasks, and check whether it still meets the requirements of the current user task.
If after executing some subtasks it is found that the previous plan has issues or is no longer the optimal solution, then the unexecuted task nodes need to be replanned; otherwise, replanning is not necessary.`;
        const messages = [
            ...chain.planRequest.messages,
            {
                role: "assistant",
                content: [{ type: "text", text: chain.planResult }],
            },
            {
                role: "user",
                content: [{ type: "text", text: prompt }],
            },
        ];
        const functionName = "check_task_status";
        const request = {
            maxOutputTokens: 512,
            temperature: 0.7,
            messages: messages,
            abortSignal: context.controller.signal,
            tools: [
                {
                    type: "function",
                    name: functionName,
                    description: "Check the task status, and based on the results of partially executed tasks, examine whether the unexecuted task nodes need to be replanned.",
                    inputSchema: {
                        type: "object",
                        properties: {
                            thinking: {
                                type: "string",
                                description: "Output the thinking process, analyzing whether the unexecuted task nodes need to be replanned.(100 words or less)",
                            },
                            replan: {
                                type: "boolean",
                                description: "Determine whether replanning of unexecuted task nodes is needed. If the existing unexecuted task nodes can meet the task requirements, then replanning is not necessary; if they cannot meet the requirements, then replanning is needed.",
                            },
                        },
                        required: ["thinking", "replan"],
                    },
                },
            ],
            toolChoice: {
                type: "tool",
                toolName: functionName,
            },
        };
        const result = await rlm.call(request);
        let input = result.content.find((c) => c.type === "tool-call")?.input;
        if (input && typeof input === "string") {
            input = JSON.parse(input);
        }
        return input.replan;
    }
    catch (e) {
        Log.error("checkTaskReplan error: ", e);
        return false;
    }
}
async function replanWorkflow(agentContext) {
    let currentIndex = 0;
    const currentAgentId = agentContext.agentChain.agent.id;
    const agents = agentContext.context.workflow?.agents;
    for (let i = 0; i < agents.length; i++) {
        currentIndex = i;
        if (agents[i].id === currentAgentId) {
            break;
        }
    }
    const planner = new Planner(agentContext.context, {
        onMessage: async (message, _agentContext) => {
            if (message.type === "workflow") {
                mergeWorkflow(agentContext.context.workflow, JSON.parse(JSON.stringify(message.workflow)), currentIndex);
                agentContext.context.config.callback?.onMessage({
                    ...message,
                    workflow: agentContext.context.workflow,
                });
            }
        },
    });
    const agentExecution = getAgentExecutionPrompt(agentContext);
    const prompt = `# Task Execution Status
${agentExecution}

# Replan
The previous plan is no longer suitable for the current task.
Please reformulate the plan for unexecuted tasks based on the results of partially executed tasks to meet the requirements of the current task.
Please do not output nodes that have already been executed. The new plan is an incremental update to the unexecuted plan nodes, and can use the results and variables from previously executed tasks.`;
    let newWorkflow;
    const chain = agentContext.context.chain;
    if (chain.planRequest && chain.planResult) {
        const messages = [
            ...chain.planRequest.messages,
            {
                role: "assistant",
                content: [{ type: "text", text: chain.planResult }],
            },
            {
                role: "user",
                content: [{ type: "text", text: prompt }],
            },
        ];
        newWorkflow = await planner.doPlan("", messages, true);
    }
    else {
        newWorkflow = await planner.plan({ type: "text", text: prompt }, true);
    }
    const workflow = agentContext.context.workflow;
    mergeWorkflow(workflow, newWorkflow, currentIndex);
    workflow.modified = true;
}
function mergeWorkflow(workflow, newWorkflow, currentIndex) {
    workflow.name = newWorkflow.name;
    workflow.thought = newWorkflow.thought;
    const old_number = currentIndex + 1;
    workflow.agents.splice(old_number, workflow.agents.length - old_number);
    for (let i = 0; i < newWorkflow.agents.length; i++) {
        const agent = newWorkflow.agents[i];
        const idx = i + currentIndex + 1;
        agent.id = workflow.taskId + "-" + (idx < 10 ? "0" + idx : idx);
        const dependsOn = agent.dependsOn || [];
        if (i == 0) {
            agent.dependsOn = [workflow.agents[workflow.agents.length - 1].id];
        }
        else {
            for (let j = 0; j < dependsOn.length; j++) {
                const dependId = dependsOn[j];
                const arr = dependId.split("-");
                const dependIndex = parseInt(arr[arr.length - 1]) + currentIndex + 1;
                arr[arr.length - 1] =
                    dependIndex < 10 ? "0" + dependIndex : dependIndex + "";
                dependsOn[j] = arr.join("-");
            }
        }
        workflow.agents.push(agent);
    }
    workflow.xml = newWorkflow.xml;
}
function getAgentExecutionPrompt(currentAgentContext) {
    let prompt = "";
    const agentMap = {};
    const chain = currentAgentContext.context.chain;
    for (let i = 0; i < chain.agents.length; i++) {
        const agentChain = chain.agents[i];
        agentMap[agentChain.agent.id] = agentChain;
    }
    let before = true;
    const workflow = currentAgentContext.context.workflow;
    const currentAgentId = currentAgentContext.agentChain.agent.id;
    for (let i = 0; i < workflow.agents.length; i++) {
        const agent = workflow.agents[i];
        const agentChain = agentMap[agent.id];
        if (agent.id === currentAgentId) {
            before = false;
        }
        if (agentChain && agentChain.agentResult && before) {
            prompt += `## ${agent.name} Agent: ${agent.task}\nExecuted, execution result:\n${agentChain.agentResult}\n\n`;
        }
        else if (agentChain && agentChain.agentRequest) {
            const messages = getExecutionMessages(agentChain.agentRequest.messages);
            prompt += `## ${agent.name} Agent: ${agent.task}\nCurrently executing, execution progress:\n${messages.join("\n\n")}\n\n`;
        }
        else {
            prompt += `## ${agent.name} Agent: ${agent.task}\nNot started execution.\n\n`;
        }
    }
    return prompt.trim();
}
function getExecutionMessages(messages) {
    const messagesContents = [];
    for (let i = 0; i < messages.length; i++) {
        const message = messages[i];
        if (message.role === "user") {
            const contents = message.content
                .filter((s) => s.type === "text" && s.text)
                .map((s) => s.text);
            for (let j = 0; j < contents.length; j++) {
                messagesContents.push("User: " + sub(contents[j], i < 3 ? 2000 : 500, true));
            }
        }
        else if (message.role === "assistant") {
            for (let j = 0; j < message.content.length; j++) {
                const content = message.content[j];
                if (content.type === "text" && content.text) {
                    messagesContents.push("Assistant: " + sub(content.text, 500, true));
                }
                else if (content.type === "tool-call") {
                    messagesContents.push(`Call \`${content.toolName}\` Tool Params: ` +
                        JSON.stringify(content.input || {}));
                }
            }
        }
        else if (message.role === "tool") {
            for (let j = 0; j < message.content.length; j++) {
                const content = message.content[j];
                const output = content.output;
                const result = JSON.stringify(output.value);
                messagesContents.push(`Call \`${content.toolName}\` Tool Result: ${sub(result, 500, true)}`);
            }
        }
    }
    return messagesContents;
}

class Eko {
    constructor(config, chatId = uuidv4()) {
        this.config = config;
        this.chatId = chatId;
    }
    async generate(taskPrompt, taskId = uuidv4(), contextParams, datetime) {
        const agents = [...(this.config.agents || [])];
        const chain = new Chain(taskPrompt);
        const context = new TaskContext(this.chatId, taskId, this.config, agents, chain);
        if (contextParams) {
            Object.keys(contextParams).forEach((key) => context.variables.set(key, contextParams[key]));
        }
        try {
            global.taskMap.set(taskId, context);
            if (this.config.a2aClient) {
                const a2aList = await this.config.a2aClient.listAgents(taskPrompt);
                context.agents = mergeAgents(context.agents, a2aList);
            }
            const planner = new Planner(context);
            context.workflow = await planner.plan(taskPrompt, true, datetime);
            return context.workflow;
        }
        catch (e) {
            this.deleteTask(taskId);
            throw e;
        }
    }
    async modify(taskId, modifyTaskPrompt) {
        const context = global.taskMap.get(taskId);
        if (!context) {
            return await this.generate(modifyTaskPrompt, taskId);
        }
        if (this.config.a2aClient) {
            const a2aList = await this.config.a2aClient.listAgents(modifyTaskPrompt);
            context.agents = mergeAgents(context.agents, a2aList);
        }
        const planner = new Planner(context);
        context.workflow = await planner.replan(modifyTaskPrompt);
        return context.workflow;
    }
    async execute(taskId) {
        const context = this.getTask(taskId);
        if (!context) {
            throw new Error("The task does not exist");
        }
        if (context.pause) {
            context.setPause(false);
        }
        if (context.controller.signal.aborted) {
            context.reset();
        }
        context.conversation = [];
        try {
            return await this.doRunWorkflow(context);
        }
        catch (e) {
            Log.error("execute error", e);
            return {
                taskId,
                success: false,
                stopReason: e?.name == "AbortError" ? "abort" : "error",
                result: typeof e == "string"
                    ? e
                    : e instanceof Error
                        ? e.name + ": " + e.message
                        : String(e || "Unknown error"),
                error: e,
            };
        }
    }
    async run(taskPrompt, taskId = uuidv4(), contextParams) {
        await this.generate(taskPrompt, taskId, contextParams);
        return await this.execute(taskId);
    }
    async initContext(workflow, contextParams) {
        const agents = this.config.agents || [];
        const chain = new Chain(workflow.taskPrompt || workflow.name);
        const context = new TaskContext(this.chatId, workflow.taskId, this.config, agents, chain);
        if (this.config.a2aClient) {
            const a2aList = await this.config.a2aClient.listAgents(workflow.taskPrompt || workflow.name);
            context.agents = mergeAgents(context.agents, a2aList);
        }
        if (contextParams) {
            Object.keys(contextParams).forEach((key) => context.variables.set(key, contextParams[key]));
        }
        context.workflow = workflow;
        global.taskMap.set(workflow.taskId, context);
        return context;
    }
    async doRunWorkflow(context) {
        const agents = context.agents;
        const workflow = context.workflow;
        if (!workflow || workflow.agents.length == 0) {
            throw new Error("Workflow error");
        }
        const agentNameMap = agents.reduce((map, item) => {
            map[item.Name] = item;
            return map;
        }, {});
        let agentTree = buildAgentTree(workflow.agents);
        const results = [];
        while (true) {
            await context.checkAborted();
            let lastAgent;
            if (agentTree.type === "normal") {
                // normal agent
                const agent = agentNameMap[agentTree.agent.name];
                if (!agent) {
                    throw new Error("Unknown Agent: " + agentTree.agent.name);
                }
                lastAgent = agent;
                const agentNode = agentTree.agent;
                const agentChain = new AgentChain(agentNode);
                context.chain.push(agentChain);
                agentTree.result = await this.runAgent(context, agent, agentTree, agentChain);
                results.push(agentTree.result);
            }
            else {
                // parallel agent
                const parallelAgents = agentTree.agents;
                const doRunAgent = async (agentNode, index) => {
                    const agent = agentNameMap[agentNode.agent.name];
                    if (!agent) {
                        throw new Error("Unknown Agent: " + agentNode.agent.name);
                    }
                    lastAgent = agent;
                    const agentChain = new AgentChain(agentNode.agent);
                    context.chain.push(agentChain);
                    const result = await this.runAgent(context, agent, agentNode, agentChain);
                    return { result: result, agentChain, index };
                };
                let agent_results = [];
                let agentParallel = context.variables.get("agentParallel");
                if (agentParallel === undefined) {
                    agentParallel = config$1.agentParallel;
                }
                if (agentParallel) {
                    // parallel execution
                    const parallelResults = await Promise.all(parallelAgents.map((agent, index) => doRunAgent(agent, index)));
                    parallelResults.sort((a, b) => a.index - b.index);
                    parallelResults.forEach(({ agentChain }) => {
                        context.chain.push(agentChain);
                    });
                    agent_results = parallelResults.map(({ result }) => result);
                }
                else {
                    // serial execution
                    for (let i = 0; i < parallelAgents.length; i++) {
                        const { result, agentChain } = await doRunAgent(parallelAgents[i], i);
                        context.chain.push(agentChain);
                        agent_results.push(result);
                    }
                }
                results.push(agent_results.join("\n\n"));
            }
            context.conversation.splice(0, context.conversation.length);
            if (config$1.mode == "expert" &&
                !workflow.modified &&
                agentTree.nextAgent &&
                lastAgent?.AgentContext &&
                (await checkTaskReplan(lastAgent.AgentContext))) {
                // replan
                await replanWorkflow(lastAgent.AgentContext);
            }
            if (workflow.modified) {
                workflow.modified = false;
                agentTree = buildAgentTree(workflow.agents.filter((agent) => agent.status == "init"));
                continue;
            }
            if (!agentTree.nextAgent) {
                break;
            }
            agentTree = agentTree.nextAgent;
        }
        return {
            success: true,
            stopReason: "done",
            taskId: context.taskId,
            result: results[results.length - 1] || "",
        };
    }
    async runAgent(context, agent, agentNode, agentChain) {
        try {
            agentNode.agent.status = "running";
            this.config.callback &&
                (await this.config.callback.onMessage({
                    streamType: "agent",
                    chatId: context.chatId,
                    taskId: context.taskId,
                    agentName: agentNode.agent.name,
                    nodeId: agentNode.agent.id,
                    type: "agent_start",
                    agentNode: agentNode.agent,
                }, agent.AgentContext));
            agentNode.result = await agent.run(context, agentChain);
            agentNode.agent.status = "done";
            this.config.callback &&
                (await this.config.callback.onMessage({
                    streamType: "agent",
                    chatId: context.chatId,
                    taskId: context.taskId,
                    agentName: agentNode.agent.name,
                    nodeId: agentNode.agent.id,
                    type: "agent_result",
                    agentNode: agentNode.agent,
                    result: agentNode.result,
                }, agent.AgentContext));
            return agentNode.result;
        }
        catch (e) {
            agentNode.agent.status = "error";
            this.config.callback &&
                (await this.config.callback.onMessage({
                    streamType: "agent",
                    chatId: context.chatId,
                    taskId: context.taskId,
                    agentName: agentNode.agent.name,
                    nodeId: agentNode.agent.id,
                    type: "agent_result",
                    agentNode: agentNode.agent,
                    error: e,
                }, agent.AgentContext));
            throw e;
        }
    }
    getTask(taskId) {
        return global.taskMap.get(taskId);
    }
    getAllTaskId() {
        return [...global.taskMap.keys()];
    }
    deleteTask(taskId) {
        this.abortTask(taskId);
        const context = global.taskMap.get(taskId);
        if (context) {
            context.variables.clear();
        }
        return global.taskMap.delete(taskId);
    }
    abortTask(taskId, reason) {
        const context = global.taskMap.get(taskId);
        if (context) {
            context.setPause(false);
            this.onTaskStatus(context, "abort", reason);
            context.controller.abort(reason);
            return true;
        }
        else {
            return false;
        }
    }
    pauseTask(taskId, pause, abortCurrentStep, reason) {
        const context = global.taskMap.get(taskId);
        if (context) {
            this.onTaskStatus(context, pause ? "pause" : "resume-pause", reason);
            context.setPause(pause, abortCurrentStep);
            return true;
        }
        else {
            return false;
        }
    }
    chatTask(taskId, userPrompt) {
        const context = global.taskMap.get(taskId);
        if (context) {
            context.conversation.push(userPrompt);
            return context.conversation;
        }
    }
    addAgent(agent) {
        this.config.agents = this.config.agents || [];
        this.config.agents.push(agent);
    }
    async onTaskStatus(context, status, reason) {
        const [agent] = context.currentAgent() || [];
        if (agent) {
            const onTaskStatus = agent["onTaskStatus"];
            if (onTaskStatus) {
                await onTaskStatus.call(agent, status, reason);
            }
        }
    }
}

class ToolWrapper {
    constructor(toolSchema, execute) {
        this.tool = convertToolSchema(toolSchema);
        this.execute = execute;
    }
    get name() {
        return this.tool.name;
    }
    getTool() {
        return this.tool;
    }
    async callTool(args, agentContext, toolCall) {
        return await this.execute.execute(args, agentContext, toolCall);
    }
}

const TOOL_NAME$a = "foreach_task";
class ForeachTaskTool {
    constructor() {
        this.name = TOOL_NAME$a;
        this.description = `When executing the \`forEach\` node, please use the current tool for counting to ensure tasks are executed sequentially, the tool needs to be called with each loop iteration.`;
        this.parameters = {
            type: "object",
            properties: {
                nodeId: {
                    type: "number",
                    description: "forEach node ID.",
                },
                progress: {
                    type: "string",
                    description: "Current execution progress.",
                },
                next_step: {
                    type: "string",
                    description: "Next task description.",
                },
            },
            required: ["nodeId", "progress", "next_step"],
        };
    }
    async execute(args, agentContext) {
        let nodeId = args.nodeId;
        let agentXml = agentContext.agentChain.agent.xml;
        let node = extractAgentXmlNode(agentXml, nodeId);
        if (node == null) {
            throw new Error("Node ID does not exist: " + nodeId);
        }
        if (node.tagName !== "forEach") {
            throw new Error("Node ID is not a forEach node: " + nodeId);
        }
        let items = node.getAttribute("items");
        let varValue = null;
        let resultText = "Recorded";
        if (items && items != "list") {
            varValue = agentContext.context.variables.get(items.trim());
            if (varValue) {
                let key = "foreach_" + nodeId;
                let loop_count = agentContext.variables.get(key) || 0;
                if (loop_count % 5 == 0) {
                    resultText = `Variable information associated with the current loop task.\nvariable_name: ${items.trim()}\nvariable_value: ${varValue}`;
                }
                agentContext.variables.set(key, ++loop_count);
            }
        }
        return {
            content: [
                {
                    type: "text",
                    text: resultText,
                },
            ],
        };
    }
}

const TOOL_NAME$9 = "watch_trigger";
const watch_system_prompt = `You are a tool for detecting element changes. Given a task description, compare two images to determine whether the changes described in the task have occurred.
If the changes have occurred, return an json with \`changed\` set to true and \`changeInfo\` containing a description of the changes. If no changes have occurred, return an object with \`changed\` set to false.

## Example
User: Monitor new messages in group chat
### No changes detected
Output:
{
  "changed": false
}
### Change detected
Output:
{
  "changed": true,
  "changeInfo": "New message received in the group chat. The message content is: 'Hello, how are you?'"
}`;
class WatchTriggerTool {
    constructor() {
        this.name = TOOL_NAME$9;
        this.description = `When executing the \`watch\` node, please use it to monitor DOM element changes, it will block the listener until the element changes or times out.`;
        this.parameters = {
            type: "object",
            properties: {
                nodeId: {
                    type: "number",
                    description: "watch node ID.",
                },
                watch_area: {
                    type: "array",
                    description: "Element changes in monitoring area, eg: [x, y, width, height].",
                    items: {
                        type: "number",
                    },
                },
                watch_index: {
                    type: "array",
                    description: "The index of elements to be monitoring multiple elements simultaneously.",
                    items: {
                        type: "number",
                    },
                },
                frequency: {
                    type: "number",
                    description: "Check frequency, how many seconds between each check, default 1 seconds.",
                    default: 1,
                    minimum: 0.5,
                    maximum: 30,
                },
                timeout: {
                    type: "number",
                    description: "Timeout in minute, default 5 minutes.",
                    default: 5,
                    minimum: 1,
                    maximum: 30,
                },
            },
            required: ["nodeId"],
        };
    }
    async execute(args, agentContext) {
        let nodeId = args.nodeId;
        let agentXml = agentContext.agentChain.agent.xml;
        let node = extractAgentXmlNode(agentXml, nodeId);
        if (node == null) {
            throw new Error("Node ID does not exist: " + nodeId);
        }
        if (node.tagName !== "watch") {
            throw new Error("Node ID is not a watch node: " + nodeId);
        }
        let task_description = node.getElementsByTagName("description")[0]?.textContent || "";
        if (!task_description) {
            return {
                content: [
                    {
                        type: "text",
                        text: "The watch node does not have a description, skip.",
                    },
                ],
            };
        }
        await this.init_eko_observer(agentContext);
        const image1 = await this.get_screenshot(agentContext);
        const start = new Date().getTime();
        const timeout = (args.timeout || 5) * 60000;
        const frequency = Math.max(500, (args.frequency || 1) * 1000);
        const rlm = new RetryLanguageModel(agentContext.context.config.llms, agentContext.agent.Llms);
        rlm.setContext(agentContext);
        while (new Date().getTime() - start < timeout) {
            await agentContext.context.checkAborted();
            await new Promise((resolve) => setTimeout(resolve, frequency));
            let changed = await this.has_eko_changed(agentContext);
            if (changed == "false") {
                continue;
            }
            await this.init_eko_observer(agentContext);
            const image2 = await this.get_screenshot(agentContext);
            const changeResult = await this.is_dom_change(agentContext, rlm, image1, image2, task_description);
            if (changeResult.changed) {
                return {
                    content: [
                        {
                            type: "text",
                            text: changeResult.changeInfo || "DOM change detected.",
                        },
                    ],
                };
            }
        }
        return {
            content: [
                {
                    type: "text",
                    text: "Timeout reached, no DOM changes detected.",
                },
            ],
        };
    }
    async get_screenshot(agentContext) {
        const screenshot = agentContext.agent["screenshot"];
        const imageResult = (await screenshot.call(agentContext.agent, agentContext));
        const image = toImage(imageResult.imageBase64);
        return {
            image: image,
            imageType: imageResult.imageType,
        };
    }
    async init_eko_observer(agentContext) {
        try {
            const screenshot = agentContext.agent["execute_script"];
            await screenshot.call(agentContext.agent, agentContext, () => {
                let _window = window;
                _window.has_eko_changed = false;
                _window.eko_observer && _window.eko_observer.disconnect();
                let eko_observer = new MutationObserver(function (mutations) {
                    _window.has_eko_changed = true;
                });
                eko_observer.observe(document.body, {
                    childList: true,
                    subtree: true,
                    attributes: true,
                    attributeOldValue: true,
                    characterData: true,
                    characterDataOldValue: true,
                });
                _window.eko_observer = eko_observer;
            }, []);
        }
        catch (error) {
            console.error("Error initializing Eko observer:", error);
        }
    }
    async has_eko_changed(agentContext) {
        try {
            const screenshot = agentContext.agent["execute_script"];
            let result = (await screenshot.call(agentContext.agent, agentContext, () => {
                return window.has_eko_changed + "";
            }, []));
            return result;
        }
        catch (e) {
            console.error("Error checking Eko change:", e);
            return "undefined";
        }
    }
    async is_dom_change(agentContext, rlm, image1, image2, task_description) {
        try {
            let request = {
                messages: [
                    {
                        role: "system",
                        content: watch_system_prompt,
                    },
                    {
                        role: "user",
                        content: [
                            {
                                type: "file",
                                data: image1.image,
                                mediaType: image1.imageType,
                            },
                            {
                                type: "file",
                                data: image2.image,
                                mediaType: image2.imageType,
                            },
                            {
                                type: "text",
                                text: task_description,
                            },
                        ],
                    },
                ],
                abortSignal: agentContext.context.controller.signal,
            };
            const result = await rlm.call(request);
            let resultText = result.text || "{}";
            resultText = resultText.substring(resultText.indexOf("{"), resultText.lastIndexOf("}") + 1);
            return JSON.parse(resultText);
        }
        catch (error) {
            Log.error("Error in is_dom_change:", error);
        }
        return {
            changed: false,
        };
    }
}

const TOOL_NAME$8 = "human_interact";
class HumanInteractTool {
    constructor() {
        this.name = TOOL_NAME$8;
        this.noPlan = true;
        this.description = `AI interacts with humans:
confirm: Ask the user to confirm whether to execute an operation, especially when performing dangerous actions such as deleting system files, users will choose Yes or No.
input: Prompt the user to enter text; for example, when a task is ambiguous, the AI can choose to ask the user for details, and the user can respond by inputting.
select: Allow the user to make a choice; in situations that require selection, the AI can ask the user to make a decision.
request_help: Request assistance from the user; for instance, when an operation is blocked, the AI can ask the user for help, For example, login required, CAPTCHA verification, SMS verification code, QR code scanning, payment operations, etc.`;
        this.parameters = {
            type: "object",
            properties: {
                interactType: {
                    type: "string",
                    description: "The type of interaction with users.",
                    enum: ["confirm", "input", "select", "request_help"],
                },
                prompt: {
                    type: "string",
                    description: "Display prompts to users",
                },
                selectOptions: {
                    type: "array",
                    description: "Options provided to users, this parameter is required when interactType is select.",
                    items: {
                        type: "string",
                    },
                },
                selectMultiple: {
                    type: "boolean",
                    description: "isMultiple, used when interactType is select",
                },
                helpType: {
                    type: "string",
                    description: "Help type, required when interactType is request_help.",
                    enum: ["request_login", "request_assistance"],
                },
            },
            required: ["interactType", "prompt"],
        };
    }
    async execute(args, agentContext) {
        let interactType = args.interactType;
        let callback = agentContext.context.config.callback;
        let resultText = "";
        if (callback) {
            switch (interactType) {
                case "confirm":
                    if (callback.onHumanConfirm) {
                        let result = await callback.onHumanConfirm(agentContext, args.prompt);
                        resultText = `confirm result: ${result ? "Yes" : "No"}`;
                    }
                    break;
                case "input":
                    if (callback.onHumanInput) {
                        let result = await callback.onHumanInput(agentContext, args.prompt);
                        resultText = `input result: ${result}`;
                    }
                    break;
                case "select":
                    if (callback.onHumanSelect) {
                        let result = await callback.onHumanSelect(agentContext, args.prompt, (args.selectOptions || []), (args.selectMultiple || false));
                        resultText = `select result: ${JSON.stringify(result)}`;
                    }
                    break;
                case "request_help":
                    if (callback.onHumanHelp) {
                        if (args.helpType == "request_login" &&
                            (await this.checkIsLogined(agentContext))) {
                            resultText = "Already logged in";
                            break;
                        }
                        let result = await callback.onHumanHelp(agentContext, (args.helpType || "request_assistance"), args.prompt);
                        resultText = `request_help result: ${result ? "Solved" : "Unresolved"}`;
                    }
                    break;
            }
        }
        if (resultText) {
            return {
                content: [
                    {
                        type: "text",
                        text: resultText,
                    },
                ],
            };
        }
        else {
            return {
                content: [
                    {
                        type: "text",
                        text: `Error: Unsupported ${interactType} interaction operation`,
                    },
                ],
                isError: true,
            };
        }
    }
    async checkIsLogined(agentContext) {
        let screenshot = agentContext.agent["screenshot"];
        if (!screenshot) {
            return false;
        }
        try {
            let imageResult = (await screenshot.call(agentContext.agent, agentContext));
            let rlm = new RetryLanguageModel(agentContext.context.config.llms, agentContext.agent.Llms);
            rlm.setContext(agentContext);
            let image = toImage(imageResult.imageBase64);
            let request = {
                messages: [
                    {
                        role: "user",
                        content: [
                            {
                                type: "file",
                                data: image,
                                mediaType: imageResult.imageType,
                            },
                            {
                                type: "text",
                                text: "Check if the current website is logged in. If not logged in, output `NOT_LOGIN`. If logged in, output `LOGGED_IN`. Output directly without explanation.",
                            },
                        ],
                    },
                ],
                abortSignal: agentContext.context.controller.signal,
            };
            let result = await rlm.call(request);
            return result.text && result.text.indexOf("LOGGED_IN") > -1;
        }
        catch (error) {
            console.error("Error auto checking login status:", error);
            return false;
        }
    }
}

const TOOL_NAME$7 = "task_node_status";
class TaskNodeStatusTool {
    constructor() {
        this.name = TOOL_NAME$7;
        this.description = `After completing each step of the task, you need to call this tool to update the status of the task node, and think about the tasks to be processed and the next action plan.`;
        this.parameters = {
            type: "object",
            properties: {
                thought: {
                    type: "string",
                    description: "Current thinking content, which can be analysis of the problem, assumptions, insights, reflections, or a summary of the previous, suggest the next action step to be taken, which should be specific, executable, and verifiable."
                },
                doneIds: {
                    type: "array",
                    description: "List of completed node IDs.",
                    items: {
                        type: "number",
                    },
                },
                todoIds: {
                    type: "array",
                    description: "List of pending node IDs.",
                    items: {
                        type: "number",
                    },
                },
            },
            required: ["thought", "doneIds", "todoIds"],
        };
    }
    async execute(args, agentContext) {
        let doneIds = args.doneIds;
        let todoIds = args.todoIds;
        let agentNode = agentContext.agentChain.agent;
        let taskPrompt = agentContext.context.chain.taskPrompt;
        let agentXml = buildAgentRootXml(agentNode.xml, taskPrompt, (nodeId, node) => {
            let done = doneIds.indexOf(nodeId) > -1;
            let todo = todoIds.indexOf(nodeId) > -1;
            if (done && todo) {
                throw new Error("The ID cannot appear in both doneIds and todoIds simultaneously, nodeId: " +
                    nodeId);
            }
            node.setAttribute("status", done ? "done" : "todo");
        });
        return {
            content: [
                {
                    type: "text",
                    text: agentXml,
                },
            ],
        };
    }
}

const TOOL_NAME$6 = "variable_storage";
class VariableStorageTool {
    constructor() {
        this.name = TOOL_NAME$6;
        this.description = `Used for storing, reading, and retrieving variable data, and maintaining input/output variables in task nodes. When the same variable is stored repeatedly, it will overwrite the previous value.`;
        this.parameters = {
            type: "object",
            properties: {
                operation: {
                    type: "string",
                    description: "variable storage operation type.",
                    enum: ["read_variable", "write_variable", "list_all_variable"],
                },
                name: {
                    type: "string",
                    description: "variable name, required when reading and writing variables, If reading variables, it supports reading multiple variables separated by commas.",
                },
                value: {
                    type: "string",
                    description: "variable value, required when writing variables",
                },
            },
            required: ["operation"],
        };
    }
    async execute(args, agentContext) {
        let operation = args.operation;
        let resultText = "";
        switch (operation) {
            case "read_variable": {
                if (!args.name) {
                    resultText = "Error: name is required";
                }
                else {
                    let result = {};
                    let name = args.name;
                    let keys = name.split(",");
                    for (let i = 0; i < keys.length; i++) {
                        let key = keys[i].trim();
                        let value = agentContext.context.variables.get(key);
                        result[key] = value;
                    }
                    resultText = JSON.stringify(result);
                }
                break;
            }
            case "write_variable": {
                if (!args.name) {
                    resultText = "Error: name is required";
                    break;
                }
                if (args.value == undefined) {
                    resultText = "Error: value is required";
                    break;
                }
                let key = args.name;
                agentContext.context.variables.set(key.trim(), args.value);
                resultText = "success";
                break;
            }
            case "list_all_variable": {
                resultText = JSON.stringify([...agentContext.context.variables.keys()]);
                break;
            }
        }
        return {
            content: [
                {
                    type: "text",
                    text: resultText || "",
                },
            ],
        };
    }
}

class McpTool {
    constructor(toolWrapper) {
        this.toolWrapper = toolWrapper;
        this.name = toolWrapper.name;
        this.description = toolWrapper.getTool().description;
        this.parameters = toolWrapper.getTool().inputSchema;
    }
    async execute(args, agentContext, toolCall) {
        return this.toolWrapper.callTool(args, agentContext, toolCall);
    }
}

const TOOL_NAME$5 = "task_result_check";
class TaskResultCheckTool {
    constructor() {
        this.name = TOOL_NAME$5;
        this.description = `Check the current task execution process and results, evaluate the overall completion status of the current task, and whether the output variables in the nodes are stored.`;
        this.parameters = {
            type: "object",
            properties: {
                thought: {
                    type: "string",
                    description: "Please conduct thoughtful analysis of the overall execution process and results of the current task, analyzing whether the task has been completed.",
                },
                completionStatus: {
                    type: "string",
                    description: "The completion status of the current task is only considered complete when the entire current task is finished; partial completion or task failure is considered incomplete",
                    enum: ["completed", "incomplete"],
                },
                todoList: {
                    type: "string",
                    description: "Pending task list for incomplete tasks, when tasks are not fully completed, please describe which tasks remain to be completed",
                },
            },
            required: ["thought", "completionStatus"],
        };
    }
    async execute(args, agentContext) {
        return {
            content: [
                {
                    type: "text",
                    text: "success",
                },
            ],
        };
    }
}
async function doTaskResultCheck(agentContext, rlm, messages, tools) {
    try {
        // extract used tool
        const usedTools = extractUsedTool(messages, tools);
        const taskResultCheck = new TaskResultCheckTool();
        const newTools = mergeTools(usedTools, [
            {
                type: "function",
                name: taskResultCheck.name,
                description: taskResultCheck.description,
                inputSchema: taskResultCheck.parameters,
            },
        ]);
        // handle messages
        const newMessages = [...messages];
        newMessages.push({
            role: "user",
            content: [
                {
                    type: "text",
                    text: `Task:\n${agentContext.agentChain.agent.xml}\n\nPlease check the completion status of the current task.`,
                },
            ],
        });
        const result = await callAgentLLM(agentContext, rlm, newMessages, newTools, true, {
            type: "tool",
            toolName: taskResultCheck.name,
        });
        const toolCall = result.filter((s) => s.type == "tool-call")[0];
        const args = typeof toolCall.input == "string"
            ? JSON.parse(toolCall.input || "{}")
            : toolCall.input || {};
        const toolResult = await taskResultCheck.execute(args, agentContext);
        const callback = agentContext.context.config.callback;
        if (callback) {
            await callback.onMessage({
                streamType: "agent",
                chatId: agentContext.context.chatId,
                taskId: agentContext.context.taskId,
                agentName: agentContext.agent.Name,
                nodeId: agentContext.agentChain.agent.id,
                type: "tool_result",
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                params: args,
                toolResult: toolResult,
            }, agentContext);
        }
        if (args.completionStatus == "incomplete") {
            messages.push({
                role: "user",
                content: [
                    {
                        type: "text",
                        text: `It seems that your task has not been fully completed. Please continue with the remaining steps:\n${args.todoList || ""}`,
                    },
                ],
            });
        }
        return {
            completionStatus: args.completionStatus,
        };
    }
    catch (e) {
        Log.error("TaskResultCheckTool error", e);
        return {
            completionStatus: "completed",
        };
    }
}

const TOOL_NAME$4 = "todo_list_manager";
class TodoListManagerTool {
    constructor() {
        this.name = TOOL_NAME$4;
        this.description =
            "Current task to-do list management, used for managing the to-do list of current tasks. During task execution, the to-do list needs to be updated according to the task execution status: completed, pending. It also detects whether tasks are being executed in repetitive loops during the execution process.";
        this.parameters = {
            type: "object",
            properties: {
                completedList: {
                    type: "array",
                    description: "Current completed task list items. Please update the completed list items based on the current task completion status.",
                    items: {
                        type: "string",
                    },
                },
                todoList: {
                    type: "array",
                    description: "Current pending task list items. Please update the pending list items based on the current task pending status.",
                    items: {
                        type: "string",
                    },
                },
                loopDetection: {
                    type: "string",
                    description: "Check if the current step is being repeatedly executed by comparing with previous steps.",
                    enum: ["loop", "no_loop"],
                },
            },
            required: ["completedList", "todoList", "loopDetection"],
        };
    }
    async execute(args, agentContext) {
        return {
            content: [
                {
                    type: "text",
                    text: "success",
                },
            ],
        };
    }
}
async function doTodoListManager(agentContext, rlm, messages, tools) {
    try {
        // extract used tool
        const usedTools = extractUsedTool(messages, tools);
        const todoListManager = new TodoListManagerTool();
        const newTools = mergeTools(usedTools, [
            {
                type: "function",
                name: todoListManager.name,
                description: todoListManager.description,
                inputSchema: todoListManager.parameters,
            },
        ]);
        // handle messages
        const newMessages = [...messages];
        newMessages.push({
            role: "user",
            content: [
                {
                    type: "text",
                    text: `Task:\n${agentContext.agentChain.agent.xml}\n\nPlease check the completion status of the current task.`,
                },
            ],
        });
        const result = await callAgentLLM(agentContext, rlm, newMessages, newTools, true, {
            type: "tool",
            toolName: todoListManager.name,
        });
        const toolCall = result.filter((s) => s.type == "tool-call")[0];
        const args = typeof toolCall.input == "string"
            ? JSON.parse(toolCall.input || "{}")
            : toolCall.input || {};
        const toolResult = await todoListManager.execute(args, agentContext);
        const callback = agentContext.context.config.callback;
        if (callback) {
            await callback.onMessage({
                streamType: "agent",
                chatId: agentContext.context.chatId,
                taskId: agentContext.context.taskId,
                agentName: agentContext.agent.Name,
                nodeId: agentContext.agentChain.agent.id,
                type: "tool_result",
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                params: args,
                toolResult: toolResult,
            }, agentContext);
        }
        let userPrompt = "# Task Execution Status\n";
        if (args.completedList && args.completedList.length > 0) {
            userPrompt += "## Completed task list\n";
            for (let i = 0; i < args.completedList.length; i++) {
                userPrompt += `- ${args.completedList[i]}\n`;
            }
            userPrompt += "\n";
        }
        if (args.todoList && args.todoList.length > 0) {
            userPrompt += "## Pending task list\n";
            for (let i = 0; i < args.todoList.length; i++) {
                userPrompt += `- ${args.todoList[i]}\n`;
            }
            userPrompt += "\n";
        }
        if (args.loopDetection == "loop") {
            userPrompt += `## Loop detection\nIt seems that your task is being executed in a loop, Please change the execution strategy and try other methods to complete the current task.\n\n`;
        }
        userPrompt += "Please continue executing the remaining tasks.";
        messages.push({
            role: "user",
            content: [
                {
                    type: "text",
                    text: userPrompt.trim(),
                },
            ],
        });
    }
    catch (e) {
        Log.error("TodoListManagerTool error", e);
    }
}

const AGENT_SYSTEM_TEMPLATE = `
You are {{name}}, an autonomous AI agent for {{agent}} agent.

# Agent Description
<if description>
{{description}}
</if>
<if extSysPrompt>
{{extSysPrompt}}
</if>
<if ${TOOL_NAME$8}Tool>
* HUMAN INTERACT
During the task execution process, you can use the \`${TOOL_NAME$8}\` tool to interact with humans, please call it in the following situations:
- When performing dangerous operations such as deleting files, confirmation from humans is required.
- When encountering obstacles while accessing websites, such as requiring user login, captcha verification, QR code scanning, or human verification, you need to request manual assistance.
- Please do not use the \`${TOOL_NAME$8}\` tool frequently.
- The \`${TOOL_NAME$8}\` tool does not support parallel calls.
</if>
<if ${TOOL_NAME$6}Tool>
* VARIABLE STORAGE
When a step node has input/output variable attributes, use the \`${TOOL_NAME$6}\` tool to read from and write to these variables, these variables enable context sharing and coordination between multiple agents.
The \`${TOOL_NAME$6}\` tool does not support parallel calls.
</if>
<if ${TOOL_NAME$a}Tool>
* forEach node
For repetitive tasks, when executing a forEach node, the \`${TOOL_NAME$a}\` tool must be used. Loop tasks support parallel tool calls, and during parallel execution, this tool needs to be called interspersed throughout the process.
</if>
<if ${TOOL_NAME$9}Tool>
* watch node
monitor changes in webpage DOM elements, when executing to the watch node, require the use of the \`${TOOL_NAME$9}\` tool.
</if>

<if mainTask>
Main task: {{mainTask}}
</if>
<if preTaskResult>
Pre-task execution results:
<subtask_results>
{{preTaskResult}}
</subtask_results>
</if>

# User input task instructions
<root>
  <!-- Main task, completed through the collaboration of multiple Agents -->
  <mainTask>main task</mainTask>
  <!-- The tasks that the current agent needs to complete, the current agent only needs to complete the currentTask -->
  <currentTask>specific task</currentTask>
  <!-- Complete the corresponding step nodes of the task, Only for reference -->
  <nodes>
    <!-- node supports input/output variables to pass dependencies -->
    <node input="variable name" output="variable name" status="todo / done">task step node</node>
<if hasForEachNode>
    <!-- duplicate task node, items support list and variable -->
    <forEach items="list or variable name">
      <node>forEach item step node</node>
    </forEach>
</if>
<if hasWatchNode>
    <!-- monitor task node, the loop attribute specifies whether to listen in a loop or listen once -->
    <watch event="dom" loop="true">
      <description>Monitor task description</description>
      <trigger>
        <node>Trigger step node</node>
        <node>...</node>
      </trigger>
    </watch>
</if>
  </nodes>
</root>

Current datetime: {{datetime}}
<if canParallelToolCalls>
For maximum efficiency, when executing multiple independent operations that do not depend on each other or conflict with one another, these tools can be called in parallel simultaneously.
</if>
The output language should follow the language corresponding to the user's task.
`;
function getAgentSystemPrompt(agent, agentNode, context, tools, extSysPrompt) {
    tools = tools || agent.Tools;
    const toolVars = {};
    for (let i = 0; i < tools.length; i++) {
        toolVars[tools[i].name + "Tool"] = true;
    }
    let mainTask = "";
    let preTaskResult = "";
    if (context.chain.agents.length > 1) {
        mainTask = context.chain.taskPrompt.trim();
        preTaskResult = buildPreTaskResult(context);
    }
    const agentSysPrompt = global.prompts.get(GlobalPromptKey.agent_system) || AGENT_SYSTEM_TEMPLATE;
    return PromptTemplate.render(agentSysPrompt, {
        name: config$1.name,
        agent: agent.Name,
        description: agent.Description,
        extSysPrompt: extSysPrompt?.trim() || "",
        mainTask: mainTask,
        preTaskResult: preTaskResult.trim(),
        hasWatchNode: agentNode.xml.indexOf("</watch>") > -1,
        hasForEachNode: agentNode.xml.indexOf("</forEach>") > -1,
        canParallelToolCalls: agent.canParallelToolCalls(),
        datetime: context.variables.get("datetime") || new Date().toLocaleString(),
        ...toolVars,
    }).trim();
}
function buildPreTaskResult(context) {
    let preTaskResult = "";
    for (let i = 0; i < context.chain.agents.length; i++) {
        const agentChain = context.chain.agents[i];
        if (agentChain.agentResult) {
            preTaskResult += `<subtask_result agent="${agentChain.agent.name}">Subtask: ${agentChain.agent.task}\nResult: ${sub(agentChain.agentResult, 600)}</subtask_result>`;
        }
    }
    return preTaskResult.trim();
}
function getAgentUserPrompt(agent, agentNode, context, tools) {
    const hasTaskNodeStatusTool = (tools || agent.Tools).filter((tool) => tool.name == TOOL_NAME$7)
        .length > 0;
    return buildAgentRootXml(agentNode.xml, context.chain.taskPrompt, (nodeId, node) => {
        if (hasTaskNodeStatusTool) {
            node.setAttribute("status", "todo");
        }
    });
}

class Agent {
    constructor(params) {
        this.tools = [];
        this.name = params.name;
        this.description = params.description;
        this.tools = params.tools;
        this.llms = params.llms;
        this.mcpClient = params.mcpClient;
        this.planDescription = params.planDescription;
        this.requestHandler = params.requestHandler;
    }
    async run(context, agentChain) {
        const mcpClient = this.mcpClient || context.config.defaultMcpClient;
        const agentContext = new AgentContext(context, this, agentChain);
        try {
            this.agentContext = agentContext;
            mcpClient &&
                !mcpClient.isConnected() &&
                (await mcpClient.connect(context.controller.signal));
            return await this.runWithContext(agentContext, mcpClient, config$1.maxReactNum);
        }
        finally {
            mcpClient && (await mcpClient.close());
        }
    }
    async runWithContext(agentContext, mcpClient, maxReactNum = 100, historyMessages = []) {
        let loopNum = 0;
        let checkNum = 0;
        this.agentContext = agentContext;
        const context = agentContext.context;
        const agentNode = agentContext.agentChain.agent;
        const tools = [
            ...this.tools,
            ...this.system_auto_tools(agentNode, agentContext),
        ];
        const systemPrompt = await this.buildSystemPrompt(agentContext, tools);
        const userPrompt = await this.buildUserPrompt(agentContext, tools);
        const messages = [
            {
                role: "system",
                content: systemPrompt,
                providerOptions: defaultMessageProviderOptions(),
            },
            ...historyMessages,
            {
                role: "user",
                content: userPrompt,
                providerOptions: defaultMessageProviderOptions(),
            },
        ];
        agentContext.messages = messages;
        const rlm = new RetryLanguageModel(context.config.llms, this.llms);
        rlm.setContext(agentContext);
        let agentTools = tools;
        while (loopNum < maxReactNum) {
            await context.checkAborted();
            if (mcpClient) {
                const controlMcp = await this.controlMcpTools(agentContext, messages, loopNum);
                if (controlMcp.mcpTools) {
                    const mcpTools = await this.listTools(context, mcpClient, agentNode, controlMcp.mcpParams);
                    const usedTools = extractUsedTool(messages, agentTools);
                    const _agentTools = mergeTools(tools, usedTools);
                    agentTools = mergeTools(_agentTools, mcpTools);
                }
            }
            await this.handleMessages(agentContext, messages, tools);
            const llm_tools = convertTools(agentTools);
            const results = await callAgentLLM(agentContext, rlm, messages, llm_tools, false, undefined, 0, this.callback, this.requestHandler);
            const forceStop = agentContext.variables.get("forceStop");
            if (forceStop) {
                return forceStop;
            }
            const finalResult = await this.handleCallResult(agentContext, messages, agentTools, results);
            loopNum++;
            if (!finalResult) {
                if (config$1.mode == "expert" &&
                    loopNum % config$1.expertModeTodoLoopNum == 0) {
                    await doTodoListManager(agentContext, rlm, messages, llm_tools);
                }
                continue;
            }
            if (config$1.mode == "expert" && checkNum == 0) {
                checkNum++;
                const { completionStatus } = await doTaskResultCheck(agentContext, rlm, messages, llm_tools);
                if (completionStatus == "incomplete") {
                    continue;
                }
            }
            return finalResult;
        }
        return "Unfinished";
    }
    async handleCallResult(agentContext, messages, agentTools, results) {
        const user_messages = [];
        const toolResults = [];
        // results = memory.removeDuplicateToolUse(results);
        messages.push({
            role: "assistant",
            content: results,
        });
        if (results.length == 0) {
            return null;
        }
        if (results.every((s) => s.type == "text")) {
            return results.map((s) => s.text).join("\n\n");
        }
        const toolCalls = results.filter((s) => s.type == "tool-call");
        if (toolCalls.length > 1 &&
            this.canParallelToolCalls(toolCalls) &&
            toolCalls.every((s) => agentTools.find((t) => t.name == s.toolName)?.supportParallelCalls)) {
            const results = await Promise.all(toolCalls.map((toolCall) => this.callToolCall(agentContext, agentTools, toolCall, user_messages)));
            for (let i = 0; i < results.length; i++) {
                toolResults.push(results[i]);
            }
        }
        else {
            for (let i = 0; i < toolCalls.length; i++) {
                const toolCall = toolCalls[i];
                const toolResult = await this.callToolCall(agentContext, agentTools, toolCall, user_messages);
                toolResults.push(toolResult);
            }
        }
        if (toolResults.length > 0) {
            messages.push({
                role: "tool",
                content: toolResults,
            });
            user_messages.forEach((message) => messages.push(message));
            return null;
        }
        else {
            return results
                .filter((s) => s.type == "text")
                .map((s) => s.text)
                .join("\n\n");
        }
    }
    async callToolCall(agentContext, agentTools, result, user_messages = []) {
        const context = agentContext.context;
        const toolChain = new ToolChain(result, agentContext.agentChain.agentRequest);
        agentContext.agentChain.push(toolChain);
        let toolResult;
        try {
            const args = typeof result.input == "string"
                ? JSON.parse(result.input || "{}")
                : result.input || {};
            toolChain.params = args;
            let tool = getTool(agentTools, result.toolName);
            if (!tool) {
                throw new Error(result.toolName + " tool does not exist");
            }
            toolResult = await tool.execute(args, agentContext, result);
            toolChain.updateToolResult(toolResult);
            agentContext.consecutiveErrorNum = 0;
        }
        catch (e) {
            Log.error("tool call error: ", result.toolName, result.input, e);
            toolResult = {
                content: [
                    {
                        type: "text",
                        text: e + "",
                    },
                ],
                isError: true,
            };
            toolChain.updateToolResult(toolResult);
            if (++agentContext.consecutiveErrorNum >= 10) {
                throw e;
            }
        }
        const callback = this.callback || context.config.callback;
        if (callback) {
            await callback.onMessage({
                streamType: "agent",
                chatId: context.chatId,
                taskId: context.taskId,
                agentName: agentContext.agent.Name,
                nodeId: agentContext.agentChain.agent.id,
                type: "tool_result",
                toolCallId: result.toolCallId,
                toolName: result.toolName,
                params: result.input || {},
                toolResult: toolResult,
            }, agentContext);
        }
        return convertToolResult(result, toolResult, user_messages);
    }
    system_auto_tools(agentNode, agentContext) {
        const tools = [];
        const agentNodeXml = agentNode.xml;
        const hasVariable = agentNodeXml.indexOf("input=") > -1 ||
            agentNodeXml.indexOf("output=") > -1;
        if (hasVariable) {
            tools.push(new VariableStorageTool());
        }
        const hasForeach = agentNodeXml.indexOf("</forEach>") > -1;
        if (hasForeach) {
            tools.push(new ForeachTaskTool());
        }
        const hasWatch = agentNodeXml.indexOf("</watch>") > -1;
        if (hasWatch) {
            tools.push(new WatchTriggerTool());
        }
        const callback = this.callback || agentContext.context.config.callback;
        if (callback?.onHumanConfirm ||
            callback?.onHumanInput ||
            callback?.onHumanSelect ||
            callback?.onHumanHelp) {
            tools.push(new HumanInteractTool());
        }
        const toolNames = this.tools.map((tool) => tool.name);
        return tools.filter((tool) => toolNames.indexOf(tool.name) == -1);
    }
    async buildSystemPrompt(agentContext, tools) {
        return getAgentSystemPrompt(this, agentContext.agentChain.agent, agentContext.context, tools, await this.extSysPrompt(agentContext, tools));
    }
    async buildUserPrompt(agentContext, tools) {
        return [
            {
                type: "text",
                text: getAgentUserPrompt(this, agentContext.agentChain.agent, agentContext.context, tools),
            },
        ];
    }
    async extSysPrompt(agentContext, tools) {
        return "";
    }
    async listTools(context, mcpClient, agentNode, mcpParams) {
        try {
            if (!mcpClient.isConnected()) {
                await mcpClient.connect(context.controller.signal);
            }
            let list = await mcpClient.listTools({
                taskId: context.taskId,
                nodeId: agentNode?.id,
                environment: config$1.platform,
                agent_name: agentNode?.name || this.name,
                params: {},
                prompt: agentNode?.task || context.chain.taskPrompt,
                ...(mcpParams || {}),
            }, context.controller.signal);
            let mcpTools = [];
            for (let i = 0; i < list.length; i++) {
                let toolSchema = list[i];
                let execute = this.toolExecuter(mcpClient, toolSchema.name);
                let toolWrapper = new ToolWrapper(toolSchema, execute);
                mcpTools.push(new McpTool(toolWrapper));
            }
            return mcpTools;
        }
        catch (e) {
            Log.error("Mcp listTools error", e);
            return [];
        }
    }
    async controlMcpTools(agentContext, messages, loopNum) {
        return {
            mcpTools: loopNum == 0,
        };
    }
    toolExecuter(mcpClient, name) {
        return {
            execute: async function (args, agentContext) {
                return await mcpClient.callTool({
                    name: name,
                    arguments: args,
                    extInfo: {
                        taskId: agentContext.context.taskId,
                        nodeId: agentContext.agentChain.agent.id,
                        environment: config$1.platform,
                        agent_name: agentContext.agent.Name,
                    },
                }, agentContext.context.controller.signal);
            },
        };
    }
    async handleMessages(agentContext, messages, tools) {
        // Only keep the last image / file, large tool-text-result
        handleLargeContextMessages(messages);
    }
    async callInnerTool(fun) {
        let result = await fun();
        return {
            content: [
                {
                    type: "text",
                    text: result
                        ? typeof result == "string"
                            ? result
                            : JSON.stringify(result)
                        : "Successful",
                },
            ],
        };
    }
    async loadTools(context) {
        if (this.mcpClient) {
            let mcpTools = await this.listTools(context, this.mcpClient);
            if (mcpTools && mcpTools.length > 0) {
                return mergeTools(this.tools, mcpTools);
            }
        }
        return this.tools;
    }
    addTool(tool) {
        this.tools.push(tool);
    }
    async onTaskStatus(status, reason) {
        if (status == "abort" && this.agentContext) {
            this.agentContext?.variables.clear();
        }
    }
    canParallelToolCalls(toolCalls) {
        return config$1.parallelToolCalls;
    }
    get Llms() {
        return this.llms;
    }
    get Name() {
        return this.name;
    }
    get Description() {
        return this.description;
    }
    get Tools() {
        return this.tools;
    }
    get PlanDescription() {
        return this.planDescription;
    }
    get McpClient() {
        return this.mcpClient;
    }
    get AgentContext() {
        return this.agentContext;
    }
}

function extract_page_content(max_url_length = 200, max_content_length = 50000) {
    let result = "";
    max_url_length = max_url_length || 200;
    try {
        function traverse(node) {
            if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toLowerCase();
                if (["script", "style", "noscript"].includes(tagName)) {
                    return;
                }
                const style = window.getComputedStyle(node);
                if (style.display == "none" ||
                    style.visibility == "hidden" ||
                    style.opacity == "0") {
                    return;
                }
            }
            if (node.nodeType === Node.TEXT_NODE) {
                // text
                const text = node.textContent.trim();
                if (text) {
                    result += text + " ";
                }
            }
            else if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toLowerCase();
                if (["input", "select", "textarea"].includes(tagName)) {
                    // input / select / textarea
                    if (tagName == "input" && node.type == "checkbox") {
                        result += node.checked + " ";
                    }
                    else if (tagName == "input" && node.type == "radio") {
                        if (node.checked && node.value) {
                            result += node.value + " ";
                        }
                    }
                    else if (node.value) {
                        result += node.value + " ";
                    }
                }
                else if (tagName === "img") {
                    // image
                    const src = node.src ||
                        node.getAttribute("src") ||
                        node.getAttribute("data-src");
                    const alt = node.alt || node.title || "";
                    if (src &&
                        src.length <= max_url_length &&
                        node.width * node.height >= 10000 &&
                        src.startsWith("http")) {
                        result += `![${alt ? alt : "image"}](${src.trim()}) `;
                    }
                }
                else if (tagName === "a" && node.children.length == 0) {
                    // link
                    const href = node.href || node.getAttribute("href");
                    const text = node.innerText.trim() || node.title;
                    if (text &&
                        href &&
                        href.length <= max_url_length &&
                        href.startsWith("http")) {
                        result += `[${text}](${href.trim()}) `;
                    }
                    else {
                        result += text + " ";
                    }
                }
                else if (tagName === "video" || tagName == "audio") {
                    // video / audio
                    let src = node.src || node.getAttribute("src");
                    const sources = node.querySelectorAll("source");
                    if (sources.length > 0 && sources[0].src) {
                        src = sources[0].src;
                        if (src && src.startsWith("http") && sources[0].type) {
                            result += sources[0].type + " ";
                        }
                    }
                    if (src && src.startsWith("http")) {
                        result += src.trim() + " ";
                    }
                }
                else if (tagName === "br") {
                    // br
                    result += "\n";
                }
                else if (["p", "div", "h1", "h2", "h3", "h4", "h5", "h6"].includes(tagName)) {
                    // block
                    result += "\n";
                    for (let child of node.childNodes) {
                        traverse(child);
                    }
                    result += "\n";
                    return;
                }
                else if (tagName === "hr") {
                    // hr
                    result += "\n--------\n";
                }
                else {
                    // recursive
                    for (let child of node.childNodes) {
                        traverse(child);
                    }
                }
            }
        }
        traverse(document.body);
    }
    catch (e) {
        result = document.body.innerText;
    }
    result = result.replace(/\s*\n/g, "\n").replace(/\n+/g, "\n").trim();
    if (result.length > max_content_length) {
        // result = result.slice(0, max_content_length) + "...";
        result = Array.from(result).slice(0, max_content_length).join("") + "...";
    }
    return result;
}
function mark_screenshot_highlight_elements(screenshot, area_map, client_rect) {
    return new Promise(async (resolve, reject) => {
        try {
            const hasOffscreen = typeof OffscreenCanvas !== "undefined";
            const hasCreateImageBitmap = typeof createImageBitmap !== "undefined";
            const hasDOM = typeof document !== "undefined" && typeof Image !== "undefined";
            // @ts-ignore
            const isNode = typeof window === "undefined" && typeof process !== "undefined" && !!process.versions && !!process.versions.node;
            const loadImageAny = async () => {
                if (hasCreateImageBitmap) {
                    const base64Data = screenshot.imageBase64;
                    const binaryString = atob(base64Data);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    const blob = new Blob([bytes], { type: screenshot.imageType });
                    const imageBitmap = await createImageBitmap(blob, {
                        resizeQuality: "high",
                        resizeWidth: client_rect.width,
                        resizeHeight: client_rect.height,
                    });
                    return { img: imageBitmap };
                }
                if (hasDOM) {
                    const img = await new Promise((resolveImg, rejectImg) => {
                        const image = new Image();
                        image.onload = () => resolveImg(image);
                        image.onerror = (e) => rejectImg(e);
                        image.src = `data:${screenshot.imageType};base64,${screenshot.imageBase64}`;
                    });
                    return { img };
                }
                if (isNode) {
                    const canvasMod = await loadPackage("canvas");
                    const { loadImage } = canvasMod;
                    const dataUrl = `data:${screenshot.imageType};base64,${screenshot.imageBase64}`;
                    const img = await loadImage(dataUrl);
                    return { img };
                }
                throw new Error("No image environment available");
            };
            const createCanvasAny = async (width, height) => {
                if (hasOffscreen) {
                    const canvas = new OffscreenCanvas(width, height);
                    return {
                        ctx: canvas.getContext("2d"),
                        exportDataUrl: async (mime) => {
                            const blob = await canvas.convertToBlob({ type: mime });
                            return await new Promise((res, rej) => {
                                const reader = new FileReader();
                                reader.onloadend = () => res(reader.result);
                                reader.onerror = () => rej(new Error("Failed to convert blob to base64"));
                                reader.readAsDataURL(blob);
                            });
                        },
                    };
                }
                if (hasDOM) {
                    const canvas = document.createElement("canvas");
                    canvas.width = width;
                    canvas.height = height;
                    return {
                        ctx: canvas.getContext("2d"),
                        exportDataUrl: async (mime) => canvas.toDataURL(mime),
                    };
                }
                if (isNode) {
                    const canvasMod = await loadPackage("canvas");
                    const { createCanvas } = canvasMod;
                    const canvas = createCanvas(width, height);
                    return {
                        ctx: canvas.getContext("2d"),
                        exportDataUrl: async (mime) => canvas.toDataURL(mime),
                    };
                }
                throw new Error("No canvas environment available");
            };
            const loaded = await loadImageAny();
            const targetWidth = client_rect.width;
            const targetHeight = client_rect.height;
            const { ctx, exportDataUrl } = await createCanvasAny(targetWidth, targetHeight);
            if (!ctx) {
                reject(new Error("Failed to get canvas context"));
                return;
            }
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = "high";
            ctx.drawImage(loaded.img, 0, 0, targetWidth, targetHeight);
            const sortedEntries = Object.entries(area_map)
                .filter(([id, area]) => area.width > 0 && area.height > 0)
                .sort((a, b) => {
                const areaA = a[1].width * a[1].height;
                const areaB = b[1].width * b[1].height;
                return areaB - areaA;
            });
            const colors = [
                "#FF0000",
                "#00FF00",
                "#0000FF",
                "#FFA500",
                "#800080",
                "#008080",
                "#FF69B4",
                "#4B0082",
                "#FF4500",
                "#2E8B57",
                "#DC143C",
                "#4682B4",
            ];
            sortedEntries.forEach(([id, area], index) => {
                const color = colors[index % colors.length];
                if (area.width * area.height < 40000) {
                    // Draw a background color
                    ctx.fillStyle = color + "1A";
                    ctx.fillRect(area.x, area.y, area.width, area.height);
                }
                // Draw a border
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.strokeRect(area.x, area.y, area.width, area.height);
                // Draw ID tag background
                const fontSize = Math.min(12, Math.max(8, area.height / 2));
                ctx.font = `${fontSize}px sans-serif`;
                const metrics = ctx.measureText(id);
                const textWidth = metrics && metrics.width ? metrics.width : 0;
                const padding = 4;
                const labelWidth = textWidth + padding * 2;
                const labelHeight = fontSize + padding * 2;
                // The tag position is in the upper right corner.
                const labelX = area.x + area.width - labelWidth;
                let labelY = area.y;
                // Adjust if box is too small
                if (area.width < labelWidth + 4 || area.height < labelHeight + 4) {
                    // Position outside the box if it's too small
                    labelY = area.y - labelHeight;
                }
                // Draw label background
                ctx.fillStyle = color;
                ctx.fillRect(labelX, labelY, labelWidth, labelHeight);
                // Draw ID text
                ctx.fillStyle = "#FFFFFF";
                ctx.textBaseline = "top";
                ctx.fillText(id, labelX + padding, labelY + padding);
            });
            // Export the image
            const out = await exportDataUrl(screenshot.imageType);
            resolve(out);
        }
        catch (error) {
            reject(error);
        }
    });
}

const AGENT_NAME = "Browser";
class BaseBrowserAgent extends Agent {
    async go_back(agentContext) {
        try {
            await this.execute_script(agentContext, () => {
                window.navigation.back();
            }, []);
            await sleep(100);
        }
        catch (e) { }
    }
    async extract_page_content(agentContext, variable_name) {
        let content = await this.execute_script(agentContext, extract_page_content, []);
        let pageInfo = await this.get_current_page(agentContext);
        let result = `title: ${pageInfo.title}\npage_url: ${pageInfo.url}\npage_content: \n${content}`;
        if (variable_name) {
            agentContext.context.variables.set(variable_name, result);
        }
        return {
            title: pageInfo.title || "",
            page_url: pageInfo.url,
            page_content: content,
        };
    }
    async controlMcpTools(agentContext, messages, loopNum) {
        if (loopNum > 0) {
            let url = null;
            try {
                url = (await this.get_current_page(agentContext)).url;
            }
            catch (e) { }
            let lastUrl = agentContext.variables.get("lastUrl");
            agentContext.variables.set("lastUrl", url);
            return {
                mcpTools: loopNum == 0 || url != lastUrl,
                mcpParams: {
                    environment: "browser",
                    browser_url: url,
                },
            };
        }
        else {
            return {
                mcpTools: true,
                mcpParams: {
                    environment: "browser",
                },
            };
        }
    }
    toolExecuter(mcpClient, name) {
        return {
            execute: async (args, agentContext) => {
                let result = await mcpClient.callTool({
                    name: name,
                    arguments: args,
                    extInfo: {
                        taskId: agentContext.context.taskId,
                        nodeId: agentContext.agentChain.agent.id,
                        environment: "browser",
                        agent_name: agentContext.agent.Name,
                        browser_url: agentContext.variables.get("lastUrl"),
                    },
                }, agentContext.context.controller.signal);
                if (result.extInfo &&
                    result.extInfo["javascript"] &&
                    result.content[0].type == "text") {
                    let script = result.content[0].text;
                    let params = JSON.stringify(args);
                    let runScript = `${script};execute(${params})`;
                    let scriptResult = await this.execute_mcp_script(agentContext, runScript);
                    let resultText;
                    if (typeof scriptResult == "string" ||
                        typeof scriptResult == "number") {
                        resultText = scriptResult + "";
                    }
                    else {
                        resultText = scriptResult
                            ? JSON.stringify(scriptResult)
                            : "Successful";
                    }
                    return {
                        content: [
                            {
                                type: "text",
                                text: resultText,
                            },
                        ],
                    };
                }
                return result;
            },
        };
    }
    async get_current_page(agentContext) {
        return await this.execute_script(agentContext, () => {
            return {
                url: window.location.href,
                title: window.document.title,
            };
        }, []);
    }
    lastToolResult(messages) {
        let lastMessage = messages[messages.length - 1];
        if (lastMessage.role != "tool") {
            return null;
        }
        let toolResult = lastMessage.content.filter((t) => t.type == "tool-result")[0];
        if (!toolResult) {
            return null;
        }
        let result = toolResult.output.value;
        for (let i = messages.length - 2; i > 0; i--) {
            if (messages[i].role !== "assistant" ||
                typeof messages[i].content == "string") {
                continue;
            }
            for (let j = 0; j < messages[i].content.length; j++) {
                let content = messages[i].content[j];
                if (typeof content !== "string" && content.type !== "tool-call") {
                    continue;
                }
                let toolUse = content;
                if (toolResult.toolCallId != toolUse.toolCallId) {
                    continue;
                }
                return {
                    id: toolResult.toolCallId,
                    toolName: toolUse.toolName,
                    args: toolUse.input,
                    result,
                };
            }
        }
        return null;
    }
    toolUseNames(messages) {
        let toolNames = [];
        if (!messages) {
            return toolNames;
        }
        for (let i = 0; i < messages.length; i++) {
            let message = messages[i];
            if (message.role == "tool") {
                toolNames.push(message.content[0].toolName);
            }
        }
        return toolNames;
    }
    async execute_mcp_script(agentContext, script) {
        return;
    }
}

// @ts-nocheck
function run_build_dom_tree() {
    var computedStyleCache = new WeakMap();
    /**
     * Gets the cached computed style for an element.
     */
    function getCachedComputedStyle(element) {
        if (!element)
            return null;
        if (computedStyleCache.has(element)) {
            return computedStyleCache.get(element);
        }
        try {
            const style = window.getComputedStyle(element);
            if (style) {
                computedStyleCache.set(element, style);
            }
            return style;
        }
        catch (e) {
            return null;
        }
    }
    /**
     * Get clickable elements on the page
     *
     * @param {*} markHighlightElements Is mark highlighted
     * @param {*} includeAttributes [attr_names...]
     * @returns { element_str, client_rect, selector_map, area_map }
     */
    function get_clickable_elements(markHighlightElements = true, includeAttributes) {
        window.clickable_elements = {};
        computedStyleCache = new WeakMap();
        document.querySelectorAll("[eko-user-highlight-id]").forEach(ele => ele.removeAttribute("eko-user-highlight-id"));
        let page_tree = build_dom_tree(markHighlightElements);
        let element_tree = parse_node(page_tree);
        let element_str = clickable_elements_to_string(element_tree, includeAttributes);
        let client_rect = {
            width: window.innerWidth || document.documentElement.clientWidth,
            height: window.innerHeight || document.documentElement.clientHeight,
        };
        if (markHighlightElements) {
            let selector_map = {};
            // selector_map = create_selector_map(element_tree);
            return { element_str, client_rect, selector_map };
        }
        else {
            let area_map = create_area_map(element_tree);
            return { element_str, client_rect, area_map };
        }
    }
    function get_highlight_element(highlightIndex) {
        let element = document.querySelector(`[eko-user-highlight-id="eko-highlight-${highlightIndex}"]`);
        return element || window.clickable_elements[highlightIndex];
    }
    function remove_highlight() {
        let highlight = document.getElementById('eko-highlight-container');
        if (highlight) {
            highlight.remove();
        }
        computedStyleCache = new WeakMap();
    }
    function clickable_elements_to_string(element_tree, includeAttributes) {
        if (!includeAttributes) {
            includeAttributes = [
                'id',
                'title',
                'type',
                'name',
                'role',
                'class',
                'src',
                'href',
                'aria-label',
                'placeholder',
                'value',
                'alt',
                'aria-expanded',
            ];
        }
        function get_all_text_till_next_clickable_element(element_node) {
            let text_parts = [];
            function collect_text(node) {
                if (node.tagName && node != element_node && node.highlightIndex != null) {
                    return;
                }
                if (!node.tagName && node.text) {
                    text_parts.push(node.text);
                }
                else if (node.tagName) {
                    for (let i = 0; i < node.children.length; i++) {
                        collect_text(node.children[i]);
                    }
                }
            }
            collect_text(element_node);
            return text_parts.join('\n').trim().replace(/\n+/g, ' ');
        }
        function has_parent_with_highlight_index(node) {
            let current = node.parent;
            while (current) {
                if (current.highlightIndex != null) {
                    return true;
                }
                current = current.parent;
            }
            return false;
        }
        let formatted_text = [];
        function process_node(node, depth) {
            if (node.text == null) {
                if (node.highlightIndex != null) {
                    let attributes_str = '';
                    if (includeAttributes) {
                        for (let i = 0; i < includeAttributes.length; i++) {
                            let key = includeAttributes[i];
                            let value = node.attributes[key];
                            if (key == "class" && value && value.length > 30) {
                                let classList = value.split(" ").slice(0, 3);
                                value = classList.join(" ");
                            }
                            else if ((key == "src" || key == "href") && value && value.length > 200) {
                                continue;
                            }
                            else if ((key == "src" || key == "href") && value && value.startsWith("/")) {
                                value = window.location.origin + value;
                            }
                            if (key && value) {
                                attributes_str += ` ${key}="${value}"`;
                            }
                        }
                        attributes_str = attributes_str.replace(/\n+/g, ' ');
                    }
                    let text = get_all_text_till_next_clickable_element(node);
                    formatted_text.push(`[${node.highlightIndex}]:<${node.tagName}${attributes_str}>${text}</${node.tagName}>`);
                }
                for (let i = 0; i < node.children.length; i++) {
                    let child = node.children[i];
                    process_node(child);
                }
            }
            else if (!has_parent_with_highlight_index(node)) {
                formatted_text.push(`[]:${node.text}`);
            }
        }
        process_node(element_tree);
        return formatted_text.join('\n');
    }
    function create_area_map(element_tree) {
        let area_map = {};
        function process_node(node) {
            if (node.tagName) {
                if (node.highlightIndex != null) {
                    const element = window.clickable_elements[node.highlightIndex];
                    area_map[node.highlightIndex] = get_element_real_bounding_rect(element);
                }
                for (let i = 0; i < node.children.length; i++) {
                    process_node(node.children[i]);
                }
            }
        }
        process_node(element_tree);
        return area_map;
    }
    function get_element_real_bounding_rect(element) {
        if (!element || !(element instanceof Element)) {
            return { x: 0, y: 0, width: 0, height: 0 };
        }
        let rect = element.getBoundingClientRect();
        let x = rect.left;
        let y = rect.top;
        let width = rect.width;
        let height = rect.height;
        let win = element.ownerDocument.defaultView;
        let maxDepth = 10;
        let depth = 0;
        while (win && win !== win.parent && depth < maxDepth) {
            depth++;
            const frameElement = win.frameElement;
            if (!frameElement) {
                break;
            }
            const frameRect = frameElement.getBoundingClientRect();
            x += frameRect.left;
            y += frameRect.top;
            // Consider the border and padding of the iframe.
            const frameStyle = getCachedComputedStyle(frameElement);
            x += parseFloat(frameStyle.borderLeftWidth) || 0;
            y += parseFloat(frameStyle.borderTopWidth) || 0;
            x += parseFloat(frameStyle.paddingLeft) || 0;
            y += parseFloat(frameStyle.paddingTop) || 0;
            win = win.parent;
        }
        return { x, y, width, height };
    }
    function parse_node(node_data, parent) {
        if (!node_data) {
            return;
        }
        if (node_data.type == 'TEXT_NODE') {
            return {
                text: node_data.text || '',
                isVisible: node_data.isVisible || false,
                parent: parent,
            };
        }
        let element_node = {
            tagName: node_data.tagName,
            xpath: node_data.xpath,
            highlightIndex: node_data.highlightIndex,
            attributes: node_data.attributes || {},
            isVisible: node_data.isVisible || false,
            isInteractive: node_data.isInteractive || false,
            isTopElement: node_data.isTopElement || false,
            shadowRoot: node_data.shadowRoot || false,
            children: [],
            parent: parent,
        };
        if (node_data.children) {
            let children = [];
            for (let i = 0; i < node_data.children.length; i++) {
                let child = node_data.children[i];
                if (child) {
                    let child_node = parse_node(child, element_node);
                    if (child_node) {
                        children.push(child_node);
                    }
                }
            }
            element_node.children = children;
        }
        return element_node;
    }
    function build_dom_tree(markHighlightElements) {
        let highlightIndex = 0; // Reset highlight index
        let duplicates = new Set();
        function highlightElement(element, index, parentIframe = null) {
            // Create or get highlight container
            let container = document.getElementById('eko-highlight-container');
            if (!container) {
                container = document.createElement('div');
                container.id = 'eko-highlight-container';
                container.style.position = 'fixed';
                container.style.pointerEvents = 'none';
                container.style.top = '0';
                container.style.left = '0';
                container.style.width = '100%';
                container.style.height = '100%';
                container.style.zIndex = '2147483647'; // Maximum z-index value
                document.documentElement.appendChild(container);
            }
            // Generate a color based on the index
            const colors = [
                '#FF0000',
                '#00FF00',
                '#0000FF',
                '#FFA500',
                '#800080',
                '#008080',
                '#FF69B4',
                '#4B0082',
                '#FF4500',
                '#2E8B57',
                '#DC143C',
                '#4682B4',
            ];
            const colorIndex = index % colors.length;
            const baseColor = colors[colorIndex];
            const backgroundColor = `${baseColor}1A`; // 10% opacity version of the color
            // Create highlight overlay
            const overlay = document.createElement('div');
            overlay.style.position = 'absolute';
            overlay.style.border = `2px solid ${baseColor}`;
            overlay.style.pointerEvents = 'none';
            overlay.style.boxSizing = 'border-box';
            // Position overlay based on element
            const rect = element.getBoundingClientRect();
            let top = rect.top;
            let left = rect.left;
            if (rect.width < window.innerWidth / 2 || rect.height < window.innerHeight / 2) {
                overlay.style.backgroundColor = backgroundColor;
            }
            // Adjust position if element is inside an iframe
            if (parentIframe) {
                const iframeRect = parentIframe.getBoundingClientRect();
                top += iframeRect.top;
                left += iframeRect.left;
            }
            overlay.style.top = `${top}px`;
            overlay.style.left = `${left}px`;
            overlay.style.width = `${rect.width}px`;
            overlay.style.height = `${rect.height}px`;
            // Create label
            const label = document.createElement('div');
            label.className = 'eko-highlight-label';
            label.style.position = 'absolute';
            label.style.background = baseColor;
            label.style.color = 'white';
            label.style.padding = '1px 4px';
            label.style.borderRadius = '4px';
            label.style.fontSize = `${Math.min(12, Math.max(8, rect.height / 2))}px`; // Responsive font size
            label.textContent = index;
            // Calculate label position
            const labelWidth = 20; // Approximate width
            const labelHeight = 16; // Approximate height
            // Default position (top-right corner inside the box)
            let labelTop = top + 2;
            let labelLeft = left + rect.width - labelWidth - 2;
            // Adjust if box is too small
            if (rect.width < labelWidth + 4 || rect.height < labelHeight + 4) {
                // Position outside the box if it's too small
                labelTop = top - labelHeight - 2;
                labelLeft = left + rect.width - labelWidth;
            }
            // Ensure label stays within viewport
            if (labelTop < 0)
                labelTop = top + 2;
            if (labelLeft < 0)
                labelLeft = left + 2;
            if (labelLeft + labelWidth > window.innerWidth) {
                labelLeft = left + rect.width - labelWidth - 2;
            }
            label.style.top = `${labelTop}px`;
            label.style.left = `${labelLeft}px`;
            // Add to container
            container.appendChild(overlay);
            container.appendChild(label);
            // Store reference for cleanup
            element.setAttribute('eko-user-highlight-id', `eko-highlight-${index}`);
            return index + 1;
        }
        // Helper function to generate XPath as a tree
        function getXPathTree(element, stopAtBoundary = true) {
            const segments = [];
            let currentElement = element;
            while (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {
                // Stop if we hit a shadow root or iframe
                if (stopAtBoundary &&
                    (currentElement.parentNode instanceof ShadowRoot ||
                        currentElement.parentNode instanceof HTMLIFrameElement)) {
                    break;
                }
                let index = 0;
                let sibling = currentElement.previousSibling;
                while (sibling) {
                    if (sibling.nodeType === Node.ELEMENT_NODE &&
                        sibling.nodeName === currentElement.nodeName) {
                        index++;
                    }
                    sibling = sibling.previousSibling;
                }
                const tagName = currentElement.nodeName.toLowerCase();
                const xpathIndex = index > 0 ? `[${index + 1}]` : '';
                segments.unshift(`${tagName}${xpathIndex}`);
                currentElement = currentElement.parentNode;
            }
            return segments.join('/');
        }
        // Helper function to check if element is accepted
        function isElementAccepted(element) {
            const leafElementDenyList = new Set(['svg', 'script', 'style', 'link', 'meta', 'noscript', 'template']);
            return !leafElementDenyList.has(element.tagName.toLowerCase());
        }
        // Helper function to check if element is interactive
        function isInteractiveElement(element) {
            if (!element || element.nodeType !== Node.ELEMENT_NODE) {
                return false;
            }
            // Base interactive elements and roles
            const interactiveElements = new Set([
                'a',
                'button',
                'details',
                'embed',
                'input',
                'label',
                'menu',
                'menuitem',
                'object',
                'select',
                'textarea',
                'summary',
                'option',
                'optgroup',
                'fieldset',
                'legend',
            ]);
            const interactiveRoles = new Set([
                'button',
                'menu',
                'menuitem',
                'menubar',
                'link',
                'checkbox',
                'radio',
                'slider',
                'tab',
                'tabpanel',
                'textbox',
                'combobox',
                'grid',
                'listbox',
                'option',
                'progressbar',
                'scrollbar',
                'searchbox',
                'switch',
                'tree',
                'treeitem',
                'spinbutton',
                'tooltip',
                'a-button-inner',
                'a-dropdown-button',
                'click',
                'menuitemcheckbox',
                'menuitemradio',
                'a-button-text',
                'button-text',
                'button-icon',
                'button-icon-only',
                'button-text-icon-only',
                'dropdown',
                'combobox',
            ]);
            const tagName = element.tagName.toLowerCase();
            const role = element.getAttribute('role');
            const ariaRole = element.getAttribute('aria-role');
            const tabIndex = element.getAttribute('tabindex');
            // Basic role/attribute checks
            const hasInteractiveRole = interactiveElements.has(tagName) ||
                interactiveRoles.has(role) ||
                interactiveRoles.has(ariaRole) ||
                (tabIndex !== null && tabIndex !== '-1') ||
                element.getAttribute('data-action') === 'a-dropdown-select' ||
                element.getAttribute('data-action') === 'a-dropdown-button' ||
                element.getAttribute('contenteditable') === 'true';
            if (hasInteractiveRole)
                return true;
            // const eventTypes = [
            //   'click',
            //   'mousedown',
            //   'mouseup',
            //   'touchstart',
            //   'touchend',
            //   'keydown',
            //   'keyup',
            //   'focus',
            //   'blur',
            // ];
            const clickEventTypes = [
                'click',
                'mousedown',
                'mouseup',
                'touchstart',
                'touchend',
            ];
            // Filter elements that have no real event listeners at all
            if (window.getEventListeners) {
                const listeners = window.getEventListeners(element);
                const hasRealClickListeners = clickEventTypes.some((type) => listeners[type]?.length > 0);
                if (!hasRealClickListeners) {
                    return false;
                }
            }
            // Check for event listeners
            const hasClickHandler = element.onclick !== null ||
                element.getAttribute('onclick') !== null ||
                element.hasAttribute('ng-click') ||
                element.hasAttribute('@click') ||
                element.hasAttribute('v-on:click');
            // Helper function to safely get event listeners
            function getElementEventListeners(el) {
                // List of common event types to check
                const listeners = {};
                for (const type of clickEventTypes) {
                    const handler = el[`on${type}`];
                    if (handler) {
                        listeners[type] = [
                            {
                                listener: handler,
                                useCapture: false,
                            },
                        ];
                    }
                }
                return listeners;
            }
            // Check for click-related events on the element itself
            const listeners = getElementEventListeners(element);
            const hasClickListeners = clickEventTypes.some((type) => listeners[type]?.length > 0);
            // Check for ARIA properties that suggest interactivity
            const hasAriaProps = element.hasAttribute('aria-expanded') ||
                element.hasAttribute('aria-pressed') ||
                element.hasAttribute('aria-selected') ||
                element.hasAttribute('aria-checked');
            // Check if element is draggable
            const isDraggable = element.draggable || element.getAttribute('draggable') === 'true';
            if (hasAriaProps || hasClickHandler || hasClickListeners || isDraggable) {
                return true;
            }
            // Check if element has click-like styling
            let hasClickStyling = element.style.cursor === 'pointer' || getCachedComputedStyle(element).cursor === 'pointer';
            if (hasClickStyling) {
                let count = 0;
                let current = element.parentElement;
                while (current && current !== document.documentElement) {
                    hasClickStyling = current.style.cursor === 'pointer' || getCachedComputedStyle(current).cursor === 'pointer';
                    if (hasClickStyling)
                        return false;
                    current = current.parentElement;
                    if (++count > 10)
                        break;
                }
                return true;
            }
            return false;
        }
        // Helper function to check if element is visible
        function isElementVisible(element) {
            if (element.offsetWidth === 0 && element.offsetHeight === 0) {
                return false;
            }
            const style = getCachedComputedStyle(element);
            return (style?.visibility !== 'hidden' &&
                style?.display !== 'none');
        }
        // Helper function to check if element is the top element at its position
        function isTopElement(element) {
            // Find the correct document context and root element
            let doc = element.ownerDocument;
            // If we're in an iframe, elements are considered top by default
            if (doc !== window.document) {
                return true;
            }
            // For shadow DOM, we need to check within its own root context
            const shadowRoot = element.getRootNode();
            if (shadowRoot instanceof ShadowRoot) {
                const rect = element.getBoundingClientRect();
                const point = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                try {
                    // Use shadow root's elementFromPoint to check within shadow DOM context
                    const topEl = shadowRoot.elementFromPoint(point.x, point.y);
                    if (!topEl)
                        return false;
                    // Check if the element or any of its parents match our target element
                    let count = 0;
                    let current = topEl;
                    while (current && current !== shadowRoot) {
                        if (current === element)
                            return true;
                        current = current.parentElement;
                        if (++count > 15)
                            break;
                    }
                    return false;
                }
                catch (e) {
                    return true; // If we can't determine, consider it visible
                }
            }
            // Regular DOM elements
            const rect = element.getBoundingClientRect();
            const point = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
            try {
                const topEl = document.elementFromPoint(point.x, point.y);
                if (!topEl)
                    return false;
                let count = 0;
                let current = topEl;
                while (current && current !== document.documentElement) {
                    if (current === element)
                        return true;
                    current = current.parentElement;
                    if (++count > 15)
                        break;
                }
                return false;
            }
            catch (e) {
                return true;
            }
        }
        // Helper function to check if text node is visible
        function isTextNodeVisible(textNode) {
            const range = document.createRange();
            range.selectNodeContents(textNode);
            const rect = range.getBoundingClientRect();
            return (rect.width !== 0 &&
                rect.height !== 0 &&
                rect.top >= 0 &&
                rect.top <= window.innerHeight &&
                textNode.parentElement?.checkVisibility({
                    checkOpacity: true,
                    checkVisibilityCSS: true,
                }));
        }
        // Function to traverse the DOM and create nested JSON
        function buildDomTree(node, parentIframe = null) {
            if (!node || duplicates.has(node)) {
                return null;
            }
            duplicates.add(node);
            // Special case for text nodes
            if (node.nodeType === Node.TEXT_NODE) {
                const textContent = node.textContent.trim();
                if (textContent && isTextNodeVisible(node)) {
                    return {
                        type: 'TEXT_NODE',
                        text: textContent,
                        isVisible: true,
                    };
                }
                return null;
            }
            // Check if element is accepted
            if (node.nodeType === Node.ELEMENT_NODE && !isElementAccepted(node)) {
                return null;
            }
            const nodeData = {
                tagName: node.tagName ? node.tagName.toLowerCase() : null,
                attributes: {},
                xpath: node.nodeType === Node.ELEMENT_NODE ? getXPathTree(node, true) : null,
                children: [],
            };
            // Copy all attributes if the node is an element
            if (node.nodeType === Node.ELEMENT_NODE && node.attributes) {
                // Use getAttributeNames() instead of directly iterating attributes
                const attributeNames = node.getAttributeNames?.() || [];
                for (const name of attributeNames) {
                    nodeData.attributes[name] = node.getAttribute(name);
                }
            }
            if (node.nodeType === Node.ELEMENT_NODE) {
                const isInteractive = isInteractiveElement(node);
                const isVisible = isElementVisible(node);
                const isTop = isTopElement(node);
                nodeData.isInteractive = isInteractive;
                nodeData.isVisible = isVisible;
                nodeData.isTopElement = isTop;
                // For Shadow DOM elements, use more lenient criteria
                const isInShadowDOM = node.getRootNode() instanceof ShadowRoot;
                const shouldHighlight = isInteractive && isVisible && (isTop || isInShadowDOM);
                // Highlight if element meets all criteria and highlighting is enabled
                if (shouldHighlight) {
                    nodeData.highlightIndex = highlightIndex++;
                    window.clickable_elements[nodeData.highlightIndex] = node;
                    if (markHighlightElements) {
                        highlightElement(node, nodeData.highlightIndex, parentIframe);
                    }
                }
            }
            // Only add iframeContext if we're inside an iframe
            // if (parentIframe) {
            //     nodeData.iframeContext = `iframe[src="${parentIframe.src || ''}"]`;
            // }
            // Only add shadowRoot field if it exists
            if (node.shadowRoot) {
                nodeData.shadowRoot = true;
            }
            // Handle shadow DOM
            if (node.shadowRoot) {
                const shadowChildren = Array.from(node.shadowRoot.children).map((child) => buildDomTree(child, parentIframe)).filter(child => child !== null);
                nodeData.children.push(...shadowChildren);
            }
            // Handle iframes
            if (node.tagName === 'IFRAME') {
                try {
                    const iframeDoc = node.contentDocument || node.contentWindow.document;
                    if (iframeDoc) {
                        const iframeChildren = Array.from(iframeDoc.body.children).map((child) => buildDomTree(child, node)).filter(child => child !== null);
                        nodeData.children.push(...iframeChildren);
                    }
                }
                catch (e) {
                    console.warn('Unable to access iframe:', node);
                }
            }
            else {
                const style = getCachedComputedStyle(node);
                if (style && style.display !== 'none') {
                    const children = Array.from(node.children).map((child) => buildDomTree(child, parentIframe)).filter(child => child !== null);
                    nodeData.children.push(...children);
                }
            }
            return nodeData;
        }
        return buildDomTree(document.body);
    }
    window.get_clickable_elements = get_clickable_elements;
    window.get_highlight_element = get_highlight_element;
    window.remove_highlight = remove_highlight;
}

class BaseBrowserLabelsAgent extends BaseBrowserAgent {
    constructor(llms, ext_tools, mcpClient) {
        let description = `You are a browser operation agent, use structured commands to interact with the browser.
* This is a browser GUI interface where you need to analyze webpages by taking screenshot and page element structures, and specify action sequences to complete designated tasks.
* For your first visit, please start by calling either the \`navigate_to\` or \`current_page\` tool. After each action you perform, I will provide you with updated information about the current state, including page screenshots and structured element data that has been specially processed for easier analysis.
* During execution, please output user-friendly step information. Do not output HTML-related element and index information to users, as this would cause user confusion.

* Screenshot description:
  - Screenshot are used to understand page layouts, with labeled bounding boxes corresponding to element indexes. Each bounding box and its label share the same color, with labels typically positioned in the top-right corner of the box.
  - Screenshot help verify element positions and relationships. Labels may sometimes overlap, so extracted elements are used to verify the correct elements.
  - In addition to screenshot, simplified information about interactive elements is returned, with element indexes corresponding to those in the screenshot.
  - This tool can ONLY screenshot the VISIBLE content. If a complete content is required, use 'extract_page_content' instead.
  - If the webpage content hasn't loaded, please use the \`wait\` tool to allow time for the content to load.
* Element interaction:
  - Only use indexes that exist in the provided element list
  - Browser tools only return elements in visible viewport by default
  - Each element has a unique index number (e.g., "[33]:<button>Submit</button>")
  - Elements marked with "[]:" are non-interactive (for context only, e.g., "[]: Google")
  - Use the latest element index, do not rely on historical outdated element indexes
  - Due to technical limitations, not all interactive elements may be identified; use coordinates to interact with unlisted elements
* Error handling:
  - If no suitable elements exist, use other functions to complete the task
  - If stuck, try alternative approaches, don't refuse tasks
  - Handle popups/cookies by accepting or closing them
  - When encountering scenarios that require user assistance such as login, verification codes, QR code scanning, Payment, etc, you can request user help.
* Browser operation:
  - Use scroll to find elements you are looking for, When extracting content, prioritize using extract_page_content, only scroll when you need to load more content
  - Please follow user instructions and don't be lazy until the task is completed. For example, if a user asks you to find 30 people, don't just find 10 - keep searching until you find all 30.`;
        if (config$1.parallelToolCalls) {
            description += `
* Parallelism:
   - Do not call the navigate_to tool simultaneously
   - Operations that support parallelism generally only include clicking and input operations
   - When filling out a form, fields that are not dependent on each other should be filled simultaneously
   - Avoid parallel processing for dependent operations, such as those that need to wait for page loading, DOM changes, redirects, subsequent operations that depend on the results of previous operations, or operations that may interfere with each other and affect the same page elements. In these cases, please do not use parallelization.`;
        }
        const _tools_ = [];
        super({
            name: AGENT_NAME,
            description: description,
            tools: _tools_,
            llms: llms,
            mcpClient: mcpClient,
            planDescription: "Browser operation agent, interact with the browser using the mouse and keyboard.",
        });
        let init_tools = this.buildInitTools();
        if (ext_tools && ext_tools.length > 0) {
            init_tools = mergeTools(init_tools, ext_tools);
        }
        init_tools.forEach((tool) => _tools_.push(tool));
    }
    async input_text(agentContext, index, text, enter) {
        await this.execute_script(agentContext, typing, [{ index, text, enter }]);
        if (enter) {
            await sleep(200);
        }
    }
    async click_element(agentContext, index, num_clicks, button) {
        await this.execute_script(agentContext, do_click, [
            { index, num_clicks, button },
        ]);
    }
    async scroll_to_element(agentContext, index) {
        await this.execute_script(agentContext, (index) => {
            return window
                .get_highlight_element(index)
                .scrollIntoView({ behavior: "smooth" });
        }, [index]);
        await sleep(200);
    }
    async scroll_mouse_wheel(agentContext, amount, extract_page_content) {
        await this.execute_script(agentContext, scroll_by, [{ amount }]);
        await sleep(200);
        if (!extract_page_content) {
            const tools = this.toolUseNames(agentContext.agentChain.agentRequest?.messages);
            let scroll_count = 0;
            for (let i = tools.length - 1; i >= Math.max(tools.length - 8, 0); i--) {
                if (tools[i] == "scroll_mouse_wheel") {
                    scroll_count++;
                }
            }
            if (scroll_count >= 3) {
                extract_page_content = true;
            }
        }
        if (extract_page_content) {
            let page_result = await this.extract_page_content(agentContext);
            return {
                result: "The current page content has been extracted, latest page content:\n" +
                    "title: " +
                    page_result.title +
                    "\n" +
                    "page_url: " +
                    page_result.page_url +
                    "\n" +
                    "page_content: " +
                    page_result.page_content,
            };
        }
    }
    async hover_to_element(agentContext, index) {
        await this.execute_script(agentContext, hover_to, [{ index }]);
    }
    async get_select_options(agentContext, index) {
        return await this.execute_script(agentContext, get_select_options, [
            { index },
        ]);
    }
    async select_option(agentContext, index, option) {
        return await this.execute_script(agentContext, select_option, [
            { index, option },
        ]);
    }
    async screenshot_and_html(agentContext) {
        try {
            let element_result;
            let double_screenshots;
            for (let i = 0; i < 5; i++) {
                await sleep(200);
                await this.execute_script(agentContext, run_build_dom_tree, []);
                await sleep(50);
                element_result = (await this.execute_script(agentContext, (markHighlightElements) => {
                    return window.get_clickable_elements(markHighlightElements);
                }, [config$1.mode != "fast" && config$1.markImageMode == "dom"]));
                if (element_result) {
                    break;
                }
            }
            await sleep(100);
            const screenshot = config$1.mode == "fast"
                ? undefined
                : await this.screenshot_and_compress(agentContext, element_result.client_rect);
            if (config$1.markImageMode == "draw" &&
                screenshot?.imageBase64 &&
                element_result.area_map) {
                double_screenshots = { ...screenshot };
                const markImageBase64 = await mark_screenshot_highlight_elements(screenshot, element_result.area_map, element_result.client_rect);
                screenshot.imageBase64 = markImageBase64;
            }
            const pseudoHtml = element_result.element_str || "";
            return {
                double_screenshots: double_screenshots,
                imageBase64: screenshot?.imageBase64,
                imageType: screenshot?.imageType,
                pseudoHtml: pseudoHtml,
                client_rect: element_result.client_rect,
            };
        }
        finally {
            try {
                await this.execute_script(agentContext, () => {
                    return window.remove_highlight();
                }, []);
            }
            catch (e) { }
        }
    }
    async screenshot_and_compress(agentContext, client_rect) {
        const screenshot = await this.screenshot(agentContext);
        if (!client_rect || !screenshot) {
            return screenshot;
        }
        const compressedImage = await compressImageData(screenshot.imageBase64, screenshot.imageType, {
            resizeWidth: client_rect.width,
            resizeHeight: client_rect.height,
        });
        return {
            imageBase64: compressedImage.imageBase64,
            imageType: compressedImage.imageType,
        };
    }
    get_element_script(index) {
        return `window.get_highlight_element(${index});`;
    }
    canParallelToolCalls(toolCalls) {
        if (toolCalls) {
            for (let i = 0; i < toolCalls.length; i++) {
                const toolCall = toolCalls[i];
                if (toolCall.toolName == "wait" ||
                    toolCall.toolName == "navigate_to" ||
                    toolCall.toolName == "switch_tab" ||
                    toolCall.toolName == "scroll_mouse_wheel") {
                    return false;
                }
            }
        }
        return super.canParallelToolCalls(toolCalls);
    }
    buildInitTools() {
        return [
            {
                name: "navigate_to",
                description: "Navigate to a specific URL in the browser. Use this tool when you need to visit a webpage or change the current page location.",
                parameters: {
                    type: "object",
                    properties: {
                        url: {
                            type: "string",
                            description: "The complete URL to navigate to",
                        },
                    },
                    required: ["url"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.navigate_to(agentContext, args.url));
                },
            },
            {
                name: "current_page",
                description: "Get the currently active webpage information, return tabId, URL and title",
                parameters: {
                    type: "object",
                    properties: {},
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.get_current_page(agentContext));
                },
            },
            {
                name: "go_back",
                description: "Go back to the previous page in browser history",
                parameters: {
                    type: "object",
                    properties: {},
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.go_back(agentContext));
                },
            },
            {
                name: "input_text",
                description: "Inputs text into a element by first clicking to focus the element, then clearing any existing text and typing the new text. Optionally presses Enter after input completion.",
                parameters: {
                    type: "object",
                    properties: {
                        index: {
                            type: "number",
                            description: "The index of the element to input text into",
                        },
                        text: {
                            type: "string",
                            description: "The text to input",
                        },
                        enter: {
                            type: "boolean",
                            description: "When text input is completed, press Enter (applicable to search boxes)",
                            default: false,
                        },
                    },
                    required: ["index", "text"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.input_text(agentContext, args.index, args.text, args.enter));
                },
            },
            {
                name: "click_element",
                description: "Click on an element by index",
                parameters: {
                    type: "object",
                    properties: {
                        index: {
                            type: "number",
                            description: "The index of the element to click",
                        },
                        num_clicks: {
                            type: "number",
                            description: "number of times to click the element, default 1",
                        },
                        button: {
                            type: "string",
                            description: "Mouse button type, default left",
                            enum: ["left", "right", "middle"],
                        },
                    },
                    required: ["index"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.click_element(agentContext, args.index, (args.num_clicks || 1), (args.button || "left")));
                },
            },
            {
                name: "scroll_mouse_wheel",
                description: "Scroll the mouse wheel at current position, only scroll when you need to load more content",
                parameters: {
                    type: "object",
                    properties: {
                        amount: {
                            type: "number",
                            description: "Scroll amount (up / down)",
                            minimum: 1,
                            maximum: 10,
                        },
                        direction: {
                            type: "string",
                            enum: ["up", "down"],
                        },
                        extract_page_content: {
                            type: "boolean",
                            default: false,
                            description: "After scrolling is completed, whether to extract the current latest page content",
                        },
                    },
                    required: ["amount", "direction", "extract_page_content"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(async () => {
                        let amount = args.amount;
                        await this.scroll_mouse_wheel(agentContext, args.direction == "up" ? -amount : amount, args.extract_page_content == true);
                    });
                },
            },
            {
                name: "hover_to_element",
                description: "Hover the mouse over an element, use it when you need to hover to display more interactive information",
                parameters: {
                    type: "object",
                    properties: {
                        index: {
                            type: "number",
                            description: "The index of the element to input text into",
                        },
                    },
                    required: ["index"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.hover_to_element(agentContext, args.index));
                },
            },
            {
                name: "extract_page_content",
                description: "Extracts all content from the current webpage, including text and image links. Please use this tool when you need to retrieve webpage content.",
                parameters: {
                    type: "object",
                    properties: {},
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.extract_page_content(agentContext));
                },
            },
            {
                name: "get_select_options",
                description: "Get all options from a native dropdown element (<select>).",
                parameters: {
                    type: "object",
                    properties: {
                        index: {
                            type: "number",
                            description: "The index of the element to select",
                        },
                    },
                    required: ["index"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.get_select_options(agentContext, args.index));
                },
            },
            {
                name: "select_option",
                description: "Select the native dropdown option, Use this after get_select_options and when you need to select an option from a dropdown.",
                parameters: {
                    type: "object",
                    properties: {
                        index: {
                            type: "number",
                            description: "The index of the element to select",
                        },
                        option: {
                            type: "string",
                            description: "Text option",
                        },
                    },
                    required: ["index", "option"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.select_option(agentContext, args.index, args.option));
                },
            },
            {
                name: "get_all_tabs",
                description: "Get all tabs of the current browser, returns the tabId, URL, and title of all tab pages",
                parameters: {
                    type: "object",
                    properties: {},
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.get_all_tabs(agentContext));
                },
            },
            {
                name: "switch_tab",
                description: "Switch to the specified tab (based on tabId)",
                parameters: {
                    type: "object",
                    properties: {
                        tabId: {
                            type: "number",
                            description: "Tab ID, obtained through get_all_tabs",
                        },
                    },
                    required: ["tabId"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.switch_tab(agentContext, args.tabId));
                },
            },
            {
                name: "wait",
                noPlan: true,
                description: "Wait/pause execution for a specified duration. Use this tool when you need to wait for data loading, page rendering, or introduce delays between operations.",
                parameters: {
                    type: "object",
                    properties: {
                        duration: {
                            type: "number",
                            description: "Wait duration in milliseconds",
                            default: 500,
                            minimum: 200,
                            maximum: 10000,
                        },
                    },
                    required: ["duration"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => sleep((args.duration || 200)));
                },
            },
        ];
    }
    async double_screenshots(agentContext, messages, tools) {
        return config$1.mode == "expert";
    }
    async handleMessages(agentContext, messages, tools) {
        const pseudoHtmlDescription = "This is the environmental information after the operation, including the latest browser screenshot and page elements. Please perform the next operation based on the environmental information. Do not output the following elements and index information in your response.\n\nIndex and elements:\n";
        let lastTool = this.lastToolResult(messages);
        if (lastTool &&
            lastTool.toolName !== "extract_page_content" &&
            lastTool.toolName !== "get_all_tabs" &&
            lastTool.toolName !== "variable_storage") {
            await sleep(300);
            const image_contents = [];
            const result = await this.screenshot_and_html(agentContext);
            if (await this.double_screenshots(agentContext, messages, tools)) {
                const imageResult = result.double_screenshots
                    ? result.double_screenshots
                    : await this.screenshot_and_compress(agentContext, result.client_rect);
                const image = toImage(imageResult.imageBase64);
                image_contents.push({
                    type: "file",
                    data: image,
                    mediaType: imageResult.imageType,
                });
            }
            if (result.imageBase64) {
                const image = toImage(result.imageBase64);
                image_contents.push({
                    type: "file",
                    data: image,
                    mediaType: result.imageType || "image/png",
                });
            }
            messages.push({
                role: "user",
                content: [
                    ...image_contents,
                    {
                        type: "text",
                        text: pseudoHtmlDescription + "```html\n" + result.pseudoHtml + "\n```",
                    },
                ],
            });
        }
        super.handleMessages(agentContext, messages, tools);
        this.handlePseudoHtmlText(messages, pseudoHtmlDescription);
    }
    handlePseudoHtmlText(messages, pseudoHtmlDescription) {
        for (let i = 0; i < messages.length; i++) {
            let message = messages[i];
            if (message.role !== "user" || message.content.length <= 1) {
                continue;
            }
            let content = message.content;
            for (let j = 0; j < content.length; j++) {
                let _content = content[j];
                if (_content.type == "text" &&
                    _content.text.startsWith(pseudoHtmlDescription)) {
                    if (i >= 2 && i < messages.length - 3) {
                        _content.text = this.removePseudoHtmlAttr(_content.text, [
                            "class",
                            "src",
                            "href",
                        ]);
                    }
                }
            }
            if (content[0].text == "[image]" &&
                content[1].text == "[image]") {
                content.splice(0, 1);
            }
        }
    }
    removePseudoHtmlAttr(pseudoHtml, remove_attrs) {
        return pseudoHtml
            .split("\n")
            .map((line) => {
            if (!line.startsWith("[") || line.indexOf("]:<") == -1) {
                return line;
            }
            line = line.substring(line.indexOf("]:<") + 2);
            for (let i = 0; i < remove_attrs.length; i++) {
                let sIdx = line.indexOf(remove_attrs[i] + '="');
                if (sIdx == -1) {
                    continue;
                }
                let eIdx = line.indexOf('"', sIdx + remove_attrs[i].length + 3);
                if (eIdx == -1) {
                    continue;
                }
                line = line.substring(0, sIdx) + line.substring(eIdx + 1).trim();
            }
            return line.replace('" >', '">').replace(" >", ">");
        })
            .join("\n");
    }
}
function typing(params) {
    let { index, text, enter } = params;
    let element = window.get_highlight_element(index);
    if (!element) {
        return false;
    }
    let input;
    if (element.tagName == "IFRAME") {
        let iframeDoc = element.contentDocument || element.contentWindow.document;
        input =
            iframeDoc.querySelector("textarea") ||
                iframeDoc.querySelector('*[contenteditable="true"]') ||
                iframeDoc.querySelector("input");
    }
    else if (element.tagName == "INPUT" ||
        element.tagName == "TEXTAREA" ||
        element.childElementCount == 0) {
        input = element;
    }
    else {
        input = element.querySelector("input") || element.querySelector("textarea");
        if (!input) {
            input = element.querySelector('*[contenteditable="true"]') || element;
            if (input.tagName == "DIV") {
                input =
                    input.querySelector("span") || input.querySelector("div") || input;
            }
        }
    }
    input.focus && input.focus();
    if (!text && enter) {
        ["keydown", "keypress", "keyup"].forEach((eventType) => {
            const event = new KeyboardEvent(eventType, {
                key: "Enter",
                code: "Enter",
                keyCode: 13,
                bubbles: true,
                cancelable: true,
            });
            input.dispatchEvent(event);
        });
        return true;
    }
    if (input.value == undefined) {
        input.textContent = text;
    }
    else {
        input.value = text;
        if (input.__proto__) {
            let value_setter = Object.getOwnPropertyDescriptor(input.__proto__, "value")?.set;
            value_setter && value_setter.call(input, text);
        }
    }
    input.dispatchEvent(new Event("input", { bubbles: true }));
    if (enter) {
        ["keydown", "keypress", "keyup"].forEach((eventType) => {
            const event = new KeyboardEvent(eventType, {
                key: "Enter",
                code: "Enter",
                keyCode: 13,
                bubbles: true,
                cancelable: true,
            });
            input.dispatchEvent(event);
        });
    }
    return true;
}
function do_click(params) {
    let { index, button, num_clicks } = params;
    function simulateMouseEvent(eventTypes, button) {
        let element = window.get_highlight_element(index);
        if (!element) {
            return false;
        }
        for (let n = 0; n < num_clicks; n++) {
            for (let i = 0; i < eventTypes.length; i++) {
                const eventType = eventTypes[i];
                const event = new MouseEvent(eventType, {
                    view: window,
                    bubbles: true,
                    cancelable: true,
                    button, // 0 left; 1 middle; 2 right
                });
                if (eventType === "click" && element.click) {
                    // support shadow dom element
                    element.click();
                }
                else {
                    element.dispatchEvent(event);
                }
                element.focus?.();
            }
        }
        return true;
    }
    if (button == "right") {
        return simulateMouseEvent(["mousedown", "mouseup", "contextmenu"], 2);
    }
    else if (button == "middle") {
        return simulateMouseEvent(["mousedown", "mouseup", "click"], 1);
    }
    else {
        return simulateMouseEvent(["mousedown", "mouseup", "click"], 0);
    }
}
function hover_to(params) {
    let element = window.get_highlight_element(params.index);
    if (!element) {
        return false;
    }
    const event = new MouseEvent("mouseenter", {
        bubbles: true,
        cancelable: true,
        view: window,
    });
    element.dispatchEvent(event);
    return true;
}
function get_select_options(params) {
    let element = window.get_highlight_element(params.index);
    if (!element || element.tagName.toUpperCase() !== "SELECT") {
        return "Error: Not a select element";
    }
    return {
        options: Array.from(element.options).map((opt) => ({
            index: opt.index,
            text: opt.text.trim(),
            value: opt.value,
        })),
        name: element.name,
    };
}
function select_option(params) {
    let element = window.get_highlight_element(params.index);
    if (!element || element.tagName.toUpperCase() !== "SELECT") {
        return "Error: Not a select element";
    }
    let text = params.option.trim();
    let option = Array.from(element.options).find((opt) => opt.text.trim() === text);
    if (!option) {
        option = Array.from(element.options).find((opt) => opt.value.trim() === text);
    }
    if (!option) {
        return {
            success: false,
            error: "Select Option not found",
            availableOptions: Array.from(element.options).map((o) => o.text.trim()),
        };
    }
    element.value = option.value;
    element.dispatchEvent(new Event("change"));
    return {
        success: true,
        selectedValue: option.value,
        selectedText: option.text.trim(),
    };
}
function scroll_by(params) {
    const amount = params.amount;
    const documentElement = document.documentElement || document.body;
    if (documentElement.scrollHeight > window.innerHeight * 1.2) {
        const y = Math.max(20, Math.min((window.innerHeight || documentElement.clientHeight) / 10, 200));
        window.scrollBy(0, y * amount);
        return;
    }
    function findNodes(element = document, nodes = []) {
        for (const node of Array.from(element.querySelectorAll("*"))) {
            if (node.tagName === "IFRAME" && node.contentDocument) {
                findNodes(node.contentDocument, nodes);
            }
            else {
                nodes.push(node);
            }
        }
        return nodes;
    }
    function findScrollableElements() {
        const allElements = findNodes();
        let elements = allElements.filter((el) => {
            const style = window.getComputedStyle(el);
            const overflowY = style.getPropertyValue("overflow-y");
            return ((overflowY === "auto" || overflowY === "scroll") &&
                el.scrollHeight > el.clientHeight);
        });
        if (elements.length == 0) {
            elements = allElements.filter((el) => {
                const style = window.getComputedStyle(el);
                const overflowY = style.getPropertyValue("overflow-y");
                return (overflowY === "auto" ||
                    overflowY === "scroll" ||
                    el.scrollHeight > el.clientHeight);
            });
        }
        return elements;
    }
    function getVisibleArea(element) {
        const rect = element.getBoundingClientRect();
        const viewportHeight = window.innerHeight || documentElement.clientHeight;
        const viewportWidth = window.innerWidth || documentElement.clientWidth;
        const visibleLeft = Math.max(0, Math.min(rect.left, viewportWidth));
        const visibleRight = Math.max(0, Math.min(rect.right, viewportWidth));
        const visibleTop = Math.max(0, Math.min(rect.top, viewportHeight));
        const visibleBottom = Math.max(0, Math.min(rect.bottom, viewportHeight));
        const visibleWidth = visibleRight - visibleLeft;
        const visibleHeight = visibleBottom - visibleTop;
        return visibleWidth * visibleHeight;
    }
    function getComputedZIndex(element) {
        while (element &&
            element !== document.body &&
            element !== document.body.parentElement) {
            const style = window.getComputedStyle(element);
            let zIndex = style.zIndex === "auto" ? 0 : parseInt(style.zIndex) || 0;
            if (zIndex > 0) {
                return zIndex;
            }
            element = element.parentElement;
        }
        return 0;
    }
    const scrollableElements = findScrollableElements();
    if (scrollableElements.length === 0) {
        const y = Math.max(20, Math.min((window.innerHeight || documentElement.clientHeight) / 10, 200));
        window.scrollBy(0, y * amount);
        return false;
    }
    const sortedElements = scrollableElements.sort((a, b) => {
        let z = getComputedZIndex(b) - getComputedZIndex(a);
        if (z > 0) {
            return 1;
        }
        else if (z < 0) {
            return -1;
        }
        let v = getVisibleArea(b) - getVisibleArea(a);
        if (v > 0) {
            return 1;
        }
        else if (v < 0) {
            return -1;
        }
        return 0;
    });
    const largestElement = sortedElements[0];
    const viewportHeight = largestElement.clientHeight;
    const y = Math.max(20, Math.min(viewportHeight / 10, 200));
    largestElement.scrollBy(0, y * amount);
    const maxHeightElement = sortedElements.sort((a, b) => b.getBoundingClientRect().height - a.getBoundingClientRect().height)[0];
    if (maxHeightElement != largestElement) {
        const viewportHeight = maxHeightElement.clientHeight;
        const y = Math.max(20, Math.min(viewportHeight / 10, 200));
        maxHeightElement.scrollBy(0, y * amount);
    }
    return true;
}

class BaseBrowserScreenAgent extends BaseBrowserAgent {
    constructor(llms, ext_tools, mcpClient) {
        const description = `You are a browser operation agent, use a mouse and keyboard to interact with a browser.
* This is a browser GUI interface, observe the webpage execution through screenshots, and specify action sequences to complete designated tasks.
* For the first visit, please call the \`navigate_to\` or \`current_page\` tool first. After that, each of your actions will return a screenshot of the page.
* BROWSER OPERATIONS:
  - Navigate to URLs and manage history
  - Fill forms and submit data
  - Click elements and interact with pages
  - Extract text and HTML content
  - Wait for elements to load
  - Scroll pages and handle infinite scroll
  - YOU CAN DO ANYTHING ON THE BROWSER - including clicking on elements, filling forms, submitting data, etc.`;
        const _tools_ = [];
        super({
            name: AGENT_NAME,
            description: description,
            tools: _tools_,
            llms: llms,
            mcpClient: mcpClient,
            planDescription: "Browser operation agent, interact with the browser using the mouse and keyboard.",
        });
        let init_tools = this.buildInitTools();
        if (ext_tools && ext_tools.length > 0) {
            init_tools = mergeTools(init_tools, ext_tools);
        }
        init_tools.forEach((tool) => _tools_.push(tool));
    }
    buildInitTools() {
        return [
            {
                name: "navigate_to",
                description: "Navigate to a specific url",
                parameters: {
                    type: "object",
                    properties: {
                        url: {
                            type: "string",
                            description: "The url to navigate to",
                        },
                    },
                    required: ["url"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.navigate_to(agentContext, args.url));
                },
            },
            {
                name: "current_page",
                description: "Get the information of the current webpage (url, title)",
                parameters: {
                    type: "object",
                    properties: {},
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.get_current_page(agentContext));
                },
            },
            {
                name: "go_back",
                description: "Navigate back in browser history",
                parameters: {
                    type: "object",
                    properties: {},
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.go_back(agentContext));
                },
            },
            {
                name: "typing",
                description: "Type specified text",
                parameters: {
                    type: "object",
                    properties: {
                        text: {
                            type: "string",
                            description: "Text to type",
                        },
                    },
                    required: ["text"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.typing(agentContext, args.text));
                },
            },
            {
                name: "click",
                description: "Click at current or specified position",
                parameters: {
                    type: "object",
                    properties: {
                        x: {
                            type: "number",
                            description: "X coordinate",
                        },
                        y: {
                            type: "number",
                            description: "Y coordinate",
                        },
                        num_clicks: {
                            type: "number",
                            description: "Number of clicks",
                            enum: [1, 2, 3],
                            default: 1,
                        },
                        button: {
                            type: "string",
                            description: "Mouse button to click",
                            enum: ["left", "right", "middle"],
                            default: "left",
                        },
                    },
                    required: ["x", "y"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.click(agentContext, args.x, args.y, (args.num_clicks || 1), (args.button || "left")));
                },
            },
            {
                name: "move_to",
                description: "Move cursor to specified position",
                parameters: {
                    type: "object",
                    properties: {
                        x: {
                            type: "number",
                            description: "X coordinate",
                        },
                        y: {
                            type: "number",
                            description: "Y coordinate",
                        },
                    },
                    required: ["x", "y"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.move_to(agentContext, args.x, args.y));
                },
            },
            {
                name: "scroll",
                description: "Scroll the mouse wheel at current position",
                parameters: {
                    type: "object",
                    properties: {
                        amount: {
                            type: "number",
                            description: "Scroll amount (up / down)",
                            minimum: 1,
                            maximum: 10,
                        },
                        direction: {
                            type: "string",
                            enum: ["up", "down"],
                        },
                    },
                    required: ["amount", "direction"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(async () => {
                        let amount = args.amount;
                        await this.scroll(agentContext, args.direction == "up" ? -amount : amount);
                    });
                },
            },
            {
                name: "extract_page_content",
                description: "Extract the text content and image links of the current webpage, please use this tool to obtain webpage data.",
                parameters: {
                    type: "object",
                    properties: {},
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.extract_page_content(agentContext));
                },
            },
            {
                name: "press",
                description: "Press and release a key, supports Enter, Delete, Backspace, Tab, Space",
                parameters: {
                    type: "object",
                    properties: {
                        key: {
                            type: "string",
                            description: "Key to press",
                            enum: ["enter", "tab", "space", "backspace", "delete"],
                        },
                    },
                    required: ["key"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.press(agentContext, args.key));
                },
            },
            {
                name: "drag_and_drop",
                description: "Drag and drop operation",
                parameters: {
                    type: "object",
                    properties: {
                        x1: {
                            type: "number",
                            description: "From X coordinate",
                        },
                        y1: {
                            type: "number",
                            description: "From Y coordinate",
                        },
                        x2: {
                            type: "number",
                            description: "Target X coordinate",
                        },
                        y2: {
                            type: "number",
                            description: "Target Y coordinate",
                        },
                    },
                    required: ["x1", "y1", "x2", "y2"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.drag_and_drop(agentContext, args.x1, args.y1, args.x2, args.y2));
                },
            },
            {
                name: "get_all_tabs",
                description: "Get all tabs of the current browser",
                parameters: {
                    type: "object",
                    properties: {},
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.get_all_tabs(agentContext));
                },
            },
            {
                name: "switch_tab",
                description: "Switch to the specified tab page",
                parameters: {
                    type: "object",
                    properties: {
                        tabId: {
                            type: "number",
                            description: "Tab ID, obtained through get_all_tabs",
                        },
                    },
                    required: ["tabId"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => this.switch_tab(agentContext, args.tabId));
                },
            },
            {
                name: "wait",
                noPlan: true,
                description: "Wait for specified duration",
                parameters: {
                    type: "object",
                    properties: {
                        duration: {
                            type: "number",
                            description: "Duration in millisecond",
                            default: 500,
                            minimum: 200,
                            maximum: 10000,
                        },
                    },
                    required: ["duration"],
                },
                execute: async (args, agentContext) => {
                    return await this.callInnerTool(() => sleep((args.duration || 200)));
                },
            },
        ];
    }
    async handleMessages(agentContext, messages, tools) {
        let lastTool = this.lastToolResult(messages);
        if (lastTool &&
            lastTool.toolName !== "extract_page_content" &&
            lastTool.toolName !== "get_all_tabs" &&
            lastTool.toolName !== "variable_storage") {
            await sleep(300);
            let result = await this.screenshot(agentContext);
            let image = toImage(result.imageBase64);
            messages.push({
                role: "user",
                content: [
                    {
                        type: "file",
                        data: image,
                        mediaType: result.imageType,
                    },
                    {
                        type: "text",
                        text: "This is the latest screenshot",
                    },
                ],
            });
        }
        super.handleMessages(agentContext, messages, tools);
    }
}

class EkoMemory {
    constructor(systemPrompt, messages = [], memoryConfig = config$1.memoryConfig) {
        this.messages = messages;
        this.systemPrompt = systemPrompt;
        this.memoryConfig = memoryConfig;
    }
    genMessageId() {
        return uuidv4();
    }
    async import(data) {
        this.messages = [...data.messages];
        if (data.config) {
            await this.updateConfig(data.config);
        }
        else {
            await this.manageCapacity();
        }
    }
    setSystemPrompt(systemPrompt) {
        this.systemPrompt = systemPrompt;
    }
    getSystemPrompt() {
        return this.systemPrompt;
    }
    async addMessages(messages) {
        this.messages.push(...messages);
        await this.manageCapacity();
    }
    getMessages() {
        return this.messages;
    }
    getMessageById(id) {
        return this.messages.find((message) => message.id === id);
    }
    removeMessageById(id, removeToNextUserMessages = true) {
        const removedIds = [];
        for (let i = 0; i < this.messages.length; i++) {
            const message = this.messages[i];
            if (message.id === id) {
                removedIds.push(id);
                if (removeToNextUserMessages) {
                    for (let j = i + 1; j < this.messages.length; j++) {
                        const nextMessage = this.messages[j];
                        if (nextMessage.role == "user") {
                            break;
                        }
                        removedIds.push(nextMessage.id);
                    }
                }
                this.messages.splice(i, removedIds.length);
                break;
            }
        }
        return removedIds.length > 0 ? removedIds : undefined;
    }
    getEstimatedTokens(calcSystemPrompt = true) {
        let tokens = 0;
        if (calcSystemPrompt && this.systemPrompt) {
            tokens += this.calcTokens(this.systemPrompt);
        }
        return this.messages.reduce((total, message) => {
            const content = typeof message.content === "string"
                ? message.content
                : JSON.stringify(message.content.filter((part) => part.type != "file"));
            return total + this.calcTokens(content);
        }, tokens);
    }
    calcTokens(content) {
        // Simple estimation: Each Chinese character is 1 token, other characters are counted as 1 token for every 4.
        const chineseCharCount = (content.match(/[\u4e00-\u9fff]/g) || []).length;
        const otherCharCount = content.length - chineseCharCount;
        return chineseCharCount + Math.ceil(otherCharCount / 4);
    }
    async updateConfig(config) {
        if (config.maxMessageNum !== undefined) {
            this.memoryConfig.maxMessageNum = config.maxMessageNum;
        }
        if (config.maxInputTokens !== undefined) {
            this.memoryConfig.maxInputTokens = config.maxInputTokens;
        }
        if (config.enableCompression !== undefined) {
            this.memoryConfig.enableCompression = config.enableCompression;
        }
        if (config.compressionThreshold !== undefined) {
            this.memoryConfig.compressionThreshold = config.compressionThreshold;
        }
        if (config.compressionMaxLength !== undefined) {
            this.memoryConfig.compressionMaxLength = config.compressionMaxLength;
        }
        await this.manageCapacity();
    }
    async manageCapacity() {
        if (this.messages.length > this.memoryConfig.maxMessageNum) {
            const excess = this.messages.length - this.memoryConfig.maxMessageNum;
            this.messages.splice(0, excess);
        }
        if (this.memoryConfig.enableCompression &&
            this.messages.length > this.memoryConfig.compressionThreshold) {
            // compress messages
            for (let i = 0; i < this.messages.length; i++) {
                const message = this.messages[i];
                if (message.role == "assistant") {
                    message.content = message.content.map((part) => {
                        if (part.type == "text" &&
                            part.text.length > this.memoryConfig.compressionMaxLength) {
                            return {
                                type: "text",
                                text: sub(part.text, this.memoryConfig.compressionMaxLength, true),
                            };
                        }
                        return part;
                    });
                }
                if (message.role == "tool") {
                    message.content = message.content.map((part) => {
                        if (typeof part.result === "string" &&
                            part.result.length > this.memoryConfig.compressionMaxLength) {
                            return {
                                ...part,
                                result: sub(part.result, this.memoryConfig.compressionMaxLength, true),
                            };
                        }
                        return part;
                    });
                }
            }
        }
        while (this.getEstimatedTokens(true) > this.memoryConfig.maxInputTokens &&
            this.messages.length > 0) {
            this.messages.shift();
        }
        this.fixDiscontinuousMessages();
    }
    fixDiscontinuousMessages() {
        if (this.messages.length > 0 && this.messages[0].role != "user") {
            for (let i = 0; i < this.messages.length; i++) {
                const message = this.messages[i];
                if (message.role == "user") {
                    this.messages.splice(0, i);
                    break;
                }
            }
        }
        const removeIds = [];
        let lastMessage = null;
        for (let i = 0; i < this.messages.length; i++) {
            const message = this.messages[i];
            if (message.role == "user" &&
                lastMessage &&
                lastMessage.role == "user"
            // && message.content == lastMessage.content
            ) {
                // remove duplicate user messages
                removeIds.push(lastMessage.id);
                continue;
            }
            if (lastMessage &&
                lastMessage.role == "assistant" &&
                lastMessage.content.filter((part) => part.type == "tool-call").length >
                    0 &&
                message.role != "tool") {
                // add tool result message
                this.messages.push({
                    role: "tool",
                    id: this.genMessageId(),
                    timestamp: message.timestamp + 1,
                    content: lastMessage.content
                        .filter((part) => part.type == "tool-call")
                        .map((part) => {
                        return {
                            type: "tool-result",
                            toolCallId: part.toolCallId,
                            toolName: part.toolName,
                            result: "Error: No result",
                        };
                    }),
                });
            }
            lastMessage = message;
        }
        if (removeIds.length > 0) {
            removeIds.forEach((id) => this.removeMessageById(id));
        }
    }
    getFirstUserMessage() {
        return this.messages.filter((message) => message.role === "user")[0];
    }
    getLastUserMessage() {
        const userMessages = this.messages.filter((message) => message.role === "user");
        return userMessages[userMessages.length - 1];
    }
    hasMessage(id) {
        return this.messages.some((message) => message.id === id);
    }
    clear() {
        this.messages = [];
    }
    buildMessages() {
        const llmMessages = [];
        for (let i = 0; i < this.messages.length; i++) {
            const message = this.messages[i];
            if (message.role == "user") {
                llmMessages.push({
                    role: message.role,
                    content: typeof message.content === "string"
                        ? [
                            {
                                type: "text",
                                text: message.content,
                            },
                        ]
                        : message.content.map((part) => {
                            if (part.type == "text") {
                                return {
                                    type: "text",
                                    text: part.text,
                                };
                            }
                            else {
                                return {
                                    type: "file",
                                    data: toFile(part.data),
                                    mediaType: part.mimeType || getMimeType(part.data),
                                };
                            }
                        }),
                    providerOptions: defaultMessageProviderOptions(),
                });
            }
            else if (message.role == "assistant") {
                llmMessages.push({
                    role: message.role,
                    content: message.content.map((part) => {
                        if (part.type == "text") {
                            return {
                                type: "text",
                                text: part.text,
                            };
                        }
                        else if (part.type == "reasoning") {
                            return {
                                type: "reasoning",
                                text: part.text,
                            };
                        }
                        else if (part.type == "tool-call") {
                            return {
                                type: "tool-call",
                                toolCallId: part.toolCallId,
                                toolName: part.toolName,
                                input: part.args,
                            };
                        }
                        else {
                            return part;
                        }
                    }),
                });
            }
            else if (message.role == "tool") {
                llmMessages.push({
                    role: message.role,
                    content: message.content.map((part) => {
                        return {
                            type: "tool-result",
                            toolCallId: part.toolCallId,
                            toolName: part.toolName,
                            output: typeof part.result == "string"
                                ? {
                                    type: "text",
                                    value: part.result,
                                }
                                : {
                                    type: "json",
                                    value: part.result,
                                },
                        };
                    }),
                });
            }
        }
        return [
            {
                role: "system",
                content: this.getSystemPrompt() || "You are a helpful assistant.",
                providerOptions: defaultMessageProviderOptions(),
            },
            ...llmMessages,
        ];
    }
}

async function callChatLLM(messageId, chatContext, rlm, messages, tools, toolChoice, retryNum = 0, callback, signal) {
    const streamCallback = callback?.chatCallback || {
        onMessage: async () => { },
    };
    const request = {
        tools: tools,
        toolChoice,
        messages: messages,
        abortSignal: signal,
    };
    let streamText = "";
    let thinkText = "";
    let toolArgsText = "";
    let textStreamId = uuidv4();
    let thinkStreamId = uuidv4();
    let textStreamDone = false;
    const toolParts = [];
    let reader = null;
    try {
        const result = await rlm.callStream(request);
        reader = result.stream.getReader();
        let toolPart = null;
        while (true) {
            const { done, value } = await reader.read();
            if (done) {
                break;
            }
            const chunk = value;
            switch (chunk.type) {
                case "text-start": {
                    textStreamId = uuidv4();
                    break;
                }
                case "text-delta": {
                    if (toolPart && !chunk.delta) {
                        continue;
                    }
                    streamText += chunk.delta || "";
                    await streamCallback.onMessage({
                        streamType: "chat",
                        chatId: chatContext.getChatId(),
                        messageId,
                        type: "text",
                        streamId: textStreamId,
                        streamDone: false,
                        text: streamText,
                    });
                    if (toolPart) {
                        await streamCallback.onMessage({
                            streamType: "chat",
                            chatId: chatContext.getChatId(),
                            messageId,
                            type: "tool_use",
                            toolCallId: toolPart.toolCallId,
                            toolName: toolPart.toolName,
                            params: toolPart.input || {},
                        });
                        toolPart = null;
                    }
                    break;
                }
                case "text-end": {
                    textStreamDone = true;
                    if (streamText) {
                        await streamCallback.onMessage({
                            streamType: "chat",
                            chatId: chatContext.getChatId(),
                            messageId,
                            type: "text",
                            streamId: textStreamId,
                            streamDone: true,
                            text: streamText,
                        });
                    }
                    break;
                }
                case "reasoning-start": {
                    thinkStreamId = uuidv4();
                    break;
                }
                case "reasoning-delta": {
                    thinkText += chunk.delta || "";
                    await streamCallback.onMessage({
                        streamType: "chat",
                        chatId: chatContext.getChatId(),
                        messageId,
                        type: "thinking",
                        streamId: thinkStreamId,
                        streamDone: false,
                        text: thinkText,
                    });
                    break;
                }
                case "reasoning-end": {
                    if (thinkText) {
                        await streamCallback.onMessage({
                            streamType: "chat",
                            chatId: chatContext.getChatId(),
                            messageId,
                            type: "thinking",
                            streamId: thinkStreamId,
                            streamDone: true,
                            text: thinkText,
                        });
                    }
                    break;
                }
                case "tool-input-start": {
                    if (toolPart && toolPart.toolCallId == chunk.id) {
                        toolPart.toolName = chunk.toolName;
                    }
                    else {
                        toolPart = {
                            type: "tool-call",
                            toolCallId: chunk.id,
                            toolName: chunk.toolName,
                            input: {},
                        };
                        toolParts.push(toolPart);
                    }
                    break;
                }
                case "tool-input-delta": {
                    if (!textStreamDone) {
                        textStreamDone = true;
                        await streamCallback.onMessage({
                            streamType: "chat",
                            chatId: chatContext.getChatId(),
                            messageId,
                            type: "text",
                            streamId: textStreamId,
                            streamDone: true,
                            text: streamText,
                        });
                    }
                    toolArgsText += chunk.delta || "";
                    await streamCallback.onMessage({
                        streamType: "chat",
                        chatId: chatContext.getChatId(),
                        messageId,
                        type: "tool_streaming",
                        toolCallId: chunk.id,
                        toolName: toolPart?.toolName || "",
                        paramsText: toolArgsText,
                    });
                    break;
                }
                case "tool-call": {
                    toolArgsText = "";
                    const args = chunk.input ? JSON.parse(chunk.input) : {};
                    const message = {
                        streamType: "chat",
                        chatId: chatContext.getChatId(),
                        messageId,
                        type: "tool_use",
                        toolCallId: chunk.toolCallId,
                        toolName: chunk.toolName,
                        params: args,
                    };
                    await streamCallback.onMessage(message);
                    if (toolPart == null) {
                        toolParts.push({
                            type: "tool-call",
                            toolCallId: chunk.toolCallId,
                            toolName: chunk.toolName,
                            input: message.params || args,
                        });
                    }
                    else {
                        toolPart.input = message.params || args;
                        toolPart = null;
                    }
                    break;
                }
                case "error": {
                    Log.error(`chatLLM error: `, chunk);
                    await streamCallback.onMessage({
                        streamType: "chat",
                        chatId: chatContext.getChatId(),
                        messageId,
                        type: "error",
                        error: chunk.error,
                    });
                    throw new Error("LLM Error: " + chunk.error);
                }
                case "finish": {
                    if (!textStreamDone) {
                        textStreamDone = true;
                        await streamCallback.onMessage({
                            streamType: "chat",
                            chatId: chatContext.getChatId(),
                            messageId,
                            type: "text",
                            streamId: textStreamId,
                            streamDone: true,
                            text: streamText,
                        });
                    }
                    if (toolPart) {
                        await streamCallback.onMessage({
                            streamType: "chat",
                            chatId: chatContext.getChatId(),
                            messageId,
                            type: "tool_use",
                            toolCallId: toolPart.toolCallId,
                            toolName: toolPart.toolName,
                            params: toolPart.input || {},
                        });
                        toolPart = null;
                    }
                    await streamCallback.onMessage({
                        streamType: "chat",
                        chatId: chatContext.getChatId(),
                        messageId,
                        type: "finish",
                        finishReason: chunk.finishReason,
                        usage: {
                            promptTokens: chunk.usage.inputTokens || 0,
                            completionTokens: chunk.usage.outputTokens || 0,
                            totalTokens: chunk.usage.totalTokens ||
                                (chunk.usage.inputTokens || 0) +
                                    (chunk.usage.outputTokens || 0),
                        },
                    });
                    break;
                }
            }
        }
    }
    catch (e) {
        if (retryNum < config$1.maxRetryNum) {
            await sleep(200 * (retryNum + 1) * (retryNum + 1));
            return callChatLLM(messageId, chatContext, rlm, messages, tools, toolChoice, ++retryNum, callback, signal);
        }
        throw e;
    }
    finally {
        reader && reader.releaseLock();
    }
    return streamText
        ? [
            { type: "text", text: streamText },
            ...toolParts,
        ]
        : toolParts;
}
function convertAssistantToolResults(results) {
    return results.map((part) => {
        if (part.type == "text") {
            return {
                type: "text",
                text: part.text,
            };
        }
        else if (part.type == "tool-call") {
            return {
                type: "tool-call",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                args: (part.input || {}),
            };
        }
        return part;
    });
}
function convertToolResults(toolResults) {
    return toolResults.map((part) => {
        const output = part.output;
        return {
            type: "tool-result",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            result: output.type == "text" || output.type == "error-text"
                ? output.value
                : output.type == "json" || output.type == "error-json"
                    ? output.value
                    : output.value
                        .map((s) => {
                        if (s.type == "text") {
                            return s.text;
                        }
                        else if (s.type == "media") {
                            return JSON.stringify({
                                data: s.data,
                                mimeType: s.mediaType,
                            });
                        }
                    })
                        .join("\n"),
        };
    });
}

class ChatContext {
    constructor(chatId, config) {
        this.chatId = chatId;
        this.config = config;
        this.ekoMap = new Map();
        this.globalVariables = new Map();
    }
    getChatId() {
        return this.chatId;
    }
    getConfig() {
        return this.config;
    }
    addEko(taskId, eko) {
        this.ekoMap.set(taskId, eko);
    }
    getEko(taskId) {
        return this.ekoMap.get(taskId);
    }
    getGlobalVariables() {
        return this.globalVariables;
    }
}

const TOOL_NAME$3 = "webpageQa";
const WEBPAGE_QA_PROMPT = `
You are a helpful assistant that can answer questions based on the provided webpage context.

# Webpage Context
<webpage_contexts>
{{contexts}}
</webpage_contexts>

# User Question
<user_question>
{{userPrompt}}
</user_question>
<if language>
<language>{{language}}</language>
</if>

Answer user's question based on the webpage context, the answer should be in the same language as the user's question.
`;
class WebpageQaTool {
    constructor(chatContext, params) {
        this.name = TOOL_NAME$3;
        this.params = params;
        this.chatContext = chatContext;
        this.description = `This tool is designed only for handling simple web-related tasks, including summarizing webpage content, extracting data from web pages, translating webpage content, and converting webpage information into more easily understandable forms. It does not interact with or operate web pages. For more complex browser tasks, please use deepAction.It does not perform operations on the webpage itself, but only involves reading the page content. Users do not need to provide the web page content, as the tool can automatically extract the content of the web page based on the tabId to respond.`;
        this.parameters = {
            type: "object",
            properties: {
                language: {
                    type: "string",
                    description: "User language used, eg: English",
                },
                tabIds: {
                    type: "array",
                    description: "The browser tab ids to be used for the QA. When the user says 'left side' or 'current', it means current active tab.",
                    items: { type: "integer" },
                },
            },
            required: ["tabIds", "language"],
        };
    }
    async execute(args, toolCall, messageId) {
        if (!global.browserService) {
            return {
                content: [
                    {
                        type: "text",
                        text: "Error: not implemented",
                    },
                ],
            };
        }
        const tabIds = args.tabIds;
        const language = args.language;
        const tabs = await global.browserService.extractPageContents(this.chatContext.getChatId(), tabIds);
        const chatConfig = this.chatContext.getConfig();
        const rlm = new RetryLanguageModel(chatConfig.llms, chatConfig.chatLlms);
        const prompt = PromptTemplate.render(global.prompts.get(GlobalPromptKey.webpage_qa_prompt) ||
            WEBPAGE_QA_PROMPT, {
            language: language,
            userPrompt: this.params.user
                .map((part) => (part.type == "text" ? part.text : ""))
                .join("\n")
                .trim(),
            contexts: this.buildTabContents(tabs),
        }).trim();
        const result = await rlm.callStream({
            temperature: 0.7,
            maxOutputTokens: config$1.maxOutputTokens,
            messages: [{ role: "user", content: [{ type: "text", text: prompt }] }],
        });
        const stream = result.stream;
        const reader = stream.getReader();
        const streamId = uuidv4();
        const callback = this.params.callback.chatCallback;
        let text = "";
        try {
            while (true) {
                const { done, value } = await reader.read();
                if (done) {
                    break;
                }
                const chunk = value;
                if (chunk.type == "text-delta") {
                    text += chunk.delta;
                    await callback.onMessage({
                        streamType: "chat",
                        chatId: this.chatContext.getChatId(),
                        messageId: messageId,
                        type: "tool_running",
                        toolName: this.name,
                        toolCallId: toolCall.toolCallId,
                        text: text,
                        streamId: streamId,
                        streamDone: false,
                    });
                }
                else if (chunk.type == "error") {
                    throw new Error(chunk.error);
                }
                else if (chunk.type == "finish") {
                    break;
                }
            }
        }
        finally {
            reader.releaseLock();
            await callback.onMessage({
                streamType: "chat",
                chatId: this.chatContext.getChatId(),
                messageId: messageId,
                type: "tool_running",
                toolName: this.name,
                toolCallId: toolCall.toolCallId,
                text: text,
                streamId: streamId,
                streamDone: true,
            });
        }
        return {
            content: [
                {
                    type: "text",
                    text: text,
                },
            ],
        };
    }
    buildTabContents(tabs) {
        return tabs
            .map((tab) => {
            return `<webpage>\nTabId: ${tab.tabId}\nTitle: ${tab.title}\nURL: ${tab.url}\nContent: ${sub(tab.content, 8000)}\n</webpage>`;
        })
            .join("\n");
    }
}

const TOOL_NAME$2 = "webSearch";
class WebSearchTool {
    constructor(chatContext, params) {
        this.name = TOOL_NAME$2;
        this.params = params;
        this.chatContext = chatContext;
        this.description = `Search the web for information using search engine API. This tool can perform web searches to find current information, news, articles, and other web content related to the query. It returns search results with titles, descriptions, URLs, and other relevant metadata, use this tool when users need the latest data/information and have NOT specified a particular platform or website, use the search tool.`;
        this.parameters = {
            type: "object",
            properties: {
                query: {
                    type: "string",
                    description: "The search query to execute. Use specific keywords and phrases for better results.",
                },
                language: {
                    type: "string",
                    description: "Language code for search results (e.g., 'en', 'zh', 'ja'). If not specified, will be auto-detected from query.",
                },
                count: {
                    type: "integer",
                    description: "Number of search results to return (default: 10, max: 50)",
                    default: 10,
                    minimum: 1,
                    maximum: 50,
                },
            },
            required: ["query", "keywords"],
        };
    }
    async execute(args) {
        if (!global.chatService) {
            return {
                content: [
                    {
                        type: "text",
                        text: "Error: not implemented",
                    },
                ],
            };
        }
        const query = args.query;
        const language = args.language;
        const count = args.count || 10;
        const results = await global.chatService.websearch(this.chatContext.getChatId(), query, undefined, language, count);
        return Promise.resolve({
            content: [
                {
                    type: "text",
                    text: JSON.stringify(results.map((result) => {
                        return {
                            title: result.title,
                            url: result.url,
                            content: sub(result.content || result.snippet || "", 6000),
                        };
                    })),
                },
            ],
        });
    }
}

async function recursiveTextNode(node, callback) {
    if (node.type === "normal") {
        callback(node, node);
    }
    if (node.type === "forEach") {
        node.nodes.map((item) => recursiveTextNode(item, callback));
    }
    if (node.type === "watch") {
        node.triggerNodes.map((triggerNode) => recursiveTextNode(triggerNode, callback));
    }
}

const TOOL_NAME$1 = "deepAction";
const deep_action_description = "Delegate tasks to a Javis AI assistant for completion. This assistant can understand natural language instructions and has full control over both networked computers, browser agent, and multiple specialized agents ({agentNames}). The assistant can autonomously decide to use various software tools, browse the internet to query information, write code, and perform direct operations to complete tasks. He can deliver various digitized outputs (text reports, tables, images, music, videos, websites, deepSearch, programs, etc.) and handle design/analysis tasks. and execute operational tasks (such as batch following bloggers of specific topics on certain websites). For operational tasks, the focus is on completing the process actions rather than delivering final outputs, and the assistant can complete these types of tasks well. It should also be noted that users may actively mention deepsearch, which is also one of the capabilities of this tool. If users mention it, please explicitly tell the assistant to use deepsearch. Supports parallel execution of multiple tasks.";
const deep_action_param_task_description = "Task description, please output the user's original instructions without omitting any information from the user's instructions, and use the same language as the user's question.";
class DeepActionTool {
    constructor(chatContext, params) {
        this.name = TOOL_NAME$1;
        this.chatContext = chatContext;
        const agents = this.chatContext.getConfig().agents || [];
        const agentNames = agents.map((agent) => agent.Name).join(", ");
        const description = global.prompts.get(GlobalPromptKey.deep_action_description) ||
            deep_action_description;
        const paramTaskDescription = global.prompts.get(GlobalPromptKey.deep_action_param_task_description) ||
            deep_action_param_task_description;
        this.description = description.replace("{agentNames}", agentNames).trim();
        this.parameters = {
            type: "object",
            properties: {
                language: {
                    type: "string",
                    description: "User language used, eg: English",
                },
                taskDescription: {
                    type: "string",
                    description: paramTaskDescription.trim(),
                },
                tabIds: {
                    type: "array",
                    description: "Browser Tab IDs associated with this task, When user says 'left side' or 'current', it means current active tab",
                    items: { type: "integer" },
                },
                dependentVariables: {
                    type: "array",
                    description: "The current task relies on variable data from prerequisite execution outputs. Provide the name of the dependent variable.",
                    items: {
                        type: "string",
                    },
                },
            },
            required: ["language", "taskDescription"],
        };
        this.params = params;
    }
    async execute(args, toolCall, messageId) {
        const chatId = this.chatContext.getChatId();
        const language = args.language;
        const taskDescription = args.taskDescription;
        const tabIds = args.tabIds;
        const dependentVariables = args.dependentVariables;
        const config = this.chatContext.getConfig();
        const globalVariables = this.chatContext.getGlobalVariables();
        const eko = new Eko({
            ...config,
            callback: this.params.callback?.taskCallback,
        }, chatId);
        this.chatContext.addEko(messageId, eko);
        if (this.params.signal) {
            if (this.params.signal.aborted) {
                const error = new Error("Operation was interrupted");
                error.name = "AbortError";
                throw error;
            }
            this.params.signal.addEventListener("abort", () => {
                eko.abortTask(messageId, "User aborted");
            });
        }
        const attachments = this.params.user
            .filter((part) => part.type === "file")
            .filter((part) => part.data && part.data.length < 500)
            .map((part) => {
            return {
                file_name: part.filename,
                file_path: part.filePath,
                file_url: part.data,
            };
        });
        const taskWebsite = await this.gettaskWebsite(tabIds);
        const workflow = await eko.generate(taskDescription, messageId, {
            ...globalVariables,
            tabIds: tabIds,
            language: language,
            attachments: attachments,
            taskWebsite: taskWebsite,
            dependentVariables: dependentVariables,
            datetime: this.params.datetime || new Date().toLocaleString(),
        });
        const context = eko.getTask(messageId);
        console.log("==> workflow", workflow);
        const result = await eko.execute(messageId);
        const variableNames = [];
        if (context.variables && context.variables.size > 0) {
            workflow.agents
                .map((agent) => agent.nodes)
                .flat()
                .forEach((node) => {
                recursiveTextNode(node, async (textNode) => {
                    if (textNode.output) {
                        variableNames.push(textNode.output);
                        globalVariables.set(textNode.output, context.variables.get(textNode.output));
                    }
                });
            });
        }
        return {
            content: [
                {
                    type: "text",
                    text: JSON.stringify({
                        taskPlan: workflow.xml,
                        subAgents: context.chain.agents.map((agent) => {
                            return {
                                agent: agent.agent.name,
                                subTask: agent.agent.task,
                                agentResult: sub(agent.agentResult || "", 800, true),
                            };
                        }),
                        variables: variableNames,
                        taskResult: result.result,
                        success: result.success,
                    }),
                },
            ],
        };
    }
    async gettaskWebsite(tabIds) {
        if (!global.browserService) {
            return [];
        }
        const tabs = await global.browserService.loadTabs(this.chatContext.getChatId(), tabIds);
        return tabs.map((tab) => {
            return {
                tabId: tab.tabId,
                title: tab.title,
                url: sub(tab.url, 300),
            };
        });
    }
}

const TOOL_NAME = "taskVariableStorage";
class TaskVariableStorageTool {
    constructor(chatContext, params) {
        this.name = TOOL_NAME;
        this.params = params;
        this.chatContext = chatContext;
        this.description = `Used for storing, reading, and retrieving variable data, and maintaining input/output variables in task nodes.`;
        this.parameters = {
            type: "object",
            properties: {
                operation: {
                    type: "string",
                    description: "variable storage operation type.",
                    enum: ["read_variable", "write_variable", "list_all_variable"],
                },
                name: {
                    type: "string",
                    description: "variable name, required when reading and writing variables, If reading variables, it supports reading multiple variables separated by commas.",
                },
                value: {
                    type: "string",
                    description: "variable value, required when writing variables",
                },
            },
            required: ["operation"],
        };
    }
    async execute(args) {
        let operation = args.operation;
        let resultText = "";
        switch (operation) {
            case "read_variable": {
                if (!args.name) {
                    resultText = "Error: name is required";
                }
                else {
                    let result = {};
                    let name = args.name;
                    let keys = name.split(",");
                    for (let i = 0; i < keys.length; i++) {
                        let key = keys[i].trim();
                        let value = this.chatContext.getGlobalVariables().get(key);
                        result[key] = value;
                    }
                    resultText = JSON.stringify(result);
                }
                break;
            }
            case "write_variable": {
                if (!args.name) {
                    resultText = "Error: name is required";
                    break;
                }
                if (args.value == undefined) {
                    resultText = "Error: value is required";
                    break;
                }
                let key = args.name;
                this.chatContext.getGlobalVariables().set(key.trim(), args.value);
                resultText = "success";
                break;
            }
            case "list_all_variable": {
                resultText = JSON.stringify([
                    ...this.chatContext.getGlobalVariables().keys(),
                ]);
                break;
            }
        }
        return {
            content: [
                {
                    type: "text",
                    text: resultText || "",
                },
            ],
        };
    }
}

const CHAT_SYSTEM_TEMPLATE = `
You are {{name}}, it is an action-oriented assistant in the browser, a general-purpose intelligent agent running in the browser environment.

<tool_instructions>
General Principles:
- Only one tool can be called at a time.
- Users may not be able to clearly describe their needs in a single conversation. When needs are ambiguous or lack details, assistant can appropriately initiate follow-up questions before making tool calls. Follow-up rounds should not exceed two rounds.
- Users may switch topics multiple times during ongoing conversations. When calling tools, assistant must focus ONLY on the current user question and ignore previous conversation topics unless they are directly related to the current request. Each question should be treated as independent unless explicitly building on previous context.

For non-chat related tasks issued by users, the following tools need to be called to complete them:
<if ${TOOL_NAME$1}Tool>
- ${TOOL_NAME$1}: This tool is used to execute tasks, delegate to Javis AI assistant with full computer control.
</if>
<if ${TOOL_NAME$3}Tool>
- ${TOOL_NAME$3}: When a user's query involves finding content in a webpage within a browser tab, extracting webpage content, summarizing webpage content, translating webpage content, read PDF page content, or converting webpage content into a more understandable format, this tool should be used. If the task requires performing actions based on webpage content, deepAction should be used. only needs to provide the required invocation parameters according to the tool's needs; users do not need to manually provide the content of the browser tab.
</if>
<if ${TOOL_NAME$2}Tool>
- ${TOOL_NAME$2}: Search the web for information using search engine API. This tool can perform web searches to find current information, news, articles, and other web content related to the query. It returns search results with titles, descriptions, URLs, and other relevant metadata. Use this tool when you need to find current information from the internet that may not be available in your training data.
</if>
<if ${TOOL_NAME}Tool>
- ${TOOL_NAME}: This tool is used to read output variables from task nodes and write input variables to task nodes, mainly used to retrieve variable results after task execution is completed.
</if>
</tool_instructions>

<if memory>
The assistant always focuses on the user's current question and will not allow previous conversation turns or irrelevant memory content to interfere with the response to the user's current question. Each question should be handled independently unless it explicitly builds upon prior context.
Before responding to user questions, the assistant intelligently analyzes the relevance of memories. When responding, the assistant first determines whether the user's current question is related to information in the retrieved memories, and only incorporates memory data when there is clear contextual relevance. If the user's question is unrelated to the retrieved memories, the assistant will directly respond to the current question without referencing memory content, ensuring the conversation flows naturally.
Avoid forcing the use of memories when they are irrelevant to the current context, prioritizing the accuracy and relevance of responses over the inclusion of memories.
<retrieved_memories>
{{memory}}
</retrieved_memories>
</if>

<if tabs>
The information about the browser tabs currently open by the user is as follows:
<browser_tabs>
{{tabs}}
</browser_tabs>
</if>

Current datetime: {{datetime}}
The output language should match the user's conversation language.
`;
function getChatSystemPrompt(tools, datetime, memory, tabs) {
    const systemPrompt = global.prompts.get(GlobalPromptKey.chat_system) || CHAT_SYSTEM_TEMPLATE;
    const toolVars = {};
    for (let i = 0; i < tools.length; i++) {
        toolVars[tools[i].name + "Tool"] = true;
    }
    return PromptTemplate.render(systemPrompt, {
        name: config$1.name,
        datetime: datetime,
        memory: memory || "",
        tabs: getTabsInfo(tabs),
        ...toolVars,
    }).trim();
}
function getTabsInfo(tabs) {
    if (!tabs || tabs.length == 0) {
        return "Empty";
    }
    return JSON.stringify(tabs.slice(0, 10).map((tab) => {
        return {
            tabId: tab.tabId,
            title: sub(tab.title, 50),
            url: sub(tab.url, 300),
            active: tab.active,
            lastAccessed: tab.lastAccessed,
        };
    }), null, 2);
}

class ChatAgent {
    constructor(config, chatId = uuidv4(), memory, tools) {
        this.tools = tools ?? [];
        this.memory = memory ?? new EkoMemory();
        this.chatContext = new ChatContext(chatId, config);
        global.chatMap.set(chatId, this.chatContext);
    }
    async chat(params) {
        return this.doChat(params, false);
    }
    async doChat(params, segmentedExecution) {
        const runStartTime = Date.now();
        let reactLoopNum = 0;
        let errorInfo = null;
        try {
            if (params.callback?.chatCallback) {
                await params.callback.chatCallback.onMessage({
                    streamType: "chat",
                    chatId: this.chatContext.getChatId(),
                    messageId: params.messageId,
                    type: "chat_start",
                });
            }
            const chatTools = mergeTools(this.buildInnerTools(params), this.tools);
            await this.buildSystemPrompt(params, chatTools);
            await this.addUserMessage(params.messageId, params.user);
            const config = this.chatContext.getConfig();
            const rlm = new RetryLanguageModel(config.llms, config.chatLlms);
            for (; reactLoopNum < 15; reactLoopNum++) {
                const messages = this.memory.buildMessages();
                const results = await callChatLLM(params.messageId, this.chatContext, rlm, messages, convertTools(chatTools), undefined, 0, params.callback, params.signal);
                const finalResult = await this.handleCallResult(params.messageId, chatTools, results, params.callback);
                if (finalResult) {
                    return finalResult;
                }
                if (params.signal?.aborted) {
                    const error = new Error("Operation was interrupted");
                    error.name = "AbortError";
                    throw error;
                }
            }
            reactLoopNum--;
            return "Unfinished";
        }
        catch (e) {
            Log.error("chat error: ", e);
            if (e instanceof Error) {
                errorInfo = e.name + ": " + e.message;
            }
            else {
                errorInfo = String(e);
            }
            return errorInfo;
        }
        finally {
            if (params.callback?.chatCallback) {
                await params.callback.chatCallback.onMessage({
                    streamType: "chat",
                    chatId: this.chatContext.getChatId(),
                    messageId: params.messageId,
                    type: "chat_end",
                    error: errorInfo,
                    duration: Date.now() - runStartTime,
                    reactLoopNum: reactLoopNum + 1,
                });
            }
        }
    }
    async initMessages() {
        if (!global.chatService) {
            return;
        }
        const messages = this.memory.getMessages();
        if (messages.length == 0) {
            const messages = await global.chatService.loadMessages(this.chatContext.getChatId());
            if (messages && messages.length > 0) {
                await this.memory.addMessages(messages);
            }
        }
    }
    async buildSystemPrompt(params, chatTools) {
        let _memory = undefined;
        if (global.chatService) {
            try {
                const userPrompt = params.user
                    .map((part) => (part.type == "text" ? part.text : ""))
                    .join("\n")
                    .trim();
                if (userPrompt) {
                    _memory = await global.chatService.memoryRecall(this.chatContext.getChatId(), userPrompt);
                }
            }
            catch (e) {
                Log.error("chat service memory recall error: ", e);
            }
        }
        let _tabs = undefined;
        if (global.browserService) {
            try {
                _tabs = await global.browserService.loadTabs(this.chatContext.getChatId());
            }
            catch (e) {
                Log.error("browser service load tabs error: ", e);
            }
        }
        const datetime = params.datetime || new Date().toLocaleString();
        const systemPrompt = getChatSystemPrompt(chatTools, datetime, _memory, _tabs);
        this.memory.setSystemPrompt(systemPrompt);
    }
    async addUserMessage(messageId, user) {
        const message = {
            id: messageId,
            role: "user",
            timestamp: Date.now(),
            content: user,
        };
        await this.addMessages([message]);
        return message;
    }
    async addMessages(messages, storage = true) {
        await this.memory.addMessages(messages);
        if (storage && global.chatService) {
            await global.chatService.addMessage(this.chatContext.getChatId(), messages);
        }
    }
    buildInnerTools(params) {
        const tools = [];
        tools.push(new DeepActionTool(this.chatContext, params));
        if (global.browserService) {
            tools.push(new WebpageQaTool(this.chatContext, params));
        }
        tools.push(new WebSearchTool(this.chatContext, params));
        tools.push(new TaskVariableStorageTool(this.chatContext, params));
        return tools;
    }
    getChatContext() {
        return this.chatContext;
    }
    async handleCallResult(messageId, chatTools, results, chatStreamCallback) {
        let text = null;
        const toolResults = [];
        if (results.length == 0) {
            return null;
        }
        for (let i = 0; i < results.length; i++) {
            const result = results[i];
            if (result.type == "text") {
                text = result.text;
                continue;
            }
            let toolResult;
            try {
                const args = typeof result.input == "string"
                    ? JSON.parse(result.input || "{}")
                    : result.input || {};
                const tool = getTool(chatTools, result.toolName);
                if (!tool) {
                    throw new Error(result.toolName + " tool does not exist");
                }
                toolResult = await tool.execute(args, result, messageId);
            }
            catch (e) {
                Log.error("tool call error: ", result.toolName, result.input, e);
                toolResult = {
                    content: [
                        {
                            type: "text",
                            text: e + "",
                        },
                    ],
                    isError: true,
                };
            }
            const callback = chatStreamCallback?.chatCallback;
            if (callback) {
                await callback.onMessage({
                    streamType: "chat",
                    chatId: this.chatContext.getChatId(),
                    messageId: messageId,
                    type: "tool_result",
                    toolCallId: result.toolCallId,
                    toolName: result.toolName,
                    params: result.input || {},
                    toolResult: toolResult,
                });
            }
            const llmToolResult = convertToolResult(result, toolResult);
            toolResults.push(llmToolResult);
        }
        await this.addMessages([
            {
                id: this.memory.genMessageId(),
                role: "assistant",
                timestamp: Date.now(),
                content: convertAssistantToolResults(results),
            },
        ]);
        if (toolResults.length > 0) {
            await this.addMessages([
                {
                    id: this.memory.genMessageId(),
                    role: "tool",
                    timestamp: Date.now(),
                    content: convertToolResults(toolResults),
                },
            ]);
            return null;
        }
        else {
            return text;
        }
    }
}

class SimpleSseMcpClient {
    constructor(sseServerUrl, clientName = "EkoMcpClient", headers = {}) {
        this.protocolVersion = "2024-11-05";
        this.sseUrl = sseServerUrl;
        this.clientName = clientName;
        this.headers = headers;
        this.requestMap = new Map();
    }
    async connect(signal) {
        Log.info("MCP Client, connecting...", this.sseUrl);
        if (this.sseHandler && this.sseHandler.readyState == 1) {
            this.sseHandler.close && this.sseHandler.close();
            this.sseHandler = undefined;
        }
        this.pingTimer && clearInterval(this.pingTimer);
        this.reconnectTimer && clearTimeout(this.reconnectTimer);
        await new Promise((resolve) => {
            const timer = setTimeout(resolve, 15000);
            this.sseHandler = {
                onopen: () => {
                    Log.info("MCP Client, connection successful", this.sseUrl);
                    clearTimeout(timer);
                    setTimeout(resolve, 200);
                },
                onmessage: (data) => this.onmessage(data),
                onerror: (e) => {
                    Log.error("MCP Client, error: ", e);
                    clearTimeout(timer);
                    if (this.sseHandler?.readyState === 2) {
                        this.pingTimer && clearInterval(this.pingTimer);
                        this.reconnectTimer = setTimeout(() => {
                            this.connect();
                        }, 500);
                    }
                    resolve();
                },
            };
            connectSse(this.sseUrl, this.sseHandler, this.headers, signal);
        });
        this.pingTimer = setInterval(() => this.ping(), 10000);
    }
    onmessage(data) {
        Log.debug("MCP Client, onmessage", this.sseUrl, data);
        if (data.event == "endpoint") {
            let uri = data.data;
            let msgUrl;
            let idx = this.sseUrl.indexOf("/", 10);
            if (idx > -1) {
                msgUrl = this.sseUrl.substring(0, idx) + uri;
            }
            else {
                msgUrl = this.sseUrl + uri;
            }
            this.msgUrl = msgUrl;
            this.initialize();
        }
        else if (data.event == "message") {
            let message = JSON.parse(data.data);
            let _resolve = this.requestMap.get(message.id);
            _resolve && _resolve(message);
        }
    }
    async initialize() {
        await this.request("initialize", {
            protocolVersion: this.protocolVersion,
            capabilities: {
                tools: {
                    listChanged: true,
                },
                sampling: {},
            },
            clientInfo: {
                name: this.clientName,
                version: "1.0.0",
            },
        });
        try {
            await this.request("notifications/initialized", {});
        }
        catch (ignored) { }
    }
    ping() {
        this.request("ping", {});
    }
    async listTools(param, signal) {
        const message = await this.request("tools/list", {
            ...param,
        }, signal);
        return message.result.tools || [];
    }
    async callTool(param, signal) {
        const message = await this.request("tools/call", {
            ...param,
        }, signal);
        return message.result;
    }
    async request(method, params, signal) {
        const id = method.startsWith("notifications/") ? undefined : uuidv4();
        try {
            const callback = new Promise((resolve, reject) => {
                if (signal) {
                    signal.addEventListener("abort", () => {
                        const error = new Error("Operation was interrupted");
                        error.name = "AbortError";
                        reject(error);
                    });
                }
                id && this.requestMap.set(id, resolve);
            });
            Log.debug(`MCP Client, ${method}`, id, params);
            const response = await fetch(this.msgUrl, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    ...this.headers,
                },
                body: JSON.stringify({
                    jsonrpc: "2.0",
                    id: id,
                    method: method,
                    params: {
                        ...params,
                    },
                }),
                signal: signal,
            });
            const body = await response.text();
            if (body == "Accepted") {
                const message = await callback;
                if (message.error) {
                    Log.error(`MCP ${method} error: ` + message.error);
                    throw new Error(`MCP ${method} error: ` +
                        (typeof message.error === "string"
                            ? message.error
                            : message.error.message));
                }
                if (message.result?.isError == true) {
                    if (message.result.content) {
                        throw new Error(`MCP ${method} error: ` +
                            (typeof message.result.content === "string"
                                ? message.result.content
                                : message.result.content[0].text));
                    }
                    else {
                        throw new Error(`MCP ${method} error: ` + JSON.stringify(message.result));
                    }
                }
                return message;
            }
            else {
                throw new Error(`MCP ${method} error:` + body);
            }
        }
        finally {
            id && this.requestMap.delete(id);
        }
    }
    isConnected() {
        if (this.sseHandler && this.sseHandler.readyState == 1) {
            return true;
        }
        return false;
    }
    async close() {
        try {
            await this.request("notifications/cancelled", {
                requestId: uuidv4(),
                reason: "User requested cancellation",
            });
        }
        catch (ignored) { }
        this.pingTimer && clearInterval(this.pingTimer);
        this.reconnectTimer && clearTimeout(this.reconnectTimer);
        this.sseHandler && this.sseHandler.close && this.sseHandler.close();
        this.pingTimer = undefined;
        this.sseHandler = undefined;
        this.reconnectTimer = undefined;
    }
}
async function connectSse(sseUrl, hander, headers = {}, _signal) {
    try {
        hander.readyState = 0;
        const controller = new AbortController();
        const signal = _signal
            ? AbortSignal.any([controller.signal, _signal])
            : controller.signal;
        const response = await fetch(sseUrl, {
            method: "GET",
            headers: {
                "Content-Type": "text/event-stream",
                "Cache-Control": "no-cache",
                ...headers,
            },
            body: null,
            keepalive: true,
            signal: signal,
        });
        const reader = response.body?.getReader();
        hander.close = () => {
            controller.abort();
            hander.readyState = 2;
            Log.debug("McpClient close abort.", sseUrl);
        };
        let str = "";
        const decoder = new TextDecoder();
        hander.readyState = 1;
        hander.onopen();
        while (hander.readyState == 1) {
            const { value, done } = await reader?.read();
            if (done) {
                break;
            }
            const text = decoder.decode(value);
            str += text;
            if (str.indexOf("\n\n") > -1) {
                const chunks = str.split("\n\n");
                for (let i = 0; i < chunks.length - 1; i++) {
                    const chunk = chunks[i];
                    const chunkData = parseChunk(chunk);
                    hander.onmessage(chunkData);
                }
                str = chunks[chunks.length - 1];
            }
        }
    }
    catch (e) {
        if (e?.name !== "AbortError") {
            Log.error("MCP Client, connectSse error:", e);
            hander.onerror(e);
        }
    }
    finally {
        hander.readyState = 2;
    }
}
function parseChunk(chunk) {
    const lines = chunk.split("\n");
    const chunk_obj = {};
    for (let j = 0; j < lines.length; j++) {
        const line = lines[j];
        if (line.startsWith("id:")) {
            chunk_obj["id"] = line.substring(3).trim();
        }
        else if (line.startsWith("event:")) {
            chunk_obj["event"] = line.substring(6).trim();
        }
        else if (line.startsWith("data:")) {
            chunk_obj["data"] = line.substring(5).trim();
        }
        else {
            const idx = line.indexOf(":");
            if (idx > -1) {
                chunk_obj[line.substring(0, idx)] = line.substring(idx + 1).trim();
            }
        }
    }
    return chunk_obj;
}

class SimpleHttpMcpClient {
    constructor(httpUrl, clientName = "EkoMcpClient", headers = {}) {
        this.protocolVersion = "2025-06-18";
        this.connected = false;
        this.httpUrl = httpUrl;
        this.clientName = clientName;
        this.headers = headers;
    }
    async connect(signal) {
        Log.info("MCP Client, connecting...", this.httpUrl);
        this.mcpSessionId = null;
        await this.request("initialize", {
            protocolVersion: this.protocolVersion,
            capabilities: {
                tools: {
                    listChanged: true,
                },
                sampling: {},
            },
            clientInfo: {
                name: this.clientName,
                version: "1.0.0",
            },
        }, signal);
        if (this.mcpSessionId) {
            try {
                await this.request("notifications/initialized", {});
            }
            catch (ignored) { }
        }
        this.connected = true;
    }
    async listTools(param, signal) {
        const message = await this.request("tools/list", {
            ...param,
        }, signal);
        return message.result.tools || [];
    }
    async callTool(param, signal) {
        const message = await this.request("tools/call", {
            ...param,
        }, signal);
        return message.result;
    }
    isConnected() {
        return this.connected;
    }
    async close() {
        this.connected = false;
        if (this.mcpSessionId) {
            try {
                await this.request("notifications/cancelled", {
                    requestId: uuidv4(),
                    reason: "User requested cancellation",
                });
            }
            catch (ignored) { }
            this.mcpSessionId = null;
        }
    }
    async request(method, params, signal) {
        try {
            const id = method.startsWith("notifications/") ? undefined : uuidv4();
            const extHeaders = {};
            if (this.mcpSessionId && method !== "initialize") {
                extHeaders["Mcp-Session-Id"] = this.mcpSessionId;
            }
            const response = await fetch(this.httpUrl, {
                method: "POST",
                headers: {
                    "Cache-Control": "no-cache",
                    "Content-Type": "application/json",
                    Accept: "application/json, text/event-stream",
                    "MCP-Protocol-Version": this.protocolVersion,
                    ...extHeaders,
                    ...this.headers,
                },
                body: JSON.stringify({
                    jsonrpc: "2.0",
                    id: id,
                    method: method,
                    params: {
                        ...params,
                    },
                }),
                keepalive: true,
                signal: signal,
            });
            if (method.startsWith("notifications/")) {
                return;
            }
            if (method == "initialize") {
                this.mcpSessionId =
                    response.headers.get("Mcp-Session-Id") ||
                        response.headers.get("mcp-session-id");
            }
            const contentType = response.headers.get("Content-Type") ||
                response.headers.get("content-type") ||
                "application/json";
            if (contentType?.includes("text/event-stream")) {
                // SSE
                const reader = response.body?.getReader();
                let str = "";
                let message;
                const decoder = new TextDecoder();
                while (true) {
                    const { value, done } = await reader?.read();
                    if (done) {
                        break;
                    }
                    const text = decoder.decode(value);
                    str += text;
                    if (str.indexOf("\n\n") > -1) {
                        const chunks = str.split("\n\n");
                        for (let i = 0; i < chunks.length - 1; i++) {
                            const chunk = chunks[i];
                            const chunkData = this.parseChunk(chunk);
                            if (chunkData.event == "message") {
                                message = JSON.parse(chunkData.data);
                                if (message.id == id) {
                                    return message;
                                }
                            }
                        }
                        str = chunks[chunks.length - 1];
                    }
                }
                this.handleError(method, message);
                return message;
            }
            else {
                // JSON
                const message = await response.json();
                this.handleError(method, message);
                return message;
            }
        }
        catch (e) {
            if (e?.name !== "AbortError") {
                Log.error("MCP Client, connectSse error:", e);
            }
            throw e;
        }
    }
    handleError(method, message) {
        if (!message) {
            throw new Error(`MCP ${method} error: no response`);
        }
        if (message?.error) {
            Log.error(`MCP ${method} error: ` + message.error);
            throw new Error(`MCP ${method} error: ` +
                (typeof message.error === "string"
                    ? message.error
                    : message.error.message));
        }
        if (message.result?.isError == true) {
            if (message.result.content) {
                throw new Error(`MCP ${method} error: ` +
                    (typeof message.result.content === "string"
                        ? message.result.content
                        : message.result.content[0].text));
            }
            else {
                throw new Error(`MCP ${method} error: ` + JSON.stringify(message.result));
            }
        }
    }
    parseChunk(chunk) {
        const lines = chunk.split("\n");
        const chunk_obj = {};
        for (let j = 0; j < lines.length; j++) {
            const line = lines[j];
            if (line.startsWith("id:")) {
                chunk_obj["id"] = line.substring(3).trim();
            }
            else if (line.startsWith("event:")) {
                chunk_obj["event"] = line.substring(6).trim();
            }
            else if (line.startsWith("data:")) {
                chunk_obj["data"] = line.substring(5).trim();
            }
            else {
                const idx = line.indexOf(":");
                if (idx > -1) {
                    chunk_obj[line.substring(0, idx)] = line.substring(idx + 1).trim();
                }
            }
        }
        return chunk_obj;
    }
}


//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ "./src/sidebar/MarkdownRenderer.tsx":
/*!******************************************!*\
  !*** ./src/sidebar/MarkdownRenderer.tsx ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MarkdownRenderer: () => (/* binding */ MarkdownRenderer)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var katex_dist_katex_min_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! katex/dist/katex.min.css */ "../../node_modules/.pnpm/katex@0.16.25/node_modules/katex/dist/katex.min.css");
/* harmony import */ var remark_gfm__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! remark-gfm */ "../../node_modules/.pnpm/remark-gfm@4.0.1/node_modules/remark-gfm/lib/index.js");
/* harmony import */ var remark_math__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! remark-math */ "../../node_modules/.pnpm/remark-math@6.0.0/node_modules/remark-math/lib/index.js");
/* harmony import */ var rehype_katex__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! rehype-katex */ "../../node_modules/.pnpm/rehype-katex@7.0.1/node_modules/rehype-katex/lib/index.js");
/* harmony import */ var react_markdown__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-markdown */ "../../node_modules/.pnpm/react-markdown@9.1.0_@types+react@18.3.26_react@18.3.1/node_modules/react-markdown/lib/index.js");






const MarkdownRenderer = ({ content, }) => {
    if (!content) {
        return null;
    }
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { className: "markdown-body" },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(react_markdown__WEBPACK_IMPORTED_MODULE_5__.Markdown, { remarkPlugins: [remark_gfm__WEBPACK_IMPORTED_MODULE_2__["default"], remark_math__WEBPACK_IMPORTED_MODULE_3__["default"]], rehypePlugins: [rehype_katex__WEBPACK_IMPORTED_MODULE_4__["default"]] }, content)));
};


/***/ }),

/***/ "./src/sidebar/components/AgentExecutionCard.tsx":
/*!*******************************************************!*\
  !*** ./src/sidebar/components/AgentExecutionCard.tsx ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AgentExecutionCard: () => (/* binding */ AgentExecutionCard)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _TextItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextItem */ "./src/sidebar/components/TextItem.tsx");
/* harmony import */ var _HumanCard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HumanCard */ "./src/sidebar/components/HumanCard.tsx");
/* harmony import */ var _ThinkingItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ThinkingItem */ "./src/sidebar/components/ThinkingItem.tsx");
/* harmony import */ var _ToolCallItem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ToolCallItem */ "./src/sidebar/components/ToolCallItem.tsx");
/* harmony import */ var _MarkdownRenderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../MarkdownRenderer */ "./src/sidebar/MarkdownRenderer.tsx");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/alert/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/card/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/image/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/space/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/spin/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/tag/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/typography/index.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/CheckCircleOutlined.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/CloseCircleOutlined.js");








const { Text, Paragraph } = antd__WEBPACK_IMPORTED_MODULE_12__["default"];
const AgentExecutionCard = ({ agentNode, task, }) => {
    const agent = task.agents.find((a) => a.agentNode.id === agentNode.id || a.agentNode.name === agentNode.name);
    const status = (agent === null || agent === void 0 ? void 0 : agent.status) || agentNode.status;
    const [respondedCallbacks, setRespondedCallbacks] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(new Set());
    const handleHumanResponse = (callbackId, value) => {
        setRespondedCallbacks((prev) => new Set(prev).add(callbackId));
        // Update the item in agent.contentItems
        if (agent) {
            const itemIndex = agent.contentItems.findIndex((item) => (item.type === "human_confirm" ||
                item.type === "human_input" ||
                item.type === "human_select" ||
                item.type === "human_help") &&
                item.callbackId === callbackId);
            if (itemIndex >= 0) {
                agent.contentItems[itemIndex].value = value;
                agent.contentItems[itemIndex].responded = true;
            }
        }
    };
    console.log("agent_error", agent === null || agent === void 0 ? void 0 : agent.error);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_7__["default"], { size: "small", style: {
            marginBottom: 8,
            borderLeft: `3px solid ${status === "done"
                ? "#52c41a"
                : status === "error"
                    ? "#ff4d4f"
                    : status === "running"
                        ? "#1890ff"
                        : "#d9d9d9"}`,
        }, title: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_9__["default"], null,
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { strong: true }, agentNode.name),
            status === "running" && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_10__["default"], { size: "small" }),
            status === "done" && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_11__["default"], { color: "success", icon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_13__["default"], null) }, "Completed")),
            status === "error" && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_11__["default"], { color: "error", icon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_14__["default"], null) }, "Error"))) },
        agentNode.task && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Paragraph, { type: "secondary", style: { marginBottom: 8 } }, agentNode.task)),
        agent && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null,
            agent.contentItems.map((item, index) => {
                if (item.type === "thinking") {
                    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: `thinking-${item.streamId}-${index}` },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ThinkingItem__WEBPACK_IMPORTED_MODULE_3__.ThinkingItem, { streamId: item.streamId, text: item.text, streamDone: item.streamDone })));
                }
                else if (item.type === "text") {
                    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: `text-${item.streamId}-${index}` },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_TextItem__WEBPACK_IMPORTED_MODULE_1__.TextItem, { streamId: item.streamId, text: item.text, streamDone: item.streamDone })));
                }
                else if (item.type === "tool") {
                    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: `tool-${item.toolCallId}-${index}`, style: { marginBottom: 8 } },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ToolCallItem__WEBPACK_IMPORTED_MODULE_4__.ToolCallItem, { item: item })));
                }
                else if (item.type === "file") {
                    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_8__["default"], { key: `file-${index}`, src: item.data.startsWith("http")
                            ? item.data
                            : `data:${item.mimeType};base64,${item.data}`, alt: "Agent file", style: { maxWidth: "100%", marginTop: 8, marginBottom: 8 } }));
                }
                else if (item.type === "human_confirm") {
                    const isResponded = respondedCallbacks.has(item.callbackId) || item.responded;
                    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: `human-confirm-${item.callbackId}-${index}` },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_HumanCard__WEBPACK_IMPORTED_MODULE_2__.HumanCard, { item: { ...item, responded: isResponded }, onRespond: (value) => handleHumanResponse(item.callbackId, value) })));
                }
                else if (item.type === "human_input") {
                    const isResponded = respondedCallbacks.has(item.callbackId) || item.responded;
                    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: `human-input-${item.callbackId}-${index}` },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_HumanCard__WEBPACK_IMPORTED_MODULE_2__.HumanCard, { item: { ...item, responded: isResponded }, onRespond: (value) => handleHumanResponse(item.callbackId, value) })));
                }
                else if (item.type === "human_select") {
                    const isResponded = respondedCallbacks.has(item.callbackId) || item.responded;
                    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: `human-select-${item.callbackId}-${index}` },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_HumanCard__WEBPACK_IMPORTED_MODULE_2__.HumanCard, { item: { ...item, responded: isResponded }, onRespond: (value) => handleHumanResponse(item.callbackId, value) })));
                }
                else if (item.type === "human_help") {
                    const isResponded = respondedCallbacks.has(item.callbackId) || item.responded;
                    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: `human-help-${item.callbackId}-${index}` },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_HumanCard__WEBPACK_IMPORTED_MODULE_2__.HumanCard, { item: { ...item, responded: isResponded }, onRespond: (value) => handleHumanResponse(item.callbackId, value) })));
                }
                return null;
            }),
            agent.result && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], { message: "Execution Result", description: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_MarkdownRenderer__WEBPACK_IMPORTED_MODULE_5__.MarkdownRenderer, { content: agent.result }), type: "success", style: { marginTop: 8 } })),
            agent.error && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], { message: "Execution Error", description: agent.error.name
                    ? agent.error.name + ": " + agent.error.message
                    : String(agent.error), type: "error", style: { marginTop: 8 } }))))));
};


/***/ }),

/***/ "./src/sidebar/components/ChatInput.tsx":
/*!**********************************************!*\
  !*** ./src/sidebar/components/ChatInput.tsx ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ChatInput: () => (/* binding */ ChatInput)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/DeleteOutlined.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/FileOutlined.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/PaperClipOutlined.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/SendOutlined.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/StopOutlined.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/button/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/image/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/space/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/typography/index.js");
/* harmony import */ var _WebpageMentionInput__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./WebpageMentionInput */ "./src/sidebar/components/WebpageMentionInput.tsx");




const { Text } = antd__WEBPACK_IMPORTED_MODULE_9__["default"];
const ChatInput = ({ inputValue, onInputChange, onSend, onStop, onFileSelect, onRemoveFile, uploadedFiles, sending, currentMessageId, }) => {
    const fileInputRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: {
            padding: "16px",
            backgroundColor: "#ffffff",
            borderTop: "1px solid #e8e8e8",
        } },
        uploadedFiles.length > 0 && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { marginBottom: 8 } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_8__["default"], { wrap: true }, uploadedFiles.map((file) => {
                const isImage = file.mimeType.startsWith("image/");
                return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: file.id, style: {
                        display: "inline-flex",
                        alignItems: "center",
                        padding: "4px 8px",
                        backgroundColor: "#f5f5f5",
                        borderRadius: 4,
                        border: "1px solid #d9d9d9",
                    } },
                    isImage ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_7__["default"], { src: file.url
                            ? file.url
                            : `data:${file.mimeType};base64,${file.base64Data}`, alt: file.filename, style: {
                            width: 40,
                            height: 40,
                            objectFit: "cover",
                            borderRadius: 4,
                            marginRight: 8,
                        }, preview: false })) : (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_2__["default"], { style: { marginRight: 8, fontSize: 16 } })),
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { style: {
                            fontSize: 12,
                            marginRight: 8,
                            maxWidth: 150,
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            whiteSpace: "nowrap",
                        } }, file.filename),
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], { type: "text", size: "small", icon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_1__["default"], null), onClick: () => onRemoveFile(file.id), style: { padding: 0, width: 20, height: 20 } })));
            })))),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_8__["default"].Compact, { style: { width: "100%", alignItems: "center" } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement("input", { ref: fileInputRef, type: "file", multiple: true, accept: "image/*,.pdf,.docx,.xlsx,.txt,.md,.json", onChange: onFileSelect, style: { display: "none" } }),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], { icon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_3__["default"], null), onClick: () => { var _a; return (_a = fileInputRef.current) === null || _a === void 0 ? void 0 : _a.click(); }, disabled: sending || currentMessageId !== null }),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_WebpageMentionInput__WEBPACK_IMPORTED_MODULE_10__.WebpageMentionInput, { value: inputValue, onChange: onInputChange, disabled: sending || currentMessageId !== null, onSend: onSend }),
            currentMessageId ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], { danger: true, icon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_5__["default"], null), onClick: onStop }, "Stop")) : (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], { type: "primary", icon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_4__["default"], null), onClick: onSend, loading: sending, disabled: (!inputValue.trim() && uploadedFiles.length === 0) || sending, style: { padding: "0 10px" } }, "Send")))));
};


/***/ }),

/***/ "./src/sidebar/components/HumanCard.tsx":
/*!**********************************************!*\
  !*** ./src/sidebar/components/HumanCard.tsx ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   HumanCard: () => (/* binding */ HumanCard)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/button/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/card/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/checkbox/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/input/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/radio/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/space/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/tag/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/typography/index.js");
/* harmony import */ var _MarkdownRenderer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../MarkdownRenderer */ "./src/sidebar/MarkdownRenderer.tsx");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/CheckOutlined.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/CloseOutlined.js");




const { TextArea } = antd__WEBPACK_IMPORTED_MODULE_4__["default"];
const { Text } = antd__WEBPACK_IMPORTED_MODULE_8__["default"];
// Human callback handler
const sendHumanCallback = (callbackId, value) => {
    chrome.runtime.sendMessage({
        type: "human_callback",
        data: { callbackId, value },
    });
};
// Human Confirm Card
const HumanConfirmCard = ({ item, onRespond }) => {
    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("");
    const handleConfirm = () => {
        setValue("true");
        sendHumanCallback(item.callbackId, true);
        onRespond(true);
    };
    const handleCancel = () => {
        setValue("false");
        sendHumanCallback(item.callbackId, false);
        onRespond(false);
    };
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_2__["default"], { size: "small", style: {
            marginBottom: 8,
            backgroundColor: "#fff7e6",
            border: "1px solid #ffd591",
        } },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { marginBottom: 12 } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_MarkdownRenderer__WEBPACK_IMPORTED_MODULE_9__.MarkdownRenderer, { content: item.prompt })),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], null,
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_1__["default"], { type: "primary", icon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_10__["default"], null), onClick: handleConfirm, disabled: item.responded }, "Confirm"),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_1__["default"], { icon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_11__["default"], null), onClick: handleCancel, disabled: item.responded }, "Cancel"),
            item.responded && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { type: "secondary", style: { fontSize: 12 } },
                "Result: ",
                value || item.value)))));
};
// Human Input Card
const HumanInputCard = ({ item, onRespond }) => {
    const [inputValue, setInputValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("");
    const handleConfirm = () => {
        if (inputValue.trim()) {
            sendHumanCallback(item.callbackId, inputValue.trim());
            onRespond(inputValue.trim());
        }
    };
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_2__["default"], { size: "small", style: {
            marginBottom: 8,
            backgroundColor: "#e6f7ff",
            border: "1px solid #91d5ff",
        } },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { marginBottom: 12 } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_MarkdownRenderer__WEBPACK_IMPORTED_MODULE_9__.MarkdownRenderer, { content: item.prompt })),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], { direction: "vertical", style: { width: "100%" } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(TextArea, { value: inputValue, onChange: (e) => setInputValue(e.target.value), placeholder: "Enter your input...", rows: 3, disabled: item.responded, onPressEnter: (e) => {
                    if (!e.shiftKey && inputValue.trim()) {
                        e.preventDefault();
                        handleConfirm();
                    }
                } }),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_1__["default"], { type: "primary", icon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_10__["default"], null), onClick: handleConfirm, disabled: item.responded || !inputValue.trim() }, "Confirm"),
            item.responded && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { type: "secondary", style: { fontSize: 12 } },
                "Result: ",
                inputValue.trim() || item.value)))));
};
// Human Select Card
const HumanSelectCard = ({ item, onRespond }) => {
    const [selectedValues, setSelectedValues] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
    const handleConfirm = () => {
        if (selectedValues.length > 0) {
            sendHumanCallback(item.callbackId, selectedValues);
            onRespond(selectedValues);
        }
    };
    const handleChange = (value) => {
        if (item.multiple) {
            setSelectedValues((prev) => prev.includes(value)
                ? prev.filter((v) => v !== value)
                : [...prev, value]);
        }
        else {
            setSelectedValues([value]);
        }
    };
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_2__["default"], { size: "small", style: {
            marginBottom: 8,
            backgroundColor: "#f6ffed",
            border: "1px solid #b7eb8f",
        } },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { marginBottom: 12 } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_MarkdownRenderer__WEBPACK_IMPORTED_MODULE_9__.MarkdownRenderer, { content: item.prompt })),
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], { direction: "vertical", style: { width: "100%" } },
            item.multiple ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_3__["default"].Group, { value: selectedValues, onChange: (values) => setSelectedValues(values), disabled: item.responded },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], { direction: "vertical" }, item.options.map((option) => (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_3__["default"], { key: option, value: option }, option)))))) : (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_5__["default"].Group, { value: selectedValues[0], onChange: (e) => handleChange(e.target.value), disabled: item.responded },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], { direction: "vertical" }, item.options.map((option) => (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_5__["default"], { key: option, value: option }, option)))))),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_1__["default"], { type: "primary", icon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_10__["default"], null), onClick: handleConfirm, disabled: item.responded || selectedValues.length === 0 }, "Confirm"),
            item.responded && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { type: "secondary", style: { fontSize: 12 } },
                "Result: ",
                selectedValues.join(", ") || item.value)))));
};
// Human Help Card
const HumanHelpCard = ({ item, onRespond }) => {
    const [value, setValue] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("");
    const handleComplete = () => {
        setValue("true");
        sendHumanCallback(item.callbackId, true);
        onRespond(true);
    };
    const handleCancel = () => {
        setValue("false");
        sendHumanCallback(item.callbackId, false);
        onRespond(false);
    };
    const helpTypeText = item.helpType === "request_login"
        ? "Login Required"
        : "Assistance Required";
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_2__["default"], { size: "small", style: {
            marginBottom: 8,
            backgroundColor: "#fff1f0",
            border: "1px solid #ffccc7",
        } },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], { direction: "vertical", style: { width: "100%" } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_7__["default"], { color: "orange" }, helpTypeText),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { marginBottom: 12 } },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_MarkdownRenderer__WEBPACK_IMPORTED_MODULE_9__.MarkdownRenderer, { content: item.prompt })),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], null,
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_1__["default"], { type: "primary", icon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_10__["default"], null), onClick: handleComplete, disabled: item.responded }, "Complete"),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_1__["default"], { icon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_11__["default"], null), onClick: handleCancel, disabled: item.responded }, "Cancel"),
                item.responded && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { type: "secondary", style: { fontSize: 12 } },
                    "Result: ",
                    value || item.value))))));
};
const HumanCard = ({ item, onRespond }) => {
    switch (item.type) {
        case "human_confirm":
            return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(HumanConfirmCard, { item: item, onRespond: onRespond });
        case "human_input":
            return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(HumanInputCard, { item: item, onRespond: onRespond });
        case "human_select":
            return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(HumanSelectCard, { item: item, onRespond: onRespond });
        case "human_help":
            return react__WEBPACK_IMPORTED_MODULE_0___default().createElement(HumanHelpCard, { item: item, onRespond: onRespond });
        default:
            return react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null,
                "Unknown human card type: ",
                item.type);
    }
};


/***/ }),

/***/ "./src/sidebar/components/MessageItem.tsx":
/*!************************************************!*\
  !*** ./src/sidebar/components/MessageItem.tsx ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MessageItem: () => (/* binding */ MessageItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _TextItem__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./TextItem */ "./src/sidebar/components/TextItem.tsx");
/* harmony import */ var _ThinkingItem__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ThinkingItem */ "./src/sidebar/components/ThinkingItem.tsx");
/* harmony import */ var _ToolCallItem__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ToolCallItem */ "./src/sidebar/components/ToolCallItem.tsx");
/* harmony import */ var _WorkflowCard__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./WorkflowCard */ "./src/sidebar/components/WorkflowCard.tsx");
/* harmony import */ var _MarkdownRenderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../MarkdownRenderer */ "./src/sidebar/MarkdownRenderer.tsx");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/alert/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/card/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/image/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/space/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/spin/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/typography/index.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/FileOutlined.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/RobotOutlined.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/UserOutlined.js");








const { Text, Paragraph } = antd__WEBPACK_IMPORTED_MODULE_11__["default"];
const decodeHtmlEntities = (text) => {
    if (!text)
        return "";
    if (typeof window === "undefined") {
        return text
            .replace(/&lt;/g, "<")
            .replace(/&gt;/g, ">")
            .replace(/&amp;/g, "&")
            .replace(/&quot;/g, '"')
            .replace(/&#39;/g, "'");
    }
    const textarea = document.createElement("textarea");
    textarea.innerHTML = text;
    return textarea.value;
};
const renderContentWithWebRefs = (content, onWebRefClick) => {
    if (!content)
        return null;
    const elements = [];
    const regex = /<span class="webpage-reference"[^>]*tab-id="([^"]+)"[^>]*url="([^"]+)"[^>]*>(.*?)<\/span>/gi;
    let lastIndex = 0;
    let keyIndex = 0;
    const pushText = (text) => {
        if (!text)
            return;
        const normalized = text.replace(/<br\s*\/?>/gi, "\n");
        const decoded = decodeHtmlEntities(normalized);
        if (!decoded)
            return;
        const parts = decoded.split(/(\n)/);
        parts.forEach((part) => {
            if (!part) {
                return;
            }
            if (part === "\n") {
                elements.push(react__WEBPACK_IMPORTED_MODULE_0___default().createElement("br", { key: `br-${keyIndex++}` }));
            }
            else {
                elements.push(react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), { key: `text-${keyIndex++}` }, part));
            }
        });
    };
    let match;
    while ((match = regex.exec(content)) !== null) {
        const [fullMatch, tabId, url, title] = match;
        if (match.index > lastIndex) {
            pushText(content.slice(lastIndex, match.index));
        }
        const decodedTitle = decodeHtmlEntities(title);
        const decodedUrl = decodeHtmlEntities(url);
        elements.push(react__WEBPACK_IMPORTED_MODULE_0___default().createElement("span", { key: `webref-${tabId || keyIndex}`, className: "webpage-reference-display user-webpage-reference", onClick: () => onWebRefClick(decodedUrl) }, `${decodedTitle}`));
        lastIndex = match.index + fullMatch.length;
    }
    if (lastIndex < content.length) {
        pushText(content.slice(lastIndex));
    }
    if (elements.length === 0) {
        return decodeHtmlEntities(content);
    }
    return elements;
};
const MessageItem = ({ message }) => {
    var _a;
    const handleWebRefClick = (url) => {
        var _a;
        if (!url)
            return;
        if (typeof chrome !== "undefined" && ((_a = chrome.tabs) === null || _a === void 0 ? void 0 : _a.create)) {
            chrome.tabs.create({ url });
        }
        else {
            window.open(url, "_blank", "noopener");
        }
    };
    const userContent = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => renderContentWithWebRefs(message.content || "", handleWebRefClick), [message.content]);
    if (message.role === "user") {
        return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: {
                display: "flex",
                justifyContent: "flex-end",
                marginBottom: 16,
            } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_7__["default"], { style: {
                    maxWidth: "70%",
                    backgroundColor: "#1890ff",
                    color: "white",
                }, styles: {
                    body: { padding: "12px 16px" },
                } },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_9__["default"], { direction: "vertical", size: "small", style: { width: "100%" } },
                    (message.content || ((_a = message.uploadedFiles) === null || _a === void 0 ? void 0 : _a.length)) && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_9__["default"], null,
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_14__["default"], null),
                        message.content && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Paragraph, { style: { margin: 0, color: "white" } }, userContent)),
                        message.status == "waiting" && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_10__["default"], { size: "small", style: { color: "white" } })))),
                    message.uploadedFiles && message.uploadedFiles.length > 0 && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { marginTop: 8 } }, message.uploadedFiles.map((file) => {
                        const isImage = file.mimeType.startsWith("image/");
                        return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: file.id, style: {
                                marginBottom: 8,
                                padding: 8,
                                backgroundColor: "rgba(255, 255, 255, 0.2)",
                                borderRadius: 4,
                            } }, isImage ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_8__["default"], { src: file.url
                                ? file.url
                                : `data:${file.mimeType};base64,${file.base64Data}`, alt: file.filename, style: {
                                maxWidth: "100%",
                                maxHeight: 200,
                                borderRadius: 4,
                            }, preview: false })) : (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_9__["default"], null,
                            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_12__["default"], { style: { color: "white" } }),
                            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { style: { color: "white", fontSize: 12 } }, file.filename)))));
                    })))))));
    }
    // AI message
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { marginBottom: 16 } },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_7__["default"], { style: { backgroundColor: "#fafafa" }, title: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_9__["default"], null,
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_13__["default"], null),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { strong: true }, "AI Assistant")) },
            message.contentItems && message.contentItems.length > 0 ? (message.contentItems.map((item, index) => {
                if (item.type === "thinking") {
                    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: `chat-thinking-${item.streamId}-${index}` },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ThinkingItem__WEBPACK_IMPORTED_MODULE_2__.ThinkingItem, { streamId: item.streamId, text: item.text, streamDone: item.streamDone })));
                }
                else if (item.type === "text") {
                    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: `chat-text-${item.streamId}-${index}` },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_TextItem__WEBPACK_IMPORTED_MODULE_1__.TextItem, { streamId: item.streamId, text: item.text, streamDone: item.streamDone })));
                }
                else if (item.type === "tool") {
                    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: `chat-tool-${item.toolCallId}-${index}`, style: { marginBottom: 8 } },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ToolCallItem__WEBPACK_IMPORTED_MODULE_3__.ToolCallItem, { item: item })));
                }
                else if (item.type === "file") {
                    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_8__["default"], { key: `chat-file-${index}`, src: item.data.startsWith("http")
                            ? item.data
                            : `data:${item.mimeType};base64,${item.data}`, alt: "Message file", style: { maxWidth: "100%", marginTop: 8, marginBottom: 8 } }));
                }
                else if (item.type === "task") {
                    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: `chat-task-${item.taskId}-${index}`, style: { marginBottom: 8 } },
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_WorkflowCard__WEBPACK_IMPORTED_MODULE_4__.WorkflowCard, { task: item.task })));
                }
                return null;
            })) : message.content ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { marginBottom: 8 } },
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_MarkdownRenderer__WEBPACK_IMPORTED_MODULE_5__.MarkdownRenderer, { content: message.content }))) : message.status == "waiting" ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_10__["default"], { size: "small" })) : (react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), null)),
            message.error && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], { message: "Error", description: String(message.error), type: "error", style: { marginTop: 8 } })))));
};


/***/ }),

/***/ "./src/sidebar/components/TextItem.tsx":
/*!*********************************************!*\
  !*** ./src/sidebar/components/TextItem.tsx ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextItem: () => (/* binding */ TextItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/spin/index.js");
/* harmony import */ var _MarkdownRenderer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../MarkdownRenderer */ "./src/sidebar/MarkdownRenderer.tsx");



const TextItem = ({ text, streamDone }) => {
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { marginBottom: 8 } },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_MarkdownRenderer__WEBPACK_IMPORTED_MODULE_2__.MarkdownRenderer, { content: text }),
        !streamDone && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_1__["default"], { size: "small", style: { color: "white" } })));
};


/***/ }),

/***/ "./src/sidebar/components/ThinkingItem.tsx":
/*!*************************************************!*\
  !*** ./src/sidebar/components/ThinkingItem.tsx ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ThinkingItem: () => (/* binding */ ThinkingItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/collapse/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/space/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/typography/index.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/LoadingOutlined.js");



const { Text, Paragraph } = antd__WEBPACK_IMPORTED_MODULE_3__["default"];
const ThinkingItem = ({ text, streamDone, }) => {
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_1__["default"], { size: "small", style: { marginBottom: 8 }, defaultActiveKey: streamDone ? [] : ["thinking"], items: [
            {
                key: "thinking",
                label: (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_2__["default"], null,
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_4__["default"], null),
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { type: "secondary" }, "Thinking..."))),
                children: (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Paragraph, { style: { margin: 0, whiteSpace: "pre-wrap" }, type: "secondary" },
                    text,
                    !streamDone && react__WEBPACK_IMPORTED_MODULE_0___default().createElement("span", { className: "streaming-cursor" }, "|"))),
            },
        ] }));
};


/***/ }),

/***/ "./src/sidebar/components/ToolCallItem.tsx":
/*!*************************************************!*\
  !*** ./src/sidebar/components/ToolCallItem.tsx ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ToolCallItem: () => (/* binding */ ToolCallItem)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/CheckCircleOutlined.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/CloseCircleOutlined.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/ToolOutlined.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "./src/sidebar/utils/index.ts");
/* harmony import */ var _MarkdownRenderer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../MarkdownRenderer */ "./src/sidebar/MarkdownRenderer.tsx");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/card/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/collapse/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/image/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/space/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/spin/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/tag/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/typography/index.js");





const { Text, Paragraph } = antd__WEBPACK_IMPORTED_MODULE_12__["default"];
const ToolCallItem = ({ item }) => {
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_6__["default"], { size: "small", style: { marginTop: 8, backgroundColor: "#f5f5f5" }, title: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_9__["default"], null,
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_3__["default"], null),
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { strong: true }, item.toolName),
            item.running && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_10__["default"], { size: "small" }),
            item.result && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_11__["default"], { color: item.result.isError ? "red" : "green", icon: item.result.isError ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_2__["default"], null)) : (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_1__["default"], null)) }, item.result.isError ? "Failed" : "Completed"))) },
        item.paramsText && !item.params && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { type: "secondary", code: true },
            item.paramsText,
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement("span", { className: "streaming-cursor" }, "|"))),
        item.params && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_7__["default"], { size: "small", defaultActiveKey: ["params"], items: [
                {
                    key: "params",
                    label: "Parameters",
                    children: (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("pre", { className: "tool-json-pre" }, JSON.stringify(item.params, null, 2))),
                },
            ] })),
        item.running && item.runningText && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Paragraph, { type: "secondary", style: { marginTop: 8, marginBottom: 0 } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_MarkdownRenderer__WEBPACK_IMPORTED_MODULE_5__.MarkdownRenderer, { content: item.runningText }))),
        item.result && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_7__["default"], { size: "small", style: { marginTop: 8 }, defaultActiveKey: item.result.isError ? ["result"] : [], items: [
                {
                    key: "result",
                    label: (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_9__["default"], null,
                        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, null, "Result"),
                        item.result.isError && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_11__["default"], { color: "red", icon: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_2__["default"], null) }, "Failed")))),
                    children: (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null, item.result.content.map((part, index) => {
                        if (part.type === "text") {
                            return (0,_utils__WEBPACK_IMPORTED_MODULE_4__.isJsonStr)(part.text) ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("pre", { key: index, className: "tool-json-pre" }, JSON.stringify(JSON.parse(part.text), null, 2))) : (
                            // <Paragraph key={index} style={{ margin: 0 }}>
                            //   {part.text}
                            // </Paragraph>
                            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_MarkdownRenderer__WEBPACK_IMPORTED_MODULE_5__.MarkdownRenderer, { key: index, content: part.text }));
                        }
                        else if (part.type === "image") {
                            return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_8__["default"], { key: index, src: part.data.startsWith("http")
                                    ? part.data
                                    : `data:${part.mimeType || "image/png"};base64,${part.data}`, alt: "Tool result", style: { maxWidth: "100%", marginTop: 8 } }));
                        }
                        return null;
                    }))),
                },
            ] }))));
};


/***/ }),

/***/ "./src/sidebar/components/WebpageMentionInput.tsx":
/*!********************************************************!*\
  !*** ./src/sidebar/components/WebpageMentionInput.tsx ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebpageMentionInput: () => (/* binding */ WebpageMentionInput)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/typography/index.js");
/* harmony import */ var _eko_ai_eko__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @eko-ai/eko */ "../../packages/eko-core/dist/index.esm.js");
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/GlobalOutlined.js");




const { Text } = antd__WEBPACK_IMPORTED_MODULE_1__["default"];
const escapeHtml = (text) => text
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#39;");
const formatValueForDisplay = (value) => {
    if (!value)
        return "";
    const container = document.createElement("div");
    container.innerHTML = value;
    container.querySelectorAll(".webpage-reference").forEach((el) => {
        const displaySpan = document.createElement("span");
        displaySpan.setAttribute("class", "webpage-reference-display");
        displaySpan.setAttribute("contenteditable", "false");
        Array.from(el.attributes).forEach((attr) => {
            if (attr.name === "class")
                return;
            displaySpan.setAttribute(attr.name, attr.value);
        });
        displaySpan.textContent = el.textContent || "";
        el.replaceWith(displaySpan);
    });
    return container.innerHTML.replace(/\n/g, "<br/>");
};
const htmlToPlainText = (html) => {
    const container = document.createElement("div");
    container.innerHTML = html;
    container.querySelectorAll(".webpage-reference-display").forEach((el) => {
        const title = el.textContent || "";
        const displayText = title.startsWith("@") ? title : `@${title}`;
        el.replaceWith(displayText);
    });
    container.querySelectorAll(".webpage-reference").forEach((el) => {
        const title = el.textContent || "";
        el.replaceWith(`@${title}`);
    });
    return container.innerText.replace(/\u00A0/g, " ");
};
const htmlToValue = (html) => {
    const container = document.createElement("div");
    container.innerHTML = html;
    container.querySelectorAll(".webpage-reference-display").forEach((el) => {
        const span = document.createElement("span");
        span.setAttribute("class", "webpage-reference");
        const tabId = el.getAttribute("tab-id") || "";
        const url = el.getAttribute("url") || "";
        if (tabId) {
            span.setAttribute("tab-id", tabId);
        }
        if (url) {
            span.setAttribute("url", url);
        }
        const textContent = (el.textContent || "").replace(/^@/, "");
        span.textContent = textContent;
        el.replaceWith(span);
    });
    const placeholders = [];
    container.querySelectorAll(".webpage-reference").forEach((el, index) => {
        const token = `__WEB_REF_${index}__`;
        placeholders.push(el.outerHTML);
        el.replaceWith(token);
    });
    let plainText = container.innerText.replace(/\u00A0/g, " ");
    placeholders.forEach((markup, index) => {
        plainText = plainText.replace(`__WEB_REF_${index}__`, markup);
    });
    return plainText.trim();
};
const getHtmlToCaret = (editor) => {
    if (!editor)
        return null;
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0)
        return null;
    const range = selection.getRangeAt(0);
    if (!editor.contains(range.endContainer))
        return null;
    const preRange = range.cloneRange();
    preRange.selectNodeContents(editor);
    preRange.setEnd(range.endContainer, range.endOffset);
    const div = document.createElement("div");
    div.appendChild(preRange.cloneContents());
    return div.innerHTML;
};
const ensureSpaceAfterElement = (element) => {
    var _a;
    const parent = element.parentNode;
    if (!parent)
        return;
    const nextNode = element.nextSibling;
    if (!nextNode) {
        parent.appendChild(document.createTextNode(" "));
        return;
    }
    if (nextNode.nodeType === Node.TEXT_NODE) {
        const textNode = nextNode;
        if (!((_a = textNode.textContent) === null || _a === void 0 ? void 0 : _a.startsWith(" "))) {
            textNode.insertData(0, " ");
        }
    }
    else {
        parent.insertBefore(document.createTextNode(" "), nextNode);
    }
};
const WebpageMentionInput = ({ value, onChange, disabled, onSend, }) => {
    const editorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    const tabListRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    const [tabs, setTabs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);
    const [showDropdown, setShowDropdown] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
    const [atPosition, setAtPosition] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);
    const [mentionQueryLength, setMentionQueryLength] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);
    const [mentionQuery, setMentionQuery] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)("");
    const [highlightedIndex, setHighlightedIndex] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0);
    const [loadingTabs, setLoadingTabs] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);
    const pendingFocusRefId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);
    const skipSyncRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);
    const resetMentionState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
        setShowDropdown(false);
        setAtPosition(null);
        setMentionQuery("");
        setMentionQueryLength(0);
        setHighlightedIndex(0);
    }, []);
    const getTabs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {
        setLoadingTabs(true);
        return new Promise((resolve, reject) => {
            const requestId = (0,_eko_ai_eko__WEBPACK_IMPORTED_MODULE_2__.uuidv4)();
            const timer = setTimeout(() => {
                chrome.runtime.onMessage.removeListener(listener);
                reject(new Error("Get tabs timeout"));
            }, 10000);
            const listener = (message) => {
                if (message.type === "getTabs_result" &&
                    message.requestId === requestId) {
                    clearTimeout(timer);
                    chrome.runtime.onMessage.removeListener(listener);
                    if (message.data.error) {
                        reject(new Error(message.data.error));
                    }
                    else {
                        resolve(message.data.tabs || []);
                    }
                }
            };
            chrome.runtime.onMessage.addListener(listener);
            chrome.runtime.sendMessage({
                requestId,
                type: "getTabs",
                data: {},
            });
        });
    }, []);
    const displayHtml = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => formatValueForDisplay(value), [value]);
    const filteredTabs = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {
        const query = mentionQuery.trim().toLowerCase();
        const list = query
            ? tabs.filter((tab) => {
                var _a, _b;
                const title = ((_a = tab.title) === null || _a === void 0 ? void 0 : _a.toLowerCase()) || "";
                const url = ((_b = tab.url) === null || _b === void 0 ? void 0 : _b.toLowerCase()) || "";
                return title.includes(query) || url.includes(query);
            })
            : tabs;
        return list;
    }, [mentionQuery, tabs]);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        if (skipSyncRef.current) {
            skipSyncRef.current = false;
            return;
        }
        const editor = editorRef.current;
        if (!editor)
            return;
        if (editor.innerHTML !== displayHtml) {
            editor.innerHTML = displayHtml || "";
        }
        if (pendingFocusRefId.current) {
            const target = editor.querySelector(`[tab-id="${pendingFocusRefId.current}"]`);
            if (target) {
                editor.focus();
                const selection = window.getSelection();
                if (selection) {
                    const range = document.createRange();
                    let nextNode = target.nextSibling;
                    if (nextNode && nextNode.nodeType === Node.TEXT_NODE) {
                        const textNode = nextNode;
                        if (textNode.textContent && textNode.textContent.startsWith(" ")) {
                            range.setStart(textNode, 1);
                            range.collapse(true);
                        }
                        else {
                            range.setStartAfter(target);
                            range.collapse(true);
                            ensureSpaceAfterElement(target);
                            const newNode = target.nextSibling;
                            if (newNode && newNode.nodeType === Node.TEXT_NODE) {
                                range.setStart(newNode, 1);
                                range.collapse(true);
                            }
                        }
                    }
                    else {
                        ensureSpaceAfterElement(target);
                        const inserted = target.nextSibling;
                        if (inserted && inserted.nodeType === Node.TEXT_NODE) {
                            range.setStart(inserted, 1);
                        }
                        else {
                            range.setStartAfter(target);
                        }
                        range.collapse(true);
                    }
                    selection.removeAllRanges();
                    selection.addRange(range);
                }
            }
            pendingFocusRefId.current = null;
        }
    }, [displayHtml]);
    const updateMentionState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
        const editor = editorRef.current;
        if (!editor) {
            resetMentionState();
            return;
        }
        const htmlToCaret = getHtmlToCaret(editor);
        if (htmlToCaret == null) {
            resetMentionState();
            return;
        }
        const plainBefore = htmlToPlainText(htmlToCaret);
        const lastAtIndex = plainBefore.lastIndexOf("@");
        if (lastAtIndex === -1) {
            resetMentionState();
            return;
        }
        const textAfterAt = plainBefore.substring(lastAtIndex + 1);
        if (textAfterAt.includes(" ") || textAfterAt.includes("\n")) {
            resetMentionState();
            return;
        }
        const rawFragment = htmlToValue(htmlToCaret);
        const atIndexInRaw = rawFragment.lastIndexOf("@");
        if (atIndexInRaw === -1) {
            resetMentionState();
            return;
        }
        setAtPosition(atIndexInRaw);
        setMentionQueryLength(textAfterAt.length);
        setMentionQuery(textAfterAt);
        if (!showDropdown) {
            setShowDropdown(true);
            setLoadingTabs(true);
            getTabs()
                .then((fetched) => {
                setTabs(fetched);
                setLoadingTabs(false);
            })
                .catch((error) => {
                console.error("Error getting tabs:", error);
                setLoadingTabs(false);
            });
        }
    }, [getTabs, resetMentionState, showDropdown]);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        const handleClickOutside = (e) => {
            const editor = editorRef.current;
            const dropdown = document.querySelector("[data-tab-dropdown]");
            if (showDropdown &&
                editor &&
                !editor.contains(e.target) &&
                dropdown &&
                !dropdown.contains(e.target)) {
                resetMentionState();
            }
        };
        document.addEventListener("click", handleClickOutside);
        return () => {
            document.removeEventListener("click", handleClickOutside);
        };
    }, [resetMentionState, showDropdown]);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        if (!showDropdown)
            return;
        if (filteredTabs.length === 0) {
            setHighlightedIndex(-1);
            return;
        }
        setHighlightedIndex((prev) => {
            if (prev < 0 || prev >= filteredTabs.length) {
                return 0;
            }
            return prev;
        });
    }, [filteredTabs, showDropdown]);
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        if (!showDropdown)
            return;
        if (highlightedIndex < 0)
            return;
        const container = tabListRef.current;
        if (!container)
            return;
        const option = container.querySelector(`[data-tab-option-index="${highlightedIndex}"]`);
        option === null || option === void 0 ? void 0 : option.scrollIntoView({ block: "nearest" });
    }, [highlightedIndex, showDropdown]);
    const insertWebpageReference = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((tab) => {
        if (atPosition === null)
            return;
        const beforeAt = value.substring(0, atPosition);
        const afterAtStart = atPosition + 1 + mentionQueryLength;
        const afterAt = value.substring(afterAtStart);
        const reference = `<span class="webpage-reference" tab-id="${tab.tabId}" url="${escapeHtml(tab.url)}">${escapeHtml(tab.title)}</span>`;
        const newValue = `${beforeAt}${reference} ${afterAt}`;
        onChange(newValue);
        resetMentionState();
        pendingFocusRefId.current = tab.tabId;
        setTimeout(() => {
            var _a;
            (_a = editorRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        }, 0);
    }, [atPosition, mentionQueryLength, onChange, resetMentionState, value]);
    const handleEditorInput = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {
        const editor = editorRef.current;
        if (!editor)
            return;
        const newValue = htmlToValue(editor.innerHTML);
        onChange(newValue);
        updateMentionState();
        skipSyncRef.current = true;
    }, [onChange, updateMentionState]);
    const handleEditorPaste = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {
        var _a;
        event.preventDefault();
        const text = ((_a = event.clipboardData) === null || _a === void 0 ? void 0 : _a.getData("text/plain")) || "";
        document.execCommand("insertText", false, text);
    }, []);
    const handleEditorKeyDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {
        if (disabled)
            return;
        if (showDropdown) {
            if (event.key === "ArrowDown") {
                event.preventDefault();
                if (filteredTabs.length > 0) {
                    setHighlightedIndex((prev) => {
                        if (prev < 0)
                            return 0;
                        return (prev + 1) % filteredTabs.length;
                    });
                }
                return;
            }
            if (event.key === "ArrowUp") {
                event.preventDefault();
                if (filteredTabs.length > 0) {
                    setHighlightedIndex((prev) => {
                        if (prev <= 0)
                            return filteredTabs.length - 1;
                        return prev - 1;
                    });
                }
                return;
            }
            if (event.key === "Enter" && !event.shiftKey) {
                event.preventDefault();
                if (highlightedIndex >= 0 && highlightedIndex < filteredTabs.length) {
                    insertWebpageReference(filteredTabs[highlightedIndex]);
                    return;
                }
            }
        }
        if (event.key === "Enter" && !event.shiftKey && !showDropdown) {
            event.preventDefault();
            onSend();
        }
        else if (event.key === "Escape" && showDropdown) {
            resetMentionState();
        }
    }, [
        disabled,
        filteredTabs,
        highlightedIndex,
        insertWebpageReference,
        onSend,
        resetMentionState,
        showDropdown,
    ]);
    const handleEditorClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {
        const target = event.target;
        if (target && target.classList.contains("webpage-reference-display")) {
            const url = target.getAttribute("url");
            if (url) {
                chrome.tabs
                    ? chrome.tabs.create({ url })
                    : window.open(url, "_blank", "noopener");
            }
        }
        updateMentionState();
    }, [updateMentionState]);
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { className: "chat-input-rich-container" },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { ref: editorRef, className: "chat-input-editor", contentEditable: !disabled, suppressContentEditableWarning: true, "data-placeholder": "Type a message...", onInput: handleEditorInput, onKeyDown: handleEditorKeyDown, onKeyUp: updateMentionState, onMouseUp: updateMentionState, onClick: handleEditorClick, onPaste: handleEditorPaste }),
        showDropdown && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { "data-tab-dropdown": true, style: {
                position: "absolute",
                bottom: "100%",
                left: 0,
                right: 0,
                marginBottom: 4,
                backgroundColor: "#ffffff",
                border: "1px solid #d9d9d9",
                borderRadius: 4,
                boxShadow: "0 2px 8px rgba(0,0,0,0.15)",
                zIndex: 1000,
            } }, loadingTabs ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { padding: 12, textAlign: "center" } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { type: "secondary" }, "Loading..."))) : filteredTabs.length === 0 ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { padding: 12, textAlign: "center" } },
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { type: "secondary" }, "No tabs found"))) : (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { ref: tabListRef, style: {
                maxHeight: 300,
                overflowY: "auto",
            } }, filteredTabs.map((tab, index) => {
            const isActive = index === highlightedIndex;
            return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: tab.tabId || index, style: {
                    cursor: "pointer",
                    padding: "8px 12px",
                    backgroundColor: isActive ? "#e6f4ff" : "transparent",
                    display: "flex",
                    alignItems: "center",
                    gap: 8,
                }, onMouseDown: (e) => {
                    e.preventDefault();
                    insertWebpageReference(tab);
                }, onMouseEnter: () => setHighlightedIndex(index), "data-tab-option-index": index },
                tab.favicon ? (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("img", { src: tab.favicon, alt: "icon", style: {
                        width: "1em",
                        height: "1em",
                        borderRadius: "50%",
                    } })) : (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_3__["default"], null)),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { flex: 1, minWidth: 0 } },
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { strong: true, style: {
                            display: "block",
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            whiteSpace: "nowrap",
                        } }, tab.title),
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { type: "secondary", style: {
                            display: "block",
                            fontSize: 12,
                            overflow: "hidden",
                            textOverflow: "ellipsis",
                            whiteSpace: "nowrap",
                        } }, tab.url))));
        })))))));
};


/***/ }),

/***/ "./src/sidebar/components/WorkflowCard.tsx":
/*!*************************************************!*\
  !*** ./src/sidebar/components/WorkflowCard.tsx ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WorkflowCard: () => (/* binding */ WorkflowCard)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ant_design_icons__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ant-design/icons */ "../../node_modules/.pnpm/@ant-design+icons@5.6.1_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/@ant-design/icons/es/icons/RobotOutlined.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/card/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/space/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/spin/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/typography/index.js");
/* harmony import */ var _AgentExecutionCard__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./AgentExecutionCard */ "./src/sidebar/components/AgentExecutionCard.tsx");




const { Text, Paragraph } = antd__WEBPACK_IMPORTED_MODULE_5__["default"];
const WorkflowCard = ({ task }) => {
    if (!task.workflow)
        return null;
    const workflow = task.workflow;
    const agents = workflow.agents;
    // Build agent tree structure
    const buildAgentGroups = () => {
        const groups = [];
        let currentGroup = [];
        for (const agent of agents) {
            if (agent.parallel) {
                currentGroup.push(agent);
            }
            else {
                if (currentGroup.length > 0) {
                    groups.push(currentGroup);
                    currentGroup = [];
                }
                groups.push([agent]);
            }
        }
        if (currentGroup.length > 0) {
            groups.push(currentGroup);
        }
        return groups;
    };
    const agentGroups = buildAgentGroups();
    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { marginTop: 16 } },
        react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_2__["default"], { size: "small", title: react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_3__["default"], null,
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_ant_design_icons__WEBPACK_IMPORTED_MODULE_1__["default"], null),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { strong: true }, "Multi-Agent Workflow"),
                !task.workflowStreamDone && react__WEBPACK_IMPORTED_MODULE_0___default().createElement(antd__WEBPACK_IMPORTED_MODULE_4__["default"], { size: "small" })), style: { backgroundColor: "#f0f7ff" } },
            workflow.thought && (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Paragraph, { type: "secondary", style: { marginBottom: 16 } }, workflow.thought)),
            agentGroups.map((group, groupIndex) => (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: groupIndex, style: { marginBottom: 16 } }, group.length === 1 ? (
            // Single agent
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null,
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_AgentExecutionCard__WEBPACK_IMPORTED_MODULE_6__.AgentExecutionCard, { agentNode: group[0], task: task }))) : (
            // Parallel agents
            react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", null,
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement(Text, { strong: true, style: { color: "#1890ff" } },
                    "[",
                    group.map((a) => a.name).join(", "),
                    "]"),
                react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { style: { marginLeft: 16, marginTop: 8 } }, group.map((agent) => (react__WEBPACK_IMPORTED_MODULE_0___default().createElement("div", { key: agent.id, style: { marginBottom: 8 } },
                    react__WEBPACK_IMPORTED_MODULE_0___default().createElement(_AgentExecutionCard__WEBPACK_IMPORTED_MODULE_6__.AgentExecutionCard, { agentNode: agent, task: task })))))))))))));
};


/***/ }),

/***/ "./src/sidebar/hooks/useChatCallbacks.ts":
/*!***********************************************!*\
  !*** ./src/sidebar/hooks/useChatCallbacks.ts ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useChatCallbacks: () => (/* binding */ useChatCallbacks)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _eko_ai_eko__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @eko-ai/eko */ "../../packages/eko-core/dist/index.esm.js");


const useChatCallbacks = (setMessages, currentMessageId, setCurrentMessageId) => {
    // Handle chat callbacks
    const handleChatCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((data) => {
        setMessages((prev) => {
            var _a;
            const newMessages = [...prev];
            const aiMessageId = `ai-${data.messageId}`;
            let aiMessage = newMessages.find((m) => m.id === aiMessageId);
            if (!aiMessage) {
                const userMessage = newMessages.find((m) => m.id === data.messageId);
                if (!userMessage) {
                    // User message doesn't exist, might be message order issue, return early
                    return prev;
                }
                userMessage.status = "running";
                const _aiMessage = {
                    id: aiMessageId,
                    role: "assistant",
                    content: "",
                    status: "waiting",
                    timestamp: Date.now(),
                    contentItems: [],
                };
                newMessages.push(_aiMessage);
                aiMessage = _aiMessage;
            }
            if (!aiMessage.contentItems) {
                aiMessage.contentItems = [];
            }
            // Handle different types of callbacks
            if (data.type === "chat_start") {
                if (data.messageId !== currentMessageId) {
                    setCurrentMessageId(data.messageId);
                }
            }
            else {
                aiMessage.status = "running";
            }
            if (data.type === "text" || data.type === "thinking") {
                const existingIndex = aiMessage.contentItems.findIndex((item) => (item.type === "text" || item.type === "thinking") &&
                    item.streamId === data.streamId);
                if (existingIndex >= 0) {
                    aiMessage.contentItems[existingIndex].text = data.text;
                    aiMessage.contentItems[existingIndex].streamDone =
                        data.streamDone;
                }
                else {
                    aiMessage.contentItems.push({
                        type: data.type,
                        streamId: data.streamId,
                        text: data.text,
                        streamDone: data.streamDone,
                    });
                }
                if (data.type === "text" && data.streamDone) {
                    aiMessage.content = data.text;
                }
            }
            else if (data.type === "file") {
                aiMessage.contentItems.push({
                    type: "file",
                    mimeType: data.mimeType,
                    data: data.data,
                });
            }
            else if (data.type === "tool_streaming") {
                const existingIndex = aiMessage.contentItems.findIndex((item) => item.type === "tool" && item.toolCallId === data.toolCallId);
                if (existingIndex >= 0) {
                    aiMessage.contentItems[existingIndex].paramsText =
                        data.paramsText;
                }
                else {
                    aiMessage.contentItems.push({
                        type: "tool",
                        toolCallId: data.toolCallId,
                        toolName: data.toolName,
                        paramsText: data.paramsText,
                    });
                }
            }
            else if (data.type === "tool_use") {
                const existingIndex = aiMessage.contentItems.findIndex((item) => item.type === "tool" && item.toolCallId === data.toolCallId);
                if (existingIndex >= 0) {
                    aiMessage.contentItems[existingIndex].params = data.params;
                }
                else {
                    aiMessage.contentItems.push({
                        type: "tool",
                        toolCallId: data.toolCallId,
                        toolName: data.toolName,
                        params: data.params,
                    });
                }
            }
            else if (data.type === "tool_running") {
                const existingIndex = aiMessage.contentItems.findIndex((item) => item.type === "tool" && item.toolCallId === data.toolCallId);
                if (existingIndex >= 0) {
                    aiMessage.contentItems[existingIndex].running =
                        !data.streamDone;
                    aiMessage.contentItems[existingIndex].runningText =
                        data.text;
                }
                else {
                    aiMessage.contentItems.push({
                        type: "tool",
                        toolCallId: data.toolCallId,
                        toolName: data.toolName,
                        running: true,
                        runningText: data.text,
                    });
                }
            }
            else if (data.type === "tool_result") {
                const existingIndex = aiMessage.contentItems.findIndex((item) => item.type === "tool" && item.toolCallId === data.toolCallId);
                if (existingIndex >= 0) {
                    aiMessage.contentItems[existingIndex].result =
                        data.toolResult;
                    aiMessage.contentItems[existingIndex].running = false;
                }
                else {
                    aiMessage.contentItems.push({
                        type: "tool",
                        toolCallId: data.toolCallId,
                        toolName: data.toolName,
                        params: data.params,
                        result: data.toolResult,
                    });
                }
                if (data.toolName === "deepAction") {
                    const taskId = ((_a = data.params) === null || _a === void 0 ? void 0 : _a.taskId) || (0,_eko_ai_eko__WEBPACK_IMPORTED_MODULE_1__.uuidv4)();
                    const taskIndex = aiMessage.contentItems.findIndex((item) => item.type === "task" && item.taskId === taskId);
                    if (taskIndex < 0) {
                        const toolIndex = aiMessage.contentItems.findIndex((item) => item.type === "tool" && item.toolCallId === data.toolCallId);
                        const insertIndex = toolIndex >= 0 ? toolIndex + 1 : aiMessage.contentItems.length;
                        aiMessage.contentItems.splice(insertIndex, 0, {
                            type: "task",
                            taskId: taskId,
                            task: {
                                taskId: taskId,
                                agents: [],
                            },
                        });
                    }
                }
            }
            else if (data.type === "error") {
                aiMessage.error = data.error;
            }
            else if (data.type === "finish") {
                aiMessage.usage = data.usage;
            }
            else if (data.type == "chat_end") {
                if (data.messageId === currentMessageId) {
                    setCurrentMessageId(null);
                }
                const userMessage = newMessages.find((m) => m.id === data.messageId);
                if (userMessage) {
                    userMessage.status = data.error ? "error" : "done";
                }
                aiMessage.error = data.error;
                if (aiMessage.status != "terminated") {
                    aiMessage.status = data.error ? "error" : "done";
                }
                aiMessage.contentItems.forEach((item) => {
                    if (item.type == "text" || item.type == "thinking") {
                        item.streamDone = true;
                    }
                    else if (item.type == "tool") {
                        item.running = false;
                    }
                    else if (item.type == "task") {
                        const task = item.task;
                        task.workflowStreamDone = true;
                        task.agents.forEach((agent) => {
                            if (agent.status == "running") {
                                agent.status = data.error ? "error" : "done";
                            }
                            agent.contentItems.forEach((contentItem) => {
                                if (contentItem.type == "text" ||
                                    contentItem.type == "thinking") {
                                    contentItem.streamDone = true;
                                }
                                else if (contentItem.type == "tool") {
                                    contentItem.running = false;
                                }
                            });
                        });
                    }
                });
            }
            return newMessages;
        });
    }, [currentMessageId, setCurrentMessageId, setMessages]);
    // Handle task callbacks
    const handleTaskCallback = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((data) => {
        setMessages((prev) => {
            const newMessages = [...prev];
            const message = newMessages.find((m) => m.id === `ai-${data.messageId}`);
            if (!message)
                return prev;
            const taskItemIndex = message.contentItems.findIndex((item) => item.type === "task" && item.taskId === data.taskId);
            if (taskItemIndex < 0) {
                message.contentItems.push({
                    type: "task",
                    taskId: data.taskId,
                    task: {
                        taskId: data.taskId,
                        agents: [],
                    },
                });
            }
            const taskItem = message.contentItems.find((item) => item.type === "task" && item.taskId === data.taskId);
            if (!taskItem)
                return prev;
            if (data.type === "workflow") {
                taskItem.task.workflow = data.workflow;
                taskItem.task.workflowStreamDone = data.streamDone;
            }
            else if (data.type === "agent_start") {
                const existingAgent = taskItem.task.agents.find((a) => a.agentNode.id === (data.nodeId || data.agentName) ||
                    a.agentNode.name === data.agentName);
                if (!existingAgent) {
                    const agentExecution = {
                        agentNode: data.agentNode,
                        contentItems: [],
                        status: "running",
                    };
                    taskItem.task.agents.push(agentExecution);
                }
            }
            else if (data.type === "text" || data.type === "thinking") {
                const agent = taskItem.task.agents.find((a) => a.agentNode.id === (data.nodeId || data.agentName) ||
                    a.agentNode.name === data.agentName);
                if (agent) {
                    const existingIndex = agent.contentItems.findIndex((item) => (item.type === "text" || item.type === "thinking") &&
                        item.streamId === data.streamId);
                    if (existingIndex >= 0) {
                        agent.contentItems[existingIndex].text = data.text;
                        agent.contentItems[existingIndex].streamDone =
                            data.streamDone;
                    }
                    else {
                        agent.contentItems.push({
                            type: data.type,
                            streamId: data.streamId,
                            text: data.text,
                            streamDone: data.streamDone,
                        });
                    }
                }
            }
            else if (data.type === "file") {
                const agent = taskItem.task.agents.find((a) => a.agentNode.id === (data.nodeId || data.agentName) ||
                    a.agentNode.name === data.agentName);
                if (agent) {
                    agent.contentItems.push({
                        type: "file",
                        mimeType: data.mimeType,
                        data: data.data,
                    });
                }
            }
            else if (data.type === "tool_streaming") {
                const agent = taskItem.task.agents.find((a) => a.agentNode.id === (data.nodeId || data.agentName) ||
                    a.agentNode.name === data.agentName);
                if (agent) {
                    const existingIndex = agent.contentItems.findIndex((item) => item.type === "tool" && item.toolCallId === data.toolCallId);
                    if (existingIndex >= 0) {
                        agent.contentItems[existingIndex].paramsText =
                            data.paramsText;
                    }
                    else {
                        agent.contentItems.push({
                            type: "tool",
                            toolCallId: data.toolCallId,
                            toolName: data.toolName,
                            paramsText: data.paramsText,
                        });
                    }
                }
            }
            else if (data.type === "tool_use") {
                const agent = taskItem.task.agents.find((a) => a.agentNode.id === (data.nodeId || data.agentName) ||
                    a.agentNode.name === data.agentName);
                if (agent) {
                    const existingIndex = agent.contentItems.findIndex((item) => item.type === "tool" && item.toolCallId === data.toolCallId);
                    if (existingIndex >= 0) {
                        agent.contentItems[existingIndex].params = data.params;
                    }
                    else {
                        agent.contentItems.push({
                            type: "tool",
                            toolCallId: data.toolCallId,
                            toolName: data.toolName,
                            params: data.params,
                        });
                    }
                }
            }
            else if (data.type === "tool_running") {
                const agent = taskItem.task.agents.find((a) => a.agentNode.id === (data.nodeId || data.agentName) ||
                    a.agentNode.name === data.agentName);
                if (agent) {
                    const existingIndex = agent.contentItems.findIndex((item) => item.type === "tool" && item.toolCallId === data.toolCallId);
                    if (existingIndex >= 0) {
                        agent.contentItems[existingIndex].running =
                            !data.streamDone;
                        agent.contentItems[existingIndex].runningText =
                            data.text;
                    }
                    else {
                        agent.contentItems.push({
                            type: "tool",
                            toolCallId: data.toolCallId,
                            toolName: data.toolName,
                            running: true,
                            runningText: data.text,
                        });
                    }
                }
            }
            else if (data.type === "tool_result") {
                const agent = taskItem.task.agents.find((a) => a.agentNode.id === (data.nodeId || data.agentName) ||
                    a.agentNode.name === data.agentName);
                if (agent) {
                    const existingIndex = agent.contentItems.findIndex((item) => item.type === "tool" && item.toolCallId === data.toolCallId);
                    if (existingIndex >= 0) {
                        agent.contentItems[existingIndex].result =
                            data.toolResult;
                        agent.contentItems[existingIndex].running = false;
                    }
                    else {
                        agent.contentItems.push({
                            type: "tool",
                            toolCallId: data.toolCallId,
                            toolName: data.toolName,
                            params: data.params,
                            result: data.toolResult,
                        });
                    }
                }
            }
            else if (data.type === "agent_result") {
                const agent = taskItem.task.agents.find((a) => a.agentNode.id === (data.nodeId || data.agentName) ||
                    a.agentNode.name === data.agentName);
                if (agent) {
                    agent.status = data.error ? "error" : "done";
                    agent.result = data.result;
                    agent.error = data.error;
                }
            }
            else if (data.type === "error") {
                const agent = taskItem.task.agents.find((a) => a.agentNode.id === (data.nodeId || data.agentName) ||
                    a.agentNode.name === data.agentName);
                if (agent) {
                    agent.status = "error";
                    agent.error = data.error;
                }
            }
            else if (data.type === "human_confirm" ||
                data.type === "human_input" ||
                data.type === "human_select" ||
                data.type === "human_help") {
                const humanData = data;
                const agent = taskItem.task.agents.find((a) => a.agentNode.id === (humanData.nodeId || humanData.agentName) ||
                    a.agentNode.name === humanData.agentName);
                if (agent) {
                    const existingIndex = agent.contentItems.findIndex((item) => (item.type === "human_confirm" ||
                        item.type === "human_input" ||
                        item.type === "human_select" ||
                        item.type === "human_help") &&
                        item.callbackId === humanData.callbackId);
                    if (existingIndex >= 0) {
                        agent.contentItems[existingIndex] = {
                            ...humanData,
                            responded: false,
                        };
                    }
                    else {
                        agent.contentItems.push({
                            ...humanData,
                            responded: false,
                        });
                    }
                }
            }
            return newMessages;
        });
    }, [setMessages]);
    return { handleChatCallback, handleTaskCallback };
};


/***/ }),

/***/ "./src/sidebar/hooks/useFileUpload.ts":
/*!********************************************!*\
  !*** ./src/sidebar/hooks/useFileUpload.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   useFileUpload: () => (/* binding */ useFileUpload)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _eko_ai_eko__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @eko-ai/eko */ "../../packages/eko-core/dist/index.esm.js");


const useFileUpload = () => {
    // Convert file to base64
    const fileToBase64 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((file) => {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                const base64 = reader.result.split(",")[1];
                resolve(base64);
            };
            reader.onerror = reject;
            reader.readAsDataURL(file);
        });
    }, []);
    // Upload file to server
    const uploadFile = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (file) => {
        return new Promise((resolve, reject) => {
            const timer = setTimeout(() => {
                chrome.runtime.onMessage.removeListener(listener);
                reject("Upload timeout");
            }, 180000);
            const requestId = (0,_eko_ai_eko__WEBPACK_IMPORTED_MODULE_1__.uuidv4)();
            // Set up listener first
            const listener = (message) => {
                if (message.type === "uploadFile_result" &&
                    message.requestId === requestId) {
                    clearTimeout(timer);
                    chrome.runtime.onMessage.removeListener(listener);
                    if (!message.data || message.data.error) {
                        reject(new Error(message.data.error || "Upload failed"));
                    }
                    else {
                        resolve(message.data);
                    }
                }
            };
            chrome.runtime.onMessage.addListener(listener);
            // Send upload request
            chrome.runtime.sendMessage({
                requestId,
                type: "uploadFile",
                data: {
                    base64Data: file.base64Data,
                    mimeType: file.mimeType,
                    filename: file.filename,
                },
            });
        });
    }, []);
    return { fileToBase64, uploadFile };
};


/***/ }),

/***/ "./src/sidebar/index.css":
/*!*******************************!*\
  !*** ./src/sidebar/index.css ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../../../../node_modules/.pnpm/style-loader@4.0.0_webpack@5.102.1/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "../../node_modules/.pnpm/style-loader@4.0.0_webpack@5.102.1/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../../../../node_modules/.pnpm/style-loader@4.0.0_webpack@5.102.1/node_modules/style-loader/dist/runtime/styleDomAPI.js */ "../../node_modules/.pnpm/style-loader@4.0.0_webpack@5.102.1/node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../../../../node_modules/.pnpm/style-loader@4.0.0_webpack@5.102.1/node_modules/style-loader/dist/runtime/insertBySelector.js */ "../../node_modules/.pnpm/style-loader@4.0.0_webpack@5.102.1/node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../../../../node_modules/.pnpm/style-loader@4.0.0_webpack@5.102.1/node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "../../node_modules/.pnpm/style-loader@4.0.0_webpack@5.102.1/node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../../../../node_modules/.pnpm/style-loader@4.0.0_webpack@5.102.1/node_modules/style-loader/dist/runtime/insertStyleElement.js */ "../../node_modules/.pnpm/style-loader@4.0.0_webpack@5.102.1/node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../../../../node_modules/.pnpm/style-loader@4.0.0_webpack@5.102.1/node_modules/style-loader/dist/runtime/styleTagTransform.js */ "../../node_modules/.pnpm/style-loader@4.0.0_webpack@5.102.1/node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../../../../node_modules/.pnpm/css-loader@7.1.2_webpack@5.102.1/node_modules/css-loader/dist/cjs.js!./index.css */ "../../node_modules/.pnpm/css-loader@7.1.2_webpack@5.102.1/node_modules/css-loader/dist/cjs.js!./src/sidebar/index.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());
options.insert = _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
options.domAPI = (_node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_pnpm_style_loader_4_0_0_webpack_5_102_1_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_pnpm_css_loader_7_1_2_webpack_5_102_1_node_modules_css_loader_dist_cjs_js_index_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./src/sidebar/index.tsx":
/*!*******************************!*\
  !*** ./src/sidebar/index.tsx ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _index_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.css */ "./src/sidebar/index.css");
/* harmony import */ var _eko_ai_eko__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @eko-ai/eko */ "../../packages/eko-core/dist/index.esm.js");
/* harmony import */ var react_dom_client__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom/client */ "../../node_modules/.pnpm/react-dom@18.3.1_react@18.3.1/node_modules/react-dom/client.js");
/* harmony import */ var _components_ChatInput__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/ChatInput */ "./src/sidebar/components/ChatInput.tsx");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/empty/index.js");
/* harmony import */ var antd__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! antd */ "../../node_modules/.pnpm/antd@5.27.5_react-dom@18.3.1_react@18.3.1__react@18.3.1/node_modules/antd/es/message/index.js");
/* harmony import */ var _hooks_useFileUpload__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./hooks/useFileUpload */ "./src/sidebar/hooks/useFileUpload.ts");
/* harmony import */ var _components_MessageItem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/MessageItem */ "./src/sidebar/components/MessageItem.tsx");
/* harmony import */ var _hooks_useChatCallbacks__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./hooks/useChatCallbacks */ "./src/sidebar/hooks/useChatCallbacks.ts");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! react */ "../../node_modules/.pnpm/react@18.3.1/node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_9__);









const AppRun = () => {
    const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_9__.useState)([]);
    const [inputValue, setInputValue] = (0,react__WEBPACK_IMPORTED_MODULE_9__.useState)("");
    const [sending, setSending] = (0,react__WEBPACK_IMPORTED_MODULE_9__.useState)(false);
    const [currentMessageId, setCurrentMessageId] = (0,react__WEBPACK_IMPORTED_MODULE_9__.useState)(null);
    const [uploadedFiles, setUploadedFiles] = (0,react__WEBPACK_IMPORTED_MODULE_9__.useState)([]);
    const messagesEndRef = (0,react__WEBPACK_IMPORTED_MODULE_9__.useRef)(null);
    const messagesContainerRef = (0,react__WEBPACK_IMPORTED_MODULE_9__.useRef)(null);
    const { handleChatCallback, handleTaskCallback } = (0,_hooks_useChatCallbacks__WEBPACK_IMPORTED_MODULE_8__.useChatCallbacks)(setMessages, currentMessageId, setCurrentMessageId);
    const { fileToBase64, uploadFile } = (0,_hooks_useFileUpload__WEBPACK_IMPORTED_MODULE_6__.useFileUpload)();
    // Scroll to bottom
    const scrollToBottom = (0,react__WEBPACK_IMPORTED_MODULE_9__.useCallback)(() => {
        var _a;
        (_a = messagesEndRef.current) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ behavior: "smooth" });
    }, []);
    (0,react__WEBPACK_IMPORTED_MODULE_9__.useEffect)(() => {
        scrollToBottom();
    }, [messages, scrollToBottom]);
    // Listen to background messages
    (0,react__WEBPACK_IMPORTED_MODULE_9__.useEffect)(() => {
        const handleMessage = (message, sender, sendResponse) => {
            if (message.type === "chat_callback") {
                handleChatCallback(message.data);
            }
            else if (message.type === "task_callback") {
                handleTaskCallback(message.data);
            }
            else if (message.type === "chat_result") {
                const messageId = message.data.messageId;
                const error = message.data.error;
                if (error && messageId === currentMessageId) {
                    setCurrentMessageId(null);
                    const userMessage = messages.find((m) => m.id === messageId);
                    if (userMessage) {
                        userMessage.status = "error";
                    }
                }
            }
            else if (message.type === "log") {
                const level = message.data.level;
                const msg = message.data.message;
                const showMessage = level === "error"
                    ? antd__WEBPACK_IMPORTED_MODULE_5__["default"].error
                    : level === "success"
                        ? antd__WEBPACK_IMPORTED_MODULE_5__["default"].success
                        : antd__WEBPACK_IMPORTED_MODULE_5__["default"].info;
                showMessage(msg, 3);
            }
        };
        chrome.runtime.onMessage.addListener(handleMessage);
        return () => {
            chrome.runtime.onMessage.removeListener(handleMessage);
        };
    }, [handleChatCallback, handleTaskCallback, currentMessageId]);
    // Send message
    const sendMessage = (0,react__WEBPACK_IMPORTED_MODULE_9__.useCallback)(async () => {
        if ((!inputValue.trim() && uploadedFiles.length === 0) || sending)
            return;
        const messageId = (0,_eko_ai_eko__WEBPACK_IMPORTED_MODULE_1__.uuidv4)();
        // Upload files
        const fileParts = [];
        for (const file of uploadedFiles) {
            try {
                const { fileId, url } = await uploadFile(file);
                file.fileId = fileId;
                file.url = url;
                fileParts.push({
                    type: "file",
                    fileId,
                    filename: file.filename,
                    mimeType: file.mimeType,
                    data: url.startsWith("http") ? url : file.base64Data,
                });
            }
            catch (error) {
                console.error("Error uploading file:", error);
            }
        }
        // Build user message content
        const userParts = [];
        if (inputValue.trim()) {
            userParts.push({ type: "text", text: inputValue });
        }
        userParts.push(...fileParts);
        const userMessage = {
            id: messageId,
            role: "user",
            content: inputValue,
            timestamp: Date.now(),
            contentItems: [],
            uploadedFiles: [...uploadedFiles],
            status: "waiting",
        };
        setMessages((prev) => [...prev, userMessage]);
        setInputValue("");
        setUploadedFiles([]);
        setSending(true);
        setCurrentMessageId(messageId);
        try {
            chrome.runtime.sendMessage({
                requestId: (0,_eko_ai_eko__WEBPACK_IMPORTED_MODULE_1__.uuidv4)(),
                type: "chat",
                data: {
                    messageId: messageId,
                    user: userParts,
                },
            });
        }
        catch (error) {
            userMessage.status = "error";
            console.error("Error sending message:", error);
        }
        finally {
            setSending(false);
        }
    }, [inputValue, uploadedFiles, sending, uploadFile]);
    // Stop message
    const stopMessage = (0,react__WEBPACK_IMPORTED_MODULE_9__.useCallback)((messageId) => {
        chrome.runtime.sendMessage({
            type: "stop",
            data: { messageId },
        });
        setCurrentMessageId(null);
    }, []);
    // Handle file selection
    const handleFileSelect = (0,react__WEBPACK_IMPORTED_MODULE_9__.useCallback)(async (event) => {
        const files = event.target.files;
        if (!files || files.length === 0)
            return;
        const newFiles = [];
        for (let i = 0; i < files.length; i++) {
            const file = files[i];
            const base64Data = await fileToBase64(file);
            newFiles.push({
                id: (0,_eko_ai_eko__WEBPACK_IMPORTED_MODULE_1__.uuidv4)(),
                file,
                base64Data,
                mimeType: file.type,
                filename: file.name,
            });
        }
        setUploadedFiles((prev) => [...prev, ...newFiles]);
    }, [fileToBase64]);
    // Remove file
    const removeFile = (0,react__WEBPACK_IMPORTED_MODULE_9__.useCallback)((fileId) => {
        setUploadedFiles((prev) => prev.filter((f) => f.id !== fileId));
    }, []);
    const handleStop = (0,react__WEBPACK_IMPORTED_MODULE_9__.useCallback)(() => {
        if (currentMessageId) {
            stopMessage(currentMessageId);
        }
    }, [currentMessageId, stopMessage]);
    return (react__WEBPACK_IMPORTED_MODULE_9___default().createElement("div", { style: {
            display: "flex",
            flexDirection: "column",
            height: "100vh",
            backgroundColor: "#ffffff",
        } },
        react__WEBPACK_IMPORTED_MODULE_9___default().createElement("div", { ref: messagesContainerRef, style: {
                flex: 1,
                overflowY: "auto",
                overflowX: "hidden",
                padding: "16px",
                backgroundColor: "#f5f5f5",
            } },
            messages.length === 0 ? (react__WEBPACK_IMPORTED_MODULE_9___default().createElement(antd__WEBPACK_IMPORTED_MODULE_4__["default"], { description: "Start a conversation!", style: { marginTop: "20vh" } })) : (messages.map((message) => (react__WEBPACK_IMPORTED_MODULE_9___default().createElement(_components_MessageItem__WEBPACK_IMPORTED_MODULE_7__.MessageItem, { key: message.id, message: message })))),
            react__WEBPACK_IMPORTED_MODULE_9___default().createElement("div", { ref: messagesEndRef })),
        react__WEBPACK_IMPORTED_MODULE_9___default().createElement(_components_ChatInput__WEBPACK_IMPORTED_MODULE_3__.ChatInput, { inputValue: inputValue, onInputChange: setInputValue, onSend: sendMessage, onStop: handleStop, onFileSelect: handleFileSelect, onRemoveFile: removeFile, uploadedFiles: uploadedFiles, sending: sending, currentMessageId: currentMessageId })));
};
const root = (0,react_dom_client__WEBPACK_IMPORTED_MODULE_2__.createRoot)(document.getElementById("root"));
root.render(react__WEBPACK_IMPORTED_MODULE_9___default().createElement((react__WEBPACK_IMPORTED_MODULE_9___default().StrictMode), null,
    react__WEBPACK_IMPORTED_MODULE_9___default().createElement(AppRun, null)));


/***/ }),

/***/ "./src/sidebar/utils/index.ts":
/*!************************************!*\
  !*** ./src/sidebar/utils/index.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isJsonStr: () => (/* binding */ isJsonStr)
/* harmony export */ });
function isJsonStr(str) {
    str = str !== null && str !== void 0 ? str : "";
    str = str.trim();
    if (!str) {
        return false;
    }
    if (!str.startsWith("{") && !str.endsWith("[")) {
        return false;
    }
    try {
        JSON.parse(str);
        return true;
    }
    catch (error) {
        return false;
    }
}


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/create fake namespace object */
/******/ 	(() => {
/******/ 		var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);
/******/ 		var leafPrototypes;
/******/ 		// create a fake namespace object
/******/ 		// mode & 1: value is a module id, require it
/******/ 		// mode & 2: merge all properties of value into the ns
/******/ 		// mode & 4: return value when already ns object
/******/ 		// mode & 16: return value when it's Promise-like
/******/ 		// mode & 8|1: behave like require
/******/ 		__webpack_require__.t = function(value, mode) {
/******/ 			if(mode & 1) value = this(value);
/******/ 			if(mode & 8) return value;
/******/ 			if(typeof value === 'object' && value) {
/******/ 				if((mode & 4) && value.__esModule) return value;
/******/ 				if((mode & 16) && typeof value.then === 'function') return value;
/******/ 			}
/******/ 			var ns = Object.create(null);
/******/ 			__webpack_require__.r(ns);
/******/ 			var def = {};
/******/ 			leafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];
/******/ 			for(var current = mode & 2 && value; (typeof current == 'object' || typeof current == 'function') && !~leafPrototypes.indexOf(current); current = getProto(current)) {
/******/ 				Object.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));
/******/ 			}
/******/ 			def['default'] = () => (value);
/******/ 			__webpack_require__.d(ns, def);
/******/ 			return ns;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/harmony module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.hmd = (module) => {
/******/ 			module = Object.create(module);
/******/ 			if (!module.children) module.children = [];
/******/ 			Object.defineProperty(module, 'exports', {
/******/ 				enumerable: true,
/******/ 				set: () => {
/******/ 					throw new Error('ES Modules may not assign module.exports or exports.*, Use ESM export syntax, instead: ' + module.id);
/******/ 				}
/******/ 			});
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript && document.currentScript.tagName.toUpperCase() === 'SCRIPT')
/******/ 				scriptUrl = document.currentScript.src;
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) {
/******/ 					var i = scripts.length - 1;
/******/ 					while (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;
/******/ 				}
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/^blob:/, "").replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = (typeof document !== 'undefined' && document.baseURI) || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"sidebar": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk_eko_ai_eko_extension_example"] = self["webpackChunk_eko_ai_eko_extension_example"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["vendor"], () => (__webpack_require__("./src/sidebar/index.tsx")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;
//# sourceMappingURL=sidebar.js.map