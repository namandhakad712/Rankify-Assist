/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "../../node_modules/.pnpm/pdfjs-dist@5.4.394/node_modules/pdfjs-dist/build/pdf.mjs":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/pdfjs-dist@5.4.394/node_modules/pdfjs-dist/build/pdf.mjs ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbortException: () => (/* binding */ AbortException),
/* harmony export */   AnnotationEditorLayer: () => (/* binding */ AnnotationEditorLayer),
/* harmony export */   AnnotationEditorParamsType: () => (/* binding */ AnnotationEditorParamsType),
/* harmony export */   AnnotationEditorType: () => (/* binding */ AnnotationEditorType),
/* harmony export */   AnnotationEditorUIManager: () => (/* binding */ AnnotationEditorUIManager),
/* harmony export */   AnnotationLayer: () => (/* binding */ AnnotationLayer),
/* harmony export */   AnnotationMode: () => (/* binding */ AnnotationMode),
/* harmony export */   AnnotationType: () => (/* binding */ AnnotationType),
/* harmony export */   CSSConstants: () => (/* binding */ CSSConstants),
/* harmony export */   ColorPicker: () => (/* binding */ ColorPicker),
/* harmony export */   DOMSVGFactory: () => (/* binding */ DOMSVGFactory),
/* harmony export */   DrawLayer: () => (/* binding */ DrawLayer),
/* harmony export */   FeatureTest: () => (/* binding */ util_FeatureTest),
/* harmony export */   GlobalWorkerOptions: () => (/* binding */ GlobalWorkerOptions),
/* harmony export */   ImageKind: () => (/* binding */ util_ImageKind),
/* harmony export */   InvalidPDFException: () => (/* binding */ InvalidPDFException),
/* harmony export */   MathClamp: () => (/* binding */ MathClamp),
/* harmony export */   OPS: () => (/* binding */ OPS),
/* harmony export */   OutputScale: () => (/* binding */ OutputScale),
/* harmony export */   PDFDataRangeTransport: () => (/* binding */ PDFDataRangeTransport),
/* harmony export */   PDFDateString: () => (/* binding */ PDFDateString),
/* harmony export */   PDFWorker: () => (/* binding */ PDFWorker),
/* harmony export */   PasswordResponses: () => (/* binding */ PasswordResponses),
/* harmony export */   PermissionFlag: () => (/* binding */ PermissionFlag),
/* harmony export */   PixelsPerInch: () => (/* binding */ PixelsPerInch),
/* harmony export */   RenderingCancelledException: () => (/* binding */ RenderingCancelledException),
/* harmony export */   ResponseException: () => (/* binding */ ResponseException),
/* harmony export */   SignatureExtractor: () => (/* binding */ SignatureExtractor),
/* harmony export */   SupportedImageMimeTypes: () => (/* binding */ SupportedImageMimeTypes),
/* harmony export */   TextLayer: () => (/* binding */ TextLayer),
/* harmony export */   TouchManager: () => (/* binding */ TouchManager),
/* harmony export */   Util: () => (/* binding */ Util),
/* harmony export */   VerbosityLevel: () => (/* binding */ VerbosityLevel),
/* harmony export */   XfaLayer: () => (/* binding */ XfaLayer),
/* harmony export */   applyOpacity: () => (/* binding */ applyOpacity),
/* harmony export */   build: () => (/* binding */ build),
/* harmony export */   createValidAbsoluteUrl: () => (/* binding */ createValidAbsoluteUrl),
/* harmony export */   fetchData: () => (/* binding */ fetchData),
/* harmony export */   findContrastColor: () => (/* binding */ findContrastColor),
/* harmony export */   getDocument: () => (/* binding */ getDocument),
/* harmony export */   getFilenameFromUrl: () => (/* binding */ getFilenameFromUrl),
/* harmony export */   getPdfFilenameFromUrl: () => (/* binding */ getPdfFilenameFromUrl),
/* harmony export */   getRGB: () => (/* binding */ getRGB),
/* harmony export */   getUuid: () => (/* binding */ getUuid),
/* harmony export */   getXfaPageViewport: () => (/* binding */ getXfaPageViewport),
/* harmony export */   isDataScheme: () => (/* binding */ isDataScheme),
/* harmony export */   isPdfFile: () => (/* binding */ isPdfFile),
/* harmony export */   isValidExplicitDest: () => (/* binding */ isValidExplicitDest),
/* harmony export */   noContextMenu: () => (/* binding */ noContextMenu),
/* harmony export */   normalizeUnicode: () => (/* binding */ normalizeUnicode),
/* harmony export */   renderRichText: () => (/* binding */ renderRichText),
/* harmony export */   setLayerDimensions: () => (/* binding */ setLayerDimensions),
/* harmony export */   shadow: () => (/* binding */ shadow),
/* harmony export */   stopEvent: () => (/* binding */ stopEvent),
/* harmony export */   updateUrlHash: () => (/* binding */ updateUrlHash),
/* harmony export */   version: () => (/* binding */ version)
          /* harmony export */
});
/**
 * @licstart The following is the entire license notice for the
 * JavaScript code in this page
 *
 * Copyright 2024 Mozilla Foundation
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @licend The above is the entire license notice for the
 * JavaScript code in this page
 */

/**
 * pdfjsVersion = 5.4.394
 * pdfjsBuild = 2cc809ade
 */
/******/ // The require scope
/******/ var __nested_webpack_require_899__ = {};
/******/
/************************************************************************/
/******/ /* webpack/runtime/define property getters */
/******/ (() => {
/******/ 	// define getter functions for harmony exports
/******/ 	__nested_webpack_require_899__.d = (exports, definition) => {
/******/ 		for (var key in definition) {
/******/ 			if (__nested_webpack_require_899__.o(definition, key) && !__nested_webpack_require_899__.o(exports, key)) {
/******/ 				Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
                /******/
}
              /******/
}
            /******/
};
          /******/
})();
/******/
/******/ /* webpack/runtime/hasOwnProperty shorthand */
/******/ (() => {
/******/ 	__nested_webpack_require_899__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
          /******/
})();
        /******/
        /************************************************************************/
        var __webpack_exports__ = {};

        ;// ./src/shared/util.js
        const isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
        const FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];
        const LINE_FACTOR = 1.35;
        const LINE_DESCENT_FACTOR = 0.35;
        const BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
        const RenderingIntentFlag = {
          ANY: 0x01,
          DISPLAY: 0x02,
          PRINT: 0x04,
          SAVE: 0x08,
          ANNOTATIONS_FORMS: 0x10,
          ANNOTATIONS_STORAGE: 0x20,
          ANNOTATIONS_DISABLE: 0x40,
          IS_EDITING: 0x80,
          OPLIST: 0x100
        };
        const AnnotationMode = {
          DISABLE: 0,
          ENABLE: 1,
          ENABLE_FORMS: 2,
          ENABLE_STORAGE: 3
        };
        const AnnotationEditorPrefix = "pdfjs_internal_editor_";
        const AnnotationEditorType = {
          DISABLE: -1,
          NONE: 0,
          FREETEXT: 3,
          HIGHLIGHT: 9,
          STAMP: 13,
          INK: 15,
          POPUP: 16,
          SIGNATURE: 101,
          COMMENT: 102
        };
        const AnnotationEditorParamsType = {
          RESIZE: 1,
          CREATE: 2,
          FREETEXT_SIZE: 11,
          FREETEXT_COLOR: 12,
          FREETEXT_OPACITY: 13,
          INK_COLOR: 21,
          INK_THICKNESS: 22,
          INK_OPACITY: 23,
          HIGHLIGHT_COLOR: 31,
          HIGHLIGHT_THICKNESS: 32,
          HIGHLIGHT_FREE: 33,
          HIGHLIGHT_SHOW_ALL: 34,
          DRAW_STEP: 41
        };
        const PermissionFlag = {
          PRINT: 0x04,
          MODIFY_CONTENTS: 0x08,
          COPY: 0x10,
          MODIFY_ANNOTATIONS: 0x20,
          FILL_INTERACTIVE_FORMS: 0x100,
          COPY_FOR_ACCESSIBILITY: 0x200,
          ASSEMBLE: 0x400,
          PRINT_HIGH_QUALITY: 0x800
        };
        const MeshFigureType = {
          TRIANGLES: 1,
          LATTICE: 2,
          PATCH: 3
        };
        const TextRenderingMode = {
          FILL: 0,
          STROKE: 1,
          FILL_STROKE: 2,
          INVISIBLE: 3,
          FILL_ADD_TO_PATH: 4,
          STROKE_ADD_TO_PATH: 5,
          FILL_STROKE_ADD_TO_PATH: 6,
          ADD_TO_PATH: 7,
          FILL_STROKE_MASK: 3,
          ADD_TO_PATH_FLAG: 4
        };
        const util_ImageKind = {
          GRAYSCALE_1BPP: 1,
          RGB_24BPP: 2,
          RGBA_32BPP: 3
        };
        const AnnotationType = {
          TEXT: 1,
          LINK: 2,
          FREETEXT: 3,
          LINE: 4,
          SQUARE: 5,
          CIRCLE: 6,
          POLYGON: 7,
          POLYLINE: 8,
          HIGHLIGHT: 9,
          UNDERLINE: 10,
          SQUIGGLY: 11,
          STRIKEOUT: 12,
          STAMP: 13,
          CARET: 14,
          INK: 15,
          POPUP: 16,
          FILEATTACHMENT: 17,
          SOUND: 18,
          MOVIE: 19,
          WIDGET: 20,
          SCREEN: 21,
          PRINTERMARK: 22,
          TRAPNET: 23,
          WATERMARK: 24,
          THREED: 25,
          REDACT: 26
        };
        const AnnotationReplyType = {
          GROUP: "Group",
          REPLY: "R"
        };
        const AnnotationFlag = {
          INVISIBLE: 0x01,
          HIDDEN: 0x02,
          PRINT: 0x04,
          NOZOOM: 0x08,
          NOROTATE: 0x10,
          NOVIEW: 0x20,
          READONLY: 0x40,
          LOCKED: 0x80,
          TOGGLENOVIEW: 0x100,
          LOCKEDCONTENTS: 0x200
        };
        const AnnotationFieldFlag = {
          READONLY: 0x0000001,
          REQUIRED: 0x0000002,
          NOEXPORT: 0x0000004,
          MULTILINE: 0x0001000,
          PASSWORD: 0x0002000,
          NOTOGGLETOOFF: 0x0004000,
          RADIO: 0x0008000,
          PUSHBUTTON: 0x0010000,
          COMBO: 0x0020000,
          EDIT: 0x0040000,
          SORT: 0x0080000,
          FILESELECT: 0x0100000,
          MULTISELECT: 0x0200000,
          DONOTSPELLCHECK: 0x0400000,
          DONOTSCROLL: 0x0800000,
          COMB: 0x1000000,
          RICHTEXT: 0x2000000,
          RADIOSINUNISON: 0x2000000,
          COMMITONSELCHANGE: 0x4000000
        };
        const AnnotationBorderStyleType = {
          SOLID: 1,
          DASHED: 2,
          BEVELED: 3,
          INSET: 4,
          UNDERLINE: 5
        };
        const AnnotationActionEventType = {
          E: "Mouse Enter",
          X: "Mouse Exit",
          D: "Mouse Down",
          U: "Mouse Up",
          Fo: "Focus",
          Bl: "Blur",
          PO: "PageOpen",
          PC: "PageClose",
          PV: "PageVisible",
          PI: "PageInvisible",
          K: "Keystroke",
          F: "Format",
          V: "Validate",
          C: "Calculate"
        };
        const DocumentActionEventType = {
          WC: "WillClose",
          WS: "WillSave",
          DS: "DidSave",
          WP: "WillPrint",
          DP: "DidPrint"
        };
        const PageActionEventType = {
          O: "PageOpen",
          C: "PageClose"
        };
        const VerbosityLevel = {
          ERRORS: 0,
          WARNINGS: 1,
          INFOS: 5
        };
        const OPS = {
          dependency: 1,
          setLineWidth: 2,
          setLineCap: 3,
          setLineJoin: 4,
          setMiterLimit: 5,
          setDash: 6,
          setRenderingIntent: 7,
          setFlatness: 8,
          setGState: 9,
          save: 10,
          restore: 11,
          transform: 12,
          moveTo: 13,
          lineTo: 14,
          curveTo: 15,
          curveTo2: 16,
          curveTo3: 17,
          closePath: 18,
          rectangle: 19,
          stroke: 20,
          closeStroke: 21,
          fill: 22,
          eoFill: 23,
          fillStroke: 24,
          eoFillStroke: 25,
          closeFillStroke: 26,
          closeEOFillStroke: 27,
          endPath: 28,
          clip: 29,
          eoClip: 30,
          beginText: 31,
          endText: 32,
          setCharSpacing: 33,
          setWordSpacing: 34,
          setHScale: 35,
          setLeading: 36,
          setFont: 37,
          setTextRenderingMode: 38,
          setTextRise: 39,
          moveText: 40,
          setLeadingMoveText: 41,
          setTextMatrix: 42,
          nextLine: 43,
          showText: 44,
          showSpacedText: 45,
          nextLineShowText: 46,
          nextLineSetSpacingShowText: 47,
          setCharWidth: 48,
          setCharWidthAndBounds: 49,
          setStrokeColorSpace: 50,
          setFillColorSpace: 51,
          setStrokeColor: 52,
          setStrokeColorN: 53,
          setFillColor: 54,
          setFillColorN: 55,
          setStrokeGray: 56,
          setFillGray: 57,
          setStrokeRGBColor: 58,
          setFillRGBColor: 59,
          setStrokeCMYKColor: 60,
          setFillCMYKColor: 61,
          shadingFill: 62,
          beginInlineImage: 63,
          beginImageData: 64,
          endInlineImage: 65,
          paintXObject: 66,
          markPoint: 67,
          markPointProps: 68,
          beginMarkedContent: 69,
          beginMarkedContentProps: 70,
          endMarkedContent: 71,
          beginCompat: 72,
          endCompat: 73,
          paintFormXObjectBegin: 74,
          paintFormXObjectEnd: 75,
          beginGroup: 76,
          endGroup: 77,
          beginAnnotation: 80,
          endAnnotation: 81,
          paintImageMaskXObject: 83,
          paintImageMaskXObjectGroup: 84,
          paintImageXObject: 85,
          paintInlineImageXObject: 86,
          paintInlineImageXObjectGroup: 87,
          paintImageXObjectRepeat: 88,
          paintImageMaskXObjectRepeat: 89,
          paintSolidColorImageMask: 90,
          constructPath: 91,
          setStrokeTransparent: 92,
          setFillTransparent: 93,
          rawFillPath: 94
        };
        const DrawOPS = {
          moveTo: 0,
          lineTo: 1,
          curveTo: 2,
          quadraticCurveTo: 3,
          closePath: 4
        };
        const PasswordResponses = {
          NEED_PASSWORD: 1,
          INCORRECT_PASSWORD: 2
        };
        let verbosity = VerbosityLevel.WARNINGS;
        function setVerbosityLevel(level) {
          if (Number.isInteger(level)) {
            verbosity = level;
          }
        }
        function getVerbosityLevel() {
          return verbosity;
        }
        function info(msg) {
          if (verbosity >= VerbosityLevel.INFOS) {
            console.info(`Info: ${msg}`);
          }
        }
        function warn(msg) {
          if (verbosity >= VerbosityLevel.WARNINGS) {
            console.warn(`Warning: ${msg}`);
          }
        }
        function unreachable(msg) {
          throw new Error(msg);
        }
        function assert(cond, msg) {
          if (!cond) {
            unreachable(msg);
          }
        }
        function _isValidProtocol(url) {
          switch (url?.protocol) {
            case "http:":
            case "https:":
            case "ftp:":
            case "mailto:":
            case "tel:":
              return true;
            default:
              return false;
          }
        }
        function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
          if (!url) {
            return null;
          }
          if (options && typeof url === "string") {
            if (options.addDefaultProtocol && url.startsWith("www.")) {
              const dots = url.match(/\./g);
              if (dots?.length >= 2) {
                url = `http://${url}`;
              }
            }
            if (options.tryConvertEncoding) {
              try {
                url = stringToUTF8String(url);
              } catch { }
            }
          }
          const absoluteUrl = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);
          return _isValidProtocol(absoluteUrl) ? absoluteUrl : null;
        }
        function updateUrlHash(url, hash, allowRel = false) {
          const res = URL.parse(url);
          if (res) {
            res.hash = hash;
            return res.href;
          }
          if (allowRel && createValidAbsoluteUrl(url, "http://example.com")) {
            return url.split("#", 1)[0] + `${hash ? `#${hash}` : ""}`;
          }
          return "";
        }
        function shadow(obj, prop, value, nonSerializable = false) {
          Object.defineProperty(obj, prop, {
            value,
            enumerable: !nonSerializable,
            configurable: true,
            writable: false
          });
          return value;
        }
        const BaseException = function BaseExceptionClosure() {
          function BaseException(message, name) {
            this.message = message;
            this.name = name;
          }
          BaseException.prototype = new Error();
          BaseException.constructor = BaseException;
          return BaseException;
        }();
        class PasswordException extends BaseException {
          constructor(msg, code) {
            super(msg, "PasswordException");
            this.code = code;
          }
        }
        class UnknownErrorException extends BaseException {
          constructor(msg, details) {
            super(msg, "UnknownErrorException");
            this.details = details;
          }
        }
        class InvalidPDFException extends BaseException {
          constructor(msg) {
            super(msg, "InvalidPDFException");
          }
        }
        class ResponseException extends BaseException {
          constructor(msg, status, missing) {
            super(msg, "ResponseException");
            this.status = status;
            this.missing = missing;
          }
        }
        class FormatError extends BaseException {
          constructor(msg) {
            super(msg, "FormatError");
          }
        }
        class AbortException extends BaseException {
          constructor(msg) {
            super(msg, "AbortException");
          }
        }
        function bytesToString(bytes) {
          if (typeof bytes !== "object" || bytes?.length === undefined) {
            unreachable("Invalid argument for bytesToString");
          }
          const length = bytes.length;
          const MAX_ARGUMENT_COUNT = 8192;
          if (length < MAX_ARGUMENT_COUNT) {
            return String.fromCharCode.apply(null, bytes);
          }
          const strBuf = [];
          for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
            const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
            const chunk = bytes.subarray(i, chunkEnd);
            strBuf.push(String.fromCharCode.apply(null, chunk));
          }
          return strBuf.join("");
        }
        function stringToBytes(str) {
          if (typeof str !== "string") {
            unreachable("Invalid argument for stringToBytes");
          }
          const length = str.length;
          const bytes = new Uint8Array(length);
          for (let i = 0; i < length; ++i) {
            bytes[i] = str.charCodeAt(i) & 0xff;
          }
          return bytes;
        }
        function string32(value) {
          return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);
        }
        function objectSize(obj) {
          return Object.keys(obj).length;
        }
        function isLittleEndian() {
          const buffer8 = new Uint8Array(4);
          buffer8[0] = 1;
          const view32 = new Uint32Array(buffer8.buffer, 0, 1);
          return view32[0] === 1;
        }
        function isEvalSupported() {
          try {
            new Function("");
            return true;
          } catch {
            return false;
          }
        }
        class util_FeatureTest {
          static get isLittleEndian() {
            return shadow(this, "isLittleEndian", isLittleEndian());
          }
          static get isEvalSupported() {
            return shadow(this, "isEvalSupported", isEvalSupported());
          }
          static get isOffscreenCanvasSupported() {
            return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
          }
          static get isImageDecoderSupported() {
            return shadow(this, "isImageDecoderSupported", typeof ImageDecoder !== "undefined");
          }
          static get isFloat16ArraySupported() {
            return shadow(this, "isFloat16ArraySupported", typeof Float16Array !== "undefined");
          }
          static get isSanitizerSupported() {
            return shadow(this, "isSanitizerSupported", typeof Sanitizer !== "undefined");
          }
          static get platform() {
            const {
              platform,
              userAgent
            } = navigator;
            return shadow(this, "platform", {
              isAndroid: userAgent.includes("Android"),
              isLinux: platform.includes("Linux"),
              isMac: platform.includes("Mac"),
              isWindows: platform.includes("Win"),
              isFirefox: userAgent.includes("Firefox")
            });
          }
          static get isCSSRoundSupported() {
            return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
          }
        }
        const hexNumbers = Array.from(Array(256).keys(), n => n.toString(16).padStart(2, "0"));
        class Util {
          static makeHexColor(r, g, b) {
            return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
          }
          static domMatrixToTransform(dm) {
            return [dm.a, dm.b, dm.c, dm.d, dm.e, dm.f];
          }
          static scaleMinMax(transform, minMax) {
            let temp;
            if (transform[0]) {
              if (transform[0] < 0) {
                temp = minMax[0];
                minMax[0] = minMax[2];
                minMax[2] = temp;
              }
              minMax[0] *= transform[0];
              minMax[2] *= transform[0];
              if (transform[3] < 0) {
                temp = minMax[1];
                minMax[1] = minMax[3];
                minMax[3] = temp;
              }
              minMax[1] *= transform[3];
              minMax[3] *= transform[3];
            } else {
              temp = minMax[0];
              minMax[0] = minMax[1];
              minMax[1] = temp;
              temp = minMax[2];
              minMax[2] = minMax[3];
              minMax[3] = temp;
              if (transform[1] < 0) {
                temp = minMax[1];
                minMax[1] = minMax[3];
                minMax[3] = temp;
              }
              minMax[1] *= transform[1];
              minMax[3] *= transform[1];
              if (transform[2] < 0) {
                temp = minMax[0];
                minMax[0] = minMax[2];
                minMax[2] = temp;
              }
              minMax[0] *= transform[2];
              minMax[2] *= transform[2];
            }
            minMax[0] += transform[4];
            minMax[1] += transform[5];
            minMax[2] += transform[4];
            minMax[3] += transform[5];
          }
          static transform(m1, m2) {
            return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
          }
          static multiplyByDOMMatrix(m, md) {
            return [m[0] * md.a + m[2] * md.b, m[1] * md.a + m[3] * md.b, m[0] * md.c + m[2] * md.d, m[1] * md.c + m[3] * md.d, m[0] * md.e + m[2] * md.f + m[4], m[1] * md.e + m[3] * md.f + m[5]];
          }
          static applyTransform(p, m, pos = 0) {
            const p0 = p[pos];
            const p1 = p[pos + 1];
            p[pos] = p0 * m[0] + p1 * m[2] + m[4];
            p[pos + 1] = p0 * m[1] + p1 * m[3] + m[5];
          }
          static applyTransformToBezier(p, transform, pos = 0) {
            const m0 = transform[0];
            const m1 = transform[1];
            const m2 = transform[2];
            const m3 = transform[3];
            const m4 = transform[4];
            const m5 = transform[5];
            for (let i = 0; i < 6; i += 2) {
              const pI = p[pos + i];
              const pI1 = p[pos + i + 1];
              p[pos + i] = pI * m0 + pI1 * m2 + m4;
              p[pos + i + 1] = pI * m1 + pI1 * m3 + m5;
            }
          }
          static applyInverseTransform(p, m) {
            const p0 = p[0];
            const p1 = p[1];
            const d = m[0] * m[3] - m[1] * m[2];
            p[0] = (p0 * m[3] - p1 * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
            p[1] = (-p0 * m[1] + p1 * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
          }
          static axialAlignedBoundingBox(rect, transform, output) {
            const m0 = transform[0];
            const m1 = transform[1];
            const m2 = transform[2];
            const m3 = transform[3];
            const m4 = transform[4];
            const m5 = transform[5];
            const r0 = rect[0];
            const r1 = rect[1];
            const r2 = rect[2];
            const r3 = rect[3];
            let a0 = m0 * r0 + m4;
            let a2 = a0;
            let a1 = m0 * r2 + m4;
            let a3 = a1;
            let b0 = m3 * r1 + m5;
            let b2 = b0;
            let b1 = m3 * r3 + m5;
            let b3 = b1;
            if (m1 !== 0 || m2 !== 0) {
              const m1r0 = m1 * r0;
              const m1r2 = m1 * r2;
              const m2r1 = m2 * r1;
              const m2r3 = m2 * r3;
              a0 += m2r1;
              a3 += m2r1;
              a1 += m2r3;
              a2 += m2r3;
              b0 += m1r0;
              b3 += m1r0;
              b1 += m1r2;
              b2 += m1r2;
            }
            output[0] = Math.min(output[0], a0, a1, a2, a3);
            output[1] = Math.min(output[1], b0, b1, b2, b3);
            output[2] = Math.max(output[2], a0, a1, a2, a3);
            output[3] = Math.max(output[3], b0, b1, b2, b3);
          }
          static inverseTransform(m) {
            const d = m[0] * m[3] - m[1] * m[2];
            return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
          }
          static singularValueDecompose2dScale(matrix, output) {
            const m0 = matrix[0];
            const m1 = matrix[1];
            const m2 = matrix[2];
            const m3 = matrix[3];
            const a = m0 ** 2 + m1 ** 2;
            const b = m0 * m2 + m1 * m3;
            const c = m2 ** 2 + m3 ** 2;
            const first = (a + c) / 2;
            const second = Math.sqrt(first ** 2 - (a * c - b ** 2));
            output[0] = Math.sqrt(first + second || 1);
            output[1] = Math.sqrt(first - second || 1);
          }
          static normalizeRect(rect) {
            const r = rect.slice(0);
            if (rect[0] > rect[2]) {
              r[0] = rect[2];
              r[2] = rect[0];
            }
            if (rect[1] > rect[3]) {
              r[1] = rect[3];
              r[3] = rect[1];
            }
            return r;
          }
          static intersect(rect1, rect2) {
            const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
            const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
            if (xLow > xHigh) {
              return null;
            }
            const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
            const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
            if (yLow > yHigh) {
              return null;
            }
            return [xLow, yLow, xHigh, yHigh];
          }
          static pointBoundingBox(x, y, minMax) {
            minMax[0] = Math.min(minMax[0], x);
            minMax[1] = Math.min(minMax[1], y);
            minMax[2] = Math.max(minMax[2], x);
            minMax[3] = Math.max(minMax[3], y);
          }
          static rectBoundingBox(x0, y0, x1, y1, minMax) {
            minMax[0] = Math.min(minMax[0], x0, x1);
            minMax[1] = Math.min(minMax[1], y0, y1);
            minMax[2] = Math.max(minMax[2], x0, x1);
            minMax[3] = Math.max(minMax[3], y0, y1);
          }
          static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {
            if (t <= 0 || t >= 1) {
              return;
            }
            const mt = 1 - t;
            const tt = t * t;
            const ttt = tt * t;
            const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;
            const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;
            minMax[0] = Math.min(minMax[0], x);
            minMax[1] = Math.min(minMax[1], y);
            minMax[2] = Math.max(minMax[2], x);
            minMax[3] = Math.max(minMax[3], y);
          }
          static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {
            if (Math.abs(a) < 1e-12) {
              if (Math.abs(b) >= 1e-12) {
                this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);
              }
              return;
            }
            const delta = b ** 2 - 4 * c * a;
            if (delta < 0) {
              return;
            }
            const sqrtDelta = Math.sqrt(delta);
            const a2 = 2 * a;
            this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);
            this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);
          }
          static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
            minMax[0] = Math.min(minMax[0], x0, x3);
            minMax[1] = Math.min(minMax[1], y0, y3);
            minMax[2] = Math.max(minMax[2], x0, x3);
            minMax[3] = Math.max(minMax[3], y0, y3);
            this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);
            this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);
          }
        }
        const PDFStringTranslateTable = (/* unused pure expression or super */ null && (0));
        function stringToPDFString(str, keepEscapeSequence = false) {
          if (str[0] >= "\xEF") {
            let encoding;
            if (str[0] === "\xFE" && str[1] === "\xFF") {
              encoding = "utf-16be";
              if (str.length % 2 === 1) {
                str = str.slice(0, -1);
              }
            } else if (str[0] === "\xFF" && str[1] === "\xFE") {
              encoding = "utf-16le";
              if (str.length % 2 === 1) {
                str = str.slice(0, -1);
              }
            } else if (str[0] === "\xEF" && str[1] === "\xBB" && str[2] === "\xBF") {
              encoding = "utf-8";
            }
            if (encoding) {
              try {
                const decoder = new TextDecoder(encoding, {
                  fatal: true
                });
                const buffer = stringToBytes(str);
                const decoded = decoder.decode(buffer);
                if (keepEscapeSequence || !decoded.includes("\x1b")) {
                  return decoded;
                }
                return decoded.replaceAll(/\x1b[^\x1b]*(?:\x1b|$)/g, "");
              } catch (ex) {
                warn(`stringToPDFString: "${ex}".`);
              }
            }
          }
          const strBuf = [];
          for (let i = 0, ii = str.length; i < ii; i++) {
            const charCode = str.charCodeAt(i);
            if (!keepEscapeSequence && charCode === 0x1b) {
              while (++i < ii && str.charCodeAt(i) !== 0x1b) { }
              continue;
            }
            const code = PDFStringTranslateTable[charCode];
            strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));
          }
          return strBuf.join("");
        }
        function stringToUTF8String(str) {
          return decodeURIComponent(escape(str));
        }
        function utf8StringToString(str) {
          return unescape(encodeURIComponent(str));
        }
        function isArrayEqual(arr1, arr2) {
          if (arr1.length !== arr2.length) {
            return false;
          }
          for (let i = 0, ii = arr1.length; i < ii; i++) {
            if (arr1[i] !== arr2[i]) {
              return false;
            }
          }
          return true;
        }
        function getModificationDate(date = new Date()) {
          if (!(date instanceof Date)) {
            date = new Date(date);
          }
          const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, "0"), date.getUTCDate().toString().padStart(2, "0"), date.getUTCHours().toString().padStart(2, "0"), date.getUTCMinutes().toString().padStart(2, "0"), date.getUTCSeconds().toString().padStart(2, "0")];
          return buffer.join("");
        }
        let NormalizeRegex = null;
        let NormalizationMap = null;
        function normalizeUnicode(str) {
          if (!NormalizeRegex) {
            NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
            NormalizationMap = new Map([["ﬅ", "ſt"]]);
          }
          return str.replaceAll(NormalizeRegex, (_, p1, p2) => p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2));
        }
        function getUuid() {
          if (typeof crypto.randomUUID === "function") {
            return crypto.randomUUID();
          }
          const buf = new Uint8Array(32);
          crypto.getRandomValues(buf);
          return bytesToString(buf);
        }
        const AnnotationPrefix = "pdfjs_internal_id_";
        function _isValidExplicitDest(validRef, validName, dest) {
          if (!Array.isArray(dest) || dest.length < 2) {
            return false;
          }
          const [page, zoom, ...args] = dest;
          if (!validRef(page) && !Number.isInteger(page)) {
            return false;
          }
          if (!validName(zoom)) {
            return false;
          }
          const argsLen = args.length;
          let allowNull = true;
          switch (zoom.name) {
            case "XYZ":
              if (argsLen < 2 || argsLen > 3) {
                return false;
              }
              break;
            case "Fit":
            case "FitB":
              return argsLen === 0;
            case "FitH":
            case "FitBH":
            case "FitV":
            case "FitBV":
              if (argsLen > 1) {
                return false;
              }
              break;
            case "FitR":
              if (argsLen !== 4) {
                return false;
              }
              allowNull = false;
              break;
            default:
              return false;
          }
          for (const arg of args) {
            if (typeof arg === "number" || allowNull && arg === null) {
              continue;
            }
            return false;
          }
          return true;
        }
        function MathClamp(v, min, max) {
          return Math.min(Math.max(v, min), max);
        }
        function toHexUtil(arr) {
          if (Uint8Array.prototype.toHex) {
            return arr.toHex();
          }
          return Array.from(arr, num => hexNumbers[num]).join("");
        }
        function toBase64Util(arr) {
          if (Uint8Array.prototype.toBase64) {
            return arr.toBase64();
          }
          return btoa(bytesToString(arr));
        }
        function fromBase64Util(str) {
          if (Uint8Array.fromBase64) {
            return Uint8Array.fromBase64(str);
          }
          return stringToBytes(atob(str));
        }
        if (typeof Promise.try !== "function") {
          Promise.try = function (fn, ...args) {
            return new Promise(resolve => {
              resolve(fn(...args));
            });
          };
        }
        if (typeof Math.sumPrecise !== "function") {
          Math.sumPrecise = function (numbers) {
            return numbers.reduce((a, b) => a + b, 0);
          };
        }

        ;// ./src/display/xfa_text.js
        class XfaText {
          static textContent(xfa) {
            const items = [];
            const output = {
              items,
              styles: Object.create(null)
            };
            function walk(node) {
              if (!node) {
                return;
              }
              let str = null;
              const name = node.name;
              if (name === "#text") {
                str = node.value;
              } else if (!XfaText.shouldBuildText(name)) {
                return;
              } else if (node?.attributes?.textContent) {
                str = node.attributes.textContent;
              } else if (node.value) {
                str = node.value;
              }
              if (str !== null) {
                items.push({
                  str
                });
              }
              if (!node.children) {
                return;
              }
              for (const child of node.children) {
                walk(child);
              }
            }
            walk(xfa);
            return output;
          }
          static shouldBuildText(name) {
            return !(name === "textarea" || name === "input" || name === "option" || name === "select");
          }
        }

        ;// ./src/display/xfa_layer.js

        class XfaLayer {
          static setupStorage(html, id, element, storage, intent) {
            const storedData = storage.getValue(id, {
              value: null
            });
            switch (element.name) {
              case "textarea":
                if (storedData.value !== null) {
                  html.textContent = storedData.value;
                }
                if (intent === "print") {
                  break;
                }
                html.addEventListener("input", event => {
                  storage.setValue(id, {
                    value: event.target.value
                  });
                });
                break;
              case "input":
                if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
                  if (storedData.value === element.attributes.xfaOn) {
                    html.setAttribute("checked", true);
                  } else if (storedData.value === element.attributes.xfaOff) {
                    html.removeAttribute("checked");
                  }
                  if (intent === "print") {
                    break;
                  }
                  html.addEventListener("change", event => {
                    storage.setValue(id, {
                      value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                    });
                  });
                } else {
                  if (storedData.value !== null) {
                    html.setAttribute("value", storedData.value);
                  }
                  if (intent === "print") {
                    break;
                  }
                  html.addEventListener("input", event => {
                    storage.setValue(id, {
                      value: event.target.value
                    });
                  });
                }
                break;
              case "select":
                if (storedData.value !== null) {
                  html.setAttribute("value", storedData.value);
                  for (const option of element.children) {
                    if (option.attributes.value === storedData.value) {
                      option.attributes.selected = true;
                    } else if (option.attributes.hasOwnProperty("selected")) {
                      delete option.attributes.selected;
                    }
                  }
                }
                html.addEventListener("input", event => {
                  const options = event.target.options;
                  const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
                  storage.setValue(id, {
                    value
                  });
                });
                break;
            }
          }
          static setAttributes({
            html,
            element,
            storage = null,
            intent,
            linkService
          }) {
            const {
              attributes
            } = element;
            const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
            if (attributes.type === "radio") {
              attributes.name = `${attributes.name}-${intent}`;
            }
            for (const [key, value] of Object.entries(attributes)) {
              if (value === null || value === undefined) {
                continue;
              }
              switch (key) {
                case "class":
                  if (value.length) {
                    html.setAttribute(key, value.join(" "));
                  }
                  break;
                case "dataId":
                  break;
                case "id":
                  html.setAttribute("data-element-id", value);
                  break;
                case "style":
                  Object.assign(html.style, value);
                  break;
                case "textContent":
                  html.textContent = value;
                  break;
                default:
                  if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
                    html.setAttribute(key, value);
                  }
              }
            }
            if (isHTMLAnchorElement) {
              linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
            }
            if (storage && attributes.dataId) {
              this.setupStorage(html, attributes.dataId, element, storage);
            }
          }
          static render(parameters) {
            const storage = parameters.annotationStorage;
            const linkService = parameters.linkService;
            const root = parameters.xfaHtml;
            const intent = parameters.intent || "display";
            const rootHtml = document.createElement(root.name);
            if (root.attributes) {
              this.setAttributes({
                html: rootHtml,
                element: root,
                intent,
                linkService
              });
            }
            const isNotForRichText = intent !== "richText";
            const rootDiv = parameters.div;
            rootDiv.append(rootHtml);
            if (parameters.viewport) {
              const transform = `matrix(${parameters.viewport.transform.join(",")})`;
              rootDiv.style.transform = transform;
            }
            if (isNotForRichText) {
              rootDiv.setAttribute("class", "xfaLayer xfaFont");
            }
            const textDivs = [];
            if (root.children.length === 0) {
              if (root.value) {
                const node = document.createTextNode(root.value);
                rootHtml.append(node);
                if (isNotForRichText && XfaText.shouldBuildText(root.name)) {
                  textDivs.push(node);
                }
              }
              return {
                textDivs
              };
            }
            const stack = [[root, -1, rootHtml]];
            while (stack.length > 0) {
              const [parent, i, html] = stack.at(-1);
              if (i + 1 === parent.children.length) {
                stack.pop();
                continue;
              }
              const child = parent.children[++stack.at(-1)[1]];
              if (child === null) {
                continue;
              }
              const {
                name
              } = child;
              if (name === "#text") {
                const node = document.createTextNode(child.value);
                textDivs.push(node);
                html.append(node);
                continue;
              }
              const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);
              html.append(childHtml);
              if (child.attributes) {
                this.setAttributes({
                  html: childHtml,
                  element: child,
                  storage,
                  intent,
                  linkService
                });
              }
              if (child.children?.length > 0) {
                stack.push([child, -1, childHtml]);
              } else if (child.value) {
                const node = document.createTextNode(child.value);
                if (isNotForRichText && XfaText.shouldBuildText(name)) {
                  textDivs.push(node);
                }
                childHtml.append(node);
              }
            }
            for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
              el.setAttribute("readOnly", true);
            }
            return {
              textDivs
            };
          }
          static update(parameters) {
            const transform = `matrix(${parameters.viewport.transform.join(",")})`;
            parameters.div.style.transform = transform;
            parameters.div.hidden = false;
          }
        }

        ;// ./src/display/display_utils.js


        const SVG_NS = "http://www.w3.org/2000/svg";
        class PixelsPerInch {
          static CSS = 96.0;
          static PDF = 72.0;
          static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
        }
        async function fetchData(url, type = "text") {
          if (isValidFetchUrl(url, document.baseURI)) {
            const response = await fetch(url);
            if (!response.ok) {
              throw new Error(response.statusText);
            }
            switch (type) {
              case "arraybuffer":
                return response.arrayBuffer();
              case "blob":
                return response.blob();
              case "json":
                return response.json();
            }
            return response.text();
          }
          return new Promise((resolve, reject) => {
            const request = new XMLHttpRequest();
            request.open("GET", url, true);
            request.responseType = type;
            request.onreadystatechange = () => {
              if (request.readyState !== XMLHttpRequest.DONE) {
                return;
              }
              if (request.status === 200 || request.status === 0) {
                switch (type) {
                  case "arraybuffer":
                  case "blob":
                  case "json":
                    resolve(request.response);
                    return;
                }
                resolve(request.responseText);
                return;
              }
              reject(new Error(request.statusText));
            };
            request.send(null);
          });
        }
        class PageViewport {
          constructor({
            viewBox,
            userUnit,
            scale,
            rotation,
            offsetX = 0,
            offsetY = 0,
            dontFlip = false
          }) {
            this.viewBox = viewBox;
            this.userUnit = userUnit;
            this.scale = scale;
            this.rotation = rotation;
            this.offsetX = offsetX;
            this.offsetY = offsetY;
            scale *= userUnit;
            const centerX = (viewBox[2] + viewBox[0]) / 2;
            const centerY = (viewBox[3] + viewBox[1]) / 2;
            let rotateA, rotateB, rotateC, rotateD;
            rotation %= 360;
            if (rotation < 0) {
              rotation += 360;
            }
            switch (rotation) {
              case 180:
                rotateA = -1;
                rotateB = 0;
                rotateC = 0;
                rotateD = 1;
                break;
              case 90:
                rotateA = 0;
                rotateB = 1;
                rotateC = 1;
                rotateD = 0;
                break;
              case 270:
                rotateA = 0;
                rotateB = -1;
                rotateC = -1;
                rotateD = 0;
                break;
              case 0:
                rotateA = 1;
                rotateB = 0;
                rotateC = 0;
                rotateD = -1;
                break;
              default:
                throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
            }
            if (dontFlip) {
              rotateC = -rotateC;
              rotateD = -rotateD;
            }
            let offsetCanvasX, offsetCanvasY;
            let width, height;
            if (rotateA === 0) {
              offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
              offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
              width = (viewBox[3] - viewBox[1]) * scale;
              height = (viewBox[2] - viewBox[0]) * scale;
            } else {
              offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
              offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
              width = (viewBox[2] - viewBox[0]) * scale;
              height = (viewBox[3] - viewBox[1]) * scale;
            }
            this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
            this.width = width;
            this.height = height;
          }
          get rawDims() {
            const dims = this.viewBox;
            return shadow(this, "rawDims", {
              pageWidth: dims[2] - dims[0],
              pageHeight: dims[3] - dims[1],
              pageX: dims[0],
              pageY: dims[1]
            });
          }
          clone({
            scale = this.scale,
            rotation = this.rotation,
            offsetX = this.offsetX,
            offsetY = this.offsetY,
            dontFlip = false
          } = {}) {
            return new PageViewport({
              viewBox: this.viewBox.slice(),
              userUnit: this.userUnit,
              scale,
              rotation,
              offsetX,
              offsetY,
              dontFlip
            });
          }
          convertToViewportPoint(x, y) {
            const p = [x, y];
            Util.applyTransform(p, this.transform);
            return p;
          }
          convertToViewportRectangle(rect) {
            const topLeft = [rect[0], rect[1]];
            Util.applyTransform(topLeft, this.transform);
            const bottomRight = [rect[2], rect[3]];
            Util.applyTransform(bottomRight, this.transform);
            return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
          }
          convertToPdfPoint(x, y) {
            const p = [x, y];
            Util.applyInverseTransform(p, this.transform);
            return p;
          }
        }
        class RenderingCancelledException extends BaseException {
          constructor(msg, extraDelay = 0) {
            super(msg, "RenderingCancelledException");
            this.extraDelay = extraDelay;
          }
        }
        function isDataScheme(url) {
          const ii = url.length;
          let i = 0;
          while (i < ii && url[i].trim() === "") {
            i++;
          }
          return url.substring(i, i + 5).toLowerCase() === "data:";
        }
        function isPdfFile(filename) {
          return typeof filename === "string" && /\.pdf$/i.test(filename);
        }
        function getFilenameFromUrl(url) {
          [url] = url.split(/[#?]/, 1);
          return url.substring(url.lastIndexOf("/") + 1);
        }
        function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
          if (typeof url !== "string") {
            return defaultFilename;
          }
          if (isDataScheme(url)) {
            warn('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
            return defaultFilename;
          }
          const getURL = urlString => {
            try {
              return new URL(urlString);
            } catch {
              try {
                return new URL(decodeURIComponent(urlString));
              } catch {
                try {
                  return new URL(urlString, "https://foo.bar");
                } catch {
                  try {
                    return new URL(decodeURIComponent(urlString), "https://foo.bar");
                  } catch {
                    return null;
                  }
                }
              }
            }
          };
          const newURL = getURL(url);
          if (!newURL) {
            return defaultFilename;
          }
          const decode = name => {
            try {
              let decoded = decodeURIComponent(name);
              if (decoded.includes("/")) {
                decoded = decoded.split("/").at(-1);
                if (decoded.test(/^\.pdf$/i)) {
                  return decoded;
                }
                return name;
              }
              return decoded;
            } catch {
              return name;
            }
          };
          const pdfRegex = /\.pdf$/i;
          const filename = newURL.pathname.split("/").at(-1);
          if (pdfRegex.test(filename)) {
            return decode(filename);
          }
          if (newURL.searchParams.size > 0) {
            const values = Array.from(newURL.searchParams.values()).reverse();
            for (const value of values) {
              if (pdfRegex.test(value)) {
                return decode(value);
              }
            }
            const keys = Array.from(newURL.searchParams.keys()).reverse();
            for (const key of keys) {
              if (pdfRegex.test(key)) {
                return decode(key);
              }
            }
          }
          if (newURL.hash) {
            const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
            const hashFilename = reFilename.exec(newURL.hash);
            if (hashFilename) {
              return decode(hashFilename[0]);
            }
          }
          return defaultFilename;
        }
        class StatTimer {
          started = Object.create(null);
          times = [];
          time(name) {
            if (name in this.started) {
              warn(`Timer is already running for ${name}`);
            }
            this.started[name] = Date.now();
          }
          timeEnd(name) {
            if (!(name in this.started)) {
              warn(`Timer has not been started for ${name}`);
            }
            this.times.push({
              name,
              start: this.started[name],
              end: Date.now()
            });
            delete this.started[name];
          }
          toString() {
            const outBuf = [];
            let longest = 0;
            for (const {
              name
            } of this.times) {
              longest = Math.max(name.length, longest);
            }
            for (const {
              name,
              start,
              end
            } of this.times) {
              outBuf.push(`${name.padEnd(longest)} ${end - start}ms\n`);
            }
            return outBuf.join("");
          }
        }
        function isValidFetchUrl(url, baseUrl) {
          const res = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);
          return res?.protocol === "http:" || res?.protocol === "https:";
        }
        function noContextMenu(e) {
          e.preventDefault();
        }
        function stopEvent(e) {
          e.preventDefault();
          e.stopPropagation();
        }
        function deprecated(details) {
          console.log("Deprecated API usage: " + details);
        }
        class PDFDateString {
          static #regex;
          static toDateObject(input) {
            if (input instanceof Date) {
              return input;
            }
            if (!input || typeof input !== "string") {
              return null;
            }
            this.#regex ||= new RegExp("^D:" + "(\\d{4})" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "(\\d{2})?" + "([Z|+|-])?" + "(\\d{2})?" + "'?" + "(\\d{2})?" + "'?");
            const matches = this.#regex.exec(input);
            if (!matches) {
              return null;
            }
            const year = parseInt(matches[1], 10);
            let month = parseInt(matches[2], 10);
            month = month >= 1 && month <= 12 ? month - 1 : 0;
            let day = parseInt(matches[3], 10);
            day = day >= 1 && day <= 31 ? day : 1;
            let hour = parseInt(matches[4], 10);
            hour = hour >= 0 && hour <= 23 ? hour : 0;
            let minute = parseInt(matches[5], 10);
            minute = minute >= 0 && minute <= 59 ? minute : 0;
            let second = parseInt(matches[6], 10);
            second = second >= 0 && second <= 59 ? second : 0;
            const universalTimeRelation = matches[7] || "Z";
            let offsetHour = parseInt(matches[8], 10);
            offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
            let offsetMinute = parseInt(matches[9], 10) || 0;
            offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
            if (universalTimeRelation === "-") {
              hour += offsetHour;
              minute += offsetMinute;
            } else if (universalTimeRelation === "+") {
              hour -= offsetHour;
              minute -= offsetMinute;
            }
            return new Date(Date.UTC(year, month, day, hour, minute, second));
          }
        }
        function getXfaPageViewport(xfaPage, {
          scale = 1,
          rotation = 0
        }) {
          const {
            width,
            height
          } = xfaPage.attributes.style;
          const viewBox = [0, 0, parseInt(width), parseInt(height)];
          return new PageViewport({
            viewBox,
            userUnit: 1,
            scale,
            rotation
          });
        }
        function getRGB(color) {
          if (color.startsWith("#")) {
            const colorRGB = parseInt(color.slice(1), 16);
            return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];
          }
          if (color.startsWith("rgb(")) {
            return color.slice(4, -1).split(",").map(x => parseInt(x));
          }
          if (color.startsWith("rgba(")) {
            return color.slice(5, -1).split(",").map(x => parseInt(x)).slice(0, 3);
          }
          warn(`Not a valid color format: "${color}"`);
          return [0, 0, 0];
        }
        function getColorValues(colors) {
          const span = document.createElement("span");
          span.style.visibility = "hidden";
          span.style.colorScheme = "only light";
          document.body.append(span);
          for (const name of colors.keys()) {
            span.style.color = name;
            const computedColor = window.getComputedStyle(span).color;
            colors.set(name, getRGB(computedColor));
          }
          span.remove();
        }
        function getCurrentTransform(ctx) {
          const {
            a,
            b,
            c,
            d,
            e,
            f
          } = ctx.getTransform();
          return [a, b, c, d, e, f];
        }
        function getCurrentTransformInverse(ctx) {
          const {
            a,
            b,
            c,
            d,
            e,
            f
          } = ctx.getTransform().invertSelf();
          return [a, b, c, d, e, f];
        }
        function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {
          if (viewport instanceof PageViewport) {
            const {
              pageWidth,
              pageHeight
            } = viewport.rawDims;
            const {
              style
            } = div;
            const useRound = util_FeatureTest.isCSSRoundSupported;
            const w = `var(--total-scale-factor) * ${pageWidth}px`,
              h = `var(--total-scale-factor) * ${pageHeight}px`;
            const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x))` : `calc(${w})`,
              heightStr = useRound ? `round(down, ${h}, var(--scale-round-y))` : `calc(${h})`;
            if (!mustFlip || viewport.rotation % 180 === 0) {
              style.width = widthStr;
              style.height = heightStr;
            } else {
              style.width = heightStr;
              style.height = widthStr;
            }
          }
          if (mustRotate) {
            div.setAttribute("data-main-rotation", viewport.rotation);
          }
        }
        class OutputScale {
          constructor() {
            const {
              pixelRatio
            } = OutputScale;
            this.sx = pixelRatio;
            this.sy = pixelRatio;
          }
          get scaled() {
            return this.sx !== 1 || this.sy !== 1;
          }
          get symmetric() {
            return this.sx === this.sy;
          }
          limitCanvas(width, height, maxPixels, maxDim, capAreaFactor = -1) {
            let maxAreaScale = Infinity,
              maxWidthScale = Infinity,
              maxHeightScale = Infinity;
            maxPixels = OutputScale.capPixels(maxPixels, capAreaFactor);
            if (maxPixels > 0) {
              maxAreaScale = Math.sqrt(maxPixels / (width * height));
            }
            if (maxDim !== -1) {
              maxWidthScale = maxDim / width;
              maxHeightScale = maxDim / height;
            }
            const maxScale = Math.min(maxAreaScale, maxWidthScale, maxHeightScale);
            if (this.sx > maxScale || this.sy > maxScale) {
              this.sx = maxScale;
              this.sy = maxScale;
              return true;
            }
            return false;
          }
          static get pixelRatio() {
            return globalThis.devicePixelRatio || 1;
          }
          static capPixels(maxPixels, capAreaFactor) {
            if (capAreaFactor >= 0) {
              const winPixels = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + capAreaFactor / 100));
              return maxPixels > 0 ? Math.min(maxPixels, winPixels) : winPixels;
            }
            return maxPixels;
          }
        }
        const SupportedImageMimeTypes = ["image/apng", "image/avif", "image/bmp", "image/gif", "image/jpeg", "image/png", "image/svg+xml", "image/webp", "image/x-icon"];
        class ColorScheme {
          static get isDarkMode() {
            return shadow(this, "isDarkMode", !!window?.matchMedia?.("(prefers-color-scheme: dark)").matches);
          }
        }
        class CSSConstants {
          static get commentForegroundColor() {
            const element = document.createElement("span");
            element.classList.add("comment", "sidebar");
            const {
              style
            } = element;
            style.width = style.height = "0";
            style.display = "none";
            style.color = "var(--comment-fg-color)";
            document.body.append(element);
            const {
              color
            } = window.getComputedStyle(element);
            element.remove();
            return shadow(this, "commentForegroundColor", getRGB(color));
          }
        }
        function applyOpacity(r, g, b, opacity) {
          opacity = Math.min(Math.max(opacity ?? 1, 0), 1);
          const white = 255 * (1 - opacity);
          r = Math.round(r * opacity + white);
          g = Math.round(g * opacity + white);
          b = Math.round(b * opacity + white);
          return [r, g, b];
        }
        function RGBToHSL(rgb, output) {
          const r = rgb[0] / 255;
          const g = rgb[1] / 255;
          const b = rgb[2] / 255;
          const max = Math.max(r, g, b);
          const min = Math.min(r, g, b);
          const l = (max + min) / 2;
          if (max === min) {
            output[0] = output[1] = 0;
          } else {
            const d = max - min;
            output[1] = l < 0.5 ? d / (max + min) : d / (2 - max - min);
            switch (max) {
              case r:
                output[0] = ((g - b) / d + (g < b ? 6 : 0)) * 60;
                break;
              case g:
                output[0] = ((b - r) / d + 2) * 60;
                break;
              case b:
                output[0] = ((r - g) / d + 4) * 60;
                break;
            }
          }
          output[2] = l;
        }
        function HSLToRGB(hsl, output) {
          const h = hsl[0];
          const s = hsl[1];
          const l = hsl[2];
          const c = (1 - Math.abs(2 * l - 1)) * s;
          const x = c * (1 - Math.abs(h / 60 % 2 - 1));
          const m = l - c / 2;
          switch (Math.floor(h / 60)) {
            case 0:
              output[0] = c + m;
              output[1] = x + m;
              output[2] = m;
              break;
            case 1:
              output[0] = x + m;
              output[1] = c + m;
              output[2] = m;
              break;
            case 2:
              output[0] = m;
              output[1] = c + m;
              output[2] = x + m;
              break;
            case 3:
              output[0] = m;
              output[1] = x + m;
              output[2] = c + m;
              break;
            case 4:
              output[0] = x + m;
              output[1] = m;
              output[2] = c + m;
              break;
            case 5:
            case 6:
              output[0] = c + m;
              output[1] = m;
              output[2] = x + m;
              break;
          }
        }
        function computeLuminance(x) {
          return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
        }
        function contrastRatio(hsl1, hsl2, output) {
          HSLToRGB(hsl1, output);
          output.map(computeLuminance);
          const lum1 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];
          HSLToRGB(hsl2, output);
          output.map(computeLuminance);
          const lum2 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];
          return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);
        }
        const contrastCache = new Map();
        function findContrastColor(baseColor, fixedColor) {
          const key = baseColor[0] + baseColor[1] * 0x100 + baseColor[2] * 0x10000 + fixedColor[0] * 0x1000000 + fixedColor[1] * 0x100000000 + fixedColor[2] * 0x10000000000;
          let cachedValue = contrastCache.get(key);
          if (cachedValue) {
            return cachedValue;
          }
          const array = new Float32Array(9);
          const output = array.subarray(0, 3);
          const baseHSL = array.subarray(3, 6);
          RGBToHSL(baseColor, baseHSL);
          const fixedHSL = array.subarray(6, 9);
          RGBToHSL(fixedColor, fixedHSL);
          const isFixedColorDark = fixedHSL[2] < 0.5;
          const minContrast = isFixedColorDark ? 12 : 4.5;
          baseHSL[2] = isFixedColorDark ? Math.sqrt(baseHSL[2]) : 1 - Math.sqrt(1 - baseHSL[2]);
          if (contrastRatio(baseHSL, fixedHSL, output) < minContrast) {
            let start, end;
            if (isFixedColorDark) {
              start = baseHSL[2];
              end = 1;
            } else {
              start = 0;
              end = baseHSL[2];
            }
            const PRECISION = 0.005;
            while (end - start > PRECISION) {
              const mid = baseHSL[2] = (start + end) / 2;
              if (isFixedColorDark === contrastRatio(baseHSL, fixedHSL, output) < minContrast) {
                start = mid;
              } else {
                end = mid;
              }
            }
            baseHSL[2] = isFixedColorDark ? end : start;
          }
          HSLToRGB(baseHSL, output);
          cachedValue = Util.makeHexColor(Math.round(output[0] * 255), Math.round(output[1] * 255), Math.round(output[2] * 255));
          contrastCache.set(key, cachedValue);
          return cachedValue;
        }
        function renderRichText({
          html,
          dir,
          className
        }, container) {
          const fragment = document.createDocumentFragment();
          if (typeof html === "string") {
            const p = document.createElement("p");
            p.dir = dir || "auto";
            const lines = html.split(/(?:\r\n?|\n)/);
            for (let i = 0, ii = lines.length; i < ii; ++i) {
              const line = lines[i];
              p.append(document.createTextNode(line));
              if (i < ii - 1) {
                p.append(document.createElement("br"));
              }
            }
            fragment.append(p);
          } else {
            XfaLayer.render({
              xfaHtml: html,
              div: fragment,
              intent: "richText"
            });
          }
          fragment.firstChild.classList.add("richText", className);
          container.append(fragment);
        }
        function makePathFromDrawOPS(data) {
          const path = new Path2D();
          if (!data) {
            return path;
          }
          for (let i = 0, ii = data.length; i < ii;) {
            switch (data[i++]) {
              case DrawOPS.moveTo:
                path.moveTo(data[i++], data[i++]);
                break;
              case DrawOPS.lineTo:
                path.lineTo(data[i++], data[i++]);
                break;
              case DrawOPS.curveTo:
                path.bezierCurveTo(data[i++], data[i++], data[i++], data[i++], data[i++], data[i++]);
                break;
              case DrawOPS.quadraticCurveTo:
                path.quadraticCurveTo(data[i++], data[i++], data[i++], data[i++]);
                break;
              case DrawOPS.closePath:
                path.closePath();
                break;
              default:
                warn(`Unrecognized drawing path operator: ${data[i - 1]}`);
                break;
            }
          }
          return path;
        }

        ;// ./src/display/editor/toolbar.js

        class EditorToolbar {
          #toolbar = null;
          #colorPicker = null;
          #editor;
          #buttons = null;
          #altText = null;
          #comment = null;
          #commentButtonDivider = null;
          #signatureDescriptionButton = null;
          static #l10nRemove = null;
          constructor(editor) {
            this.#editor = editor;
            EditorToolbar.#l10nRemove ||= Object.freeze({
              freetext: "pdfjs-editor-remove-freetext-button",
              highlight: "pdfjs-editor-remove-highlight-button",
              ink: "pdfjs-editor-remove-ink-button",
              stamp: "pdfjs-editor-remove-stamp-button",
              signature: "pdfjs-editor-remove-signature-button"
            });
          }
          render() {
            const editToolbar = this.#toolbar = document.createElement("div");
            editToolbar.classList.add("editToolbar", "hidden");
            editToolbar.setAttribute("role", "toolbar");
            const signal = this.#editor._uiManager._signal;
            if (signal instanceof AbortSignal && !signal.aborted) {
              editToolbar.addEventListener("contextmenu", noContextMenu, {
                signal
              });
              editToolbar.addEventListener("pointerdown", EditorToolbar.#pointerDown, {
                signal
              });
            }
            const buttons = this.#buttons = document.createElement("div");
            buttons.className = "buttons";
            editToolbar.append(buttons);
            const position = this.#editor.toolbarPosition;
            if (position) {
              const {
                style
              } = editToolbar;
              const x = this.#editor._uiManager.direction === "ltr" ? 1 - position[0] : position[0];
              style.insetInlineEnd = `${100 * x}%`;
              style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;
            }
            return editToolbar;
          }
          get div() {
            return this.#toolbar;
          }
          static #pointerDown(e) {
            e.stopPropagation();
          }
          #focusIn(e) {
            this.#editor._focusEventsAllowed = false;
            stopEvent(e);
          }
          #focusOut(e) {
            this.#editor._focusEventsAllowed = true;
            stopEvent(e);
          }
          #addListenersToElement(element) {
            const signal = this.#editor._uiManager._signal;
            if (!(signal instanceof AbortSignal) || signal.aborted) {
              return false;
            }
            element.addEventListener("focusin", this.#focusIn.bind(this), {
              capture: true,
              signal
            });
            element.addEventListener("focusout", this.#focusOut.bind(this), {
              capture: true,
              signal
            });
            element.addEventListener("contextmenu", noContextMenu, {
              signal
            });
            return true;
          }
          hide() {
            this.#toolbar.classList.add("hidden");
            this.#colorPicker?.hideDropdown();
          }
          show() {
            this.#toolbar.classList.remove("hidden");
            this.#altText?.shown();
            this.#comment?.shown();
          }
          addDeleteButton() {
            const {
              editorType,
              _uiManager
            } = this.#editor;
            const button = document.createElement("button");
            button.classList.add("basic", "deleteButton");
            button.tabIndex = 0;
            button.setAttribute("data-l10n-id", EditorToolbar.#l10nRemove[editorType]);
            if (this.#addListenersToElement(button)) {
              button.addEventListener("click", e => {
                _uiManager.delete();
              }, {
                signal: _uiManager._signal
              });
            }
            this.#buttons.append(button);
          }
          get #divider() {
            const divider = document.createElement("div");
            divider.className = "divider";
            return divider;
          }
          async addAltText(altText) {
            const button = await altText.render();
            this.#addListenersToElement(button);
            this.#buttons.append(button, this.#divider);
            this.#altText = altText;
          }
          addComment(comment, beforeElement = null) {
            if (this.#comment) {
              return;
            }
            const button = comment.renderForToolbar();
            if (!button) {
              return;
            }
            this.#addListenersToElement(button);
            const divider = this.#commentButtonDivider = this.#divider;
            if (!beforeElement) {
              this.#buttons.append(button, divider);
            } else {
              this.#buttons.insertBefore(button, beforeElement);
              this.#buttons.insertBefore(divider, beforeElement);
            }
            this.#comment = comment;
            comment.toolbar = this;
          }
          addColorPicker(colorPicker) {
            if (this.#colorPicker) {
              return;
            }
            this.#colorPicker = colorPicker;
            const button = colorPicker.renderButton();
            this.#addListenersToElement(button);
            this.#buttons.append(button, this.#divider);
          }
          async addEditSignatureButton(signatureManager) {
            const button = this.#signatureDescriptionButton = await signatureManager.renderEditButton(this.#editor);
            this.#addListenersToElement(button);
            this.#buttons.append(button, this.#divider);
          }
          removeButton(name) {
            switch (name) {
              case "comment":
                this.#comment?.removeToolbarCommentButton();
                this.#comment = null;
                this.#commentButtonDivider?.remove();
                this.#commentButtonDivider = null;
                break;
            }
          }
          async addButton(name, tool) {
            switch (name) {
              case "colorPicker":
                if (tool) {
                  this.addColorPicker(tool);
                }
                break;
              case "altText":
                if (tool) {
                  await this.addAltText(tool);
                }
                break;
              case "editSignature":
                if (tool) {
                  await this.addEditSignatureButton(tool);
                }
                break;
              case "delete":
                this.addDeleteButton();
                break;
              case "comment":
                if (tool) {
                  this.addComment(tool);
                }
                break;
            }
          }
          async addButtonBefore(name, tool, beforeSelector) {
            if (!tool && name === "comment") {
              return;
            }
            const beforeElement = this.#buttons.querySelector(beforeSelector);
            if (!beforeElement) {
              return;
            }
            if (name === "comment") {
              this.addComment(tool, beforeElement);
            }
          }
          updateEditSignatureButton(description) {
            if (this.#signatureDescriptionButton) {
              this.#signatureDescriptionButton.title = description;
            }
          }
          remove() {
            this.#toolbar.remove();
            this.#colorPicker?.destroy();
            this.#colorPicker = null;
          }
        }
        class FloatingToolbar {
          #buttons = null;
          #toolbar = null;
          #uiManager;
          constructor(uiManager) {
            this.#uiManager = uiManager;
          }
          #render() {
            const editToolbar = this.#toolbar = document.createElement("div");
            editToolbar.className = "editToolbar";
            editToolbar.setAttribute("role", "toolbar");
            const signal = this.#uiManager._signal;
            if (signal instanceof AbortSignal && !signal.aborted) {
              editToolbar.addEventListener("contextmenu", noContextMenu, {
                signal
              });
            }
            const buttons = this.#buttons = document.createElement("div");
            buttons.className = "buttons";
            editToolbar.append(buttons);
            if (this.#uiManager.hasCommentManager()) {
              this.#makeButton("commentButton", `pdfjs-comment-floating-button`, "pdfjs-comment-floating-button-label", () => {
                this.#uiManager.commentSelection("floating_button");
              });
            }
            this.#makeButton("highlightButton", `pdfjs-highlight-floating-button1`, "pdfjs-highlight-floating-button-label", () => {
              this.#uiManager.highlightSelection("floating_button");
            });
            return editToolbar;
          }
          #getLastPoint(boxes, isLTR) {
            let lastY = 0;
            let lastX = 0;
            for (const box of boxes) {
              const y = box.y + box.height;
              if (y < lastY) {
                continue;
              }
              const x = box.x + (isLTR ? box.width : 0);
              if (y > lastY) {
                lastX = x;
                lastY = y;
                continue;
              }
              if (isLTR) {
                if (x > lastX) {
                  lastX = x;
                }
              } else if (x < lastX) {
                lastX = x;
              }
            }
            return [isLTR ? 1 - lastX : lastX, lastY];
          }
          show(parent, boxes, isLTR) {
            const [x, y] = this.#getLastPoint(boxes, isLTR);
            const {
              style
            } = this.#toolbar ||= this.#render();
            parent.append(this.#toolbar);
            style.insetInlineEnd = `${100 * x}%`;
            style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;
          }
          hide() {
            this.#toolbar.remove();
          }
          #makeButton(buttonClass, l10nId, labelL10nId, clickHandler) {
            const button = document.createElement("button");
            button.classList.add("basic", buttonClass);
            button.tabIndex = 0;
            button.setAttribute("data-l10n-id", l10nId);
            const span = document.createElement("span");
            button.append(span);
            span.className = "visuallyHidden";
            span.setAttribute("data-l10n-id", labelL10nId);
            const signal = this.#uiManager._signal;
            if (signal instanceof AbortSignal && !signal.aborted) {
              button.addEventListener("contextmenu", noContextMenu, {
                signal
              });
              button.addEventListener("click", clickHandler, {
                signal
              });
            }
            this.#buttons.append(button);
          }
        }

        ;// ./src/display/editor/tools.js



        function bindEvents(obj, element, names) {
          for (const name of names) {
            element.addEventListener(name, obj[name].bind(obj));
          }
        }
        class CurrentPointers {
          static #pointerId = NaN;
          static #pointerIds = null;
          static #moveTimestamp = NaN;
          static #pointerType = null;
          static initializeAndAddPointerId(pointerId) {
            (CurrentPointers.#pointerIds ||= new Set()).add(pointerId);
          }
          static setPointer(pointerType, pointerId) {
            CurrentPointers.#pointerId ||= pointerId;
            CurrentPointers.#pointerType ??= pointerType;
          }
          static setTimeStamp(timeStamp) {
            CurrentPointers.#moveTimestamp = timeStamp;
          }
          static isSamePointerId(pointerId) {
            return CurrentPointers.#pointerId === pointerId;
          }
          static isSamePointerIdOrRemove(pointerId) {
            if (CurrentPointers.#pointerId === pointerId) {
              return true;
            }
            CurrentPointers.#pointerIds?.delete(pointerId);
            return false;
          }
          static isSamePointerType(pointerType) {
            return CurrentPointers.#pointerType === pointerType;
          }
          static isInitializedAndDifferentPointerType(pointerType) {
            return CurrentPointers.#pointerType !== null && !CurrentPointers.isSamePointerType(pointerType);
          }
          static isSameTimeStamp(timeStamp) {
            return CurrentPointers.#moveTimestamp === timeStamp;
          }
          static isUsingMultiplePointers() {
            return CurrentPointers.#pointerIds?.size >= 1;
          }
          static clearPointerType() {
            CurrentPointers.#pointerType = null;
          }
          static clearPointerIds() {
            CurrentPointers.#pointerId = NaN;
            CurrentPointers.#pointerIds = null;
          }
          static clearTimeStamp() {
            CurrentPointers.#moveTimestamp = NaN;
          }
        }
        class IdManager {
          #id = 0;
          get id() {
            return `${AnnotationEditorPrefix}${this.#id++}`;
          }
        }
        class ImageManager {
          #baseId = getUuid();
          #id = 0;
          #cache = null;
          static get _isSVGFittingCanvas() {
            const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
            const canvas = new OffscreenCanvas(1, 3);
            const ctx = canvas.getContext("2d", {
              willReadFrequently: true
            });
            const image = new Image();
            image.src = svg;
            const promise = image.decode().then(() => {
              ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
              return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
            });
            return shadow(this, "_isSVGFittingCanvas", promise);
          }
          async #get(key, rawData) {
            this.#cache ||= new Map();
            let data = this.#cache.get(key);
            if (data === null) {
              return null;
            }
            if (data?.bitmap) {
              data.refCounter += 1;
              return data;
            }
            try {
              data ||= {
                bitmap: null,
                id: `image_${this.#baseId}_${this.#id++}`,
                refCounter: 0,
                isSvg: false
              };
              let image;
              if (typeof rawData === "string") {
                data.url = rawData;
                image = await fetchData(rawData, "blob");
              } else if (rawData instanceof File) {
                image = data.file = rawData;
              } else if (rawData instanceof Blob) {
                image = rawData;
              }
              if (image.type === "image/svg+xml") {
                const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;
                const fileReader = new FileReader();
                const imageElement = new Image();
                const imagePromise = new Promise((resolve, reject) => {
                  imageElement.onload = () => {
                    data.bitmap = imageElement;
                    data.isSvg = true;
                    resolve();
                  };
                  fileReader.onload = async () => {
                    const url = data.svgUrl = fileReader.result;
                    imageElement.src = (await mustRemoveAspectRatioPromise) ? `${url}#svgView(preserveAspectRatio(none))` : url;
                  };
                  imageElement.onerror = fileReader.onerror = reject;
                });
                fileReader.readAsDataURL(image);
                await imagePromise;
              } else {
                data.bitmap = await createImageBitmap(image);
              }
              data.refCounter = 1;
            } catch (e) {
              warn(e);
              data = null;
            }
            this.#cache.set(key, data);
            if (data) {
              this.#cache.set(data.id, data);
            }
            return data;
          }
          async getFromFile(file) {
            const {
              lastModified,
              name,
              size,
              type
            } = file;
            return this.#get(`${lastModified}_${name}_${size}_${type}`, file);
          }
          async getFromUrl(url) {
            return this.#get(url, url);
          }
          async getFromBlob(id, blobPromise) {
            const blob = await blobPromise;
            return this.#get(id, blob);
          }
          async getFromId(id) {
            this.#cache ||= new Map();
            const data = this.#cache.get(id);
            if (!data) {
              return null;
            }
            if (data.bitmap) {
              data.refCounter += 1;
              return data;
            }
            if (data.file) {
              return this.getFromFile(data.file);
            }
            if (data.blobPromise) {
              const {
                blobPromise
              } = data;
              delete data.blobPromise;
              return this.getFromBlob(data.id, blobPromise);
            }
            return this.getFromUrl(data.url);
          }
          getFromCanvas(id, canvas) {
            this.#cache ||= new Map();
            let data = this.#cache.get(id);
            if (data?.bitmap) {
              data.refCounter += 1;
              return data;
            }
            const offscreen = new OffscreenCanvas(canvas.width, canvas.height);
            const ctx = offscreen.getContext("2d");
            ctx.drawImage(canvas, 0, 0);
            data = {
              bitmap: offscreen.transferToImageBitmap(),
              id: `image_${this.#baseId}_${this.#id++}`,
              refCounter: 1,
              isSvg: false
            };
            this.#cache.set(id, data);
            this.#cache.set(data.id, data);
            return data;
          }
          getSvgUrl(id) {
            const data = this.#cache.get(id);
            if (!data?.isSvg) {
              return null;
            }
            return data.svgUrl;
          }
          deleteId(id) {
            this.#cache ||= new Map();
            const data = this.#cache.get(id);
            if (!data) {
              return;
            }
            data.refCounter -= 1;
            if (data.refCounter !== 0) {
              return;
            }
            const {
              bitmap
            } = data;
            if (!data.url && !data.file) {
              const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
              const ctx = canvas.getContext("bitmaprenderer");
              ctx.transferFromImageBitmap(bitmap);
              data.blobPromise = canvas.convertToBlob();
            }
            bitmap.close?.();
            data.bitmap = null;
          }
          isValidId(id) {
            return id.startsWith(`image_${this.#baseId}_`);
          }
        }
        class CommandManager {
          #commands = [];
          #locked = false;
          #maxSize;
          #position = -1;
          constructor(maxSize = 128) {
            this.#maxSize = maxSize;
          }
          add({
            cmd,
            undo,
            post,
            mustExec,
            type = NaN,
            overwriteIfSameType = false,
            keepUndo = false
          }) {
            if (mustExec) {
              cmd();
            }
            if (this.#locked) {
              return;
            }
            const save = {
              cmd,
              undo,
              post,
              type
            };
            if (this.#position === -1) {
              if (this.#commands.length > 0) {
                this.#commands.length = 0;
              }
              this.#position = 0;
              this.#commands.push(save);
              return;
            }
            if (overwriteIfSameType && this.#commands[this.#position].type === type) {
              if (keepUndo) {
                save.undo = this.#commands[this.#position].undo;
              }
              this.#commands[this.#position] = save;
              return;
            }
            const next = this.#position + 1;
            if (next === this.#maxSize) {
              this.#commands.splice(0, 1);
            } else {
              this.#position = next;
              if (next < this.#commands.length) {
                this.#commands.splice(next);
              }
            }
            this.#commands.push(save);
          }
          undo() {
            if (this.#position === -1) {
              return;
            }
            this.#locked = true;
            const {
              undo,
              post
            } = this.#commands[this.#position];
            undo();
            post?.();
            this.#locked = false;
            this.#position -= 1;
          }
          redo() {
            if (this.#position < this.#commands.length - 1) {
              this.#position += 1;
              this.#locked = true;
              const {
                cmd,
                post
              } = this.#commands[this.#position];
              cmd();
              post?.();
              this.#locked = false;
            }
          }
          hasSomethingToUndo() {
            return this.#position !== -1;
          }
          hasSomethingToRedo() {
            return this.#position < this.#commands.length - 1;
          }
          cleanType(type) {
            if (this.#position === -1) {
              return;
            }
            for (let i = this.#position; i >= 0; i--) {
              if (this.#commands[i].type !== type) {
                this.#commands.splice(i + 1, this.#position - i);
                this.#position = i;
                return;
              }
            }
            this.#commands.length = 0;
            this.#position = -1;
          }
          destroy() {
            this.#commands = null;
          }
        }
        class KeyboardManager {
          constructor(callbacks) {
            this.buffer = [];
            this.callbacks = new Map();
            this.allKeys = new Set();
            const {
              isMac
            } = util_FeatureTest.platform;
            for (const [keys, callback, options = {}] of callbacks) {
              for (const key of keys) {
                const isMacKey = key.startsWith("mac+");
                if (isMac && isMacKey) {
                  this.callbacks.set(key.slice(4), {
                    callback,
                    options
                  });
                  this.allKeys.add(key.split("+").at(-1));
                } else if (!isMac && !isMacKey) {
                  this.callbacks.set(key, {
                    callback,
                    options
                  });
                  this.allKeys.add(key.split("+").at(-1));
                }
              }
            }
          }
          #serialize(event) {
            if (event.altKey) {
              this.buffer.push("alt");
            }
            if (event.ctrlKey) {
              this.buffer.push("ctrl");
            }
            if (event.metaKey) {
              this.buffer.push("meta");
            }
            if (event.shiftKey) {
              this.buffer.push("shift");
            }
            this.buffer.push(event.key);
            const str = this.buffer.join("+");
            this.buffer.length = 0;
            return str;
          }
          exec(self, event) {
            if (!this.allKeys.has(event.key)) {
              return;
            }
            const info = this.callbacks.get(this.#serialize(event));
            if (!info) {
              return;
            }
            const {
              callback,
              options: {
                bubbles = false,
                args = [],
                checker = null
              }
            } = info;
            if (checker && !checker(self, event)) {
              return;
            }
            callback.bind(self, ...args, event)();
            if (!bubbles) {
              stopEvent(event);
            }
          }
        }
        class ColorManager {
          static _colorsMapping = new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]);
          get _colors() {
            const colors = new Map([["CanvasText", null], ["Canvas", null]]);
            getColorValues(colors);
            return shadow(this, "_colors", colors);
          }
          convert(color) {
            const rgb = getRGB(color);
            if (!window.matchMedia("(forced-colors: active)").matches) {
              return rgb;
            }
            for (const [name, RGB] of this._colors) {
              if (RGB.every((x, i) => x === rgb[i])) {
                return ColorManager._colorsMapping.get(name);
              }
            }
            return rgb;
          }
          getHexCode(name) {
            const rgb = this._colors.get(name);
            if (!rgb) {
              return name;
            }
            return Util.makeHexColor(...rgb);
          }
        }
        class AnnotationEditorUIManager {
          #abortController = new AbortController();
          #activeEditor = null;
          #allEditableAnnotations = null;
          #allEditors = new Map();
          #allLayers = new Map();
          #altTextManager = null;
          #annotationStorage = null;
          #changedExistingAnnotations = null;
          #commandManager = new CommandManager();
          #commentManager = null;
          #copyPasteAC = null;
          #currentDrawingSession = null;
          #currentPageIndex = 0;
          #deletedAnnotationsElementIds = new Set();
          #draggingEditors = null;
          #editorTypes = null;
          #editorsToRescale = new Set();
          _editorUndoBar = null;
          #enableHighlightFloatingButton = false;
          #enableUpdatedAddImage = false;
          #enableNewAltTextWhenAddingImage = false;
          #filterFactory = null;
          #focusMainContainerTimeoutId = null;
          #focusManagerAC = null;
          #highlightColors = null;
          #highlightWhenShiftUp = false;
          #floatingToolbar = null;
          #idManager = new IdManager();
          #isEnabled = false;
          #isPointerDown = false;
          #isWaiting = false;
          #keyboardManagerAC = null;
          #lastActiveElement = null;
          #mainHighlightColorPicker = null;
          #missingCanvases = null;
          #mlManager = null;
          #mode = AnnotationEditorType.NONE;
          #selectedEditors = new Set();
          #selectedTextNode = null;
          #signatureManager = null;
          #pageColors = null;
          #showAllStates = null;
          #pdfDocument = null;
          #previousStates = {
            isEditing: false,
            isEmpty: true,
            hasSomethingToUndo: false,
            hasSomethingToRedo: false,
            hasSelectedEditor: false,
            hasSelectedText: false
          };
          #translation = [0, 0];
          #translationTimeoutId = null;
          #container = null;
          #viewer = null;
          #viewerAlert = null;
          #updateModeCapability = null;
          static TRANSLATE_SMALL = 1;
          static TRANSLATE_BIG = 10;
          static get _keyboardManager() {
            const proto = AnnotationEditorUIManager.prototype;
            const arrowChecker = self => self.#container.contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && self.hasSomethingToControl();
            const textInputChecker = (_self, {
              target: el
            }) => {
              if (el instanceof HTMLInputElement) {
                const {
                  type
                } = el;
                return type !== "text" && type !== "number";
              }
              return true;
            };
            const small = this.TRANSLATE_SMALL;
            const big = this.TRANSLATE_BIG;
            return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], proto.selectAll, {
              checker: textInputChecker
            }], [["ctrl+z", "mac+meta+z"], proto.undo, {
              checker: textInputChecker
            }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], proto.redo, {
              checker: textInputChecker
            }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], proto.delete, {
              checker: textInputChecker
            }], [["Enter", "mac+Enter"], proto.addNewEditorFromKeyboard, {
              checker: (self, {
                target: el
              }) => !(el instanceof HTMLButtonElement) && self.#container.contains(el) && !self.isEnterHandled
            }], [[" ", "mac+ "], proto.addNewEditorFromKeyboard, {
              checker: (self, {
                target: el
              }) => !(el instanceof HTMLButtonElement) && self.#container.contains(document.activeElement)
            }], [["Escape", "mac+Escape"], proto.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], proto.translateSelectedEditors, {
              args: [-small, 0],
              checker: arrowChecker
            }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto.translateSelectedEditors, {
              args: [-big, 0],
              checker: arrowChecker
            }], [["ArrowRight", "mac+ArrowRight"], proto.translateSelectedEditors, {
              args: [small, 0],
              checker: arrowChecker
            }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto.translateSelectedEditors, {
              args: [big, 0],
              checker: arrowChecker
            }], [["ArrowUp", "mac+ArrowUp"], proto.translateSelectedEditors, {
              args: [0, -small],
              checker: arrowChecker
            }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto.translateSelectedEditors, {
              args: [0, -big],
              checker: arrowChecker
            }], [["ArrowDown", "mac+ArrowDown"], proto.translateSelectedEditors, {
              args: [0, small],
              checker: arrowChecker
            }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto.translateSelectedEditors, {
              args: [0, big],
              checker: arrowChecker
            }]]));
          }
          constructor(container, viewer, viewerAlert, altTextManager, commentManager, signatureManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom) {
            const signal = this._signal = this.#abortController.signal;
            this.#container = container;
            this.#viewer = viewer;
            this.#viewerAlert = viewerAlert;
            this.#altTextManager = altTextManager;
            this.#commentManager = commentManager;
            this.#signatureManager = signatureManager;
            this.#pdfDocument = pdfDocument;
            this._eventBus = eventBus;
            eventBus._on("editingaction", this.onEditingAction.bind(this), {
              signal
            });
            eventBus._on("pagechanging", this.onPageChanging.bind(this), {
              signal
            });
            eventBus._on("scalechanging", this.onScaleChanging.bind(this), {
              signal
            });
            eventBus._on("rotationchanging", this.onRotationChanging.bind(this), {
              signal
            });
            eventBus._on("setpreference", this.onSetPreference.bind(this), {
              signal
            });
            eventBus._on("switchannotationeditorparams", evt => this.updateParams(evt.type, evt.value), {
              signal
            });
            window.addEventListener("pointerdown", () => {
              this.#isPointerDown = true;
            }, {
              capture: true,
              signal
            });
            window.addEventListener("pointerup", () => {
              this.#isPointerDown = false;
            }, {
              capture: true,
              signal
            });
            this.#addSelectionListener();
            this.#addDragAndDropListeners();
            this.#addKeyboardManager();
            this.#annotationStorage = pdfDocument.annotationStorage;
            this.#filterFactory = pdfDocument.filterFactory;
            this.#pageColors = pageColors;
            this.#highlightColors = highlightColors || null;
            this.#enableHighlightFloatingButton = enableHighlightFloatingButton;
            this.#enableUpdatedAddImage = enableUpdatedAddImage;
            this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;
            this.#mlManager = mlManager || null;
            this.viewParameters = {
              realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
              rotation: 0
            };
            this.isShiftKeyDown = false;
            this._editorUndoBar = editorUndoBar || null;
            this._supportsPinchToZoom = supportsPinchToZoom !== false;
            commentManager?.setSidebarUiManager(this);
          }
          destroy() {
            this.#updateModeCapability?.resolve();
            this.#updateModeCapability = null;
            this.#abortController?.abort();
            this.#abortController = null;
            this._signal = null;
            for (const layer of this.#allLayers.values()) {
              layer.destroy();
            }
            this.#allLayers.clear();
            this.#allEditors.clear();
            this.#editorsToRescale.clear();
            this.#missingCanvases?.clear();
            this.#activeEditor = null;
            this.#selectedEditors.clear();
            this.#commandManager.destroy();
            this.#altTextManager?.destroy();
            this.#commentManager?.destroy();
            this.#signatureManager?.destroy();
            this.#floatingToolbar?.hide();
            this.#floatingToolbar = null;
            this.#mainHighlightColorPicker?.destroy();
            this.#mainHighlightColorPicker = null;
            this.#allEditableAnnotations = null;
            if (this.#focusMainContainerTimeoutId) {
              clearTimeout(this.#focusMainContainerTimeoutId);
              this.#focusMainContainerTimeoutId = null;
            }
            if (this.#translationTimeoutId) {
              clearTimeout(this.#translationTimeoutId);
              this.#translationTimeoutId = null;
            }
            this._editorUndoBar?.destroy();
            this.#pdfDocument = null;
          }
          combinedSignal(ac) {
            return AbortSignal.any([this._signal, ac.signal]);
          }
          get mlManager() {
            return this.#mlManager;
          }
          get useNewAltTextFlow() {
            return this.#enableUpdatedAddImage;
          }
          get useNewAltTextWhenAddingImage() {
            return this.#enableNewAltTextWhenAddingImage;
          }
          get hcmFilter() {
            return shadow(this, "hcmFilter", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : "none");
          }
          get direction() {
            return shadow(this, "direction", getComputedStyle(this.#container).direction);
          }
          get _highlightColors() {
            return shadow(this, "_highlightColors", this.#highlightColors ? new Map(this.#highlightColors.split(",").map(pair => {
              pair = pair.split("=").map(x => x.trim());
              pair[1] = pair[1].toUpperCase();
              return pair;
            })) : null);
          }
          get highlightColors() {
            const {
              _highlightColors
            } = this;
            if (!_highlightColors) {
              return shadow(this, "highlightColors", null);
            }
            const map = new Map();
            const hasHCM = !!this.#pageColors;
            for (const [name, color] of _highlightColors) {
              const isNameForHCM = name.endsWith("_HCM");
              if (hasHCM && isNameForHCM) {
                map.set(name.replace("_HCM", ""), color);
                continue;
              }
              if (!hasHCM && !isNameForHCM) {
                map.set(name, color);
              }
            }
            return shadow(this, "highlightColors", map);
          }
          get highlightColorNames() {
            return shadow(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, e => e.reverse())) : null);
          }
          getNonHCMColor(color) {
            if (!this._highlightColors) {
              return color;
            }
            const colorName = this.highlightColorNames.get(color);
            return this._highlightColors.get(colorName) || color;
          }
          getNonHCMColorName(color) {
            return this.highlightColorNames.get(color) || color;
          }
          setCurrentDrawingSession(layer) {
            if (layer) {
              this.unselectAll();
              this.disableUserSelect(true);
            } else {
              this.disableUserSelect(false);
            }
            this.#currentDrawingSession = layer;
          }
          setMainHighlightColorPicker(colorPicker) {
            this.#mainHighlightColorPicker = colorPicker;
          }
          editAltText(editor, firstTime = false) {
            this.#altTextManager?.editAltText(this, editor, firstTime);
          }
          hasCommentManager() {
            return !!this.#commentManager;
          }
          editComment(editor, posX, posY, options) {
            this.#commentManager?.showDialog(this, editor, posX, posY, options);
          }
          selectComment(pageIndex, uid) {
            const layer = this.#allLayers.get(pageIndex);
            const editor = layer?.getEditorByUID(uid);
            editor?.toggleComment(true, true);
          }
          updateComment(editor) {
            this.#commentManager?.updateComment(editor.getData());
          }
          updatePopupColor(editor) {
            this.#commentManager?.updatePopupColor(editor);
          }
          removeComment(editor) {
            this.#commentManager?.removeComments([editor.uid]);
          }
          toggleComment(editor, isSelected, visibility = undefined) {
            this.#commentManager?.toggleCommentPopup(editor, isSelected, visibility);
          }
          makeCommentColor(color, opacity) {
            return color && this.#commentManager?.makeCommentColor(color, opacity) || null;
          }
          getCommentDialogElement() {
            return this.#commentManager?.dialogElement || null;
          }
          async waitForEditorsRendered(pageNumber) {
            if (this.#allLayers.has(pageNumber - 1)) {
              return;
            }
            const {
              resolve,
              promise
            } = Promise.withResolvers();
            const onEditorsRendered = evt => {
              if (evt.pageNumber === pageNumber) {
                this._eventBus._off("editorsrendered", onEditorsRendered);
                resolve();
              }
            };
            this._eventBus.on("editorsrendered", onEditorsRendered);
            await promise;
          }
          getSignature(editor) {
            this.#signatureManager?.getSignature({
              uiManager: this,
              editor
            });
          }
          get signatureManager() {
            return this.#signatureManager;
          }
          switchToMode(mode, callback) {
            this._eventBus.on("annotationeditormodechanged", callback, {
              once: true,
              signal: this._signal
            });
            this._eventBus.dispatch("showannotationeditorui", {
              source: this,
              mode
            });
          }
          setPreference(name, value) {
            this._eventBus.dispatch("setpreference", {
              source: this,
              name,
              value
            });
          }
          onSetPreference({
            name,
            value
          }) {
            switch (name) {
              case "enableNewAltTextWhenAddingImage":
                this.#enableNewAltTextWhenAddingImage = value;
                break;
            }
          }
          onPageChanging({
            pageNumber
          }) {
            this.#currentPageIndex = pageNumber - 1;
          }
          focusMainContainer() {
            this.#container.focus();
          }
          findParent(x, y) {
            for (const layer of this.#allLayers.values()) {
              const {
                x: layerX,
                y: layerY,
                width,
                height
              } = layer.div.getBoundingClientRect();
              if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {
                return layer;
              }
            }
            return null;
          }
          disableUserSelect(value = false) {
            this.#viewer.classList.toggle("noUserSelect", value);
          }
          addShouldRescale(editor) {
            this.#editorsToRescale.add(editor);
          }
          removeShouldRescale(editor) {
            this.#editorsToRescale.delete(editor);
          }
          onScaleChanging({
            scale
          }) {
            this.commitOrRemove();
            this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
            for (const editor of this.#editorsToRescale) {
              editor.onScaleChanging();
            }
            this.#currentDrawingSession?.onScaleChanging();
          }
          onRotationChanging({
            pagesRotation
          }) {
            this.commitOrRemove();
            this.viewParameters.rotation = pagesRotation;
          }
          #getAnchorElementForSelection({
            anchorNode
          }) {
            return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;
          }
          #getLayerForTextLayer(textLayer) {
            const {
              currentLayer
            } = this;
            if (currentLayer.hasTextLayer(textLayer)) {
              return currentLayer;
            }
            for (const layer of this.#allLayers.values()) {
              if (layer.hasTextLayer(textLayer)) {
                return layer;
              }
            }
            return null;
          }
          highlightSelection(methodOfCreation = "", comment = false) {
            const selection = document.getSelection();
            if (!selection || selection.isCollapsed) {
              return;
            }
            const {
              anchorNode,
              anchorOffset,
              focusNode,
              focusOffset
            } = selection;
            const text = selection.toString();
            const anchorElement = this.#getAnchorElementForSelection(selection);
            const textLayer = anchorElement.closest(".textLayer");
            const boxes = this.getSelectionBoxes(textLayer);
            if (!boxes) {
              return;
            }
            selection.empty();
            const layer = this.#getLayerForTextLayer(textLayer);
            const isNoneMode = this.#mode === AnnotationEditorType.NONE;
            const callback = () => {
              const editor = layer?.createAndAddNewEditor({
                x: 0,
                y: 0
              }, false, {
                methodOfCreation,
                boxes,
                anchorNode,
                anchorOffset,
                focusNode,
                focusOffset,
                text
              });
              if (isNoneMode) {
                this.showAllEditors("highlight", true, true);
              }
              if (comment) {
                editor?.editComment();
              }
            };
            if (isNoneMode) {
              this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);
              return;
            }
            callback();
          }
          commentSelection(methodOfCreation = "") {
            this.highlightSelection(methodOfCreation, true);
          }
          #displayFloatingToolbar() {
            const selection = document.getSelection();
            if (!selection || selection.isCollapsed) {
              return;
            }
            const anchorElement = this.#getAnchorElementForSelection(selection);
            const textLayer = anchorElement.closest(".textLayer");
            const boxes = this.getSelectionBoxes(textLayer);
            if (!boxes) {
              return;
            }
            this.#floatingToolbar ||= new FloatingToolbar(this);
            this.#floatingToolbar.show(textLayer, boxes, this.direction === "ltr");
          }
          getAndRemoveDataFromAnnotationStorage(annotationId) {
            if (!this.#annotationStorage) {
              return null;
            }
            const key = `${AnnotationEditorPrefix}${annotationId}`;
            const storedValue = this.#annotationStorage.getRawValue(key);
            if (storedValue) {
              this.#annotationStorage.remove(key);
            }
            return storedValue;
          }
          addToAnnotationStorage(editor) {
            if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {
              this.#annotationStorage.setValue(editor.id, editor);
            }
          }
          a11yAlert(messageId, args = null) {
            const viewerAlert = this.#viewerAlert;
            if (!viewerAlert) {
              return;
            }
            viewerAlert.setAttribute("data-l10n-id", messageId);
            if (args) {
              viewerAlert.setAttribute("data-l10n-args", JSON.stringify(args));
            } else {
              viewerAlert.removeAttribute("data-l10n-args");
            }
          }
          #selectionChange() {
            const selection = document.getSelection();
            if (!selection || selection.isCollapsed) {
              if (this.#selectedTextNode) {
                this.#floatingToolbar?.hide();
                this.#selectedTextNode = null;
                this.#dispatchUpdateStates({
                  hasSelectedText: false
                });
              }
              return;
            }
            const {
              anchorNode
            } = selection;
            if (anchorNode === this.#selectedTextNode) {
              return;
            }
            const anchorElement = this.#getAnchorElementForSelection(selection);
            const textLayer = anchorElement.closest(".textLayer");
            if (!textLayer) {
              if (this.#selectedTextNode) {
                this.#floatingToolbar?.hide();
                this.#selectedTextNode = null;
                this.#dispatchUpdateStates({
                  hasSelectedText: false
                });
              }
              return;
            }
            this.#floatingToolbar?.hide();
            this.#selectedTextNode = anchorNode;
            this.#dispatchUpdateStates({
              hasSelectedText: true
            });
            if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {
              return;
            }
            if (this.#mode === AnnotationEditorType.HIGHLIGHT) {
              this.showAllEditors("highlight", true, true);
            }
            this.#highlightWhenShiftUp = this.isShiftKeyDown;
            if (!this.isShiftKeyDown) {
              const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;
              activeLayer?.toggleDrawing();
              if (this.#isPointerDown) {
                const ac = new AbortController();
                const signal = this.combinedSignal(ac);
                const pointerup = e => {
                  if (e.type === "pointerup" && e.button !== 0) {
                    return;
                  }
                  ac.abort();
                  activeLayer?.toggleDrawing(true);
                  if (e.type === "pointerup") {
                    this.#onSelectEnd("main_toolbar");
                  }
                };
                window.addEventListener("pointerup", pointerup, {
                  signal
                });
                window.addEventListener("blur", pointerup, {
                  signal
                });
              } else {
                activeLayer?.toggleDrawing(true);
                this.#onSelectEnd("main_toolbar");
              }
            }
          }
          #onSelectEnd(methodOfCreation = "") {
            if (this.#mode === AnnotationEditorType.HIGHLIGHT) {
              this.highlightSelection(methodOfCreation);
            } else if (this.#enableHighlightFloatingButton) {
              this.#displayFloatingToolbar();
            }
          }
          #addSelectionListener() {
            document.addEventListener("selectionchange", this.#selectionChange.bind(this), {
              signal: this._signal
            });
          }
          #addFocusManager() {
            if (this.#focusManagerAC) {
              return;
            }
            this.#focusManagerAC = new AbortController();
            const signal = this.combinedSignal(this.#focusManagerAC);
            window.addEventListener("focus", this.focus.bind(this), {
              signal
            });
            window.addEventListener("blur", this.blur.bind(this), {
              signal
            });
          }
          #removeFocusManager() {
            this.#focusManagerAC?.abort();
            this.#focusManagerAC = null;
          }
          blur() {
            this.isShiftKeyDown = false;
            if (this.#highlightWhenShiftUp) {
              this.#highlightWhenShiftUp = false;
              this.#onSelectEnd("main_toolbar");
            }
            if (!this.hasSelection) {
              return;
            }
            const {
              activeElement
            } = document;
            for (const editor of this.#selectedEditors) {
              if (editor.div.contains(activeElement)) {
                this.#lastActiveElement = [editor, activeElement];
                editor._focusEventsAllowed = false;
                break;
              }
            }
          }
          focus() {
            if (!this.#lastActiveElement) {
              return;
            }
            const [lastEditor, lastActiveElement] = this.#lastActiveElement;
            this.#lastActiveElement = null;
            lastActiveElement.addEventListener("focusin", () => {
              lastEditor._focusEventsAllowed = true;
            }, {
              once: true,
              signal: this._signal
            });
            lastActiveElement.focus();
          }
          #addKeyboardManager() {
            if (this.#keyboardManagerAC) {
              return;
            }
            this.#keyboardManagerAC = new AbortController();
            const signal = this.combinedSignal(this.#keyboardManagerAC);
            window.addEventListener("keydown", this.keydown.bind(this), {
              signal
            });
            window.addEventListener("keyup", this.keyup.bind(this), {
              signal
            });
          }
          #removeKeyboardManager() {
            this.#keyboardManagerAC?.abort();
            this.#keyboardManagerAC = null;
          }
          #addCopyPasteListeners() {
            if (this.#copyPasteAC) {
              return;
            }
            this.#copyPasteAC = new AbortController();
            const signal = this.combinedSignal(this.#copyPasteAC);
            document.addEventListener("copy", this.copy.bind(this), {
              signal
            });
            document.addEventListener("cut", this.cut.bind(this), {
              signal
            });
            document.addEventListener("paste", this.paste.bind(this), {
              signal
            });
          }
          #removeCopyPasteListeners() {
            this.#copyPasteAC?.abort();
            this.#copyPasteAC = null;
          }
          #addDragAndDropListeners() {
            const signal = this._signal;
            document.addEventListener("dragover", this.dragOver.bind(this), {
              signal
            });
            document.addEventListener("drop", this.drop.bind(this), {
              signal
            });
          }
          addEditListeners() {
            this.#addKeyboardManager();
            this.setEditingState(true);
          }
          removeEditListeners() {
            this.#removeKeyboardManager();
            this.setEditingState(false);
          }
          dragOver(event) {
            for (const {
              type
            } of event.dataTransfer.items) {
              for (const editorType of this.#editorTypes) {
                if (editorType.isHandlingMimeForPasting(type)) {
                  event.dataTransfer.dropEffect = "copy";
                  event.preventDefault();
                  return;
                }
              }
            }
          }
          drop(event) {
            for (const item of event.dataTransfer.items) {
              for (const editorType of this.#editorTypes) {
                if (editorType.isHandlingMimeForPasting(item.type)) {
                  editorType.paste(item, this.currentLayer);
                  event.preventDefault();
                  return;
                }
              }
            }
          }
          copy(event) {
            event.preventDefault();
            this.#activeEditor?.commitOrRemove();
            if (!this.hasSelection) {
              return;
            }
            const editors = [];
            for (const editor of this.#selectedEditors) {
              const serialized = editor.serialize(true);
              if (serialized) {
                editors.push(serialized);
              }
            }
            if (editors.length === 0) {
              return;
            }
            event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
          }
          cut(event) {
            this.copy(event);
            this.delete();
          }
          async paste(event) {
            event.preventDefault();
            const {
              clipboardData
            } = event;
            for (const item of clipboardData.items) {
              for (const editorType of this.#editorTypes) {
                if (editorType.isHandlingMimeForPasting(item.type)) {
                  editorType.paste(item, this.currentLayer);
                  return;
                }
              }
            }
            let data = clipboardData.getData("application/pdfjs");
            if (!data) {
              return;
            }
            try {
              data = JSON.parse(data);
            } catch (ex) {
              warn(`paste: "${ex.message}".`);
              return;
            }
            if (!Array.isArray(data)) {
              return;
            }
            this.unselectAll();
            const layer = this.currentLayer;
            try {
              const newEditors = [];
              for (const editor of data) {
                const deserializedEditor = await layer.deserialize(editor);
                if (!deserializedEditor) {
                  return;
                }
                newEditors.push(deserializedEditor);
              }
              const cmd = () => {
                for (const editor of newEditors) {
                  this.#addEditorToLayer(editor);
                }
                this.#selectEditors(newEditors);
              };
              const undo = () => {
                for (const editor of newEditors) {
                  editor.remove();
                }
              };
              this.addCommands({
                cmd,
                undo,
                mustExec: true
              });
            } catch (ex) {
              warn(`paste: "${ex.message}".`);
            }
          }
          keydown(event) {
            if (!this.isShiftKeyDown && event.key === "Shift") {
              this.isShiftKeyDown = true;
            }
            if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {
              AnnotationEditorUIManager._keyboardManager.exec(this, event);
            }
          }
          keyup(event) {
            if (this.isShiftKeyDown && event.key === "Shift") {
              this.isShiftKeyDown = false;
              if (this.#highlightWhenShiftUp) {
                this.#highlightWhenShiftUp = false;
                this.#onSelectEnd("main_toolbar");
              }
            }
          }
          onEditingAction({
            name
          }) {
            switch (name) {
              case "undo":
              case "redo":
              case "delete":
              case "selectAll":
                this[name]();
                break;
              case "highlightSelection":
                this.highlightSelection("context_menu");
                break;
              case "commentSelection":
                this.commentSelection("context_menu");
                break;
            }
          }
          #dispatchUpdateStates(details) {
            const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);
            if (hasChanged) {
              this._eventBus.dispatch("annotationeditorstateschanged", {
                source: this,
                details: Object.assign(this.#previousStates, details)
              });
              if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {
                this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_FREE, true]]);
              }
            }
          }
          #dispatchUpdateUI(details) {
            this._eventBus.dispatch("annotationeditorparamschanged", {
              source: this,
              details
            });
          }
          setEditingState(isEditing) {
            if (isEditing) {
              this.#addFocusManager();
              this.#addCopyPasteListeners();
              this.#dispatchUpdateStates({
                isEditing: this.#mode !== AnnotationEditorType.NONE,
                isEmpty: this.#isEmpty(),
                hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
                hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
                hasSelectedEditor: false
              });
            } else {
              this.#removeFocusManager();
              this.#removeCopyPasteListeners();
              this.#dispatchUpdateStates({
                isEditing: false
              });
              this.disableUserSelect(false);
            }
          }
          registerEditorTypes(types) {
            if (this.#editorTypes) {
              return;
            }
            this.#editorTypes = types;
            for (const editorType of this.#editorTypes) {
              this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
            }
          }
          getId() {
            return this.#idManager.id;
          }
          get currentLayer() {
            return this.#allLayers.get(this.#currentPageIndex);
          }
          getLayer(pageIndex) {
            return this.#allLayers.get(pageIndex);
          }
          get currentPageIndex() {
            return this.#currentPageIndex;
          }
          addLayer(layer) {
            this.#allLayers.set(layer.pageIndex, layer);
            if (this.#isEnabled) {
              layer.enable();
            } else {
              layer.disable();
            }
          }
          removeLayer(layer) {
            this.#allLayers.delete(layer.pageIndex);
          }
          async updateMode(mode, editId = null, isFromKeyboard = false, mustEnterInEditMode = false, editComment = false) {
            if (this.#mode === mode) {
              return;
            }
            if (this.#updateModeCapability) {
              await this.#updateModeCapability.promise;
              if (!this.#updateModeCapability) {
                return;
              }
            }
            this.#updateModeCapability = Promise.withResolvers();
            this.#currentDrawingSession?.commitOrRemove();
            if (this.#mode === AnnotationEditorType.POPUP) {
              this.#commentManager?.hideSidebar();
            }
            this.#commentManager?.destroyPopup();
            this.#mode = mode;
            if (mode === AnnotationEditorType.NONE) {
              this.setEditingState(false);
              this.#disableAll();
              for (const editor of this.#allEditors.values()) {
                editor.hideStandaloneCommentButton();
              }
              this._editorUndoBar?.hide();
              this.toggleComment(null);
              this.#updateModeCapability.resolve();
              return;
            }
            for (const editor of this.#allEditors.values()) {
              editor.addStandaloneCommentButton();
            }
            if (mode === AnnotationEditorType.SIGNATURE) {
              await this.#signatureManager?.loadSignatures();
            }
            this.setEditingState(true);
            await this.#enableAll();
            this.unselectAll();
            for (const layer of this.#allLayers.values()) {
              layer.updateMode(mode);
            }
            if (mode === AnnotationEditorType.POPUP) {
              this.#allEditableAnnotations ||= await this.#pdfDocument.getAnnotationsByType(new Set(this.#editorTypes.map(editorClass => editorClass._editorType)));
              const elementIds = new Set();
              const allComments = [];
              for (const editor of this.#allEditors.values()) {
                const {
                  annotationElementId,
                  hasComment,
                  deleted
                } = editor;
                if (annotationElementId) {
                  elementIds.add(annotationElementId);
                }
                if (hasComment && !deleted) {
                  allComments.push(editor.getData());
                }
              }
              for (const annotation of this.#allEditableAnnotations) {
                const {
                  id,
                  popupRef,
                  contentsObj
                } = annotation;
                if (popupRef && contentsObj?.str && !elementIds.has(id) && !this.#deletedAnnotationsElementIds.has(id)) {
                  allComments.push(annotation);
                }
              }
              this.#commentManager?.showSidebar(allComments);
            }
            if (!editId) {
              if (isFromKeyboard) {
                this.addNewEditorFromKeyboard();
              }
              this.#updateModeCapability.resolve();
              return;
            }
            for (const editor of this.#allEditors.values()) {
              if (editor.uid === editId) {
                this.setSelected(editor);
                if (editComment) {
                  editor.editComment();
                } else if (mustEnterInEditMode) {
                  editor.enterInEditMode();
                } else {
                  editor.focus();
                }
              } else {
                editor.unselect();
              }
            }
            this.#updateModeCapability.resolve();
          }
          addNewEditorFromKeyboard() {
            if (this.currentLayer.canCreateNewEmptyEditor()) {
              this.currentLayer.addNewEditor();
            }
          }
          updateToolbar(options) {
            if (options.mode === this.#mode) {
              return;
            }
            this._eventBus.dispatch("switchannotationeditormode", {
              source: this,
              ...options
            });
          }
          updateParams(type, value) {
            if (!this.#editorTypes) {
              return;
            }
            switch (type) {
              case AnnotationEditorParamsType.CREATE:
                this.currentLayer.addNewEditor(value);
                return;
              case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:
                this._eventBus.dispatch("reporttelemetry", {
                  source: this,
                  details: {
                    type: "editing",
                    data: {
                      type: "highlight",
                      action: "toggle_visibility"
                    }
                  }
                });
                (this.#showAllStates ||= new Map()).set(type, value);
                this.showAllEditors("highlight", value);
                break;
            }
            if (this.hasSelection) {
              for (const editor of this.#selectedEditors) {
                editor.updateParams(type, value);
              }
            } else {
              for (const editorType of this.#editorTypes) {
                editorType.updateDefaultParams(type, value);
              }
            }
          }
          showAllEditors(type, visible, updateButton = false) {
            for (const editor of this.#allEditors.values()) {
              if (editor.editorType === type) {
                editor.show(visible);
              }
            }
            const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;
            if (state !== visible) {
              this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, visible]]);
            }
          }
          enableWaiting(mustWait = false) {
            if (this.#isWaiting === mustWait) {
              return;
            }
            this.#isWaiting = mustWait;
            for (const layer of this.#allLayers.values()) {
              if (mustWait) {
                layer.disableClick();
              } else {
                layer.enableClick();
              }
              layer.div.classList.toggle("waiting", mustWait);
            }
          }
          async #enableAll() {
            if (!this.#isEnabled) {
              this.#isEnabled = true;
              const promises = [];
              for (const layer of this.#allLayers.values()) {
                promises.push(layer.enable());
              }
              await Promise.all(promises);
              for (const editor of this.#allEditors.values()) {
                editor.enable();
              }
            }
          }
          #disableAll() {
            this.unselectAll();
            if (this.#isEnabled) {
              this.#isEnabled = false;
              for (const layer of this.#allLayers.values()) {
                layer.disable();
              }
              for (const editor of this.#allEditors.values()) {
                editor.disable();
              }
            }
          }
          *getEditors(pageIndex) {
            for (const editor of this.#allEditors.values()) {
              if (editor.pageIndex === pageIndex) {
                yield editor;
              }
            }
          }
          getEditor(id) {
            return this.#allEditors.get(id);
          }
          addEditor(editor) {
            this.#allEditors.set(editor.id, editor);
          }
          removeEditor(editor) {
            if (editor.div.contains(document.activeElement)) {
              if (this.#focusMainContainerTimeoutId) {
                clearTimeout(this.#focusMainContainerTimeoutId);
              }
              this.#focusMainContainerTimeoutId = setTimeout(() => {
                this.focusMainContainer();
                this.#focusMainContainerTimeoutId = null;
              }, 0);
            }
            this.#allEditors.delete(editor.id);
            if (editor.annotationElementId) {
              this.#missingCanvases?.delete(editor.annotationElementId);
            }
            this.unselect(editor);
            if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {
              this.#annotationStorage?.remove(editor.id);
            }
          }
          addDeletedAnnotationElement(editor) {
            this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
            this.addChangedExistingAnnotation(editor);
            editor.deleted = true;
          }
          isDeletedAnnotationElement(annotationElementId) {
            return this.#deletedAnnotationsElementIds.has(annotationElementId);
          }
          removeDeletedAnnotationElement(editor) {
            this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
            this.removeChangedExistingAnnotation(editor);
            editor.deleted = false;
          }
          #addEditorToLayer(editor) {
            const layer = this.#allLayers.get(editor.pageIndex);
            if (layer) {
              layer.addOrRebuild(editor);
            } else {
              this.addEditor(editor);
              this.addToAnnotationStorage(editor);
            }
          }
          setActiveEditor(editor) {
            if (this.#activeEditor === editor) {
              return;
            }
            this.#activeEditor = editor;
            if (editor) {
              this.#dispatchUpdateUI(editor.propertiesToUpdate);
            }
          }
          get #lastSelectedEditor() {
            let ed = null;
            for (ed of this.#selectedEditors) { }
            return ed;
          }
          updateUI(editor) {
            if (this.#lastSelectedEditor === editor) {
              this.#dispatchUpdateUI(editor.propertiesToUpdate);
            }
          }
          updateUIForDefaultProperties(editorType) {
            this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
          }
          toggleSelected(editor) {
            if (this.#selectedEditors.has(editor)) {
              this.#selectedEditors.delete(editor);
              editor.unselect();
              this.#dispatchUpdateStates({
                hasSelectedEditor: this.hasSelection
              });
              return;
            }
            this.#selectedEditors.add(editor);
            editor.select();
            this.#dispatchUpdateUI(editor.propertiesToUpdate);
            this.#dispatchUpdateStates({
              hasSelectedEditor: true
            });
          }
          setSelected(editor) {
            this.updateToolbar({
              mode: editor.mode,
              editId: editor.uid
            });
            this.#currentDrawingSession?.commitOrRemove();
            for (const ed of this.#selectedEditors) {
              if (ed !== editor) {
                ed.unselect();
              }
            }
            this.#selectedEditors.clear();
            this.#selectedEditors.add(editor);
            editor.select();
            this.#dispatchUpdateUI(editor.propertiesToUpdate);
            this.#dispatchUpdateStates({
              hasSelectedEditor: true
            });
          }
          isSelected(editor) {
            return this.#selectedEditors.has(editor);
          }
          get firstSelectedEditor() {
            return this.#selectedEditors.values().next().value;
          }
          unselect(editor) {
            editor.unselect();
            this.#selectedEditors.delete(editor);
            this.#dispatchUpdateStates({
              hasSelectedEditor: this.hasSelection
            });
          }
          get hasSelection() {
            return this.#selectedEditors.size !== 0;
          }
          get isEnterHandled() {
            return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;
          }
          undo() {
            this.#commandManager.undo();
            this.#dispatchUpdateStates({
              hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
              hasSomethingToRedo: true,
              isEmpty: this.#isEmpty()
            });
            this._editorUndoBar?.hide();
          }
          redo() {
            this.#commandManager.redo();
            this.#dispatchUpdateStates({
              hasSomethingToUndo: true,
              hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
              isEmpty: this.#isEmpty()
            });
          }
          addCommands(params) {
            this.#commandManager.add(params);
            this.#dispatchUpdateStates({
              hasSomethingToUndo: true,
              hasSomethingToRedo: false,
              isEmpty: this.#isEmpty()
            });
          }
          cleanUndoStack(type) {
            this.#commandManager.cleanType(type);
          }
          #isEmpty() {
            if (this.#allEditors.size === 0) {
              return true;
            }
            if (this.#allEditors.size === 1) {
              for (const editor of this.#allEditors.values()) {
                return editor.isEmpty();
              }
            }
            return false;
          }
          delete() {
            this.commitOrRemove();
            const drawingEditor = this.currentLayer?.endDrawingSession(true);
            if (!this.hasSelection && !drawingEditor) {
              return;
            }
            const editors = drawingEditor ? [drawingEditor] : [...this.#selectedEditors];
            const cmd = () => {
              this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);
              for (const editor of editors) {
                editor.remove();
              }
            };
            const undo = () => {
              for (const editor of editors) {
                this.#addEditorToLayer(editor);
              }
            };
            this.addCommands({
              cmd,
              undo,
              mustExec: true
            });
          }
          commitOrRemove() {
            this.#activeEditor?.commitOrRemove();
          }
          hasSomethingToControl() {
            return this.#activeEditor || this.hasSelection;
          }
          #selectEditors(editors) {
            for (const editor of this.#selectedEditors) {
              editor.unselect();
            }
            this.#selectedEditors.clear();
            for (const editor of editors) {
              if (editor.isEmpty()) {
                continue;
              }
              this.#selectedEditors.add(editor);
              editor.select();
            }
            this.#dispatchUpdateStates({
              hasSelectedEditor: this.hasSelection
            });
          }
          selectAll() {
            for (const editor of this.#selectedEditors) {
              editor.commit();
            }
            this.#selectEditors(this.#allEditors.values());
          }
          unselectAll() {
            if (this.#activeEditor) {
              this.#activeEditor.commitOrRemove();
              if (this.#mode !== AnnotationEditorType.NONE) {
                return;
              }
            }
            if (this.#currentDrawingSession?.commitOrRemove()) {
              return;
            }
            if (!this.hasSelection) {
              return;
            }
            for (const editor of this.#selectedEditors) {
              editor.unselect();
            }
            this.#selectedEditors.clear();
            this.#dispatchUpdateStates({
              hasSelectedEditor: false
            });
          }
          translateSelectedEditors(x, y, noCommit = false) {
            if (!noCommit) {
              this.commitOrRemove();
            }
            if (!this.hasSelection) {
              return;
            }
            this.#translation[0] += x;
            this.#translation[1] += y;
            const [totalX, totalY] = this.#translation;
            const editors = [...this.#selectedEditors];
            const TIME_TO_WAIT = 1000;
            if (this.#translationTimeoutId) {
              clearTimeout(this.#translationTimeoutId);
            }
            this.#translationTimeoutId = setTimeout(() => {
              this.#translationTimeoutId = null;
              this.#translation[0] = this.#translation[1] = 0;
              this.addCommands({
                cmd: () => {
                  for (const editor of editors) {
                    if (this.#allEditors.has(editor.id)) {
                      editor.translateInPage(totalX, totalY);
                      editor.translationDone();
                    }
                  }
                },
                undo: () => {
                  for (const editor of editors) {
                    if (this.#allEditors.has(editor.id)) {
                      editor.translateInPage(-totalX, -totalY);
                      editor.translationDone();
                    }
                  }
                },
                mustExec: false
              });
            }, TIME_TO_WAIT);
            for (const editor of editors) {
              editor.translateInPage(x, y);
              editor.translationDone();
            }
          }
          setUpDragSession() {
            if (!this.hasSelection) {
              return;
            }
            this.disableUserSelect(true);
            this.#draggingEditors = new Map();
            for (const editor of this.#selectedEditors) {
              this.#draggingEditors.set(editor, {
                savedX: editor.x,
                savedY: editor.y,
                savedPageIndex: editor.pageIndex,
                newX: 0,
                newY: 0,
                newPageIndex: -1
              });
            }
          }
          endDragSession() {
            if (!this.#draggingEditors) {
              return false;
            }
            this.disableUserSelect(false);
            const map = this.#draggingEditors;
            this.#draggingEditors = null;
            let mustBeAddedInUndoStack = false;
            for (const [{
              x,
              y,
              pageIndex
            }, value] of map) {
              value.newX = x;
              value.newY = y;
              value.newPageIndex = pageIndex;
              mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;
            }
            if (!mustBeAddedInUndoStack) {
              return false;
            }
            const move = (editor, x, y, pageIndex) => {
              if (this.#allEditors.has(editor.id)) {
                const parent = this.#allLayers.get(pageIndex);
                if (parent) {
                  editor._setParentAndPosition(parent, x, y);
                } else {
                  editor.pageIndex = pageIndex;
                  editor.x = x;
                  editor.y = y;
                }
              }
            };
            this.addCommands({
              cmd: () => {
                for (const [editor, {
                  newX,
                  newY,
                  newPageIndex
                }] of map) {
                  move(editor, newX, newY, newPageIndex);
                }
              },
              undo: () => {
                for (const [editor, {
                  savedX,
                  savedY,
                  savedPageIndex
                }] of map) {
                  move(editor, savedX, savedY, savedPageIndex);
                }
              },
              mustExec: true
            });
            return true;
          }
          dragSelectedEditors(tx, ty) {
            if (!this.#draggingEditors) {
              return;
            }
            for (const editor of this.#draggingEditors.keys()) {
              editor.drag(tx, ty);
            }
          }
          rebuild(editor) {
            if (editor.parent === null) {
              const parent = this.getLayer(editor.pageIndex);
              if (parent) {
                parent.changeParent(editor);
                parent.addOrRebuild(editor);
              } else {
                this.addEditor(editor);
                this.addToAnnotationStorage(editor);
                editor.rebuild();
              }
            } else {
              editor.parent.addOrRebuild(editor);
            }
          }
          get isEditorHandlingKeyboard() {
            return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
          }
          isActive(editor) {
            return this.#activeEditor === editor;
          }
          getActive() {
            return this.#activeEditor;
          }
          getMode() {
            return this.#mode;
          }
          isEditingMode() {
            return this.#mode !== AnnotationEditorType.NONE;
          }
          get imageManager() {
            return shadow(this, "imageManager", new ImageManager());
          }
          getSelectionBoxes(textLayer) {
            if (!textLayer) {
              return null;
            }
            const selection = document.getSelection();
            for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
              if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {
                return null;
              }
            }
            const {
              x: layerX,
              y: layerY,
              width: parentWidth,
              height: parentHeight
            } = textLayer.getBoundingClientRect();
            let rotator;
            switch (textLayer.getAttribute("data-main-rotation")) {
              case "90":
                rotator = (x, y, w, h) => ({
                  x: (y - layerY) / parentHeight,
                  y: 1 - (x + w - layerX) / parentWidth,
                  width: h / parentHeight,
                  height: w / parentWidth
                });
                break;
              case "180":
                rotator = (x, y, w, h) => ({
                  x: 1 - (x + w - layerX) / parentWidth,
                  y: 1 - (y + h - layerY) / parentHeight,
                  width: w / parentWidth,
                  height: h / parentHeight
                });
                break;
              case "270":
                rotator = (x, y, w, h) => ({
                  x: 1 - (y + h - layerY) / parentHeight,
                  y: (x - layerX) / parentWidth,
                  width: h / parentHeight,
                  height: w / parentWidth
                });
                break;
              default:
                rotator = (x, y, w, h) => ({
                  x: (x - layerX) / parentWidth,
                  y: (y - layerY) / parentHeight,
                  width: w / parentWidth,
                  height: h / parentHeight
                });
                break;
            }
            const boxes = [];
            for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
              const range = selection.getRangeAt(i);
              if (range.collapsed) {
                continue;
              }
              for (const {
                x,
                y,
                width,
                height
              } of range.getClientRects()) {
                if (width === 0 || height === 0) {
                  continue;
                }
                boxes.push(rotator(x, y, width, height));
              }
            }
            return boxes.length === 0 ? null : boxes;
          }
          addChangedExistingAnnotation({
            annotationElementId,
            id
          }) {
            (this.#changedExistingAnnotations ||= new Map()).set(annotationElementId, id);
          }
          removeChangedExistingAnnotation({
            annotationElementId
          }) {
            this.#changedExistingAnnotations?.delete(annotationElementId);
          }
          renderAnnotationElement(annotation) {
            const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);
            if (!editorId) {
              return;
            }
            const editor = this.#annotationStorage.getRawValue(editorId);
            if (!editor) {
              return;
            }
            if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {
              return;
            }
            editor.renderAnnotationElement(annotation);
          }
          setMissingCanvas(annotationId, annotationElementId, canvas) {
            const editor = this.#missingCanvases?.get(annotationId);
            if (!editor) {
              return;
            }
            editor.setCanvas(annotationElementId, canvas);
            this.#missingCanvases.delete(annotationId);
          }
          addMissingCanvas(annotationId, editor) {
            (this.#missingCanvases ||= new Map()).set(annotationId, editor);
          }
        }

        ;// ./src/display/editor/alt_text.js

        class AltText {
          #altText = null;
          #altTextDecorative = false;
          #altTextButton = null;
          #altTextButtonLabel = null;
          #altTextTooltip = null;
          #altTextTooltipTimeout = null;
          #altTextWasFromKeyBoard = false;
          #badge = null;
          #editor = null;
          #guessedText = null;
          #textWithDisclaimer = null;
          #useNewAltTextFlow = false;
          static #l10nNewButton = null;
          static _l10n = null;
          constructor(editor) {
            this.#editor = editor;
            this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;
            AltText.#l10nNewButton ||= Object.freeze({
              added: "pdfjs-editor-new-alt-text-added-button",
              "added-label": "pdfjs-editor-new-alt-text-added-button-label",
              missing: "pdfjs-editor-new-alt-text-missing-button",
              "missing-label": "pdfjs-editor-new-alt-text-missing-button-label",
              review: "pdfjs-editor-new-alt-text-to-review-button",
              "review-label": "pdfjs-editor-new-alt-text-to-review-button-label"
            });
          }
          static initialize(l10n) {
            AltText._l10n ??= l10n;
          }
          async render() {
            const altText = this.#altTextButton = document.createElement("button");
            altText.className = "altText";
            altText.tabIndex = "0";
            const label = this.#altTextButtonLabel = document.createElement("span");
            altText.append(label);
            if (this.#useNewAltTextFlow) {
              altText.classList.add("new");
              altText.setAttribute("data-l10n-id", AltText.#l10nNewButton.missing);
              label.setAttribute("data-l10n-id", AltText.#l10nNewButton["missing-label"]);
            } else {
              altText.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button");
              label.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label");
            }
            const signal = this.#editor._uiManager._signal;
            altText.addEventListener("contextmenu", noContextMenu, {
              signal
            });
            altText.addEventListener("pointerdown", event => event.stopPropagation(), {
              signal
            });
            const onClick = event => {
              event.preventDefault();
              this.#editor._uiManager.editAltText(this.#editor);
              if (this.#useNewAltTextFlow) {
                this.#editor._reportTelemetry({
                  action: "pdfjs.image.alt_text.image_status_label_clicked",
                  data: {
                    label: this.#label
                  }
                });
              }
            };
            altText.addEventListener("click", onClick, {
              capture: true,
              signal
            });
            altText.addEventListener("keydown", event => {
              if (event.target === altText && event.key === "Enter") {
                this.#altTextWasFromKeyBoard = true;
                onClick(event);
              }
            }, {
              signal
            });
            await this.#setState();
            return altText;
          }
          get #label() {
            return this.#altText && "added" || this.#altText === null && this.guessedText && "review" || "missing";
          }
          finish() {
            if (!this.#altTextButton) {
              return;
            }
            this.#altTextButton.focus({
              focusVisible: this.#altTextWasFromKeyBoard
            });
            this.#altTextWasFromKeyBoard = false;
          }
          isEmpty() {
            if (this.#useNewAltTextFlow) {
              return this.#altText === null;
            }
            return !this.#altText && !this.#altTextDecorative;
          }
          hasData() {
            if (this.#useNewAltTextFlow) {
              return this.#altText !== null || !!this.#guessedText;
            }
            return this.isEmpty();
          }
          get guessedText() {
            return this.#guessedText;
          }
          async setGuessedText(guessedText) {
            if (this.#altText !== null) {
              return;
            }
            this.#guessedText = guessedText;
            this.#textWithDisclaimer = await AltText._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", {
              generatedAltText: guessedText
            });
            this.#setState();
          }
          toggleAltTextBadge(visibility = false) {
            if (!this.#useNewAltTextFlow || this.#altText) {
              this.#badge?.remove();
              this.#badge = null;
              return;
            }
            if (!this.#badge) {
              const badge = this.#badge = document.createElement("div");
              badge.className = "noAltTextBadge";
              this.#editor.div.append(badge);
            }
            this.#badge.classList.toggle("hidden", !visibility);
          }
          serialize(isForCopying) {
            let altText = this.#altText;
            if (!isForCopying && this.#guessedText === altText) {
              altText = this.#textWithDisclaimer;
            }
            return {
              altText,
              decorative: this.#altTextDecorative,
              guessedText: this.#guessedText,
              textWithDisclaimer: this.#textWithDisclaimer
            };
          }
          get data() {
            return {
              altText: this.#altText,
              decorative: this.#altTextDecorative
            };
          }
          set data({
            altText,
            decorative,
            guessedText,
            textWithDisclaimer,
            cancel = false
          }) {
            if (guessedText) {
              this.#guessedText = guessedText;
              this.#textWithDisclaimer = textWithDisclaimer;
            }
            if (this.#altText === altText && this.#altTextDecorative === decorative) {
              return;
            }
            if (!cancel) {
              this.#altText = altText;
              this.#altTextDecorative = decorative;
            }
            this.#setState();
          }
          toggle(enabled = false) {
            if (!this.#altTextButton) {
              return;
            }
            if (!enabled && this.#altTextTooltipTimeout) {
              clearTimeout(this.#altTextTooltipTimeout);
              this.#altTextTooltipTimeout = null;
            }
            this.#altTextButton.disabled = !enabled;
          }
          shown() {
            this.#editor._reportTelemetry({
              action: "pdfjs.image.alt_text.image_status_label_displayed",
              data: {
                label: this.#label
              }
            });
          }
          destroy() {
            this.#altTextButton?.remove();
            this.#altTextButton = null;
            this.#altTextButtonLabel = null;
            this.#altTextTooltip = null;
            this.#badge?.remove();
            this.#badge = null;
          }
          async #setState() {
            const button = this.#altTextButton;
            if (!button) {
              return;
            }
            if (this.#useNewAltTextFlow) {
              button.classList.toggle("done", !!this.#altText);
              button.setAttribute("data-l10n-id", AltText.#l10nNewButton[this.#label]);
              this.#altTextButtonLabel?.setAttribute("data-l10n-id", AltText.#l10nNewButton[`${this.#label}-label`]);
              if (!this.#altText) {
                this.#altTextTooltip?.remove();
                return;
              }
            } else {
              if (!this.#altText && !this.#altTextDecorative) {
                button.classList.remove("done");
                this.#altTextTooltip?.remove();
                return;
              }
              button.classList.add("done");
              button.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
            }
            let tooltip = this.#altTextTooltip;
            if (!tooltip) {
              this.#altTextTooltip = tooltip = document.createElement("span");
              tooltip.className = "tooltip";
              tooltip.setAttribute("role", "tooltip");
              tooltip.id = `alt-text-tooltip-${this.#editor.id}`;
              const DELAY_TO_SHOW_TOOLTIP = 100;
              const signal = this.#editor._uiManager._signal;
              signal.addEventListener("abort", () => {
                clearTimeout(this.#altTextTooltipTimeout);
                this.#altTextTooltipTimeout = null;
              }, {
                once: true
              });
              button.addEventListener("mouseenter", () => {
                this.#altTextTooltipTimeout = setTimeout(() => {
                  this.#altTextTooltipTimeout = null;
                  this.#altTextTooltip.classList.add("show");
                  this.#editor._reportTelemetry({
                    action: "alt_text_tooltip"
                  });
                }, DELAY_TO_SHOW_TOOLTIP);
              }, {
                signal
              });
              button.addEventListener("mouseleave", () => {
                if (this.#altTextTooltipTimeout) {
                  clearTimeout(this.#altTextTooltipTimeout);
                  this.#altTextTooltipTimeout = null;
                }
                this.#altTextTooltip?.classList.remove("show");
              }, {
                signal
              });
            }
            if (this.#altTextDecorative) {
              tooltip.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip");
            } else {
              tooltip.removeAttribute("data-l10n-id");
              tooltip.textContent = this.#altText;
            }
            if (!tooltip.parentNode) {
              button.append(tooltip);
            }
            const element = this.#editor.getElementForAltText();
            element?.setAttribute("aria-describedby", tooltip.id);
          }
        }

        ;// ./src/display/editor/comment.js

        class Comment {
          #commentStandaloneButton = null;
          #commentToolbarButton = null;
          #commentWasFromKeyBoard = false;
          #editor = null;
          #initialText = null;
          #richText = null;
          #text = null;
          #date = null;
          #deleted = false;
          #popupPosition = null;
          constructor(editor) {
            this.#editor = editor;
          }
          renderForToolbar() {
            const button = this.#commentToolbarButton = document.createElement("button");
            button.className = "comment";
            return this.#render(button, false);
          }
          renderForStandalone() {
            const button = this.#commentStandaloneButton = document.createElement("button");
            button.className = "annotationCommentButton";
            const position = this.#editor.commentButtonPosition;
            if (position) {
              const {
                style
              } = button;
              style.insetInlineEnd = `calc(${100 * (this.#editor._uiManager.direction === "ltr" ? 1 - position[0] : position[0])}% - var(--comment-button-dim))`;
              style.top = `calc(${100 * position[1]}% - var(--comment-button-dim))`;
              const color = this.#editor.commentButtonColor;
              if (color) {
                style.backgroundColor = color;
              }
            }
            return this.#render(button, true);
          }
          focusButton() {
            setTimeout(() => {
              (this.#commentStandaloneButton ?? this.#commentToolbarButton)?.focus();
            }, 0);
          }
          onUpdatedColor() {
            if (!this.#commentStandaloneButton) {
              return;
            }
            const color = this.#editor.commentButtonColor;
            if (color) {
              this.#commentStandaloneButton.style.backgroundColor = color;
            }
            this.#editor._uiManager.updatePopupColor(this.#editor);
          }
          get commentButtonWidth() {
            return (this.#commentStandaloneButton?.getBoundingClientRect().width ?? 0) / this.#editor.parent.boundingClientRect.width;
          }
          get commentPopupPositionInLayer() {
            if (this.#popupPosition) {
              return this.#popupPosition;
            }
            if (!this.#commentStandaloneButton) {
              return null;
            }
            const {
              x,
              y,
              height
            } = this.#commentStandaloneButton.getBoundingClientRect();
            const {
              x: parentX,
              y: parentY,
              width: parentWidth,
              height: parentHeight
            } = this.#editor.parent.boundingClientRect;
            return [(x - parentX) / parentWidth, (y + height - parentY) / parentHeight];
          }
          set commentPopupPositionInLayer(pos) {
            this.#popupPosition = pos;
          }
          hasDefaultPopupPosition() {
            return this.#popupPosition === null;
          }
          removeStandaloneCommentButton() {
            this.#commentStandaloneButton?.remove();
            this.#commentStandaloneButton = null;
          }
          removeToolbarCommentButton() {
            this.#commentToolbarButton?.remove();
            this.#commentToolbarButton = null;
          }
          setCommentButtonStates({
            selected,
            hasPopup
          }) {
            if (!this.#commentStandaloneButton) {
              return;
            }
            this.#commentStandaloneButton.classList.toggle("selected", selected);
            this.#commentStandaloneButton.ariaExpanded = hasPopup;
          }
          #render(comment, isStandalone) {
            if (!this.#editor._uiManager.hasCommentManager()) {
              return null;
            }
            comment.tabIndex = "0";
            comment.ariaHasPopup = "dialog";
            if (isStandalone) {
              comment.ariaControls = "commentPopup";
              comment.setAttribute("data-l10n-id", "pdfjs-show-comment-button");
            } else {
              comment.ariaControlsElements = [this.#editor._uiManager.getCommentDialogElement()];
              comment.setAttribute("data-l10n-id", "pdfjs-editor-add-comment-button");
            }
            const signal = this.#editor._uiManager._signal;
            if (!(signal instanceof AbortSignal) || signal.aborted) {
              return comment;
            }
            comment.addEventListener("contextmenu", noContextMenu, {
              signal
            });
            if (isStandalone) {
              comment.addEventListener("focusin", e => {
                this.#editor._focusEventsAllowed = false;
                stopEvent(e);
              }, {
                capture: true,
                signal
              });
              comment.addEventListener("focusout", e => {
                this.#editor._focusEventsAllowed = true;
                stopEvent(e);
              }, {
                capture: true,
                signal
              });
            }
            comment.addEventListener("pointerdown", event => event.stopPropagation(), {
              signal
            });
            const onClick = event => {
              event.preventDefault();
              if (comment === this.#commentToolbarButton) {
                this.edit();
              } else {
                this.#editor.toggleComment(true);
              }
            };
            comment.addEventListener("click", onClick, {
              capture: true,
              signal
            });
            comment.addEventListener("keydown", event => {
              if (event.target === comment && event.key === "Enter") {
                this.#commentWasFromKeyBoard = true;
                onClick(event);
              }
            }, {
              signal
            });
            comment.addEventListener("pointerenter", () => {
              this.#editor.toggleComment(false, true);
            }, {
              signal
            });
            comment.addEventListener("pointerleave", () => {
              this.#editor.toggleComment(false, false);
            }, {
              signal
            });
            return comment;
          }
          edit(options) {
            const position = this.commentPopupPositionInLayer;
            let posX, posY;
            if (position) {
              [posX, posY] = position;
            } else {
              [posX, posY] = this.#editor.commentButtonPosition;
              const {
                width,
                height,
                x,
                y
              } = this.#editor;
              posX = x + posX * width;
              posY = y + posY * height;
            }
            const parentDimensions = this.#editor.parent.boundingClientRect;
            const {
              x: parentX,
              y: parentY,
              width: parentWidth,
              height: parentHeight
            } = parentDimensions;
            this.#editor._uiManager.editComment(this.#editor, parentX + posX * parentWidth, parentY + posY * parentHeight, {
              ...options,
              parentDimensions
            });
          }
          finish() {
            if (!this.#commentToolbarButton) {
              return;
            }
            this.#commentToolbarButton.focus({
              focusVisible: this.#commentWasFromKeyBoard
            });
            this.#commentWasFromKeyBoard = false;
          }
          isDeleted() {
            return this.#deleted || this.#text === "";
          }
          isEmpty() {
            return this.#text === null;
          }
          hasBeenEdited() {
            return this.isDeleted() || this.#text !== this.#initialText;
          }
          serialize() {
            return this.data;
          }
          get data() {
            return {
              text: this.#text,
              richText: this.#richText,
              date: this.#date,
              deleted: this.isDeleted()
            };
          }
          set data(text) {
            if (text !== this.#text) {
              this.#richText = null;
            }
            if (text === null) {
              this.#text = "";
              this.#deleted = true;
              return;
            }
            this.#text = text;
            this.#date = new Date();
            this.#deleted = false;
          }
          setInitialText(text, richText = null) {
            this.#initialText = text;
            this.data = text;
            this.#date = null;
            this.#richText = richText;
          }
          shown() { }
          destroy() {
            this.#commentToolbarButton?.remove();
            this.#commentToolbarButton = null;
            this.#commentStandaloneButton?.remove();
            this.#commentStandaloneButton = null;
            this.#text = "";
            this.#richText = null;
            this.#date = null;
            this.#editor = null;
            this.#commentWasFromKeyBoard = false;
            this.#deleted = false;
          }
        }

        ;// ./src/display/touch_manager.js

        class TouchManager {
          #container;
          #isPinching = false;
          #isPinchingStopped = null;
          #isPinchingDisabled;
          #onPinchStart;
          #onPinching;
          #onPinchEnd;
          #pointerDownAC = null;
          #signal;
          #touchInfo = null;
          #touchManagerAC;
          #touchMoveAC = null;
          constructor({
            container,
            isPinchingDisabled = null,
            isPinchingStopped = null,
            onPinchStart = null,
            onPinching = null,
            onPinchEnd = null,
            signal
          }) {
            this.#container = container;
            this.#isPinchingStopped = isPinchingStopped;
            this.#isPinchingDisabled = isPinchingDisabled;
            this.#onPinchStart = onPinchStart;
            this.#onPinching = onPinching;
            this.#onPinchEnd = onPinchEnd;
            this.#touchManagerAC = new AbortController();
            this.#signal = AbortSignal.any([signal, this.#touchManagerAC.signal]);
            container.addEventListener("touchstart", this.#onTouchStart.bind(this), {
              passive: false,
              signal: this.#signal
            });
          }
          get MIN_TOUCH_DISTANCE_TO_PINCH() {
            return 35 / OutputScale.pixelRatio;
          }
          #onTouchStart(evt) {
            if (this.#isPinchingDisabled?.()) {
              return;
            }
            if (evt.touches.length === 1) {
              if (this.#pointerDownAC) {
                return;
              }
              const pointerDownAC = this.#pointerDownAC = new AbortController();
              const signal = AbortSignal.any([this.#signal, pointerDownAC.signal]);
              const container = this.#container;
              const opts = {
                capture: true,
                signal,
                passive: false
              };
              const cancelPointerDown = e => {
                if (e.pointerType === "touch") {
                  this.#pointerDownAC?.abort();
                  this.#pointerDownAC = null;
                }
              };
              container.addEventListener("pointerdown", e => {
                if (e.pointerType === "touch") {
                  stopEvent(e);
                  cancelPointerDown(e);
                }
              }, opts);
              container.addEventListener("pointerup", cancelPointerDown, opts);
              container.addEventListener("pointercancel", cancelPointerDown, opts);
              return;
            }
            if (!this.#touchMoveAC) {
              this.#touchMoveAC = new AbortController();
              const signal = AbortSignal.any([this.#signal, this.#touchMoveAC.signal]);
              const container = this.#container;
              const opt = {
                signal,
                capture: false,
                passive: false
              };
              container.addEventListener("touchmove", this.#onTouchMove.bind(this), opt);
              const onTouchEnd = this.#onTouchEnd.bind(this);
              container.addEventListener("touchend", onTouchEnd, opt);
              container.addEventListener("touchcancel", onTouchEnd, opt);
              opt.capture = true;
              container.addEventListener("pointerdown", stopEvent, opt);
              container.addEventListener("pointermove", stopEvent, opt);
              container.addEventListener("pointercancel", stopEvent, opt);
              container.addEventListener("pointerup", stopEvent, opt);
              this.#onPinchStart?.();
            }
            stopEvent(evt);
            if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {
              this.#touchInfo = null;
              return;
            }
            let [touch0, touch1] = evt.touches;
            if (touch0.identifier > touch1.identifier) {
              [touch0, touch1] = [touch1, touch0];
            }
            this.#touchInfo = {
              touch0X: touch0.screenX,
              touch0Y: touch0.screenY,
              touch1X: touch1.screenX,
              touch1Y: touch1.screenY
            };
          }
          #onTouchMove(evt) {
            if (!this.#touchInfo || evt.touches.length !== 2) {
              return;
            }
            stopEvent(evt);
            let [touch0, touch1] = evt.touches;
            if (touch0.identifier > touch1.identifier) {
              [touch0, touch1] = [touch1, touch0];
            }
            const {
              screenX: screen0X,
              screenY: screen0Y
            } = touch0;
            const {
              screenX: screen1X,
              screenY: screen1Y
            } = touch1;
            const touchInfo = this.#touchInfo;
            const {
              touch0X: pTouch0X,
              touch0Y: pTouch0Y,
              touch1X: pTouch1X,
              touch1Y: pTouch1Y
            } = touchInfo;
            const prevGapX = pTouch1X - pTouch0X;
            const prevGapY = pTouch1Y - pTouch0Y;
            const currGapX = screen1X - screen0X;
            const currGapY = screen1Y - screen0Y;
            const distance = Math.hypot(currGapX, currGapY) || 1;
            const pDistance = Math.hypot(prevGapX, prevGapY) || 1;
            if (!this.#isPinching && Math.abs(pDistance - distance) <= TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {
              return;
            }
            touchInfo.touch0X = screen0X;
            touchInfo.touch0Y = screen0Y;
            touchInfo.touch1X = screen1X;
            touchInfo.touch1Y = screen1Y;
            if (!this.#isPinching) {
              this.#isPinching = true;
              return;
            }
            const origin = [(screen0X + screen1X) / 2, (screen0Y + screen1Y) / 2];
            this.#onPinching?.(origin, pDistance, distance);
          }
          #onTouchEnd(evt) {
            if (evt.touches.length >= 2) {
              return;
            }
            if (this.#touchMoveAC) {
              this.#touchMoveAC.abort();
              this.#touchMoveAC = null;
              this.#onPinchEnd?.();
            }
            if (!this.#touchInfo) {
              return;
            }
            stopEvent(evt);
            this.#touchInfo = null;
            this.#isPinching = false;
          }
          destroy() {
            this.#touchManagerAC?.abort();
            this.#touchManagerAC = null;
            this.#pointerDownAC?.abort();
            this.#pointerDownAC = null;
          }
        }

        ;// ./src/display/editor/editor.js







        class AnnotationEditor {
          #accessibilityData = null;
          #allResizerDivs = null;
          #altText = null;
          #comment = null;
          #commentStandaloneButton = null;
          #disabled = false;
          #dragPointerId = null;
          #dragPointerType = "";
          #resizersDiv = null;
          #lastPointerCoords = null;
          #savedDimensions = null;
          #fakeAnnotation = null;
          #focusAC = null;
          #focusedResizerName = "";
          #hasBeenClicked = false;
          #initialRect = null;
          #isEditing = false;
          #isInEditMode = false;
          #isResizerEnabledForKeyboard = false;
          #moveInDOMTimeout = null;
          #prevDragX = 0;
          #prevDragY = 0;
          #telemetryTimeouts = null;
          #touchManager = null;
          isSelected = false;
          _isCopy = false;
          _editToolbar = null;
          _initialOptions = Object.create(null);
          _initialData = null;
          _isVisible = true;
          _uiManager = null;
          _focusEventsAllowed = true;
          static _l10n = null;
          static _l10nResizer = null;
          #isDraggable = false;
          #zIndex = AnnotationEditor._zIndex++;
          static _borderLineWidth = -1;
          static _colorManager = new ColorManager();
          static _zIndex = 1;
          static _telemetryTimeout = 1000;
          static get _resizerKeyboardManager() {
            const resize = AnnotationEditor.prototype._resizeWithKeyboard;
            const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
            const big = AnnotationEditorUIManager.TRANSLATE_BIG;
            return shadow(this, "_resizerKeyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], resize, {
              args: [-small, 0]
            }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], resize, {
              args: [-big, 0]
            }], [["ArrowRight", "mac+ArrowRight"], resize, {
              args: [small, 0]
            }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], resize, {
              args: [big, 0]
            }], [["ArrowUp", "mac+ArrowUp"], resize, {
              args: [0, -small]
            }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], resize, {
              args: [0, -big]
            }], [["ArrowDown", "mac+ArrowDown"], resize, {
              args: [0, small]
            }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], resize, {
              args: [0, big]
            }], [["Escape", "mac+Escape"], AnnotationEditor.prototype._stopResizingWithKeyboard]]));
          }
          constructor(parameters) {
            this.parent = parameters.parent;
            this.id = parameters.id;
            this.width = this.height = null;
            this.pageIndex = parameters.parent.pageIndex;
            this.name = parameters.name;
            this.div = null;
            this._uiManager = parameters.uiManager;
            this.annotationElementId = null;
            this._willKeepAspectRatio = false;
            this._initialOptions.isCentered = parameters.isCentered;
            this._structTreeParentId = null;
            this.annotationElementId = parameters.annotationElementId || null;
            this.creationDate = parameters.creationDate || new Date();
            this.modificationDate = parameters.modificationDate || null;
            this.canAddComment = true;
            const {
              rotation,
              rawDims: {
                pageWidth,
                pageHeight,
                pageX,
                pageY
              }
            } = this.parent.viewport;
            this.rotation = rotation;
            this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
            this.pageDimensions = [pageWidth, pageHeight];
            this.pageTranslation = [pageX, pageY];
            const [width, height] = this.parentDimensions;
            this.x = parameters.x / width;
            this.y = parameters.y / height;
            this.isAttachedToDOM = false;
            this.deleted = false;
          }
          get editorType() {
            return Object.getPrototypeOf(this).constructor._type;
          }
          get mode() {
            return Object.getPrototypeOf(this).constructor._editorType;
          }
          static get isDrawer() {
            return false;
          }
          static get _defaultLineColor() {
            return shadow(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
          }
          static deleteAnnotationElement(editor) {
            const fakeEditor = new FakeEditor({
              id: editor.parent.getNextId(),
              parent: editor.parent,
              uiManager: editor._uiManager
            });
            fakeEditor.annotationElementId = editor.annotationElementId;
            fakeEditor.deleted = true;
            fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
          }
          static initialize(l10n, _uiManager) {
            AnnotationEditor._l10n ??= l10n;
            AnnotationEditor._l10nResizer ||= Object.freeze({
              topLeft: "pdfjs-editor-resizer-top-left",
              topMiddle: "pdfjs-editor-resizer-top-middle",
              topRight: "pdfjs-editor-resizer-top-right",
              middleRight: "pdfjs-editor-resizer-middle-right",
              bottomRight: "pdfjs-editor-resizer-bottom-right",
              bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
              bottomLeft: "pdfjs-editor-resizer-bottom-left",
              middleLeft: "pdfjs-editor-resizer-middle-left"
            });
            if (AnnotationEditor._borderLineWidth !== -1) {
              return;
            }
            const style = getComputedStyle(document.documentElement);
            AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue("--outline-width")) || 0;
          }
          static updateDefaultParams(_type, _value) { }
          static get defaultPropertiesToUpdate() {
            return [];
          }
          static isHandlingMimeForPasting(mime) {
            return false;
          }
          static paste(item, parent) {
            unreachable("Not implemented");
          }
          get propertiesToUpdate() {
            return [];
          }
          get _isDraggable() {
            return this.#isDraggable;
          }
          set _isDraggable(value) {
            this.#isDraggable = value;
            this.div?.classList.toggle("draggable", value);
          }
          get uid() {
            return this.annotationElementId || this.id;
          }
          get isEnterHandled() {
            return true;
          }
          center() {
            const [pageWidth, pageHeight] = this.pageDimensions;
            switch (this.parentRotation) {
              case 90:
                this.x -= this.height * pageHeight / (pageWidth * 2);
                this.y += this.width * pageWidth / (pageHeight * 2);
                break;
              case 180:
                this.x += this.width / 2;
                this.y += this.height / 2;
                break;
              case 270:
                this.x += this.height * pageHeight / (pageWidth * 2);
                this.y -= this.width * pageWidth / (pageHeight * 2);
                break;
              default:
                this.x -= this.width / 2;
                this.y -= this.height / 2;
                break;
            }
            this.fixAndSetPosition();
          }
          addCommands(params) {
            this._uiManager.addCommands(params);
          }
          get currentLayer() {
            return this._uiManager.currentLayer;
          }
          setInBackground() {
            this.div.style.zIndex = 0;
          }
          setInForeground() {
            this.div.style.zIndex = this.#zIndex;
          }
          setParent(parent) {
            if (parent !== null) {
              this.pageIndex = parent.pageIndex;
              this.pageDimensions = parent.pageDimensions;
            } else {
              this.#stopResizing();
              this.#fakeAnnotation?.remove();
              this.#fakeAnnotation = null;
            }
            this.parent = parent;
          }
          focusin(event) {
            if (!this._focusEventsAllowed) {
              return;
            }
            if (!this.#hasBeenClicked) {
              this.parent.setSelected(this);
            } else {
              this.#hasBeenClicked = false;
            }
          }
          focusout(event) {
            if (!this._focusEventsAllowed) {
              return;
            }
            if (!this.isAttachedToDOM) {
              return;
            }
            const target = event.relatedTarget;
            if (target?.closest(`#${this.id}`)) {
              return;
            }
            event.preventDefault();
            if (!this.parent?.isMultipleSelection) {
              this.commitOrRemove();
            }
          }
          commitOrRemove() {
            if (this.isEmpty()) {
              this.remove();
            } else {
              this.commit();
            }
          }
          commit() {
            if (!this.isInEditMode()) {
              return;
            }
            this.addToAnnotationStorage();
          }
          addToAnnotationStorage() {
            this._uiManager.addToAnnotationStorage(this);
          }
          setAt(x, y, tx, ty) {
            const [width, height] = this.parentDimensions;
            [tx, ty] = this.screenToPageTranslation(tx, ty);
            this.x = (x + tx) / width;
            this.y = (y + ty) / height;
            this.fixAndSetPosition();
          }
          _moveAfterPaste(baseX, baseY) {
            const [parentWidth, parentHeight] = this.parentDimensions;
            this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
            this._onTranslated();
          }
          #translate([width, height], x, y) {
            [x, y] = this.screenToPageTranslation(x, y);
            this.x += x / width;
            this.y += y / height;
            this._onTranslating(this.x, this.y);
            this.fixAndSetPosition();
          }
          translate(x, y) {
            this.#translate(this.parentDimensions, x, y);
          }
          translateInPage(x, y) {
            this.#initialRect ||= [this.x, this.y, this.width, this.height];
            this.#translate(this.pageDimensions, x, y);
            this.div.scrollIntoView({
              block: "nearest"
            });
          }
          translationDone() {
            this._onTranslated(this.x, this.y);
          }
          drag(tx, ty) {
            this.#initialRect ||= [this.x, this.y, this.width, this.height];
            const {
              div,
              parentDimensions: [parentWidth, parentHeight]
            } = this;
            this.x += tx / parentWidth;
            this.y += ty / parentHeight;
            if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
              const {
                x,
                y
              } = this.div.getBoundingClientRect();
              if (this.parent.findNewParent(this, x, y)) {
                this.x -= Math.floor(this.x);
                this.y -= Math.floor(this.y);
              }
            }
            let {
              x,
              y
            } = this;
            const [bx, by] = this.getBaseTranslation();
            x += bx;
            y += by;
            const {
              style
            } = div;
            style.left = `${(100 * x).toFixed(2)}%`;
            style.top = `${(100 * y).toFixed(2)}%`;
            this._onTranslating(x, y);
            div.scrollIntoView({
              block: "nearest"
            });
          }
          _onTranslating(x, y) { }
          _onTranslated(x, y) { }
          get _hasBeenMoved() {
            return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);
          }
          get _hasBeenResized() {
            return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);
          }
          getBaseTranslation() {
            const [parentWidth, parentHeight] = this.parentDimensions;
            const {
              _borderLineWidth
            } = AnnotationEditor;
            const x = _borderLineWidth / parentWidth;
            const y = _borderLineWidth / parentHeight;
            switch (this.rotation) {
              case 90:
                return [-x, y];
              case 180:
                return [x, y];
              case 270:
                return [x, -y];
              default:
                return [-x, -y];
            }
          }
          get _mustFixPosition() {
            return true;
          }
          fixAndSetPosition(rotation = this.rotation) {
            const {
              div: {
                style
              },
              pageDimensions: [pageWidth, pageHeight]
            } = this;
            let {
              x,
              y,
              width,
              height
            } = this;
            width *= pageWidth;
            height *= pageHeight;
            x *= pageWidth;
            y *= pageHeight;
            if (this._mustFixPosition) {
              switch (rotation) {
                case 0:
                  x = MathClamp(x, 0, pageWidth - width);
                  y = MathClamp(y, 0, pageHeight - height);
                  break;
                case 90:
                  x = MathClamp(x, 0, pageWidth - height);
                  y = MathClamp(y, width, pageHeight);
                  break;
                case 180:
                  x = MathClamp(x, width, pageWidth);
                  y = MathClamp(y, height, pageHeight);
                  break;
                case 270:
                  x = MathClamp(x, height, pageWidth);
                  y = MathClamp(y, 0, pageHeight - width);
                  break;
              }
            }
            this.x = x /= pageWidth;
            this.y = y /= pageHeight;
            const [bx, by] = this.getBaseTranslation();
            x += bx;
            y += by;
            style.left = `${(100 * x).toFixed(2)}%`;
            style.top = `${(100 * y).toFixed(2)}%`;
            this.moveInDOM();
          }
          static #rotatePoint(x, y, angle) {
            switch (angle) {
              case 90:
                return [y, -x];
              case 180:
                return [-x, -y];
              case 270:
                return [-y, x];
              default:
                return [x, y];
            }
          }
          screenToPageTranslation(x, y) {
            return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);
          }
          pageTranslationToScreen(x, y) {
            return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);
          }
          #getRotationMatrix(rotation) {
            switch (rotation) {
              case 90:
                {
                  const [pageWidth, pageHeight] = this.pageDimensions;
                  return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
                }
              case 180:
                return [-1, 0, 0, -1];
              case 270:
                {
                  const [pageWidth, pageHeight] = this.pageDimensions;
                  return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];
                }
              default:
                return [1, 0, 0, 1];
            }
          }
          get parentScale() {
            return this._uiManager.viewParameters.realScale;
          }
          get parentRotation() {
            return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
          }
          get parentDimensions() {
            const {
              parentScale,
              pageDimensions: [pageWidth, pageHeight]
            } = this;
            return [pageWidth * parentScale, pageHeight * parentScale];
          }
          setDims() {
            const {
              div: {
                style
              },
              width,
              height
            } = this;
            style.width = `${(100 * width).toFixed(2)}%`;
            style.height = `${(100 * height).toFixed(2)}%`;
          }
          getInitialTranslation() {
            return [0, 0];
          }
          #createResizers() {
            if (this.#resizersDiv) {
              return;
            }
            this.#resizersDiv = document.createElement("div");
            this.#resizersDiv.classList.add("resizers");
            const classes = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"];
            const signal = this._uiManager._signal;
            for (const name of classes) {
              const div = document.createElement("div");
              this.#resizersDiv.append(div);
              div.classList.add("resizer", name);
              div.setAttribute("data-resizer-name", name);
              div.addEventListener("pointerdown", this.#resizerPointerdown.bind(this, name), {
                signal
              });
              div.addEventListener("contextmenu", noContextMenu, {
                signal
              });
              div.tabIndex = -1;
            }
            this.div.prepend(this.#resizersDiv);
          }
          #resizerPointerdown(name, event) {
            event.preventDefault();
            const {
              isMac
            } = util_FeatureTest.platform;
            if (event.button !== 0 || event.ctrlKey && isMac) {
              return;
            }
            this.#altText?.toggle(false);
            const savedDraggable = this._isDraggable;
            this._isDraggable = false;
            this.#lastPointerCoords = [event.screenX, event.screenY];
            const ac = new AbortController();
            const signal = this._uiManager.combinedSignal(ac);
            this.parent.togglePointerEvents(false);
            window.addEventListener("pointermove", this.#resizerPointermove.bind(this, name), {
              passive: true,
              capture: true,
              signal
            });
            window.addEventListener("touchmove", stopEvent, {
              passive: false,
              signal
            });
            window.addEventListener("contextmenu", noContextMenu, {
              signal
            });
            this.#savedDimensions = {
              savedX: this.x,
              savedY: this.y,
              savedWidth: this.width,
              savedHeight: this.height
            };
            const savedParentCursor = this.parent.div.style.cursor;
            const savedCursor = this.div.style.cursor;
            this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;
            const pointerUpCallback = () => {
              ac.abort();
              this.parent.togglePointerEvents(true);
              this.#altText?.toggle(true);
              this._isDraggable = savedDraggable;
              this.parent.div.style.cursor = savedParentCursor;
              this.div.style.cursor = savedCursor;
              this.#addResizeToUndoStack();
            };
            window.addEventListener("pointerup", pointerUpCallback, {
              signal
            });
            window.addEventListener("blur", pointerUpCallback, {
              signal
            });
          }
          #resize(x, y, width, height) {
            this.width = width;
            this.height = height;
            this.x = x;
            this.y = y;
            this.setDims();
            this.fixAndSetPosition();
            this._onResized();
          }
          _onResized() { }
          #addResizeToUndoStack() {
            if (!this.#savedDimensions) {
              return;
            }
            const {
              savedX,
              savedY,
              savedWidth,
              savedHeight
            } = this.#savedDimensions;
            this.#savedDimensions = null;
            const newX = this.x;
            const newY = this.y;
            const newWidth = this.width;
            const newHeight = this.height;
            if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {
              return;
            }
            this.addCommands({
              cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),
              undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),
              mustExec: true
            });
          }
          static _round(x) {
            return Math.round(x * 10000) / 10000;
          }
          #resizerPointermove(name, event) {
            const [parentWidth, parentHeight] = this.parentDimensions;
            const savedX = this.x;
            const savedY = this.y;
            const savedWidth = this.width;
            const savedHeight = this.height;
            const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;
            const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;
            const rotationMatrix = this.#getRotationMatrix(this.rotation);
            const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];
            const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);
            const invTransf = (x, y) => [invRotationMatrix[0] * x + invRotationMatrix[2] * y, invRotationMatrix[1] * x + invRotationMatrix[3] * y];
            let getPoint;
            let getOpposite;
            let isDiagonal = false;
            let isHorizontal = false;
            switch (name) {
              case "topLeft":
                isDiagonal = true;
                getPoint = (w, h) => [0, 0];
                getOpposite = (w, h) => [w, h];
                break;
              case "topMiddle":
                getPoint = (w, h) => [w / 2, 0];
                getOpposite = (w, h) => [w / 2, h];
                break;
              case "topRight":
                isDiagonal = true;
                getPoint = (w, h) => [w, 0];
                getOpposite = (w, h) => [0, h];
                break;
              case "middleRight":
                isHorizontal = true;
                getPoint = (w, h) => [w, h / 2];
                getOpposite = (w, h) => [0, h / 2];
                break;
              case "bottomRight":
                isDiagonal = true;
                getPoint = (w, h) => [w, h];
                getOpposite = (w, h) => [0, 0];
                break;
              case "bottomMiddle":
                getPoint = (w, h) => [w / 2, h];
                getOpposite = (w, h) => [w / 2, 0];
                break;
              case "bottomLeft":
                isDiagonal = true;
                getPoint = (w, h) => [0, h];
                getOpposite = (w, h) => [w, 0];
                break;
              case "middleLeft":
                isHorizontal = true;
                getPoint = (w, h) => [0, h / 2];
                getOpposite = (w, h) => [w, h / 2];
                break;
            }
            const point = getPoint(savedWidth, savedHeight);
            const oppositePoint = getOpposite(savedWidth, savedHeight);
            let transfOppositePoint = transf(...oppositePoint);
            const oppositeX = AnnotationEditor._round(savedX + transfOppositePoint[0]);
            const oppositeY = AnnotationEditor._round(savedY + transfOppositePoint[1]);
            let ratioX = 1;
            let ratioY = 1;
            let deltaX, deltaY;
            if (!event.fromKeyboard) {
              const {
                screenX,
                screenY
              } = event;
              const [lastScreenX, lastScreenY] = this.#lastPointerCoords;
              [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);
              this.#lastPointerCoords[0] = screenX;
              this.#lastPointerCoords[1] = screenY;
            } else {
              ({
                deltaX,
                deltaY
              } = event);
            }
            [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
            if (isDiagonal) {
              const oldDiag = Math.hypot(savedWidth, savedHeight);
              ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
            } else if (isHorizontal) {
              ratioX = MathClamp(Math.abs(oppositePoint[0] - point[0] - deltaX), minWidth, 1) / savedWidth;
            } else {
              ratioY = MathClamp(Math.abs(oppositePoint[1] - point[1] - deltaY), minHeight, 1) / savedHeight;
            }
            const newWidth = AnnotationEditor._round(savedWidth * ratioX);
            const newHeight = AnnotationEditor._round(savedHeight * ratioY);
            transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
            const newX = oppositeX - transfOppositePoint[0];
            const newY = oppositeY - transfOppositePoint[1];
            this.#initialRect ||= [this.x, this.y, this.width, this.height];
            this.width = newWidth;
            this.height = newHeight;
            this.x = newX;
            this.y = newY;
            this.setDims();
            this.fixAndSetPosition();
            this._onResizing();
          }
          _onResizing() { }
          altTextFinish() {
            this.#altText?.finish();
          }
          get toolbarButtons() {
            return null;
          }
          async addEditToolbar() {
            if (this._editToolbar || this.#isInEditMode) {
              return this._editToolbar;
            }
            this._editToolbar = new EditorToolbar(this);
            this.div.append(this._editToolbar.render());
            const {
              toolbarButtons
            } = this;
            if (toolbarButtons) {
              for (const [name, tool] of toolbarButtons) {
                await this._editToolbar.addButton(name, tool);
              }
            }
            if (!this.hasComment) {
              this._editToolbar.addButton("comment", this.addCommentButton());
            }
            this._editToolbar.addButton("delete");
            return this._editToolbar;
          }
          addCommentButtonInToolbar() {
            this._editToolbar?.addButtonBefore("comment", this.addCommentButton(), ".deleteButton");
          }
          removeCommentButtonFromToolbar() {
            this._editToolbar?.removeButton("comment");
          }
          removeEditToolbar() {
            this._editToolbar?.remove();
            this._editToolbar = null;
            this.#altText?.destroy();
          }
          addContainer(container) {
            const editToolbarDiv = this._editToolbar?.div;
            if (editToolbarDiv) {
              editToolbarDiv.before(container);
            } else {
              this.div.append(container);
            }
          }
          getClientDimensions() {
            return this.div.getBoundingClientRect();
          }
          createAltText() {
            if (!this.#altText) {
              AltText.initialize(AnnotationEditor._l10n);
              this.#altText = new AltText(this);
              if (this.#accessibilityData) {
                this.#altText.data = this.#accessibilityData;
                this.#accessibilityData = null;
              }
            }
            return this.#altText;
          }
          get altTextData() {
            return this.#altText?.data;
          }
          set altTextData(data) {
            if (!this.#altText) {
              return;
            }
            this.#altText.data = data;
          }
          get guessedAltText() {
            return this.#altText?.guessedText;
          }
          async setGuessedAltText(text) {
            await this.#altText?.setGuessedText(text);
          }
          serializeAltText(isForCopying) {
            return this.#altText?.serialize(isForCopying);
          }
          hasAltText() {
            return !!this.#altText && !this.#altText.isEmpty();
          }
          hasAltTextData() {
            return this.#altText?.hasData() ?? false;
          }
          focusCommentButton() {
            this.#comment?.focusButton();
          }
          addCommentButton() {
            return this.canAddComment ? this.#comment ||= new Comment(this) : null;
          }
          addStandaloneCommentButton() {
            if (!this._uiManager.hasCommentManager()) {
              return;
            }
            if (this.#commentStandaloneButton) {
              if (this._uiManager.isEditingMode()) {
                this.#commentStandaloneButton.classList.remove("hidden");
              }
              return;
            }
            if (!this.hasComment) {
              return;
            }
            this.#commentStandaloneButton = this.#comment.renderForStandalone();
            this.div.append(this.#commentStandaloneButton);
          }
          removeStandaloneCommentButton() {
            this.#comment.removeStandaloneCommentButton();
            this.#commentStandaloneButton = null;
          }
          hideStandaloneCommentButton() {
            this.#commentStandaloneButton?.classList.add("hidden");
          }
          get comment() {
            const {
              data: {
                richText,
                text,
                date,
                deleted
              }
            } = this.#comment;
            return {
              text,
              richText,
              date,
              deleted,
              color: this.getNonHCMColor(),
              opacity: this.opacity ?? 1
            };
          }
          set comment(text) {
            this.#comment ||= new Comment(this);
            this.#comment.data = text;
            if (this.hasComment) {
              this.removeCommentButtonFromToolbar();
              this.addStandaloneCommentButton();
              this._uiManager.updateComment(this);
            } else {
              this.addCommentButtonInToolbar();
              this.removeStandaloneCommentButton();
              this._uiManager.removeComment(this);
            }
          }
          setCommentData({
            comment,
            popupRef,
            richText
          }) {
            if (!popupRef) {
              return;
            }
            this.#comment ||= new Comment(this);
            this.#comment.setInitialText(comment, richText);
            if (!this.annotationElementId) {
              return;
            }
            const storedData = this._uiManager.getAndRemoveDataFromAnnotationStorage(this.annotationElementId);
            if (storedData) {
              this.updateFromAnnotationLayer(storedData);
            }
          }
          get hasEditedComment() {
            return this.#comment?.hasBeenEdited();
          }
          get hasDeletedComment() {
            return this.#comment?.isDeleted();
          }
          get hasComment() {
            return !!this.#comment && !this.#comment.isEmpty() && !this.#comment.isDeleted();
          }
          async editComment(options) {
            this.#comment ||= new Comment(this);
            this.#comment.edit(options);
          }
          toggleComment(isSelected, visibility = undefined) {
            if (this.hasComment) {
              this._uiManager.toggleComment(this, isSelected, visibility);
            }
          }
          setSelectedCommentButton(selected) {
            this.#comment.setSelectedButton(selected);
          }
          addComment(serialized) {
            if (this.hasEditedComment) {
              const DEFAULT_POPUP_WIDTH = 180;
              const DEFAULT_POPUP_HEIGHT = 100;
              const [, , , trY] = serialized.rect;
              const [pageWidth] = this.pageDimensions;
              const [pageX] = this.pageTranslation;
              const blX = pageX + pageWidth + 1;
              const blY = trY - DEFAULT_POPUP_HEIGHT;
              const trX = blX + DEFAULT_POPUP_WIDTH;
              serialized.popup = {
                contents: this.comment.text,
                deleted: this.comment.deleted,
                rect: [blX, blY, trX, trY]
              };
            }
          }
          updateFromAnnotationLayer({
            popup: {
              contents,
              deleted
            }
          }) {
            this.#comment.data = deleted ? null : contents;
          }
          get parentBoundingClientRect() {
            return this.parent.boundingClientRect;
          }
          render() {
            const div = this.div = document.createElement("div");
            div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
            div.className = this.name;
            div.setAttribute("id", this.id);
            div.tabIndex = this.#disabled ? -1 : 0;
            div.setAttribute("role", "application");
            if (this.defaultL10nId) {
              div.setAttribute("data-l10n-id", this.defaultL10nId);
            }
            if (!this._isVisible) {
              div.classList.add("hidden");
            }
            this.setInForeground();
            this.#addFocusListeners();
            const [parentWidth, parentHeight] = this.parentDimensions;
            if (this.parentRotation % 180 !== 0) {
              div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;
              div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;
            }
            const [tx, ty] = this.getInitialTranslation();
            this.translate(tx, ty);
            bindEvents(this, div, ["keydown", "pointerdown", "dblclick"]);
            if (this.isResizable && this._uiManager._supportsPinchToZoom) {
              this.#touchManager ||= new TouchManager({
                container: div,
                isPinchingDisabled: () => !this.isSelected,
                onPinchStart: this.#touchPinchStartCallback.bind(this),
                onPinching: this.#touchPinchCallback.bind(this),
                onPinchEnd: this.#touchPinchEndCallback.bind(this),
                signal: this._uiManager._signal
              });
            }
            this.addStandaloneCommentButton();
            this._uiManager._editorUndoBar?.hide();
            return div;
          }
          #touchPinchStartCallback() {
            this.#savedDimensions = {
              savedX: this.x,
              savedY: this.y,
              savedWidth: this.width,
              savedHeight: this.height
            };
            this.#altText?.toggle(false);
            this.parent.togglePointerEvents(false);
          }
          #touchPinchCallback(_origin, prevDistance, distance) {
            const slowDownFactor = 0.7;
            let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;
            if (factor === 1) {
              return;
            }
            const rotationMatrix = this.#getRotationMatrix(this.rotation);
            const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];
            const [parentWidth, parentHeight] = this.parentDimensions;
            const savedX = this.x;
            const savedY = this.y;
            const savedWidth = this.width;
            const savedHeight = this.height;
            const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;
            const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;
            factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
            const newWidth = AnnotationEditor._round(savedWidth * factor);
            const newHeight = AnnotationEditor._round(savedHeight * factor);
            if (newWidth === savedWidth && newHeight === savedHeight) {
              return;
            }
            this.#initialRect ||= [savedX, savedY, savedWidth, savedHeight];
            const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);
            const centerX = AnnotationEditor._round(savedX + transfCenterPoint[0]);
            const centerY = AnnotationEditor._round(savedY + transfCenterPoint[1]);
            const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);
            this.x = centerX - newTransfCenterPoint[0];
            this.y = centerY - newTransfCenterPoint[1];
            this.width = newWidth;
            this.height = newHeight;
            this.setDims();
            this.fixAndSetPosition();
            this._onResizing();
          }
          #touchPinchEndCallback() {
            this.#altText?.toggle(true);
            this.parent.togglePointerEvents(true);
            this.#addResizeToUndoStack();
          }
          pointerdown(event) {
            const {
              isMac
            } = util_FeatureTest.platform;
            if (event.button !== 0 || event.ctrlKey && isMac) {
              event.preventDefault();
              return;
            }
            this.#hasBeenClicked = true;
            if (this._isDraggable) {
              this.#setUpDragSession(event);
              return;
            }
            this.#selectOnPointerEvent(event);
          }
          #selectOnPointerEvent(event) {
            const {
              isMac
            } = util_FeatureTest.platform;
            if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
              this.parent.toggleSelected(this);
            } else {
              this.parent.setSelected(this);
            }
          }
          #setUpDragSession(event) {
            const {
              isSelected
            } = this;
            this._uiManager.setUpDragSession();
            let hasDraggingStarted = false;
            const ac = new AbortController();
            const signal = this._uiManager.combinedSignal(ac);
            const opts = {
              capture: true,
              passive: false,
              signal
            };
            const cancelDrag = e => {
              ac.abort();
              this.#dragPointerId = null;
              this.#hasBeenClicked = false;
              if (!this._uiManager.endDragSession()) {
                this.#selectOnPointerEvent(e);
              }
              if (hasDraggingStarted) {
                this._onStopDragging();
              }
            };
            if (isSelected) {
              this.#prevDragX = event.clientX;
              this.#prevDragY = event.clientY;
              this.#dragPointerId = event.pointerId;
              this.#dragPointerType = event.pointerType;
              window.addEventListener("pointermove", e => {
                if (!hasDraggingStarted) {
                  hasDraggingStarted = true;
                  this._uiManager.toggleComment(this, true, false);
                  this._onStartDragging();
                }
                const {
                  clientX: x,
                  clientY: y,
                  pointerId
                } = e;
                if (pointerId !== this.#dragPointerId) {
                  stopEvent(e);
                  return;
                }
                const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);
                this.#prevDragX = x;
                this.#prevDragY = y;
                this._uiManager.dragSelectedEditors(tx, ty);
              }, opts);
              window.addEventListener("touchmove", stopEvent, opts);
              window.addEventListener("pointerdown", e => {
                if (e.pointerType === this.#dragPointerType) {
                  if (this.#touchManager || e.isPrimary) {
                    cancelDrag(e);
                  }
                }
                stopEvent(e);
              }, opts);
            }
            const pointerUpCallback = e => {
              if (!this.#dragPointerId || this.#dragPointerId === e.pointerId) {
                cancelDrag(e);
                return;
              }
              stopEvent(e);
            };
            window.addEventListener("pointerup", pointerUpCallback, {
              signal
            });
            window.addEventListener("blur", pointerUpCallback, {
              signal
            });
          }
          _onStartDragging() { }
          _onStopDragging() { }
          moveInDOM() {
            if (this.#moveInDOMTimeout) {
              clearTimeout(this.#moveInDOMTimeout);
            }
            this.#moveInDOMTimeout = setTimeout(() => {
              this.#moveInDOMTimeout = null;
              this.parent?.moveEditorInDOM(this);
            }, 0);
          }
          _setParentAndPosition(parent, x, y) {
            parent.changeParent(this);
            this.x = x;
            this.y = y;
            this.fixAndSetPosition();
            this._onTranslated();
          }
          getRect(tx, ty, rotation = this.rotation) {
            const scale = this.parentScale;
            const [pageWidth, pageHeight] = this.pageDimensions;
            const [pageX, pageY] = this.pageTranslation;
            const shiftX = tx / scale;
            const shiftY = ty / scale;
            const x = this.x * pageWidth;
            const y = this.y * pageHeight;
            const width = this.width * pageWidth;
            const height = this.height * pageHeight;
            switch (rotation) {
              case 0:
                return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];
              case 90:
                return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];
              case 180:
                return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];
              case 270:
                return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];
              default:
                throw new Error("Invalid rotation");
            }
          }
          getRectInCurrentCoords(rect, pageHeight) {
            const [x1, y1, x2, y2] = rect;
            const width = x2 - x1;
            const height = y2 - y1;
            switch (this.rotation) {
              case 0:
                return [x1, pageHeight - y2, width, height];
              case 90:
                return [x1, pageHeight - y1, height, width];
              case 180:
                return [x2, pageHeight - y1, width, height];
              case 270:
                return [x2, pageHeight - y2, height, width];
              default:
                throw new Error("Invalid rotation");
            }
          }
          getPDFRect() {
            return this.getRect(0, 0);
          }
          getNonHCMColor() {
            return this.color && AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));
          }
          onUpdatedColor() {
            this.#comment?.onUpdatedColor();
          }
          getData() {
            const {
              comment: {
                text: str,
                color,
                date,
                opacity,
                deleted,
                richText
              },
              uid: id,
              pageIndex,
              creationDate,
              modificationDate
            } = this;
            return {
              id,
              pageIndex,
              rect: this.getPDFRect(),
              richText,
              contentsObj: {
                str
              },
              creationDate,
              modificationDate: date || modificationDate,
              popupRef: !deleted,
              color,
              opacity
            };
          }
          onceAdded(focus) { }
          isEmpty() {
            return false;
          }
          enableEditMode() {
            if (this.isInEditMode()) {
              return false;
            }
            this.parent.setEditingState(false);
            this.#isInEditMode = true;
            return true;
          }
          disableEditMode() {
            if (!this.isInEditMode()) {
              return false;
            }
            this.parent.setEditingState(true);
            this.#isInEditMode = false;
            return true;
          }
          isInEditMode() {
            return this.#isInEditMode;
          }
          shouldGetKeyboardEvents() {
            return this.#isResizerEnabledForKeyboard;
          }
          needsToBeRebuilt() {
            return this.div && !this.isAttachedToDOM;
          }
          get isOnScreen() {
            const {
              top,
              left,
              bottom,
              right
            } = this.getClientDimensions();
            const {
              innerHeight,
              innerWidth
            } = window;
            return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;
          }
          #addFocusListeners() {
            if (this.#focusAC || !this.div) {
              return;
            }
            this.#focusAC = new AbortController();
            const signal = this._uiManager.combinedSignal(this.#focusAC);
            this.div.addEventListener("focusin", this.focusin.bind(this), {
              signal
            });
            this.div.addEventListener("focusout", this.focusout.bind(this), {
              signal
            });
          }
          rebuild() {
            this.#addFocusListeners();
          }
          rotate(_angle) { }
          resize() { }
          serializeDeleted() {
            return {
              id: this.annotationElementId,
              deleted: true,
              pageIndex: this.pageIndex,
              popupRef: this._initialData?.popupRef || ""
            };
          }
          serialize(isForCopying = false, context = null) {
            return {
              annotationType: this.mode,
              pageIndex: this.pageIndex,
              rect: this.getPDFRect(),
              rotation: this.rotation,
              structTreeParentId: this._structTreeParentId,
              popupRef: this._initialData?.popupRef || ""
            };
          }
          static async deserialize(data, parent, uiManager) {
            const editor = new this.prototype.constructor({
              parent,
              id: parent.getNextId(),
              uiManager,
              annotationElementId: data.annotationElementId,
              creationDate: data.creationDate,
              modificationDate: data.modificationDate
            });
            editor.rotation = data.rotation;
            editor.#accessibilityData = data.accessibilityData;
            editor._isCopy = data.isCopy || false;
            const [pageWidth, pageHeight] = editor.pageDimensions;
            const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
            editor.x = x / pageWidth;
            editor.y = y / pageHeight;
            editor.width = width / pageWidth;
            editor.height = height / pageHeight;
            return editor;
          }
          get hasBeenModified() {
            return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
          }
          remove() {
            this.#focusAC?.abort();
            this.#focusAC = null;
            if (!this.isEmpty()) {
              this.commit();
            }
            if (this.parent) {
              this.parent.remove(this);
            } else {
              this._uiManager.removeEditor(this);
            }
            this.hideCommentPopup();
            if (this.#moveInDOMTimeout) {
              clearTimeout(this.#moveInDOMTimeout);
              this.#moveInDOMTimeout = null;
            }
            this.#stopResizing();
            this.removeEditToolbar();
            if (this.#telemetryTimeouts) {
              for (const timeout of this.#telemetryTimeouts.values()) {
                clearTimeout(timeout);
              }
              this.#telemetryTimeouts = null;
            }
            this.parent = null;
            this.#touchManager?.destroy();
            this.#touchManager = null;
            this.#fakeAnnotation?.remove();
            this.#fakeAnnotation = null;
          }
          get isResizable() {
            return false;
          }
          makeResizable() {
            if (this.isResizable) {
              this.#createResizers();
              this.#resizersDiv.classList.remove("hidden");
            }
          }
          get toolbarPosition() {
            return null;
          }
          get commentButtonPosition() {
            return this._uiManager.direction === "ltr" ? [1, 0] : [0, 0];
          }
          get commentButtonPositionInPage() {
            const {
              commentButtonPosition: [posX, posY]
            } = this;
            const [blX, blY, trX, trY] = this.getPDFRect();
            return [AnnotationEditor._round(blX + (trX - blX) * posX), AnnotationEditor._round(blY + (trY - blY) * (1 - posY))];
          }
          get commentButtonColor() {
            return this._uiManager.makeCommentColor(this.getNonHCMColor(), this.opacity);
          }
          get commentPopupPosition() {
            return this.#comment.commentPopupPositionInLayer;
          }
          set commentPopupPosition(pos) {
            this.#comment.commentPopupPositionInLayer = pos;
          }
          hasDefaultPopupPosition() {
            return this.#comment.hasDefaultPopupPosition();
          }
          get commentButtonWidth() {
            return this.#comment.commentButtonWidth;
          }
          get elementBeforePopup() {
            return this.div;
          }
          setCommentButtonStates(options) {
            this.#comment?.setCommentButtonStates(options);
          }
          keydown(event) {
            if (!this.isResizable || event.target !== this.div || event.key !== "Enter") {
              return;
            }
            this._uiManager.setSelected(this);
            this.#savedDimensions = {
              savedX: this.x,
              savedY: this.y,
              savedWidth: this.width,
              savedHeight: this.height
            };
            const children = this.#resizersDiv.children;
            if (!this.#allResizerDivs) {
              this.#allResizerDivs = Array.from(children);
              const boundResizerKeydown = this.#resizerKeydown.bind(this);
              const boundResizerBlur = this.#resizerBlur.bind(this);
              const signal = this._uiManager._signal;
              for (const div of this.#allResizerDivs) {
                const name = div.getAttribute("data-resizer-name");
                div.setAttribute("role", "spinbutton");
                div.addEventListener("keydown", boundResizerKeydown, {
                  signal
                });
                div.addEventListener("blur", boundResizerBlur, {
                  signal
                });
                div.addEventListener("focus", this.#resizerFocus.bind(this, name), {
                  signal
                });
                div.setAttribute("data-l10n-id", AnnotationEditor._l10nResizer[name]);
              }
            }
            const first = this.#allResizerDivs[0];
            let firstPosition = 0;
            for (const div of children) {
              if (div === first) {
                break;
              }
              firstPosition++;
            }
            const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);
            if (nextFirstPosition !== firstPosition) {
              if (nextFirstPosition < firstPosition) {
                for (let i = 0; i < firstPosition - nextFirstPosition; i++) {
                  this.#resizersDiv.append(this.#resizersDiv.firstChild);
                }
              } else if (nextFirstPosition > firstPosition) {
                for (let i = 0; i < nextFirstPosition - firstPosition; i++) {
                  this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);
                }
              }
              let i = 0;
              for (const child of children) {
                const div = this.#allResizerDivs[i++];
                const name = div.getAttribute("data-resizer-name");
                child.setAttribute("data-l10n-id", AnnotationEditor._l10nResizer[name]);
              }
            }
            this.#setResizerTabIndex(0);
            this.#isResizerEnabledForKeyboard = true;
            this.#resizersDiv.firstChild.focus({
              focusVisible: true
            });
            event.preventDefault();
            event.stopImmediatePropagation();
          }
          #resizerKeydown(event) {
            AnnotationEditor._resizerKeyboardManager.exec(this, event);
          }
          #resizerBlur(event) {
            if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {
              this.#stopResizing();
            }
          }
          #resizerFocus(name) {
            this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : "";
          }
          #setResizerTabIndex(value) {
            if (!this.#allResizerDivs) {
              return;
            }
            for (const div of this.#allResizerDivs) {
              div.tabIndex = value;
            }
          }
          _resizeWithKeyboard(x, y) {
            if (!this.#isResizerEnabledForKeyboard) {
              return;
            }
            this.#resizerPointermove(this.#focusedResizerName, {
              deltaX: x,
              deltaY: y,
              fromKeyboard: true
            });
          }
          #stopResizing() {
            this.#isResizerEnabledForKeyboard = false;
            this.#setResizerTabIndex(-1);
            this.#addResizeToUndoStack();
          }
          _stopResizingWithKeyboard() {
            this.#stopResizing();
            this.div.focus();
          }
          select() {
            if (this.isSelected && this._editToolbar) {
              this._editToolbar.show();
              return;
            }
            this.isSelected = true;
            this.makeResizable();
            this.div?.classList.add("selectedEditor");
            if (!this._editToolbar) {
              this.addEditToolbar().then(() => {
                if (this.div?.classList.contains("selectedEditor")) {
                  this._editToolbar?.show();
                }
              });
              return;
            }
            this._editToolbar?.show();
            this.#altText?.toggleAltTextBadge(false);
          }
          focus() {
            if (this.div && !this.div.contains(document.activeElement)) {
              setTimeout(() => this.div?.focus({
                preventScroll: true
              }), 0);
            }
          }
          unselect() {
            if (!this.isSelected) {
              return;
            }
            this.isSelected = false;
            this.#resizersDiv?.classList.add("hidden");
            this.div?.classList.remove("selectedEditor");
            if (this.div?.contains(document.activeElement)) {
              this._uiManager.currentLayer.div.focus({
                preventScroll: true
              });
            }
            this._editToolbar?.hide();
            this.#altText?.toggleAltTextBadge(true);
            this.hideCommentPopup();
          }
          hideCommentPopup() {
            if (this.hasComment) {
              this._uiManager.toggleComment(null);
            }
          }
          updateParams(type, value) { }
          disableEditing() { }
          enableEditing() { }
          get canChangeContent() {
            return false;
          }
          enterInEditMode() {
            if (!this.canChangeContent) {
              return;
            }
            this.enableEditMode();
            this.div.focus();
          }
          dblclick(event) {
            if (event.target.nodeName === "BUTTON") {
              return;
            }
            this.enterInEditMode();
            this.parent.updateToolbar({
              mode: this.constructor._editorType,
              editId: this.uid
            });
          }
          getElementForAltText() {
            return this.div;
          }
          get contentDiv() {
            return this.div;
          }
          get isEditing() {
            return this.#isEditing;
          }
          set isEditing(value) {
            this.#isEditing = value;
            if (!this.parent) {
              return;
            }
            if (value) {
              this.parent.setSelected(this);
              this.parent.setActiveEditor(this);
            } else {
              this.parent.setActiveEditor(null);
            }
          }
          static get MIN_SIZE() {
            return 16;
          }
          static canCreateNewEmptyEditor() {
            return true;
          }
          get telemetryInitialData() {
            return {
              action: "added"
            };
          }
          get telemetryFinalData() {
            return null;
          }
          _reportTelemetry(data, mustWait = false) {
            if (mustWait) {
              this.#telemetryTimeouts ||= new Map();
              const {
                action
              } = data;
              let timeout = this.#telemetryTimeouts.get(action);
              if (timeout) {
                clearTimeout(timeout);
              }
              timeout = setTimeout(() => {
                this._reportTelemetry(data);
                this.#telemetryTimeouts.delete(action);
                if (this.#telemetryTimeouts.size === 0) {
                  this.#telemetryTimeouts = null;
                }
              }, AnnotationEditor._telemetryTimeout);
              this.#telemetryTimeouts.set(action, timeout);
              return;
            }
            data.type ||= this.editorType;
            this._uiManager._eventBus.dispatch("reporttelemetry", {
              source: this,
              details: {
                type: "editing",
                data
              }
            });
          }
          show(visible = this._isVisible) {
            this.div.classList.toggle("hidden", !visible);
            this._isVisible = visible;
          }
          enable() {
            if (this.div) {
              this.div.tabIndex = 0;
            }
            this.#disabled = false;
          }
          disable() {
            if (this.div) {
              this.div.tabIndex = -1;
            }
            this.#disabled = true;
          }
          updateFakeAnnotationElement(annotationLayer) {
            if (!this.#fakeAnnotation && !this.deleted) {
              this.#fakeAnnotation = annotationLayer.addFakeAnnotation(this);
              return;
            }
            if (this.deleted) {
              this.#fakeAnnotation.remove();
              this.#fakeAnnotation = null;
              return;
            }
            if (this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized) {
              this.#fakeAnnotation.updateEdited({
                rect: this.getPDFRect(),
                popup: this.comment
              });
            }
          }
          renderAnnotationElement(annotation) {
            if (this.deleted) {
              annotation.hide();
              return null;
            }
            let content = annotation.container.querySelector(".annotationContent");
            if (!content) {
              content = document.createElement("div");
              content.classList.add("annotationContent", this.editorType);
              annotation.container.prepend(content);
            } else if (content.nodeName === "CANVAS") {
              const canvas = content;
              content = document.createElement("div");
              content.classList.add("annotationContent", this.editorType);
              canvas.before(content);
            }
            return content;
          }
          resetAnnotationElement(annotation) {
            const {
              firstChild
            } = annotation.container;
            if (firstChild?.nodeName === "DIV" && firstChild.classList.contains("annotationContent")) {
              firstChild.remove();
            }
          }
        }
        class FakeEditor extends AnnotationEditor {
          constructor(params) {
            super(params);
            this.annotationElementId = params.annotationElementId;
            this.deleted = true;
          }
          serialize() {
            return this.serializeDeleted();
          }
        }

        ;// ./src/shared/murmurhash3.js
        const SEED = 0xc3d2e1f0;
        const MASK_HIGH = 0xffff0000;
        const MASK_LOW = 0xffff;
        class MurmurHash3_64 {
          constructor(seed) {
            this.h1 = seed ? seed & 0xffffffff : SEED;
            this.h2 = seed ? seed & 0xffffffff : SEED;
          }
          update(input) {
            let data, length;
            if (typeof input === "string") {
              data = new Uint8Array(input.length * 2);
              length = 0;
              for (let i = 0, ii = input.length; i < ii; i++) {
                const code = input.charCodeAt(i);
                if (code <= 0xff) {
                  data[length++] = code;
                } else {
                  data[length++] = code >>> 8;
                  data[length++] = code & 0xff;
                }
              }
            } else if (ArrayBuffer.isView(input)) {
              data = input.slice();
              length = data.byteLength;
            } else {
              throw new Error("Invalid data format, must be a string or TypedArray.");
            }
            const blockCounts = length >> 2;
            const tailLength = length - blockCounts * 4;
            const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
            let k1 = 0,
              k2 = 0;
            let h1 = this.h1,
              h2 = this.h2;
            const C1 = 0xcc9e2d51,
              C2 = 0x1b873593;
            const C1_LOW = C1 & MASK_LOW,
              C2_LOW = C2 & MASK_LOW;
            for (let i = 0; i < blockCounts; i++) {
              if (i & 1) {
                k1 = dataUint32[i];
                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                k1 = k1 << 15 | k1 >>> 17;
                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                h1 ^= k1;
                h1 = h1 << 13 | h1 >>> 19;
                h1 = h1 * 5 + 0xe6546b64;
              } else {
                k2 = dataUint32[i];
                k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
                k2 = k2 << 15 | k2 >>> 17;
                k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
                h2 ^= k2;
                h2 = h2 << 13 | h2 >>> 19;
                h2 = h2 * 5 + 0xe6546b64;
              }
            }
            k1 = 0;
            switch (tailLength) {
              case 3:
                k1 ^= data[blockCounts * 4 + 2] << 16;
              case 2:
                k1 ^= data[blockCounts * 4 + 1] << 8;
              case 1:
                k1 ^= data[blockCounts * 4];
                k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
                k1 = k1 << 15 | k1 >>> 17;
                k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
                if (blockCounts & 1) {
                  h1 ^= k1;
                } else {
                  h2 ^= k1;
                }
            }
            this.h1 = h1;
            this.h2 = h2;
          }
          hexdigest() {
            let h1 = this.h1,
              h2 = this.h2;
            h1 ^= h2 >>> 1;
            h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;
            h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;
            h1 ^= h2 >>> 1;
            h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;
            h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;
            h1 ^= h2 >>> 1;
            return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
          }
        }

        ;// ./src/display/annotation_storage.js



        const SerializableEmpty = Object.freeze({
          map: null,
          hash: "",
          transfer: undefined
        });
        class AnnotationStorage {
          #modified = false;
          #modifiedIds = null;
          #editorsMap = null;
          #storage = new Map();
          constructor() {
            this.onSetModified = null;
            this.onResetModified = null;
            this.onAnnotationEditor = null;
          }
          getValue(key, defaultValue) {
            const value = this.#storage.get(key);
            if (value === undefined) {
              return defaultValue;
            }
            return Object.assign(defaultValue, value);
          }
          getRawValue(key) {
            return this.#storage.get(key);
          }
          remove(key) {
            const storedValue = this.#storage.get(key);
            if (storedValue === undefined) {
              return;
            }
            if (storedValue instanceof AnnotationEditor) {
              this.#editorsMap.delete(storedValue.annotationElementId);
            }
            this.#storage.delete(key);
            if (this.#storage.size === 0) {
              this.resetModified();
            }
            if (typeof this.onAnnotationEditor === "function") {
              for (const value of this.#storage.values()) {
                if (value instanceof AnnotationEditor) {
                  return;
                }
              }
              this.onAnnotationEditor(null);
            }
          }
          setValue(key, value) {
            const obj = this.#storage.get(key);
            let modified = false;
            if (obj !== undefined) {
              for (const [entry, val] of Object.entries(value)) {
                if (obj[entry] !== val) {
                  modified = true;
                  obj[entry] = val;
                }
              }
            } else {
              modified = true;
              this.#storage.set(key, value);
            }
            if (modified) {
              this.#setModified();
            }
            if (value instanceof AnnotationEditor) {
              (this.#editorsMap ||= new Map()).set(value.annotationElementId, value);
              if (typeof this.onAnnotationEditor === "function") {
                this.onAnnotationEditor(value.constructor._type);
              }
            }
          }
          has(key) {
            return this.#storage.has(key);
          }
          get size() {
            return this.#storage.size;
          }
          #setModified() {
            if (!this.#modified) {
              this.#modified = true;
              if (typeof this.onSetModified === "function") {
                this.onSetModified();
              }
            }
          }
          resetModified() {
            if (this.#modified) {
              this.#modified = false;
              if (typeof this.onResetModified === "function") {
                this.onResetModified();
              }
            }
          }
          get print() {
            return new PrintAnnotationStorage(this);
          }
          get serializable() {
            if (this.#storage.size === 0) {
              return SerializableEmpty;
            }
            const map = new Map(),
              hash = new MurmurHash3_64(),
              transfer = [];
            const context = Object.create(null);
            let hasBitmap = false;
            for (const [key, val] of this.#storage) {
              const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;
              if (serialized) {
                map.set(key, serialized);
                hash.update(`${key}:${JSON.stringify(serialized)}`);
                hasBitmap ||= !!serialized.bitmap;
              }
            }
            if (hasBitmap) {
              for (const value of map.values()) {
                if (value.bitmap) {
                  transfer.push(value.bitmap);
                }
              }
            }
            return map.size > 0 ? {
              map,
              hash: hash.hexdigest(),
              transfer
            } : SerializableEmpty;
          }
          get editorStats() {
            let stats = null;
            const typeToEditor = new Map();
            let numberOfEditedComments = 0;
            let numberOfDeletedComments = 0;
            for (const value of this.#storage.values()) {
              if (!(value instanceof AnnotationEditor)) {
                if (value.popup) {
                  if (value.popup.deleted) {
                    numberOfDeletedComments += 1;
                  } else {
                    numberOfEditedComments += 1;
                  }
                }
                continue;
              }
              if (value.isCommentDeleted) {
                numberOfDeletedComments += 1;
              } else if (value.hasEditedComment) {
                numberOfEditedComments += 1;
              }
              const editorStats = value.telemetryFinalData;
              if (!editorStats) {
                continue;
              }
              const {
                type
              } = editorStats;
              if (!typeToEditor.has(type)) {
                typeToEditor.set(type, Object.getPrototypeOf(value).constructor);
              }
              stats ||= Object.create(null);
              const map = stats[type] ||= new Map();
              for (const [key, val] of Object.entries(editorStats)) {
                if (key === "type") {
                  continue;
                }
                let counters = map.get(key);
                if (!counters) {
                  counters = new Map();
                  map.set(key, counters);
                }
                const count = counters.get(val) ?? 0;
                counters.set(val, count + 1);
              }
            }
            if (numberOfDeletedComments > 0 || numberOfEditedComments > 0) {
              stats ||= Object.create(null);
              stats.comments = {
                deleted: numberOfDeletedComments,
                edited: numberOfEditedComments
              };
            }
            if (!stats) {
              return null;
            }
            for (const [type, editor] of typeToEditor) {
              stats[type] = editor.computeTelemetryFinalData(stats[type]);
            }
            return stats;
          }
          resetModifiedIds() {
            this.#modifiedIds = null;
          }
          updateEditor(annotationId, data) {
            const value = this.#editorsMap?.get(annotationId);
            if (value) {
              value.updateFromAnnotationLayer(data);
              return true;
            }
            return false;
          }
          getEditor(annotationId) {
            return this.#editorsMap?.get(annotationId) || null;
          }
          get modifiedIds() {
            if (this.#modifiedIds) {
              return this.#modifiedIds;
            }
            const ids = [];
            if (this.#editorsMap) {
              for (const value of this.#editorsMap.values()) {
                if (!value.serialize()) {
                  continue;
                }
                ids.push(value.annotationElementId);
              }
            }
            return this.#modifiedIds = {
              ids: new Set(ids),
              hash: ids.join(",")
            };
          }
          [Symbol.iterator]() {
            return this.#storage.entries();
          }
        }
        class PrintAnnotationStorage extends AnnotationStorage {
          #serializable;
          constructor(parent) {
            super();
            const {
              map,
              hash,
              transfer
            } = parent.serializable;
            const clone = structuredClone(map, transfer ? {
              transfer
            } : null);
            this.#serializable = {
              map: clone,
              hash,
              transfer
            };
          }
          get print() {
            unreachable("Should not call PrintAnnotationStorage.print");
          }
          get serializable() {
            return this.#serializable;
          }
          get modifiedIds() {
            return shadow(this, "modifiedIds", {
              ids: new Set(),
              hash: ""
            });
          }
        }

        ;// ./src/display/font_loader.js


        class FontLoader {
          #systemFonts = new Set();
          constructor({
            ownerDocument = globalThis.document,
            styleElement = null
          }) {
            this._document = ownerDocument;
            this.nativeFontFaces = new Set();
            this.styleElement = null;
            this.loadingRequests = [];
            this.loadTestFontId = 0;
          }
          addNativeFontFace(nativeFontFace) {
            this.nativeFontFaces.add(nativeFontFace);
            this._document.fonts.add(nativeFontFace);
          }
          removeNativeFontFace(nativeFontFace) {
            this.nativeFontFaces.delete(nativeFontFace);
            this._document.fonts.delete(nativeFontFace);
          }
          insertRule(rule) {
            if (!this.styleElement) {
              this.styleElement = this._document.createElement("style");
              this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
            }
            const styleSheet = this.styleElement.sheet;
            styleSheet.insertRule(rule, styleSheet.cssRules.length);
          }
          clear() {
            for (const nativeFontFace of this.nativeFontFaces) {
              this._document.fonts.delete(nativeFontFace);
            }
            this.nativeFontFaces.clear();
            this.#systemFonts.clear();
            if (this.styleElement) {
              this.styleElement.remove();
              this.styleElement = null;
            }
          }
          async loadSystemFont({
            systemFontInfo: info,
            disableFontFace,
            _inspectFont
          }) {
            if (!info || this.#systemFonts.has(info.loadedName)) {
              return;
            }
            assert(!disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
            if (this.isFontLoadingAPISupported) {
              const {
                loadedName,
                src,
                style
              } = info;
              const fontFace = new FontFace(loadedName, src, style);
              this.addNativeFontFace(fontFace);
              try {
                await fontFace.load();
                this.#systemFonts.add(loadedName);
                _inspectFont?.(info);
              } catch {
                warn(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);
                this.removeNativeFontFace(fontFace);
              }
              return;
            }
            unreachable("Not implemented: loadSystemFont without the Font Loading API.");
          }
          async bind(font) {
            if (font.attached || font.missingFile && !font.systemFontInfo) {
              return;
            }
            font.attached = true;
            if (font.systemFontInfo) {
              await this.loadSystemFont(font);
              return;
            }
            if (this.isFontLoadingAPISupported) {
              const nativeFontFace = font.createNativeFontFace();
              if (nativeFontFace) {
                this.addNativeFontFace(nativeFontFace);
                try {
                  await nativeFontFace.loaded;
                } catch (ex) {
                  warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
                  font.disableFontFace = true;
                  throw ex;
                }
              }
              return;
            }
            const rule = font.createFontFaceRule();
            if (rule) {
              this.insertRule(rule);
              if (this.isSyncFontLoadingSupported) {
                return;
              }
              await new Promise(resolve => {
                const request = this._queueLoadingCallback(resolve);
                this._prepareFontLoadEvent(font, request);
              });
            }
          }
          get isFontLoadingAPISupported() {
            const hasFonts = !!this._document?.fonts;
            return shadow(this, "isFontLoadingAPISupported", hasFonts);
          }
          get isSyncFontLoadingSupported() {
            return shadow(this, "isSyncFontLoadingSupported", isNodeJS || util_FeatureTest.platform.isFirefox);
          }
          _queueLoadingCallback(callback) {
            function completeRequest() {
              assert(!request.done, "completeRequest() cannot be called twice.");
              request.done = true;
              while (loadingRequests.length > 0 && loadingRequests[0].done) {
                const otherRequest = loadingRequests.shift();
                setTimeout(otherRequest.callback, 0);
              }
            }
            const {
              loadingRequests
            } = this;
            const request = {
              done: false,
              complete: completeRequest,
              callback
            };
            loadingRequests.push(request);
            return request;
          }
          get _loadTestFont() {
            const testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA" + "FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA" + "ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA" + "AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1" + "AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD" + "6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM" + "AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D" + "IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA" + "AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA" + "AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB" + "AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY" + "AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA" + "AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" + "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA" + "AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC" + "AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3" + "Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj" + "FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
            return shadow(this, "_loadTestFont", testFont);
          }
          _prepareFontLoadEvent(font, request) {
            function int32(data, offset) {
              return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;
            }
            function spliceString(s, offset, remove, insert) {
              const chunk1 = s.substring(0, offset);
              const chunk2 = s.substring(offset + remove);
              return chunk1 + insert + chunk2;
            }
            let i, ii;
            const canvas = this._document.createElement("canvas");
            canvas.width = 1;
            canvas.height = 1;
            const ctx = canvas.getContext("2d");
            let called = 0;
            function isFontReady(name, callback) {
              if (++called > 30) {
                warn("Load test font never loaded.");
                callback();
                return;
              }
              ctx.font = "30px " + name;
              ctx.fillText(".", 0, 20);
              const imageData = ctx.getImageData(0, 0, 1, 1);
              if (imageData.data[3] > 0) {
                callback();
                return;
              }
              setTimeout(isFontReady.bind(null, name, callback));
            }
            const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
            let data = this._loadTestFont;
            const COMMENT_OFFSET = 976;
            data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
            const CFF_CHECKSUM_OFFSET = 16;
            const XXXX_VALUE = 0x58585858;
            let checksum = int32(data, CFF_CHECKSUM_OFFSET);
            for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
              checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
            }
            if (i < loadTestFontId.length) {
              checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
            }
            data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));
            const url = `url(data:font/opentype;base64,${btoa(data)});`;
            const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
            this.insertRule(rule);
            const div = this._document.createElement("div");
            div.style.visibility = "hidden";
            div.style.width = div.style.height = "10px";
            div.style.position = "absolute";
            div.style.top = div.style.left = "0px";
            for (const name of [font.loadedName, loadTestFontId]) {
              const span = this._document.createElement("span");
              span.textContent = "Hi";
              span.style.fontFamily = name;
              div.append(span);
            }
            this._document.body.append(div);
            isFontReady(loadTestFontId, () => {
              div.remove();
              request.complete();
            });
          }
        }
        class FontFaceObject {
          #fontData;
          constructor(translatedData, inspectFont = null, extra, charProcOperatorList) {
            this.compiledGlyphs = Object.create(null);
            this.#fontData = translatedData;
            this._inspectFont = inspectFont;
            if (extra) {
              Object.assign(this, extra);
            }
            if (charProcOperatorList) {
              this.charProcOperatorList = charProcOperatorList;
            }
          }
          createNativeFontFace() {
            if (!this.data || this.disableFontFace) {
              return null;
            }
            let nativeFontFace;
            if (!this.cssFontInfo) {
              nativeFontFace = new FontFace(this.loadedName, this.data, {});
            } else {
              const css = {
                weight: this.cssFontInfo.fontWeight
              };
              if (this.cssFontInfo.italicAngle) {
                css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
              }
              nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
            }
            this._inspectFont?.(this);
            return nativeFontFace;
          }
          createFontFaceRule() {
            if (!this.data || this.disableFontFace) {
              return null;
            }
            const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;
            let rule;
            if (!this.cssFontInfo) {
              rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
            } else {
              let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
              if (this.cssFontInfo.italicAngle) {
                css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
              }
              rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
            }
            this._inspectFont?.(this, url);
            return rule;
          }
          getPathGenerator(objs, character) {
            if (this.compiledGlyphs[character] !== undefined) {
              return this.compiledGlyphs[character];
            }
            const objId = this.loadedName + "_path_" + character;
            let cmds;
            try {
              cmds = objs.get(objId);
            } catch (ex) {
              warn(`getPathGenerator - ignoring character: "${ex}".`);
            }
            const path = makePathFromDrawOPS(cmds);
            if (!this.fontExtraProperties) {
              objs.delete(objId);
            }
            return this.compiledGlyphs[character] = path;
          }
          get black() {
            return this.#fontData.black;
          }
          get bold() {
            return this.#fontData.bold;
          }
          get disableFontFace() {
            return this.#fontData.disableFontFace ?? false;
          }
          get fontExtraProperties() {
            return this.#fontData.fontExtraProperties ?? false;
          }
          get isInvalidPDFjsFont() {
            return this.#fontData.isInvalidPDFjsFont;
          }
          get isType3Font() {
            return this.#fontData.isType3Font;
          }
          get italic() {
            return this.#fontData.italic;
          }
          get missingFile() {
            return this.#fontData.missingFile;
          }
          get remeasure() {
            return this.#fontData.remeasure;
          }
          get vertical() {
            return this.#fontData.vertical;
          }
          get ascent() {
            return this.#fontData.ascent;
          }
          get defaultWidth() {
            return this.#fontData.defaultWidth;
          }
          get descent() {
            return this.#fontData.descent;
          }
          get bbox() {
            return this.#fontData.bbox;
          }
          get fontMatrix() {
            return this.#fontData.fontMatrix;
          }
          get fallbackName() {
            return this.#fontData.fallbackName;
          }
          get loadedName() {
            return this.#fontData.loadedName;
          }
          get mimetype() {
            return this.#fontData.mimetype;
          }
          get name() {
            return this.#fontData.name;
          }
          get data() {
            return this.#fontData.data;
          }
          clearData() {
            this.#fontData.clearData();
          }
          get cssFontInfo() {
            return this.#fontData.cssFontInfo;
          }
          get systemFontInfo() {
            return this.#fontData.systemFontInfo;
          }
          get defaultVMetrics() {
            return this.#fontData.defaultVMetrics;
          }
        }

        ;// ./src/shared/obj-bin-transform.js

        class CssFontInfo {
          #buffer;
          #view;
          #decoder;
          static strings = ["fontFamily", "fontWeight", "italicAngle"];
          static write(info) {
            const encoder = new TextEncoder();
            const encodedStrings = {};
            let stringsLength = 0;
            for (const prop of CssFontInfo.strings) {
              const encoded = encoder.encode(info[prop]);
              encodedStrings[prop] = encoded;
              stringsLength += 4 + encoded.length;
            }
            const buffer = new ArrayBuffer(stringsLength);
            const data = new Uint8Array(buffer);
            const view = new DataView(buffer);
            let offset = 0;
            for (const prop of CssFontInfo.strings) {
              const encoded = encodedStrings[prop];
              const length = encoded.length;
              view.setUint32(offset, length);
              data.set(encoded, offset + 4);
              offset += 4 + length;
            }
            assert(offset === buffer.byteLength, "CssFontInfo.write: Buffer overflow");
            return buffer;
          }
          constructor(buffer) {
            this.#buffer = buffer;
            this.#view = new DataView(this.#buffer);
            this.#decoder = new TextDecoder();
          }
          #readString(index) {
            assert(index < CssFontInfo.strings.length, "Invalid string index");
            let offset = 0;
            for (let i = 0; i < index; i++) {
              offset += this.#view.getUint32(offset) + 4;
            }
            const length = this.#view.getUint32(offset);
            return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));
          }
          get fontFamily() {
            return this.#readString(0);
          }
          get fontWeight() {
            return this.#readString(1);
          }
          get italicAngle() {
            return this.#readString(2);
          }
        }
        class SystemFontInfo {
          #buffer;
          #view;
          #decoder;
          static strings = ["css", "loadedName", "baseFontName", "src"];
          static write(info) {
            const encoder = new TextEncoder();
            const encodedStrings = {};
            let stringsLength = 0;
            for (const prop of SystemFontInfo.strings) {
              const encoded = encoder.encode(info[prop]);
              encodedStrings[prop] = encoded;
              stringsLength += 4 + encoded.length;
            }
            stringsLength += 4;
            let encodedStyleStyle,
              encodedStyleWeight,
              lengthEstimate = 1 + stringsLength;
            if (info.style) {
              encodedStyleStyle = encoder.encode(info.style.style);
              encodedStyleWeight = encoder.encode(info.style.weight);
              lengthEstimate += 4 + encodedStyleStyle.length + 4 + encodedStyleWeight.length;
            }
            const buffer = new ArrayBuffer(lengthEstimate);
            const data = new Uint8Array(buffer);
            const view = new DataView(buffer);
            let offset = 0;
            view.setUint8(offset++, info.guessFallback ? 1 : 0);
            view.setUint32(offset, 0);
            offset += 4;
            stringsLength = 0;
            for (const prop of SystemFontInfo.strings) {
              const encoded = encodedStrings[prop];
              const length = encoded.length;
              stringsLength += 4 + length;
              view.setUint32(offset, length);
              data.set(encoded, offset + 4);
              offset += 4 + length;
            }
            view.setUint32(offset - stringsLength - 4, stringsLength);
            if (info.style) {
              view.setUint32(offset, encodedStyleStyle.length);
              data.set(encodedStyleStyle, offset + 4);
              offset += 4 + encodedStyleStyle.length;
              view.setUint32(offset, encodedStyleWeight.length);
              data.set(encodedStyleWeight, offset + 4);
              offset += 4 + encodedStyleWeight.length;
            }
            assert(offset <= buffer.byteLength, "SubstitionInfo.write: Buffer overflow");
            return buffer.transferToFixedLength(offset);
          }
          constructor(buffer) {
            this.#buffer = buffer;
            this.#view = new DataView(this.#buffer);
            this.#decoder = new TextDecoder();
          }
          get guessFallback() {
            return this.#view.getUint8(0) !== 0;
          }
          #readString(index) {
            assert(index < SystemFontInfo.strings.length, "Invalid string index");
            let offset = 5;
            for (let i = 0; i < index; i++) {
              offset += this.#view.getUint32(offset) + 4;
            }
            const length = this.#view.getUint32(offset);
            return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));
          }
          get css() {
            return this.#readString(0);
          }
          get loadedName() {
            return this.#readString(1);
          }
          get baseFontName() {
            return this.#readString(2);
          }
          get src() {
            return this.#readString(3);
          }
          get style() {
            let offset = 1;
            offset += 4 + this.#view.getUint32(offset);
            const styleLength = this.#view.getUint32(offset);
            const style = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, styleLength));
            offset += 4 + styleLength;
            const weightLength = this.#view.getUint32(offset);
            const weight = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, weightLength));
            return {
              style,
              weight
            };
          }
        }
        class FontInfo {
          static bools = ["black", "bold", "disableFontFace", "fontExtraProperties", "isInvalidPDFjsFont", "isType3Font", "italic", "missingFile", "remeasure", "vertical"];
          static numbers = ["ascent", "defaultWidth", "descent"];
          static strings = ["fallbackName", "loadedName", "mimetype", "name"];
          static #OFFSET_NUMBERS = Math.ceil(this.bools.length * 2 / 8);
          static #OFFSET_BBOX = this.#OFFSET_NUMBERS + this.numbers.length * 8;
          static #OFFSET_FONT_MATRIX = this.#OFFSET_BBOX + 1 + 2 * 4;
          static #OFFSET_DEFAULT_VMETRICS = this.#OFFSET_FONT_MATRIX + 1 + 8 * 6;
          static #OFFSET_STRINGS = this.#OFFSET_DEFAULT_VMETRICS + 1 + 2 * 3;
          #buffer;
          #decoder;
          #view;
          constructor({
            data,
            extra
          }) {
            this.#buffer = data;
            this.#decoder = new TextDecoder();
            this.#view = new DataView(this.#buffer);
            if (extra) {
              Object.assign(this, extra);
            }
          }
          #readBoolean(index) {
            assert(index < FontInfo.bools.length, "Invalid boolean index");
            const byteOffset = Math.floor(index / 4);
            const bitOffset = index * 2 % 8;
            const value = this.#view.getUint8(byteOffset) >> bitOffset & 0x03;
            return value === 0x00 ? undefined : value === 0x02;
          }
          get black() {
            return this.#readBoolean(0);
          }
          get bold() {
            return this.#readBoolean(1);
          }
          get disableFontFace() {
            return this.#readBoolean(2);
          }
          get fontExtraProperties() {
            return this.#readBoolean(3);
          }
          get isInvalidPDFjsFont() {
            return this.#readBoolean(4);
          }
          get isType3Font() {
            return this.#readBoolean(5);
          }
          get italic() {
            return this.#readBoolean(6);
          }
          get missingFile() {
            return this.#readBoolean(7);
          }
          get remeasure() {
            return this.#readBoolean(8);
          }
          get vertical() {
            return this.#readBoolean(9);
          }
          #readNumber(index) {
            assert(index < FontInfo.numbers.length, "Invalid number index");
            return this.#view.getFloat64(FontInfo.#OFFSET_NUMBERS + index * 8);
          }
          get ascent() {
            return this.#readNumber(0);
          }
          get defaultWidth() {
            return this.#readNumber(1);
          }
          get descent() {
            return this.#readNumber(2);
          }
          get bbox() {
            let offset = FontInfo.#OFFSET_BBOX;
            const numCoords = this.#view.getUint8(offset);
            if (numCoords === 0) {
              return undefined;
            }
            offset += 1;
            const bbox = [];
            for (let i = 0; i < 4; i++) {
              bbox.push(this.#view.getInt16(offset, true));
              offset += 2;
            }
            return bbox;
          }
          get fontMatrix() {
            let offset = FontInfo.#OFFSET_FONT_MATRIX;
            const numPoints = this.#view.getUint8(offset);
            if (numPoints === 0) {
              return undefined;
            }
            offset += 1;
            const fontMatrix = [];
            for (let i = 0; i < 6; i++) {
              fontMatrix.push(this.#view.getFloat64(offset, true));
              offset += 8;
            }
            return fontMatrix;
          }
          get defaultVMetrics() {
            let offset = FontInfo.#OFFSET_DEFAULT_VMETRICS;
            const numMetrics = this.#view.getUint8(offset);
            if (numMetrics === 0) {
              return undefined;
            }
            offset += 1;
            const defaultVMetrics = [];
            for (let i = 0; i < 3; i++) {
              defaultVMetrics.push(this.#view.getInt16(offset, true));
              offset += 2;
            }
            return defaultVMetrics;
          }
          #readString(index) {
            assert(index < FontInfo.strings.length, "Invalid string index");
            let offset = FontInfo.#OFFSET_STRINGS + 4;
            for (let i = 0; i < index; i++) {
              offset += this.#view.getUint32(offset) + 4;
            }
            const length = this.#view.getUint32(offset);
            const stringData = new Uint8Array(length);
            stringData.set(new Uint8Array(this.#buffer, offset + 4, length));
            return this.#decoder.decode(stringData);
          }
          get fallbackName() {
            return this.#readString(0);
          }
          get loadedName() {
            return this.#readString(1);
          }
          get mimetype() {
            return this.#readString(2);
          }
          get name() {
            return this.#readString(3);
          }
          get data() {
            let offset = FontInfo.#OFFSET_STRINGS;
            const stringsLength = this.#view.getUint32(offset);
            offset += 4 + stringsLength;
            const systemFontInfoLength = this.#view.getUint32(offset);
            offset += 4 + systemFontInfoLength;
            const cssFontInfoLength = this.#view.getUint32(offset);
            offset += 4 + cssFontInfoLength;
            const length = this.#view.getUint32(offset);
            if (length === 0) {
              return undefined;
            }
            return new Uint8Array(this.#buffer, offset + 4, length);
          }
          clearData() {
            let offset = FontInfo.#OFFSET_STRINGS;
            const stringsLength = this.#view.getUint32(offset);
            offset += 4 + stringsLength;
            const systemFontInfoLength = this.#view.getUint32(offset);
            offset += 4 + systemFontInfoLength;
            const cssFontInfoLength = this.#view.getUint32(offset);
            offset += 4 + cssFontInfoLength;
            const length = this.#view.getUint32(offset);
            const data = new Uint8Array(this.#buffer, offset + 4, length);
            data.fill(0);
            this.#view.setUint32(offset, 0);
          }
          get cssFontInfo() {
            let offset = FontInfo.#OFFSET_STRINGS;
            const stringsLength = this.#view.getUint32(offset);
            offset += 4 + stringsLength;
            const systemFontInfoLength = this.#view.getUint32(offset);
            offset += 4 + systemFontInfoLength;
            const cssFontInfoLength = this.#view.getUint32(offset);
            if (cssFontInfoLength === 0) {
              return null;
            }
            const cssFontInfoData = new Uint8Array(cssFontInfoLength);
            cssFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, cssFontInfoLength));
            return new CssFontInfo(cssFontInfoData.buffer);
          }
          get systemFontInfo() {
            let offset = FontInfo.#OFFSET_STRINGS;
            const stringsLength = this.#view.getUint32(offset);
            offset += 4 + stringsLength;
            const systemFontInfoLength = this.#view.getUint32(offset);
            if (systemFontInfoLength === 0) {
              return null;
            }
            const systemFontInfoData = new Uint8Array(systemFontInfoLength);
            systemFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, systemFontInfoLength));
            return new SystemFontInfo(systemFontInfoData.buffer);
          }
          static write(font) {
            const systemFontInfoBuffer = font.systemFontInfo ? SystemFontInfo.write(font.systemFontInfo) : null;
            const cssFontInfoBuffer = font.cssFontInfo ? CssFontInfo.write(font.cssFontInfo) : null;
            const encoder = new TextEncoder();
            const encodedStrings = {};
            let stringsLength = 0;
            for (const prop of FontInfo.strings) {
              encodedStrings[prop] = encoder.encode(font[prop]);
              stringsLength += 4 + encodedStrings[prop].length;
            }
            const lengthEstimate = FontInfo.#OFFSET_STRINGS + 4 + stringsLength + 4 + (systemFontInfoBuffer ? systemFontInfoBuffer.byteLength : 0) + 4 + (cssFontInfoBuffer ? cssFontInfoBuffer.byteLength : 0) + 4 + (font.data ? font.data.length : 0);
            const buffer = new ArrayBuffer(lengthEstimate);
            const data = new Uint8Array(buffer);
            const view = new DataView(buffer);
            let offset = 0;
            const numBools = FontInfo.bools.length;
            let boolByte = 0,
              boolBit = 0;
            for (let i = 0; i < numBools; i++) {
              const value = font[FontInfo.bools[i]];
              const bits = value === undefined ? 0x00 : value ? 0x02 : 0x01;
              boolByte |= bits << boolBit;
              boolBit += 2;
              if (boolBit === 8 || i === numBools - 1) {
                view.setUint8(offset++, boolByte);
                boolByte = 0;
                boolBit = 0;
              }
            }
            assert(offset === FontInfo.#OFFSET_NUMBERS, "FontInfo.write: Boolean properties offset mismatch");
            for (const prop of FontInfo.numbers) {
              view.setFloat64(offset, font[prop]);
              offset += 8;
            }
            assert(offset === FontInfo.#OFFSET_BBOX, "FontInfo.write: Number properties offset mismatch");
            if (font.bbox) {
              view.setUint8(offset++, 4);
              for (const coord of font.bbox) {
                view.setInt16(offset, coord, true);
                offset += 2;
              }
            } else {
              view.setUint8(offset++, 0);
              offset += 2 * 4;
            }
            assert(offset === FontInfo.#OFFSET_FONT_MATRIX, "FontInfo.write: BBox properties offset mismatch");
            if (font.fontMatrix) {
              view.setUint8(offset++, 6);
              for (const point of font.fontMatrix) {
                view.setFloat64(offset, point, true);
                offset += 8;
              }
            } else {
              view.setUint8(offset++, 0);
              offset += 8 * 6;
            }
            assert(offset === FontInfo.#OFFSET_DEFAULT_VMETRICS, "FontInfo.write: FontMatrix properties offset mismatch");
            if (font.defaultVMetrics) {
              view.setUint8(offset++, 1);
              for (const metric of font.defaultVMetrics) {
                view.setInt16(offset, metric, true);
                offset += 2;
              }
            } else {
              view.setUint8(offset++, 0);
              offset += 3 * 2;
            }
            assert(offset === FontInfo.#OFFSET_STRINGS, "FontInfo.write: DefaultVMetrics properties offset mismatch");
            view.setUint32(FontInfo.#OFFSET_STRINGS, 0);
            offset += 4;
            for (const prop of FontInfo.strings) {
              const encoded = encodedStrings[prop];
              const length = encoded.length;
              view.setUint32(offset, length);
              data.set(encoded, offset + 4);
              offset += 4 + length;
            }
            view.setUint32(FontInfo.#OFFSET_STRINGS, offset - FontInfo.#OFFSET_STRINGS - 4);
            if (!systemFontInfoBuffer) {
              view.setUint32(offset, 0);
              offset += 4;
            } else {
              const length = systemFontInfoBuffer.byteLength;
              view.setUint32(offset, length);
              assert(offset + 4 + length <= buffer.byteLength, "FontInfo.write: Buffer overflow at systemFontInfo");
              data.set(new Uint8Array(systemFontInfoBuffer), offset + 4);
              offset += 4 + length;
            }
            if (!cssFontInfoBuffer) {
              view.setUint32(offset, 0);
              offset += 4;
            } else {
              const length = cssFontInfoBuffer.byteLength;
              view.setUint32(offset, length);
              assert(offset + 4 + length <= buffer.byteLength, "FontInfo.write: Buffer overflow at cssFontInfo");
              data.set(new Uint8Array(cssFontInfoBuffer), offset + 4);
              offset += 4 + length;
            }
            if (font.data === undefined) {
              view.setUint32(offset, 0);
              offset += 4;
            } else {
              view.setUint32(offset, font.data.length);
              data.set(font.data, offset + 4);
              offset += 4 + font.data.length;
            }
            assert(offset <= buffer.byteLength, "FontInfo.write: Buffer overflow");
            return buffer.transferToFixedLength(offset);
          }
        }
        class PatternInfo {
          static #KIND = 0;
          static #HAS_BBOX = 1;
          static #HAS_BACKGROUND = 2;
          static #SHADING_TYPE = 3;
          static #N_COORD = 4;
          static #N_COLOR = 8;
          static #N_STOP = 12;
          static #N_FIGURES = 16;
          constructor(buffer) {
            this.buffer = buffer;
            this.view = new DataView(buffer);
            this.data = new Uint8Array(buffer);
          }
          static write(ir) {
            let kind,
              bbox = null,
              coords = [],
              colors = [],
              colorStops = [],
              figures = [],
              shadingType = null,
              background = null;
            switch (ir[0]) {
              case "RadialAxial":
                kind = ir[1] === "axial" ? 1 : 2;
                bbox = ir[2];
                colorStops = ir[3];
                if (kind === 1) {
                  coords.push(...ir[4], ...ir[5]);
                } else {
                  coords.push(ir[4][0], ir[4][1], ir[6], ir[5][0], ir[5][1], ir[7]);
                }
                break;
              case "Mesh":
                kind = 3;
                shadingType = ir[1];
                coords = ir[2];
                colors = ir[3];
                figures = ir[4] || [];
                bbox = ir[6];
                background = ir[7];
                break;
              default:
                throw new Error(`Unsupported pattern type: ${ir[0]}`);
            }
            const nCoord = Math.floor(coords.length / 2);
            const nColor = Math.floor(colors.length / 3);
            const nStop = colorStops.length;
            const nFigures = figures.length;
            let figuresSize = 0;
            for (const figure of figures) {
              figuresSize += 1;
              figuresSize = Math.ceil(figuresSize / 4) * 4;
              figuresSize += 4 + figure.coords.length * 4;
              figuresSize += 4 + figure.colors.length * 4;
              if (figure.verticesPerRow !== undefined) {
                figuresSize += 4;
              }
            }
            const byteLen = 20 + nCoord * 8 + nColor * 3 + nStop * 8 + (bbox ? 16 : 0) + (background ? 3 : 0) + figuresSize;
            const buffer = new ArrayBuffer(byteLen);
            const dataView = new DataView(buffer);
            const u8data = new Uint8Array(buffer);
            dataView.setUint8(PatternInfo.#KIND, kind);
            dataView.setUint8(PatternInfo.#HAS_BBOX, bbox ? 1 : 0);
            dataView.setUint8(PatternInfo.#HAS_BACKGROUND, background ? 1 : 0);
            dataView.setUint8(PatternInfo.#SHADING_TYPE, shadingType);
            dataView.setUint32(PatternInfo.#N_COORD, nCoord, true);
            dataView.setUint32(PatternInfo.#N_COLOR, nColor, true);
            dataView.setUint32(PatternInfo.#N_STOP, nStop, true);
            dataView.setUint32(PatternInfo.#N_FIGURES, nFigures, true);
            let offset = 20;
            const coordsView = new Float32Array(buffer, offset, nCoord * 2);
            coordsView.set(coords);
            offset += nCoord * 8;
            u8data.set(colors, offset);
            offset += nColor * 3;
            for (const [pos, hex] of colorStops) {
              dataView.setFloat32(offset, pos, true);
              offset += 4;
              dataView.setUint32(offset, parseInt(hex.slice(1), 16), true);
              offset += 4;
            }
            if (bbox) {
              for (const v of bbox) {
                dataView.setFloat32(offset, v, true);
                offset += 4;
              }
            }
            if (background) {
              u8data.set(background, offset);
              offset += 3;
            }
            for (let i = 0; i < figures.length; i++) {
              const figure = figures[i];
              dataView.setUint8(offset, figure.type);
              offset += 1;
              offset = Math.ceil(offset / 4) * 4;
              dataView.setUint32(offset, figure.coords.length, true);
              offset += 4;
              const figureCoordsView = new Int32Array(buffer, offset, figure.coords.length);
              figureCoordsView.set(figure.coords);
              offset += figure.coords.length * 4;
              dataView.setUint32(offset, figure.colors.length, true);
              offset += 4;
              const colorsView = new Int32Array(buffer, offset, figure.colors.length);
              colorsView.set(figure.colors);
              offset += figure.colors.length * 4;
              if (figure.verticesPerRow !== undefined) {
                dataView.setUint32(offset, figure.verticesPerRow, true);
                offset += 4;
              }
            }
            return buffer;
          }
          getIR() {
            const dataView = this.view;
            const kind = this.data[PatternInfo.#KIND];
            const hasBBox = !!this.data[PatternInfo.#HAS_BBOX];
            const hasBackground = !!this.data[PatternInfo.#HAS_BACKGROUND];
            const nCoord = dataView.getUint32(PatternInfo.#N_COORD, true);
            const nColor = dataView.getUint32(PatternInfo.#N_COLOR, true);
            const nStop = dataView.getUint32(PatternInfo.#N_STOP, true);
            const nFigures = dataView.getUint32(PatternInfo.#N_FIGURES, true);
            let offset = 20;
            const coords = new Float32Array(this.buffer, offset, nCoord * 2);
            offset += nCoord * 8;
            const colors = new Uint8Array(this.buffer, offset, nColor * 3);
            offset += nColor * 3;
            const stops = [];
            for (let i = 0; i < nStop; ++i) {
              const p = dataView.getFloat32(offset, true);
              offset += 4;
              const rgb = dataView.getUint32(offset, true);
              offset += 4;
              stops.push([p, `#${rgb.toString(16).padStart(6, "0")}`]);
            }
            let bbox = null;
            if (hasBBox) {
              bbox = [];
              for (let i = 0; i < 4; ++i) {
                bbox.push(dataView.getFloat32(offset, true));
                offset += 4;
              }
            }
            let background = null;
            if (hasBackground) {
              background = new Uint8Array(this.buffer, offset, 3);
              offset += 3;
            }
            const figures = [];
            for (let i = 0; i < nFigures; ++i) {
              const type = dataView.getUint8(offset);
              offset += 1;
              offset = Math.ceil(offset / 4) * 4;
              const coordsLength = dataView.getUint32(offset, true);
              offset += 4;
              const figureCoords = new Int32Array(this.buffer, offset, coordsLength);
              offset += coordsLength * 4;
              const colorsLength = dataView.getUint32(offset, true);
              offset += 4;
              const figureColors = new Int32Array(this.buffer, offset, colorsLength);
              offset += colorsLength * 4;
              const figure = {
                type,
                coords: figureCoords,
                colors: figureColors
              };
              if (type === MeshFigureType.LATTICE) {
                figure.verticesPerRow = dataView.getUint32(offset, true);
                offset += 4;
              }
              figures.push(figure);
            }
            if (kind === 1) {
              return ["RadialAxial", "axial", bbox, stops, Array.from(coords.slice(0, 2)), Array.from(coords.slice(2, 4)), null, null];
            }
            if (kind === 2) {
              return ["RadialAxial", "radial", bbox, stops, [coords[0], coords[1]], [coords[3], coords[4]], coords[2], coords[5]];
            }
            if (kind === 3) {
              const shadingType = this.data[PatternInfo.#SHADING_TYPE];
              let bounds = null;
              if (coords.length > 0) {
                let minX = coords[0],
                  maxX = coords[0];
                let minY = coords[1],
                  maxY = coords[1];
                for (let i = 0; i < coords.length; i += 2) {
                  const x = coords[i],
                    y = coords[i + 1];
                  minX = minX > x ? x : minX;
                  minY = minY > y ? y : minY;
                  maxX = maxX < x ? x : maxX;
                  maxY = maxY < y ? y : maxY;
                }
                bounds = [minX, minY, maxX, maxY];
              }
              return ["Mesh", shadingType, coords, colors, figures, bounds, bbox, background];
            }
            throw new Error(`Unsupported pattern kind: ${kind}`);
          }
        }

        ;// ./src/display/api_utils.js

        function getUrlProp(val) {
          if (val instanceof URL) {
            return val.href;
          }
          if (typeof val === "string") {
            if (isNodeJS) {
              return val;
            }
            const url = URL.parse(val, window.location);
            if (url) {
              return url.href;
            }
          }
          throw new Error("Invalid PDF url data: " + "either string or URL-object is expected in the url property.");
        }
        function getDataProp(val) {
          if (isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) {
            throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
          }
          if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
            return val;
          }
          if (typeof val === "string") {
            return stringToBytes(val);
          }
          if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === "object" && !isNaN(val?.length)) {
            return new Uint8Array(val);
          }
          throw new Error("Invalid PDF binary data: either TypedArray, " + "string, or array-like object is expected in the data property.");
        }
        function getFactoryUrlProp(val) {
          if (typeof val !== "string") {
            return null;
          }
          if (val.endsWith("/")) {
            return val;
          }
          throw new Error(`Invalid factory url: "${val}" must include trailing slash.`);
        }
        const isRefProxy = v => typeof v === "object" && Number.isInteger(v?.num) && v.num >= 0 && Number.isInteger(v?.gen) && v.gen >= 0;
        const isNameProxy = v => typeof v === "object" && typeof v?.name === "string";
        const isValidExplicitDest = _isValidExplicitDest.bind(null, isRefProxy, isNameProxy);
        class LoopbackPort {
          #listeners = new Map();
          #deferred = Promise.resolve();
          postMessage(obj, transfer) {
            const event = {
              data: structuredClone(obj, transfer ? {
                transfer
              } : null)
            };
            this.#deferred.then(() => {
              for (const [listener] of this.#listeners) {
                listener.call(this, event);
              }
            });
          }
          addEventListener(name, listener, options = null) {
            let rmAbort = null;
            if (options?.signal instanceof AbortSignal) {
              const {
                signal
              } = options;
              if (signal.aborted) {
                warn("LoopbackPort - cannot use an `aborted` signal.");
                return;
              }
              const onAbort = () => this.removeEventListener(name, listener);
              rmAbort = () => signal.removeEventListener("abort", onAbort);
              signal.addEventListener("abort", onAbort);
            }
            this.#listeners.set(listener, rmAbort);
          }
          removeEventListener(name, listener) {
            const rmAbort = this.#listeners.get(listener);
            rmAbort?.();
            this.#listeners.delete(listener);
          }
          terminate() {
            for (const [, rmAbort] of this.#listeners) {
              rmAbort?.();
            }
            this.#listeners.clear();
          }
        }

        ;// ./src/shared/message_handler.js

        const CallbackKind = {
          DATA: 1,
          ERROR: 2
        };
        const StreamKind = {
          CANCEL: 1,
          CANCEL_COMPLETE: 2,
          CLOSE: 3,
          ENQUEUE: 4,
          ERROR: 5,
          PULL: 6,
          PULL_COMPLETE: 7,
          START_COMPLETE: 8
        };
        function onFn() { }
        function wrapReason(ex) {
          if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof PasswordException || ex instanceof ResponseException || ex instanceof UnknownErrorException) {
            return ex;
          }
          if (!(ex instanceof Error || typeof ex === "object" && ex !== null)) {
            unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
          }
          switch (ex.name) {
            case "AbortException":
              return new AbortException(ex.message);
            case "InvalidPDFException":
              return new InvalidPDFException(ex.message);
            case "PasswordException":
              return new PasswordException(ex.message, ex.code);
            case "ResponseException":
              return new ResponseException(ex.message, ex.status, ex.missing);
            case "UnknownErrorException":
              return new UnknownErrorException(ex.message, ex.details);
          }
          return new UnknownErrorException(ex.message, ex.toString());
        }
        class MessageHandler {
          #messageAC = new AbortController();
          constructor(sourceName, targetName, comObj) {
            this.sourceName = sourceName;
            this.targetName = targetName;
            this.comObj = comObj;
            this.callbackId = 1;
            this.streamId = 1;
            this.streamSinks = Object.create(null);
            this.streamControllers = Object.create(null);
            this.callbackCapabilities = Object.create(null);
            this.actionHandler = Object.create(null);
            comObj.addEventListener("message", this.#onMessage.bind(this), {
              signal: this.#messageAC.signal
            });
          }
          #onMessage({
            data
          }) {
            if (data.targetName !== this.sourceName) {
              return;
            }
            if (data.stream) {
              this.#processStreamMessage(data);
              return;
            }
            if (data.callback) {
              const callbackId = data.callbackId;
              const capability = this.callbackCapabilities[callbackId];
              if (!capability) {
                throw new Error(`Cannot resolve callback ${callbackId}`);
              }
              delete this.callbackCapabilities[callbackId];
              if (data.callback === CallbackKind.DATA) {
                capability.resolve(data.data);
              } else if (data.callback === CallbackKind.ERROR) {
                capability.reject(wrapReason(data.reason));
              } else {
                throw new Error("Unexpected callback case");
              }
              return;
            }
            const action = this.actionHandler[data.action];
            if (!action) {
              throw new Error(`Unknown action from worker: ${data.action}`);
            }
            if (data.callbackId) {
              const sourceName = this.sourceName,
                targetName = data.sourceName,
                comObj = this.comObj;
              Promise.try(action, data.data).then(function (result) {
                comObj.postMessage({
                  sourceName,
                  targetName,
                  callback: CallbackKind.DATA,
                  callbackId: data.callbackId,
                  data: result
                });
              }, function (reason) {
                comObj.postMessage({
                  sourceName,
                  targetName,
                  callback: CallbackKind.ERROR,
                  callbackId: data.callbackId,
                  reason: wrapReason(reason)
                });
              });
              return;
            }
            if (data.streamId) {
              this.#createStreamSink(data);
              return;
            }
            action(data.data);
          }
          on(actionName, handler) {
            const ah = this.actionHandler;
            if (ah[actionName]) {
              throw new Error(`There is already an actionName called "${actionName}"`);
            }
            ah[actionName] = handler;
          }
          send(actionName, data, transfers) {
            this.comObj.postMessage({
              sourceName: this.sourceName,
              targetName: this.targetName,
              action: actionName,
              data
            }, transfers);
          }
          sendWithPromise(actionName, data, transfers) {
            const callbackId = this.callbackId++;
            const capability = Promise.withResolvers();
            this.callbackCapabilities[callbackId] = capability;
            try {
              this.comObj.postMessage({
                sourceName: this.sourceName,
                targetName: this.targetName,
                action: actionName,
                callbackId,
                data
              }, transfers);
            } catch (ex) {
              capability.reject(ex);
            }
            return capability.promise;
          }
          sendWithStream(actionName, data, queueingStrategy, transfers) {
            const streamId = this.streamId++,
              sourceName = this.sourceName,
              targetName = this.targetName,
              comObj = this.comObj;
            return new ReadableStream({
              start: controller => {
                const startCapability = Promise.withResolvers();
                this.streamControllers[streamId] = {
                  controller,
                  startCall: startCapability,
                  pullCall: null,
                  cancelCall: null,
                  isClosed: false
                };
                comObj.postMessage({
                  sourceName,
                  targetName,
                  action: actionName,
                  streamId,
                  data,
                  desiredSize: controller.desiredSize
                }, transfers);
                return startCapability.promise;
              },
              pull: controller => {
                const pullCapability = Promise.withResolvers();
                this.streamControllers[streamId].pullCall = pullCapability;
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.PULL,
                  streamId,
                  desiredSize: controller.desiredSize
                });
                return pullCapability.promise;
              },
              cancel: reason => {
                assert(reason instanceof Error, "cancel must have a valid reason");
                const cancelCapability = Promise.withResolvers();
                this.streamControllers[streamId].cancelCall = cancelCapability;
                this.streamControllers[streamId].isClosed = true;
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.CANCEL,
                  streamId,
                  reason: wrapReason(reason)
                });
                return cancelCapability.promise;
              }
            }, queueingStrategy);
          }
          #createStreamSink(data) {
            const streamId = data.streamId,
              sourceName = this.sourceName,
              targetName = data.sourceName,
              comObj = this.comObj;
            const self = this,
              action = this.actionHandler[data.action];
            const streamSink = {
              enqueue(chunk, size = 1, transfers) {
                if (this.isCancelled) {
                  return;
                }
                const lastDesiredSize = this.desiredSize;
                this.desiredSize -= size;
                if (lastDesiredSize > 0 && this.desiredSize <= 0) {
                  this.sinkCapability = Promise.withResolvers();
                  this.ready = this.sinkCapability.promise;
                }
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.ENQUEUE,
                  streamId,
                  chunk
                }, transfers);
              },
              close() {
                if (this.isCancelled) {
                  return;
                }
                this.isCancelled = true;
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.CLOSE,
                  streamId
                });
                delete self.streamSinks[streamId];
              },
              error(reason) {
                assert(reason instanceof Error, "error must have a valid reason");
                if (this.isCancelled) {
                  return;
                }
                this.isCancelled = true;
                comObj.postMessage({
                  sourceName,
                  targetName,
                  stream: StreamKind.ERROR,
                  streamId,
                  reason: wrapReason(reason)
                });
              },
              sinkCapability: Promise.withResolvers(),
              onPull: null,
              onCancel: null,
              isCancelled: false,
              desiredSize: data.desiredSize,
              ready: null
            };
            streamSink.sinkCapability.resolve();
            streamSink.ready = streamSink.sinkCapability.promise;
            this.streamSinks[streamId] = streamSink;
            Promise.try(action, data.data, streamSink).then(function () {
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.START_COMPLETE,
                streamId,
                success: true
              });
            }, function (reason) {
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.START_COMPLETE,
                streamId,
                reason: wrapReason(reason)
              });
            });
          }
          #processStreamMessage(data) {
            const streamId = data.streamId,
              sourceName = this.sourceName,
              targetName = data.sourceName,
              comObj = this.comObj;
            const streamController = this.streamControllers[streamId],
              streamSink = this.streamSinks[streamId];
            switch (data.stream) {
              case StreamKind.START_COMPLETE:
                if (data.success) {
                  streamController.startCall.resolve();
                } else {
                  streamController.startCall.reject(wrapReason(data.reason));
                }
                break;
              case StreamKind.PULL_COMPLETE:
                if (data.success) {
                  streamController.pullCall.resolve();
                } else {
                  streamController.pullCall.reject(wrapReason(data.reason));
                }
                break;
              case StreamKind.PULL:
                if (!streamSink) {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.PULL_COMPLETE,
                    streamId,
                    success: true
                  });
                  break;
                }
                if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
                  streamSink.sinkCapability.resolve();
                }
                streamSink.desiredSize = data.desiredSize;
                Promise.try(streamSink.onPull || onFn).then(function () {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.PULL_COMPLETE,
                    streamId,
                    success: true
                  });
                }, function (reason) {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.PULL_COMPLETE,
                    streamId,
                    reason: wrapReason(reason)
                  });
                });
                break;
              case StreamKind.ENQUEUE:
                assert(streamController, "enqueue should have stream controller");
                if (streamController.isClosed) {
                  break;
                }
                streamController.controller.enqueue(data.chunk);
                break;
              case StreamKind.CLOSE:
                assert(streamController, "close should have stream controller");
                if (streamController.isClosed) {
                  break;
                }
                streamController.isClosed = true;
                streamController.controller.close();
                this.#deleteStreamController(streamController, streamId);
                break;
              case StreamKind.ERROR:
                assert(streamController, "error should have stream controller");
                streamController.controller.error(wrapReason(data.reason));
                this.#deleteStreamController(streamController, streamId);
                break;
              case StreamKind.CANCEL_COMPLETE:
                if (data.success) {
                  streamController.cancelCall.resolve();
                } else {
                  streamController.cancelCall.reject(wrapReason(data.reason));
                }
                this.#deleteStreamController(streamController, streamId);
                break;
              case StreamKind.CANCEL:
                if (!streamSink) {
                  break;
                }
                const dataReason = wrapReason(data.reason);
                Promise.try(streamSink.onCancel || onFn, dataReason).then(function () {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.CANCEL_COMPLETE,
                    streamId,
                    success: true
                  });
                }, function (reason) {
                  comObj.postMessage({
                    sourceName,
                    targetName,
                    stream: StreamKind.CANCEL_COMPLETE,
                    streamId,
                    reason: wrapReason(reason)
                  });
                });
                streamSink.sinkCapability.reject(dataReason);
                streamSink.isCancelled = true;
                delete this.streamSinks[streamId];
                break;
              default:
                throw new Error("Unexpected stream case");
            }
          }
          async #deleteStreamController(streamController, streamId) {
            await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);
            delete this.streamControllers[streamId];
          }
          destroy() {
            this.#messageAC?.abort();
            this.#messageAC = null;
          }
        }

        ;// ./src/display/canvas_factory.js

        class BaseCanvasFactory {
          #enableHWA = false;
          constructor({
            enableHWA = false
          }) {
            this.#enableHWA = enableHWA;
          }
          create(width, height) {
            if (width <= 0 || height <= 0) {
              throw new Error("Invalid canvas size");
            }
            const canvas = this._createCanvas(width, height);
            return {
              canvas,
              context: canvas.getContext("2d", {
                willReadFrequently: !this.#enableHWA
              })
            };
          }
          reset(canvasAndContext, width, height) {
            if (!canvasAndContext.canvas) {
              throw new Error("Canvas is not specified");
            }
            if (width <= 0 || height <= 0) {
              throw new Error("Invalid canvas size");
            }
            canvasAndContext.canvas.width = width;
            canvasAndContext.canvas.height = height;
          }
          destroy(canvasAndContext) {
            if (!canvasAndContext.canvas) {
              throw new Error("Canvas is not specified");
            }
            canvasAndContext.canvas.width = 0;
            canvasAndContext.canvas.height = 0;
            canvasAndContext.canvas = null;
            canvasAndContext.context = null;
          }
          _createCanvas(width, height) {
            unreachable("Abstract method `_createCanvas` called.");
          }
        }
        class DOMCanvasFactory extends BaseCanvasFactory {
          constructor({
            ownerDocument = globalThis.document,
            enableHWA = false
          }) {
            super({
              enableHWA
            });
            this._document = ownerDocument;
          }
          _createCanvas(width, height) {
            const canvas = this._document.createElement("canvas");
            canvas.width = width;
            canvas.height = height;
            return canvas;
          }
        }

        ;// ./src/display/cmap_reader_factory.js


        class BaseCMapReaderFactory {
          constructor({
            baseUrl = null,
            isCompressed = true
          }) {
            this.baseUrl = baseUrl;
            this.isCompressed = isCompressed;
          }
          async fetch({
            name
          }) {
            if (!this.baseUrl) {
              throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
            }
            if (!name) {
              throw new Error("CMap name must be specified.");
            }
            const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
            return this._fetch(url).then(cMapData => ({
              cMapData,
              isCompressed: this.isCompressed
            })).catch(reason => {
              throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
            });
          }
          async _fetch(url) {
            unreachable("Abstract method `_fetch` called.");
          }
        }
        class DOMCMapReaderFactory extends BaseCMapReaderFactory {
          async _fetch(url) {
            const data = await fetchData(url, this.isCompressed ? "arraybuffer" : "text");
            return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);
          }
        }

        ;// ./src/display/filter_factory.js


        class BaseFilterFactory {
          addFilter(maps) {
            return "none";
          }
          addHCMFilter(fgColor, bgColor) {
            return "none";
          }
          addAlphaFilter(map) {
            return "none";
          }
          addLuminosityFilter(map) {
            return "none";
          }
          addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
            return "none";
          }
          destroy(keepHCM = false) { }
        }
        class DOMFilterFactory extends BaseFilterFactory {
          #baseUrl;
          #_cache;
          #_defs;
          #docId;
          #document;
          #_hcmCache;
          #id = 0;
          constructor({
            docId,
            ownerDocument = globalThis.document
          }) {
            super();
            this.#docId = docId;
            this.#document = ownerDocument;
          }
          get #cache() {
            return this.#_cache ||= new Map();
          }
          get #hcmCache() {
            return this.#_hcmCache ||= new Map();
          }
          get #defs() {
            if (!this.#_defs) {
              const div = this.#document.createElement("div");
              const {
                style
              } = div;
              style.visibility = "hidden";
              style.contain = "strict";
              style.width = style.height = 0;
              style.position = "absolute";
              style.top = style.left = 0;
              style.zIndex = -1;
              const svg = this.#document.createElementNS(SVG_NS, "svg");
              svg.setAttribute("width", 0);
              svg.setAttribute("height", 0);
              this.#_defs = this.#document.createElementNS(SVG_NS, "defs");
              div.append(svg);
              svg.append(this.#_defs);
              this.#document.body.append(div);
            }
            return this.#_defs;
          }
          #createTables(maps) {
            if (maps.length === 1) {
              const mapR = maps[0];
              const buffer = new Array(256);
              for (let i = 0; i < 256; i++) {
                buffer[i] = mapR[i] / 255;
              }
              const table = buffer.join(",");
              return [table, table, table];
            }
            const [mapR, mapG, mapB] = maps;
            const bufferR = new Array(256);
            const bufferG = new Array(256);
            const bufferB = new Array(256);
            for (let i = 0; i < 256; i++) {
              bufferR[i] = mapR[i] / 255;
              bufferG[i] = mapG[i] / 255;
              bufferB[i] = mapB[i] / 255;
            }
            return [bufferR.join(","), bufferG.join(","), bufferB.join(",")];
          }
          #createUrl(id) {
            if (this.#baseUrl === undefined) {
              this.#baseUrl = "";
              const url = this.#document.URL;
              if (url !== this.#document.baseURI) {
                if (isDataScheme(url)) {
                  warn('#createUrl: ignore "data:"-URL for performance reasons.');
                } else {
                  this.#baseUrl = updateUrlHash(url, "");
                }
              }
            }
            return `url(${this.#baseUrl}#${id})`;
          }
          addFilter(maps) {
            if (!maps) {
              return "none";
            }
            let value = this.#cache.get(maps);
            if (value) {
              return value;
            }
            const [tableR, tableG, tableB] = this.#createTables(maps);
            const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;
            value = this.#cache.get(key);
            if (value) {
              this.#cache.set(maps, value);
              return value;
            }
            const id = `g_${this.#docId}_transfer_map_${this.#id++}`;
            const url = this.#createUrl(id);
            this.#cache.set(maps, url);
            this.#cache.set(key, url);
            const filter = this.#createFilter(id);
            this.#addTransferMapConversion(tableR, tableG, tableB, filter);
            return url;
          }
          addHCMFilter(fgColor, bgColor) {
            const key = `${fgColor}-${bgColor}`;
            const filterName = "base";
            let info = this.#hcmCache.get(filterName);
            if (info?.key === key) {
              return info.url;
            }
            if (info) {
              info.filter?.remove();
              info.key = key;
              info.url = "none";
              info.filter = null;
            } else {
              info = {
                key,
                url: "none",
                filter: null
              };
              this.#hcmCache.set(filterName, info);
            }
            if (!fgColor || !bgColor) {
              return info.url;
            }
            const fgRGB = this.#getRGB(fgColor);
            fgColor = Util.makeHexColor(...fgRGB);
            const bgRGB = this.#getRGB(bgColor);
            bgColor = Util.makeHexColor(...bgRGB);
            this.#defs.style.color = "";
            if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) {
              return info.url;
            }
            const map = new Array(256);
            for (let i = 0; i <= 255; i++) {
              const x = i / 255;
              map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
            }
            const table = map.join(",");
            const id = `g_${this.#docId}_hcm_filter`;
            const filter = info.filter = this.#createFilter(id);
            this.#addTransferMapConversion(table, table, table, filter);
            this.#addGrayConversion(filter);
            const getSteps = (c, n) => {
              const start = fgRGB[c] / 255;
              const end = bgRGB[c] / 255;
              const arr = new Array(n + 1);
              for (let i = 0; i <= n; i++) {
                arr[i] = start + i / n * (end - start);
              }
              return arr.join(",");
            };
            this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);
            info.url = this.#createUrl(id);
            return info.url;
          }
          addAlphaFilter(map) {
            let value = this.#cache.get(map);
            if (value) {
              return value;
            }
            const [tableA] = this.#createTables([map]);
            const key = `alpha_${tableA}`;
            value = this.#cache.get(key);
            if (value) {
              this.#cache.set(map, value);
              return value;
            }
            const id = `g_${this.#docId}_alpha_map_${this.#id++}`;
            const url = this.#createUrl(id);
            this.#cache.set(map, url);
            this.#cache.set(key, url);
            const filter = this.#createFilter(id);
            this.#addTransferMapAlphaConversion(tableA, filter);
            return url;
          }
          addLuminosityFilter(map) {
            let value = this.#cache.get(map || "luminosity");
            if (value) {
              return value;
            }
            let tableA, key;
            if (map) {
              [tableA] = this.#createTables([map]);
              key = `luminosity_${tableA}`;
            } else {
              key = "luminosity";
            }
            value = this.#cache.get(key);
            if (value) {
              this.#cache.set(map, value);
              return value;
            }
            const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;
            const url = this.#createUrl(id);
            this.#cache.set(map, url);
            this.#cache.set(key, url);
            const filter = this.#createFilter(id);
            this.#addLuminosityConversion(filter);
            if (map) {
              this.#addTransferMapAlphaConversion(tableA, filter);
            }
            return url;
          }
          addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
            const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;
            let info = this.#hcmCache.get(filterName);
            if (info?.key === key) {
              return info.url;
            }
            if (info) {
              info.filter?.remove();
              info.key = key;
              info.url = "none";
              info.filter = null;
            } else {
              info = {
                key,
                url: "none",
                filter: null
              };
              this.#hcmCache.set(filterName, info);
            }
            if (!fgColor || !bgColor) {
              return info.url;
            }
            const [fgRGB, bgRGB] = [fgColor, bgColor].map(this.#getRGB.bind(this));
            let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
            let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
            let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(this.#getRGB.bind(this));
            if (bgGray < fgGray) {
              [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];
            }
            this.#defs.style.color = "";
            const getSteps = (fg, bg, n) => {
              const arr = new Array(256);
              const step = (bgGray - fgGray) / n;
              const newStart = fg / 255;
              const newStep = (bg - fg) / (255 * n);
              let prev = 0;
              for (let i = 0; i <= n; i++) {
                const k = Math.round(fgGray + i * step);
                const value = newStart + i * newStep;
                for (let j = prev; j <= k; j++) {
                  arr[j] = value;
                }
                prev = k + 1;
              }
              for (let i = prev; i < 256; i++) {
                arr[i] = arr[prev - 1];
              }
              return arr.join(",");
            };
            const id = `g_${this.#docId}_hcm_${filterName}_filter`;
            const filter = info.filter = this.#createFilter(id);
            this.#addGrayConversion(filter);
            this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);
            info.url = this.#createUrl(id);
            return info.url;
          }
          destroy(keepHCM = false) {
            if (keepHCM && this.#_hcmCache?.size) {
              return;
            }
            this.#_defs?.parentNode.parentNode.remove();
            this.#_defs = null;
            this.#_cache?.clear();
            this.#_cache = null;
            this.#_hcmCache?.clear();
            this.#_hcmCache = null;
            this.#id = 0;
          }
          #addLuminosityConversion(filter) {
            const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0");
            filter.append(feColorMatrix);
          }
          #addGrayConversion(filter) {
            const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
            feColorMatrix.setAttribute("type", "matrix");
            feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
            filter.append(feColorMatrix);
          }
          #createFilter(id) {
            const filter = this.#document.createElementNS(SVG_NS, "filter");
            filter.setAttribute("color-interpolation-filters", "sRGB");
            filter.setAttribute("id", id);
            this.#defs.append(filter);
            return filter;
          }
          #appendFeFunc(feComponentTransfer, func, table) {
            const feFunc = this.#document.createElementNS(SVG_NS, func);
            feFunc.setAttribute("type", "discrete");
            feFunc.setAttribute("tableValues", table);
            feComponentTransfer.append(feFunc);
          }
          #addTransferMapConversion(rTable, gTable, bTable, filter) {
            const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
            filter.append(feComponentTransfer);
            this.#appendFeFunc(feComponentTransfer, "feFuncR", rTable);
            this.#appendFeFunc(feComponentTransfer, "feFuncG", gTable);
            this.#appendFeFunc(feComponentTransfer, "feFuncB", bTable);
          }
          #addTransferMapAlphaConversion(aTable, filter) {
            const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
            filter.append(feComponentTransfer);
            this.#appendFeFunc(feComponentTransfer, "feFuncA", aTable);
          }
          #getRGB(color) {
            this.#defs.style.color = color;
            return getRGB(getComputedStyle(this.#defs).getPropertyValue("color"));
          }
        }

        ;// ./src/display/standard_fontdata_factory.js


        class BaseStandardFontDataFactory {
          constructor({
            baseUrl = null
          }) {
            this.baseUrl = baseUrl;
          }
          async fetch({
            filename
          }) {
            if (!this.baseUrl) {
              throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
            }
            if (!filename) {
              throw new Error("Font filename must be specified.");
            }
            const url = `${this.baseUrl}${filename}`;
            return this._fetch(url).catch(reason => {
              throw new Error(`Unable to load font data at: ${url}`);
            });
          }
          async _fetch(url) {
            unreachable("Abstract method `_fetch` called.");
          }
        }
        class DOMStandardFontDataFactory extends BaseStandardFontDataFactory {
          async _fetch(url) {
            const data = await fetchData(url, "arraybuffer");
            return new Uint8Array(data);
          }
        }

        ;// ./src/display/wasm_factory.js


        class BaseWasmFactory {
          constructor({
            baseUrl = null
          }) {
            this.baseUrl = baseUrl;
          }
          async fetch({
            filename
          }) {
            if (!this.baseUrl) {
              throw new Error("Ensure that the `wasmUrl` API parameter is provided.");
            }
            if (!filename) {
              throw new Error("Wasm filename must be specified.");
            }
            const url = `${this.baseUrl}${filename}`;
            return this._fetch(url).catch(reason => {
              throw new Error(`Unable to load wasm data at: ${url}`);
            });
          }
          async _fetch(url) {
            unreachable("Abstract method `_fetch` called.");
          }
        }
        class DOMWasmFactory extends BaseWasmFactory {
          async _fetch(url) {
            const data = await fetchData(url, "arraybuffer");
            return new Uint8Array(data);
          }
        }

        ;// ./src/display/node_utils.js






        if (isNodeJS) {
          warn("Please use the `legacy` build in Node.js environments.");
        }
        async function node_utils_fetchData(url) {
          const fs = process.getBuiltinModule("fs");
          const data = await fs.promises.readFile(url);
          return new Uint8Array(data);
        }
        class NodeFilterFactory extends BaseFilterFactory { }
        class NodeCanvasFactory extends BaseCanvasFactory {
          _createCanvas(width, height) {
            const require = process.getBuiltinModule("module").createRequire("file:///Users/fellou/Desktop/fellou/eko/node_modules/.pnpm/pdfjs-dist@5.4.394/node_modules/pdfjs-dist/build/pdf.mjs");
            const canvas = require("@napi-rs/canvas");
            return canvas.createCanvas(width, height);
          }
        }
        class NodeCMapReaderFactory extends BaseCMapReaderFactory {
          async _fetch(url) {
            return node_utils_fetchData(url);
          }
        }
        class NodeStandardFontDataFactory extends BaseStandardFontDataFactory {
          async _fetch(url) {
            return node_utils_fetchData(url);
          }
        }
        class NodeWasmFactory extends BaseWasmFactory {
          async _fetch(url) {
            return node_utils_fetchData(url);
          }
        }

        ;// ./src/display/canvas_dependency_tracker.js

        const FORCED_DEPENDENCY_LABEL = "__forcedDependency";
        const {
          floor,
          ceil
        } = Math;
        function expandBBox(array, index, minX, minY, maxX, maxY) {
          array[index * 4 + 0] = Math.min(array[index * 4 + 0], minX);
          array[index * 4 + 1] = Math.min(array[index * 4 + 1], minY);
          array[index * 4 + 2] = Math.max(array[index * 4 + 2], maxX);
          array[index * 4 + 3] = Math.max(array[index * 4 + 3], maxY);
        }
        const EMPTY_BBOX = new Uint32Array(new Uint8Array([255, 255, 0, 0]).buffer)[0];
        class BBoxReader {
          #bboxes;
          #coords;
          constructor(bboxes, coords) {
            this.#bboxes = bboxes;
            this.#coords = coords;
          }
          get length() {
            return this.#bboxes.length;
          }
          isEmpty(i) {
            return this.#bboxes[i] === EMPTY_BBOX;
          }
          minX(i) {
            return this.#coords[i * 4 + 0] / 256;
          }
          minY(i) {
            return this.#coords[i * 4 + 1] / 256;
          }
          maxX(i) {
            return (this.#coords[i * 4 + 2] + 1) / 256;
          }
          maxY(i) {
            return (this.#coords[i * 4 + 3] + 1) / 256;
          }
        }
        const ensureDebugMetadata = (map, key) => {
          if (!map) {
            return undefined;
          }
          let value = map.get(key);
          if (!value) {
            value = {
              dependencies: new Set(),
              isRenderingOperation: false
            };
            map.set(key, value);
          }
          return value;
        };
        class CanvasDependencyTracker {
          #simple = {
            __proto__: null
          };
          #incremental = {
            __proto__: null,
            transform: [],
            moveText: [],
            sameLineText: [],
            [FORCED_DEPENDENCY_LABEL]: []
          };
          #namedDependencies = new Map();
          #savesStack = [];
          #markedContentStack = [];
          #baseTransformStack = [[1, 0, 0, 1, 0, 0]];
          #clipBox = [-Infinity, -Infinity, Infinity, Infinity];
          #pendingBBox = new Float64Array([Infinity, Infinity, -Infinity, -Infinity]);
          #pendingBBoxIdx = -1;
          #pendingDependencies = new Set();
          #operations = new Map();
          #fontBBoxTrustworthy = new Map();
          #canvasWidth;
          #canvasHeight;
          #bboxesCoords;
          #bboxes;
          #debugMetadata;
          constructor(canvas, operationsCount, recordDebugMetadata = false) {
            this.#canvasWidth = canvas.width;
            this.#canvasHeight = canvas.height;
            this.#initializeBBoxes(operationsCount);
            if (recordDebugMetadata) {
              this.#debugMetadata = new Map();
            }
          }
          growOperationsCount(operationsCount) {
            if (operationsCount >= this.#bboxes.length) {
              this.#initializeBBoxes(operationsCount, this.#bboxes);
            }
          }
          #initializeBBoxes(operationsCount, oldBBoxes) {
            const buffer = new ArrayBuffer(operationsCount * 4);
            this.#bboxesCoords = new Uint8ClampedArray(buffer);
            this.#bboxes = new Uint32Array(buffer);
            if (oldBBoxes && oldBBoxes.length > 0) {
              this.#bboxes.set(oldBBoxes);
              this.#bboxes.fill(EMPTY_BBOX, oldBBoxes.length);
            } else {
              this.#bboxes.fill(EMPTY_BBOX);
            }
          }
          save(opIdx) {
            this.#simple = {
              __proto__: this.#simple
            };
            this.#incremental = {
              __proto__: this.#incremental,
              transform: {
                __proto__: this.#incremental.transform
              },
              moveText: {
                __proto__: this.#incremental.moveText
              },
              sameLineText: {
                __proto__: this.#incremental.sameLineText
              },
              [FORCED_DEPENDENCY_LABEL]: {
                __proto__: this.#incremental[FORCED_DEPENDENCY_LABEL]
              }
            };
            this.#clipBox = {
              __proto__: this.#clipBox
            };
            this.#savesStack.push(opIdx);
            return this;
          }
          restore(opIdx) {
            const previous = Object.getPrototypeOf(this.#simple);
            if (previous === null) {
              return this;
            }
            this.#simple = previous;
            this.#incremental = Object.getPrototypeOf(this.#incremental);
            this.#clipBox = Object.getPrototypeOf(this.#clipBox);
            const lastSave = this.#savesStack.pop();
            if (lastSave !== undefined) {
              ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);
              this.#bboxes[opIdx] = this.#bboxes[lastSave];
            }
            return this;
          }
          recordOpenMarker(idx) {
            this.#savesStack.push(idx);
            return this;
          }
          getOpenMarker() {
            if (this.#savesStack.length === 0) {
              return null;
            }
            return this.#savesStack.at(-1);
          }
          recordCloseMarker(opIdx) {
            const lastSave = this.#savesStack.pop();
            if (lastSave !== undefined) {
              ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);
              this.#bboxes[opIdx] = this.#bboxes[lastSave];
            }
            return this;
          }
          beginMarkedContent(opIdx) {
            this.#markedContentStack.push(opIdx);
            return this;
          }
          endMarkedContent(opIdx) {
            const lastSave = this.#markedContentStack.pop();
            if (lastSave !== undefined) {
              ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);
              this.#bboxes[opIdx] = this.#bboxes[lastSave];
            }
            return this;
          }
          pushBaseTransform(ctx) {
            this.#baseTransformStack.push(Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform()));
            return this;
          }
          popBaseTransform() {
            if (this.#baseTransformStack.length > 1) {
              this.#baseTransformStack.pop();
            }
            return this;
          }
          recordSimpleData(name, idx) {
            this.#simple[name] = idx;
            return this;
          }
          recordIncrementalData(name, idx) {
            this.#incremental[name].push(idx);
            return this;
          }
          resetIncrementalData(name, idx) {
            this.#incremental[name].length = 0;
            return this;
          }
          recordNamedData(name, idx) {
            this.#namedDependencies.set(name, idx);
            return this;
          }
          recordSimpleDataFromNamed(name, depName, fallbackIdx) {
            this.#simple[name] = this.#namedDependencies.get(depName) ?? fallbackIdx;
          }
          recordFutureForcedDependency(name, idx) {
            this.recordIncrementalData(FORCED_DEPENDENCY_LABEL, idx);
            return this;
          }
          inheritSimpleDataAsFutureForcedDependencies(names) {
            for (const name of names) {
              if (name in this.#simple) {
                this.recordFutureForcedDependency(name, this.#simple[name]);
              }
            }
            return this;
          }
          inheritPendingDependenciesAsFutureForcedDependencies() {
            for (const dep of this.#pendingDependencies) {
              this.recordFutureForcedDependency(FORCED_DEPENDENCY_LABEL, dep);
            }
            return this;
          }
          resetBBox(idx) {
            if (this.#pendingBBoxIdx !== idx) {
              this.#pendingBBoxIdx = idx;
              this.#pendingBBox[0] = Infinity;
              this.#pendingBBox[1] = Infinity;
              this.#pendingBBox[2] = -Infinity;
              this.#pendingBBox[3] = -Infinity;
            }
            return this;
          }
          recordClipBox(idx, ctx, minX, maxX, minY, maxY) {
            const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());
            const clipBox = [Infinity, Infinity, -Infinity, -Infinity];
            Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, clipBox);
            const intersection = Util.intersect(this.#clipBox, clipBox);
            if (intersection) {
              this.#clipBox[0] = intersection[0];
              this.#clipBox[1] = intersection[1];
              this.#clipBox[2] = intersection[2];
              this.#clipBox[3] = intersection[3];
            } else {
              this.#clipBox[0] = this.#clipBox[1] = Infinity;
              this.#clipBox[2] = this.#clipBox[3] = -Infinity;
            }
            return this;
          }
          recordBBox(idx, ctx, minX, maxX, minY, maxY) {
            const clipBox = this.#clipBox;
            if (clipBox[0] === Infinity) {
              return this;
            }
            const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());
            if (clipBox[0] === -Infinity) {
              Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, this.#pendingBBox);
              return this;
            }
            const bbox = [Infinity, Infinity, -Infinity, -Infinity];
            Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, bbox);
            this.#pendingBBox[0] = Math.min(this.#pendingBBox[0], Math.max(bbox[0], clipBox[0]));
            this.#pendingBBox[1] = Math.min(this.#pendingBBox[1], Math.max(bbox[1], clipBox[1]));
            this.#pendingBBox[2] = Math.max(this.#pendingBBox[2], Math.min(bbox[2], clipBox[2]));
            this.#pendingBBox[3] = Math.max(this.#pendingBBox[3], Math.min(bbox[3], clipBox[3]));
            return this;
          }
          recordCharacterBBox(idx, ctx, font, scale = 1, x = 0, y = 0, getMeasure) {
            const fontBBox = font.bbox;
            let isBBoxTrustworthy;
            let computedBBox;
            if (fontBBox) {
              isBBoxTrustworthy = fontBBox[2] !== fontBBox[0] && fontBBox[3] !== fontBBox[1] && this.#fontBBoxTrustworthy.get(font);
              if (isBBoxTrustworthy !== false) {
                computedBBox = [0, 0, 0, 0];
                Util.axialAlignedBoundingBox(fontBBox, font.fontMatrix, computedBBox);
                if (scale !== 1 || x !== 0 || y !== 0) {
                  Util.scaleMinMax([scale, 0, 0, -scale, x, y], computedBBox);
                }
                if (isBBoxTrustworthy) {
                  return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);
                }
              }
            }
            if (!getMeasure) {
              return this.recordFullPageBBox(idx);
            }
            const measure = getMeasure();
            if (fontBBox && computedBBox && isBBoxTrustworthy === undefined) {
              isBBoxTrustworthy = computedBBox[0] <= x - measure.actualBoundingBoxLeft && computedBBox[2] >= x + measure.actualBoundingBoxRight && computedBBox[1] <= y - measure.actualBoundingBoxAscent && computedBBox[3] >= y + measure.actualBoundingBoxDescent;
              this.#fontBBoxTrustworthy.set(font, isBBoxTrustworthy);
              if (isBBoxTrustworthy) {
                return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);
              }
            }
            return this.recordBBox(idx, ctx, x - measure.actualBoundingBoxLeft, x + measure.actualBoundingBoxRight, y - measure.actualBoundingBoxAscent, y + measure.actualBoundingBoxDescent);
          }
          recordFullPageBBox(idx) {
            this.#pendingBBox[0] = Math.max(0, this.#clipBox[0]);
            this.#pendingBBox[1] = Math.max(0, this.#clipBox[1]);
            this.#pendingBBox[2] = Math.min(this.#canvasWidth, this.#clipBox[2]);
            this.#pendingBBox[3] = Math.min(this.#canvasHeight, this.#clipBox[3]);
            return this;
          }
          getSimpleIndex(dependencyName) {
            return this.#simple[dependencyName];
          }
          recordDependencies(idx, dependencyNames) {
            const pendingDependencies = this.#pendingDependencies;
            const simple = this.#simple;
            const incremental = this.#incremental;
            for (const name of dependencyNames) {
              if (name in this.#simple) {
                pendingDependencies.add(simple[name]);
              } else if (name in incremental) {
                incremental[name].forEach(pendingDependencies.add, pendingDependencies);
              }
            }
            return this;
          }
          recordNamedDependency(idx, name) {
            if (this.#namedDependencies.has(name)) {
              this.#pendingDependencies.add(this.#namedDependencies.get(name));
            }
            return this;
          }
          recordOperation(idx, preserve = false) {
            this.recordDependencies(idx, [FORCED_DEPENDENCY_LABEL]);
            if (this.#debugMetadata) {
              const metadata = ensureDebugMetadata(this.#debugMetadata, idx);
              const {
                dependencies
              } = metadata;
              this.#pendingDependencies.forEach(dependencies.add, dependencies);
              this.#savesStack.forEach(dependencies.add, dependencies);
              this.#markedContentStack.forEach(dependencies.add, dependencies);
              dependencies.delete(idx);
              metadata.isRenderingOperation = true;
            }
            if (this.#pendingBBoxIdx === idx) {
              const minX = floor(this.#pendingBBox[0] * 256 / this.#canvasWidth);
              const minY = floor(this.#pendingBBox[1] * 256 / this.#canvasHeight);
              const maxX = ceil(this.#pendingBBox[2] * 256 / this.#canvasWidth);
              const maxY = ceil(this.#pendingBBox[3] * 256 / this.#canvasHeight);
              expandBBox(this.#bboxesCoords, idx, minX, minY, maxX, maxY);
              for (const depIdx of this.#pendingDependencies) {
                if (depIdx !== idx) {
                  expandBBox(this.#bboxesCoords, depIdx, minX, minY, maxX, maxY);
                }
              }
              for (const saveIdx of this.#savesStack) {
                if (saveIdx !== idx) {
                  expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);
                }
              }
              for (const saveIdx of this.#markedContentStack) {
                if (saveIdx !== idx) {
                  expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);
                }
              }
              if (!preserve) {
                this.#pendingDependencies.clear();
                this.#pendingBBoxIdx = -1;
              }
            }
            return this;
          }
          recordShowTextOperation(idx, preserve = false) {
            const deps = Array.from(this.#pendingDependencies);
            this.recordOperation(idx, preserve);
            this.recordIncrementalData("sameLineText", idx);
            for (const dep of deps) {
              this.recordIncrementalData("sameLineText", dep);
            }
            return this;
          }
          bboxToClipBoxDropOperation(idx, preserve = false) {
            if (this.#pendingBBoxIdx === idx) {
              this.#pendingBBoxIdx = -1;
              this.#clipBox[0] = Math.max(this.#clipBox[0], this.#pendingBBox[0]);
              this.#clipBox[1] = Math.max(this.#clipBox[1], this.#pendingBBox[1]);
              this.#clipBox[2] = Math.min(this.#clipBox[2], this.#pendingBBox[2]);
              this.#clipBox[3] = Math.min(this.#clipBox[3], this.#pendingBBox[3]);
              if (!preserve) {
                this.#pendingDependencies.clear();
              }
            }
            return this;
          }
          _takePendingDependencies() {
            const pendingDependencies = this.#pendingDependencies;
            this.#pendingDependencies = new Set();
            return pendingDependencies;
          }
          _extractOperation(idx) {
            const operation = this.#operations.get(idx);
            this.#operations.delete(idx);
            return operation;
          }
          _pushPendingDependencies(dependencies) {
            for (const dep of dependencies) {
              this.#pendingDependencies.add(dep);
            }
          }
          take() {
            this.#fontBBoxTrustworthy.clear();
            return new BBoxReader(this.#bboxes, this.#bboxesCoords);
          }
          takeDebugMetadata() {
            return this.#debugMetadata;
          }
        }
        class CanvasNestedDependencyTracker {
          #dependencyTracker;
          #opIdx;
          #ignoreBBoxes;
          #nestingLevel = 0;
          #savesLevel = 0;
          constructor(dependencyTracker, opIdx, ignoreBBoxes) {
            if (dependencyTracker instanceof CanvasNestedDependencyTracker && dependencyTracker.#ignoreBBoxes === !!ignoreBBoxes) {
              return dependencyTracker;
            }
            this.#dependencyTracker = dependencyTracker;
            this.#opIdx = opIdx;
            this.#ignoreBBoxes = !!ignoreBBoxes;
          }
          growOperationsCount() {
            throw new Error("Unreachable");
          }
          save(opIdx) {
            this.#savesLevel++;
            this.#dependencyTracker.save(this.#opIdx);
            return this;
          }
          restore(opIdx) {
            if (this.#savesLevel > 0) {
              this.#dependencyTracker.restore(this.#opIdx);
              this.#savesLevel--;
            }
            return this;
          }
          recordOpenMarker(idx) {
            this.#nestingLevel++;
            return this;
          }
          getOpenMarker() {
            return this.#nestingLevel > 0 ? this.#opIdx : this.#dependencyTracker.getOpenMarker();
          }
          recordCloseMarker(idx) {
            this.#nestingLevel--;
            return this;
          }
          beginMarkedContent(opIdx) {
            return this;
          }
          endMarkedContent(opIdx) {
            return this;
          }
          pushBaseTransform(ctx) {
            this.#dependencyTracker.pushBaseTransform(ctx);
            return this;
          }
          popBaseTransform() {
            this.#dependencyTracker.popBaseTransform();
            return this;
          }
          recordSimpleData(name, idx) {
            this.#dependencyTracker.recordSimpleData(name, this.#opIdx);
            return this;
          }
          recordIncrementalData(name, idx) {
            this.#dependencyTracker.recordIncrementalData(name, this.#opIdx);
            return this;
          }
          resetIncrementalData(name, idx) {
            this.#dependencyTracker.resetIncrementalData(name, this.#opIdx);
            return this;
          }
          recordNamedData(name, idx) {
            return this;
          }
          recordSimpleDataFromNamed(name, depName, fallbackIdx) {
            this.#dependencyTracker.recordSimpleDataFromNamed(name, depName, this.#opIdx);
            return this;
          }
          recordFutureForcedDependency(name, idx) {
            this.#dependencyTracker.recordFutureForcedDependency(name, this.#opIdx);
            return this;
          }
          inheritSimpleDataAsFutureForcedDependencies(names) {
            this.#dependencyTracker.inheritSimpleDataAsFutureForcedDependencies(names);
            return this;
          }
          inheritPendingDependenciesAsFutureForcedDependencies() {
            this.#dependencyTracker.inheritPendingDependenciesAsFutureForcedDependencies();
            return this;
          }
          resetBBox(idx) {
            if (!this.#ignoreBBoxes) {
              this.#dependencyTracker.resetBBox(this.#opIdx);
            }
            return this;
          }
          recordClipBox(idx, ctx, minX, maxX, minY, maxY) {
            if (!this.#ignoreBBoxes) {
              this.#dependencyTracker.recordClipBox(this.#opIdx, ctx, minX, maxX, minY, maxY);
            }
            return this;
          }
          recordBBox(idx, ctx, minX, maxX, minY, maxY) {
            if (!this.#ignoreBBoxes) {
              this.#dependencyTracker.recordBBox(this.#opIdx, ctx, minX, maxX, minY, maxY);
            }
            return this;
          }
          recordCharacterBBox(idx, ctx, font, scale, x, y, getMeasure) {
            if (!this.#ignoreBBoxes) {
              this.#dependencyTracker.recordCharacterBBox(this.#opIdx, ctx, font, scale, x, y, getMeasure);
            }
            return this;
          }
          recordFullPageBBox(idx) {
            if (!this.#ignoreBBoxes) {
              this.#dependencyTracker.recordFullPageBBox(this.#opIdx);
            }
            return this;
          }
          getSimpleIndex(dependencyName) {
            return this.#dependencyTracker.getSimpleIndex(dependencyName);
          }
          recordDependencies(idx, dependencyNames) {
            this.#dependencyTracker.recordDependencies(this.#opIdx, dependencyNames);
            return this;
          }
          recordNamedDependency(idx, name) {
            this.#dependencyTracker.recordNamedDependency(this.#opIdx, name);
            return this;
          }
          recordOperation(idx) {
            this.#dependencyTracker.recordOperation(this.#opIdx, true);
            return this;
          }
          recordShowTextOperation(idx) {
            this.#dependencyTracker.recordShowTextOperation(this.#opIdx, true);
            return this;
          }
          bboxToClipBoxDropOperation(idx) {
            if (!this.#ignoreBBoxes) {
              this.#dependencyTracker.bboxToClipBoxDropOperation(this.#opIdx, true);
            }
            return this;
          }
          take() {
            throw new Error("Unreachable");
          }
          takeDebugMetadata() {
            throw new Error("Unreachable");
          }
        }
        const Dependencies = {
          stroke: ["path", "transform", "filter", "strokeColor", "strokeAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "dash"],
          fill: ["path", "transform", "filter", "fillColor", "fillAlpha", "globalCompositeOperation", "SMask"],
          imageXObject: ["transform", "SMask", "filter", "fillAlpha", "strokeAlpha", "globalCompositeOperation"],
          rawFillPath: ["filter", "fillColor", "fillAlpha"],
          showText: ["transform", "leading", "charSpacing", "wordSpacing", "hScale", "textRise", "moveText", "textMatrix", "font", "fontObj", "filter", "fillColor", "textRenderingMode", "SMask", "fillAlpha", "strokeAlpha", "globalCompositeOperation", "sameLineText"],
          transform: ["transform"],
          transformAndFill: ["transform", "fillColor"]
        };

        ;// ./src/display/pattern_helper.js


        const PathType = {
          FILL: "Fill",
          STROKE: "Stroke",
          SHADING: "Shading"
        };
        function applyBoundingBox(ctx, bbox) {
          if (!bbox) {
            return;
          }
          const width = bbox[2] - bbox[0];
          const height = bbox[3] - bbox[1];
          const region = new Path2D();
          region.rect(bbox[0], bbox[1], width, height);
          ctx.clip(region);
        }
        class BaseShadingPattern {
          isModifyingCurrentTransform() {
            return false;
          }
          getPattern() {
            unreachable("Abstract method `getPattern` called.");
          }
        }
        class RadialAxialShadingPattern extends BaseShadingPattern {
          constructor(IR) {
            super();
            this._type = IR[1];
            this._bbox = IR[2];
            this._colorStops = IR[3];
            this._p0 = IR[4];
            this._p1 = IR[5];
            this._r0 = IR[6];
            this._r1 = IR[7];
            this.matrix = null;
          }
          _createGradient(ctx) {
            let grad;
            if (this._type === "axial") {
              grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
            } else if (this._type === "radial") {
              grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
            }
            for (const colorStop of this._colorStops) {
              grad.addColorStop(colorStop[0], colorStop[1]);
            }
            return grad;
          }
          getPattern(ctx, owner, inverse, pathType) {
            let pattern;
            if (pathType === PathType.STROKE || pathType === PathType.FILL) {
              const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [0, 0, 0, 0];
              const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
              const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
              const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height);
              const tmpCtx = tmpCanvas.context;
              tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
              tmpCtx.beginPath();
              tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
              tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
              inverse = Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
              tmpCtx.transform(...owner.baseTransform);
              if (this.matrix) {
                tmpCtx.transform(...this.matrix);
              }
              applyBoundingBox(tmpCtx, this._bbox);
              tmpCtx.fillStyle = this._createGradient(tmpCtx);
              tmpCtx.fill();
              pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
              const domMatrix = new DOMMatrix(inverse);
              pattern.setTransform(domMatrix);
            } else {
              applyBoundingBox(ctx, this._bbox);
              pattern = this._createGradient(ctx);
            }
            return pattern;
          }
        }
        function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
          const coords = context.coords,
            colors = context.colors;
          const bytes = data.data,
            rowSize = data.width * 4;
          let tmp;
          if (coords[p1 + 1] > coords[p2 + 1]) {
            tmp = p1;
            p1 = p2;
            p2 = tmp;
            tmp = c1;
            c1 = c2;
            c2 = tmp;
          }
          if (coords[p2 + 1] > coords[p3 + 1]) {
            tmp = p2;
            p2 = p3;
            p3 = tmp;
            tmp = c2;
            c2 = c3;
            c3 = tmp;
          }
          if (coords[p1 + 1] > coords[p2 + 1]) {
            tmp = p1;
            p1 = p2;
            p2 = tmp;
            tmp = c1;
            c1 = c2;
            c2 = tmp;
          }
          const x1 = (coords[p1] + context.offsetX) * context.scaleX;
          const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
          const x2 = (coords[p2] + context.offsetX) * context.scaleX;
          const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
          const x3 = (coords[p3] + context.offsetX) * context.scaleX;
          const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
          if (y1 >= y3) {
            return;
          }
          const c1r = colors[c1],
            c1g = colors[c1 + 1],
            c1b = colors[c1 + 2];
          const c2r = colors[c2],
            c2g = colors[c2 + 1],
            c2b = colors[c2 + 2];
          const c3r = colors[c3],
            c3g = colors[c3 + 1],
            c3b = colors[c3 + 2];
          const minY = Math.round(y1),
            maxY = Math.round(y3);
          let xa, car, cag, cab;
          let xb, cbr, cbg, cbb;
          for (let y = minY; y <= maxY; y++) {
            if (y < y2) {
              const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);
              xa = x1 - (x1 - x2) * k;
              car = c1r - (c1r - c2r) * k;
              cag = c1g - (c1g - c2g) * k;
              cab = c1b - (c1b - c2b) * k;
            } else {
              let k;
              if (y > y3) {
                k = 1;
              } else if (y2 === y3) {
                k = 0;
              } else {
                k = (y2 - y) / (y2 - y3);
              }
              xa = x2 - (x2 - x3) * k;
              car = c2r - (c2r - c3r) * k;
              cag = c2g - (c2g - c3g) * k;
              cab = c2b - (c2b - c3b) * k;
            }
            let k;
            if (y < y1) {
              k = 0;
            } else if (y > y3) {
              k = 1;
            } else {
              k = (y1 - y) / (y1 - y3);
            }
            xb = x1 - (x1 - x3) * k;
            cbr = c1r - (c1r - c3r) * k;
            cbg = c1g - (c1g - c3g) * k;
            cbb = c1b - (c1b - c3b) * k;
            const x1_ = Math.round(Math.min(xa, xb));
            const x2_ = Math.round(Math.max(xa, xb));
            let j = rowSize * y + x1_ * 4;
            for (let x = x1_; x <= x2_; x++) {
              k = (xa - x) / (xa - xb);
              if (k < 0) {
                k = 0;
              } else if (k > 1) {
                k = 1;
              }
              bytes[j++] = car - (car - cbr) * k | 0;
              bytes[j++] = cag - (cag - cbg) * k | 0;
              bytes[j++] = cab - (cab - cbb) * k | 0;
              bytes[j++] = 255;
            }
          }
        }
        function drawFigure(data, figure, context) {
          const ps = figure.coords;
          const cs = figure.colors;
          let i, ii;
          switch (figure.type) {
            case MeshFigureType.LATTICE:
              const verticesPerRow = figure.verticesPerRow;
              const rows = Math.floor(ps.length / verticesPerRow) - 1;
              const cols = verticesPerRow - 1;
              for (i = 0; i < rows; i++) {
                let q = i * verticesPerRow;
                for (let j = 0; j < cols; j++, q++) {
                  drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
                  drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
                }
              }
              break;
            case MeshFigureType.TRIANGLES:
              for (i = 0, ii = ps.length; i < ii; i += 3) {
                drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
              }
              break;
            default:
              throw new Error("illegal figure");
          }
        }
        class MeshShadingPattern extends BaseShadingPattern {
          constructor(IR) {
            super();
            this._coords = IR[2];
            this._colors = IR[3];
            this._figures = IR[4];
            this._bounds = IR[5];
            this._bbox = IR[6];
            this._background = IR[7];
            this.matrix = null;
          }
          _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
            const EXPECTED_SCALE = 1.1;
            const MAX_PATTERN_SIZE = 3000;
            const BORDER_SIZE = 2;
            const offsetX = Math.floor(this._bounds[0]);
            const offsetY = Math.floor(this._bounds[1]);
            const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
            const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
            const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
            const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
            const scaleX = boundsWidth / width;
            const scaleY = boundsHeight / height;
            const context = {
              coords: this._coords,
              colors: this._colors,
              offsetX: -offsetX,
              offsetY: -offsetY,
              scaleX: 1 / scaleX,
              scaleY: 1 / scaleY
            };
            const paddedWidth = width + BORDER_SIZE * 2;
            const paddedHeight = height + BORDER_SIZE * 2;
            const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight);
            const tmpCtx = tmpCanvas.context;
            const data = tmpCtx.createImageData(width, height);
            if (backgroundColor) {
              const bytes = data.data;
              for (let i = 0, ii = bytes.length; i < ii; i += 4) {
                bytes[i] = backgroundColor[0];
                bytes[i + 1] = backgroundColor[1];
                bytes[i + 2] = backgroundColor[2];
                bytes[i + 3] = 255;
              }
            }
            for (const figure of this._figures) {
              drawFigure(data, figure, context);
            }
            tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
            const canvas = tmpCanvas.canvas;
            return {
              canvas,
              offsetX: offsetX - BORDER_SIZE * scaleX,
              offsetY: offsetY - BORDER_SIZE * scaleY,
              scaleX,
              scaleY
            };
          }
          isModifyingCurrentTransform() {
            return true;
          }
          getPattern(ctx, owner, inverse, pathType) {
            applyBoundingBox(ctx, this._bbox);
            const scale = new Float32Array(2);
            if (pathType === PathType.SHADING) {
              Util.singularValueDecompose2dScale(getCurrentTransform(ctx), scale);
            } else if (this.matrix) {
              Util.singularValueDecompose2dScale(this.matrix, scale);
              const [matrixScaleX, matrixScaleY] = scale;
              Util.singularValueDecompose2dScale(owner.baseTransform, scale);
              scale[0] *= matrixScaleX;
              scale[1] *= matrixScaleY;
            } else {
              Util.singularValueDecompose2dScale(owner.baseTransform, scale);
            }
            const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
            if (pathType !== PathType.SHADING) {
              ctx.setTransform(...owner.baseTransform);
              if (this.matrix) {
                ctx.transform(...this.matrix);
              }
            }
            ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
            ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
            return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
          }
        }
        class DummyShadingPattern extends BaseShadingPattern {
          getPattern() {
            return "hotpink";
          }
        }
        function getShadingPattern(IR) {
          switch (IR[0]) {
            case "RadialAxial":
              return new RadialAxialShadingPattern(IR);
            case "Mesh":
              return new MeshShadingPattern(IR);
            case "Dummy":
              return new DummyShadingPattern();
          }
          throw new Error(`Unknown IR type: ${IR[0]}`);
        }
        const PaintType = {
          COLORED: 1,
          UNCOLORED: 2
        };
        class TilingPattern {
          static MAX_PATTERN_SIZE = 3000;
          constructor(IR, ctx, canvasGraphicsFactory, baseTransform) {
            this.color = IR[1];
            this.operatorList = IR[2];
            this.matrix = IR[3];
            this.bbox = IR[4];
            this.xstep = IR[5];
            this.ystep = IR[6];
            this.paintType = IR[7];
            this.tilingType = IR[8];
            this.ctx = ctx;
            this.canvasGraphicsFactory = canvasGraphicsFactory;
            this.baseTransform = baseTransform;
          }
          createPatternCanvas(owner, opIdx) {
            const {
              bbox,
              operatorList,
              paintType,
              tilingType,
              color,
              canvasGraphicsFactory
            } = this;
            let {
              xstep,
              ystep
            } = this;
            xstep = Math.abs(xstep);
            ystep = Math.abs(ystep);
            info("TilingType: " + tilingType);
            const x0 = bbox[0],
              y0 = bbox[1],
              x1 = bbox[2],
              y1 = bbox[3];
            const width = x1 - x0;
            const height = y1 - y0;
            const scale = new Float32Array(2);
            Util.singularValueDecompose2dScale(this.matrix, scale);
            const [matrixScaleX, matrixScaleY] = scale;
            Util.singularValueDecompose2dScale(this.baseTransform, scale);
            const combinedScaleX = matrixScaleX * scale[0];
            const combinedScaleY = matrixScaleY * scale[1];
            let canvasWidth = width,
              canvasHeight = height,
              redrawHorizontally = false,
              redrawVertically = false;
            const xScaledStep = Math.ceil(xstep * combinedScaleX);
            const yScaledStep = Math.ceil(ystep * combinedScaleY);
            const xScaledWidth = Math.ceil(width * combinedScaleX);
            const yScaledHeight = Math.ceil(height * combinedScaleY);
            if (xScaledStep >= xScaledWidth) {
              canvasWidth = xstep;
            } else {
              redrawHorizontally = true;
            }
            if (yScaledStep >= yScaledHeight) {
              canvasHeight = ystep;
            } else {
              redrawVertically = true;
            }
            const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
            const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
            const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size);
            const tmpCtx = tmpCanvas.context;
            const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx, opIdx);
            graphics.groupLevel = owner.groupLevel;
            this.setFillAndStrokeStyleToContext(graphics, paintType, color);
            tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);
            graphics.transform(0, dimx.scale, 0, 0, dimy.scale, 0, 0);
            tmpCtx.save();
            graphics.dependencyTracker?.save();
            this.clipBbox(graphics, x0, y0, x1, y1);
            graphics.baseTransform = getCurrentTransform(graphics.ctx);
            graphics.executeOperatorList(operatorList);
            graphics.endDrawing();
            graphics.dependencyTracker?.restore();
            tmpCtx.restore();
            if (redrawHorizontally || redrawVertically) {
              const image = tmpCanvas.canvas;
              if (redrawHorizontally) {
                canvasWidth = xstep;
              }
              if (redrawVertically) {
                canvasHeight = ystep;
              }
              const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
              const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
              const xSize = dimx2.size;
              const ySize = dimy2.size;
              const tmpCanvas2 = owner.cachedCanvases.getCanvas("pattern-workaround", xSize, ySize);
              const tmpCtx2 = tmpCanvas2.context;
              const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;
              const jj = redrawVertically ? Math.floor(height / ystep) : 0;
              for (let i = 0; i <= ii; i++) {
                for (let j = 0; j <= jj; j++) {
                  tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);
                }
              }
              return {
                canvas: tmpCanvas2.canvas,
                scaleX: dimx2.scale,
                scaleY: dimy2.scale,
                offsetX: x0,
                offsetY: y0
              };
            }
            return {
              canvas: tmpCanvas.canvas,
              scaleX: dimx.scale,
              scaleY: dimy.scale,
              offsetX: x0,
              offsetY: y0
            };
          }
          getSizeAndScale(step, realOutputSize, scale) {
            const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
            let size = Math.ceil(step * scale);
            if (size >= maxSize) {
              size = maxSize;
            } else {
              scale = size / step;
            }
            return {
              scale,
              size
            };
          }
          clipBbox(graphics, x0, y0, x1, y1) {
            const bboxWidth = x1 - x0;
            const bboxHeight = y1 - y0;
            graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
            Util.axialAlignedBoundingBox([x0, y0, x1, y1], getCurrentTransform(graphics.ctx), graphics.current.minMax);
            graphics.clip();
            graphics.endPath();
          }
          setFillAndStrokeStyleToContext(graphics, paintType, color) {
            const context = graphics.ctx,
              current = graphics.current;
            switch (paintType) {
              case PaintType.COLORED:
                const {
                  fillStyle,
                  strokeStyle
                } = this.ctx;
                context.fillStyle = current.fillColor = fillStyle;
                context.strokeStyle = current.strokeColor = strokeStyle;
                break;
              case PaintType.UNCOLORED:
                context.fillStyle = context.strokeStyle = color;
                current.fillColor = current.strokeColor = color;
                break;
              default:
                throw new FormatError(`Unsupported paint type: ${paintType}`);
            }
          }
          isModifyingCurrentTransform() {
            return false;
          }
          getPattern(ctx, owner, inverse, pathType, opIdx) {
            let matrix = inverse;
            if (pathType !== PathType.SHADING) {
              matrix = Util.transform(matrix, owner.baseTransform);
              if (this.matrix) {
                matrix = Util.transform(matrix, this.matrix);
              }
            }
            const temporaryPatternCanvas = this.createPatternCanvas(owner, opIdx);
            let domMatrix = new DOMMatrix(matrix);
            domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
            domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
            const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
            pattern.setTransform(domMatrix);
            return pattern;
          }
        }

        ;// ./src/shared/image_utils.js

        function convertToRGBA(params) {
          switch (params.kind) {
            case ImageKind.GRAYSCALE_1BPP:
              return convertBlackAndWhiteToRGBA(params);
            case ImageKind.RGB_24BPP:
              return convertRGBToRGBA(params);
          }
          return null;
        }
        function convertBlackAndWhiteToRGBA({
          src,
          srcPos = 0,
          dest,
          width,
          height,
          nonBlackColor = 0xffffffff,
          inverseDecode = false
        }) {
          const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
          const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
          const widthInSource = width >> 3;
          const widthRemainder = width & 7;
          const srcLength = src.length;
          dest = new Uint32Array(dest.buffer);
          let destPos = 0;
          for (let i = 0; i < height; i++) {
            for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {
              const elem = srcPos < srcLength ? src[srcPos] : 255;
              dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;
              dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;
              dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;
              dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;
              dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;
              dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;
              dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;
              dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;
            }
            if (widthRemainder === 0) {
              continue;
            }
            const elem = srcPos < srcLength ? src[srcPos++] : 255;
            for (let j = 0; j < widthRemainder; j++) {
              dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
            }
          }
          return {
            srcPos,
            destPos
          };
        }
        function convertRGBToRGBA({
          src,
          srcPos = 0,
          dest,
          destPos = 0,
          width,
          height
        }) {
          let i = 0;
          const len = width * height * 3;
          const len32 = len >> 2;
          const src32 = new Uint32Array(src.buffer, srcPos, len32);
          if (FeatureTest.isLittleEndian) {
            for (; i < len32 - 2; i += 3, destPos += 4) {
              const s1 = src32[i];
              const s2 = src32[i + 1];
              const s3 = src32[i + 2];
              dest[destPos] = s1 | 0xff000000;
              dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;
              dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;
              dest[destPos + 3] = s3 >>> 8 | 0xff000000;
            }
            for (let j = i * 4, jj = srcPos + len; j < jj; j += 3) {
              dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;
            }
          } else {
            for (; i < len32 - 2; i += 3, destPos += 4) {
              const s1 = src32[i];
              const s2 = src32[i + 1];
              const s3 = src32[i + 2];
              dest[destPos] = s1 | 0xff;
              dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;
              dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;
              dest[destPos + 3] = s3 << 8 | 0xff;
            }
            for (let j = i * 4, jj = srcPos + len; j < jj; j += 3) {
              dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;
            }
          }
          return {
            srcPos: srcPos + len,
            destPos
          };
        }
        function grayToRGBA(src, dest) {
          if (FeatureTest.isLittleEndian) {
            for (let i = 0, ii = src.length; i < ii; i++) {
              dest[i] = src[i] * 0x10101 | 0xff000000;
            }
          } else {
            for (let i = 0, ii = src.length; i < ii; i++) {
              dest[i] = src[i] * 0x1010100 | 0x000000ff;
            }
          }
        }

        ;// ./src/display/canvas.js





        const MIN_FONT_SIZE = 16;
        const MAX_FONT_SIZE = 100;
        const EXECUTION_TIME = 15;
        const EXECUTION_STEPS = 10;
        const FULL_CHUNK_HEIGHT = 16;
        const SCALE_MATRIX = new DOMMatrix();
        const XY = new Float32Array(2);
        const MIN_MAX_INIT = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);
        function mirrorContextOperations(ctx, destCtx) {
          if (ctx._removeMirroring) {
            throw new Error("Context is already forwarding operations.");
          }
          ctx.__originalSave = ctx.save;
          ctx.__originalRestore = ctx.restore;
          ctx.__originalRotate = ctx.rotate;
          ctx.__originalScale = ctx.scale;
          ctx.__originalTranslate = ctx.translate;
          ctx.__originalTransform = ctx.transform;
          ctx.__originalSetTransform = ctx.setTransform;
          ctx.__originalResetTransform = ctx.resetTransform;
          ctx.__originalClip = ctx.clip;
          ctx.__originalMoveTo = ctx.moveTo;
          ctx.__originalLineTo = ctx.lineTo;
          ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
          ctx.__originalRect = ctx.rect;
          ctx.__originalClosePath = ctx.closePath;
          ctx.__originalBeginPath = ctx.beginPath;
          ctx._removeMirroring = () => {
            ctx.save = ctx.__originalSave;
            ctx.restore = ctx.__originalRestore;
            ctx.rotate = ctx.__originalRotate;
            ctx.scale = ctx.__originalScale;
            ctx.translate = ctx.__originalTranslate;
            ctx.transform = ctx.__originalTransform;
            ctx.setTransform = ctx.__originalSetTransform;
            ctx.resetTransform = ctx.__originalResetTransform;
            ctx.clip = ctx.__originalClip;
            ctx.moveTo = ctx.__originalMoveTo;
            ctx.lineTo = ctx.__originalLineTo;
            ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
            ctx.rect = ctx.__originalRect;
            ctx.closePath = ctx.__originalClosePath;
            ctx.beginPath = ctx.__originalBeginPath;
            delete ctx._removeMirroring;
          };
          ctx.save = function () {
            destCtx.save();
            this.__originalSave();
          };
          ctx.restore = function () {
            destCtx.restore();
            this.__originalRestore();
          };
          ctx.translate = function (x, y) {
            destCtx.translate(x, y);
            this.__originalTranslate(x, y);
          };
          ctx.scale = function (x, y) {
            destCtx.scale(x, y);
            this.__originalScale(x, y);
          };
          ctx.transform = function (a, b, c, d, e, f) {
            destCtx.transform(a, b, c, d, e, f);
            this.__originalTransform(a, b, c, d, e, f);
          };
          ctx.setTransform = function (a, b, c, d, e, f) {
            destCtx.setTransform(a, b, c, d, e, f);
            this.__originalSetTransform(a, b, c, d, e, f);
          };
          ctx.resetTransform = function () {
            destCtx.resetTransform();
            this.__originalResetTransform();
          };
          ctx.rotate = function (angle) {
            destCtx.rotate(angle);
            this.__originalRotate(angle);
          };
          ctx.clip = function (rule) {
            destCtx.clip(rule);
            this.__originalClip(rule);
          };
          ctx.moveTo = function (x, y) {
            destCtx.moveTo(x, y);
            this.__originalMoveTo(x, y);
          };
          ctx.lineTo = function (x, y) {
            destCtx.lineTo(x, y);
            this.__originalLineTo(x, y);
          };
          ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
            destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
            this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
          };
          ctx.rect = function (x, y, width, height) {
            destCtx.rect(x, y, width, height);
            this.__originalRect(x, y, width, height);
          };
          ctx.closePath = function () {
            destCtx.closePath();
            this.__originalClosePath();
          };
          ctx.beginPath = function () {
            destCtx.beginPath();
            this.__originalBeginPath();
          };
        }
        class CachedCanvases {
          constructor(canvasFactory) {
            this.canvasFactory = canvasFactory;
            this.cache = Object.create(null);
          }
          getCanvas(id, width, height) {
            let canvasEntry;
            if (this.cache[id] !== undefined) {
              canvasEntry = this.cache[id];
              this.canvasFactory.reset(canvasEntry, width, height);
            } else {
              canvasEntry = this.canvasFactory.create(width, height);
              this.cache[id] = canvasEntry;
            }
            return canvasEntry;
          }
          delete(id) {
            delete this.cache[id];
          }
          clear() {
            for (const id in this.cache) {
              const canvasEntry = this.cache[id];
              this.canvasFactory.destroy(canvasEntry);
              delete this.cache[id];
            }
          }
        }
        function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
          const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
          if (b === 0 && c === 0) {
            const tlX = destX * a + tx;
            const rTlX = Math.round(tlX);
            const tlY = destY * d + ty;
            const rTlY = Math.round(tlY);
            const brX = (destX + destW) * a + tx;
            const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
            const brY = (destY + destH) * d + ty;
            const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
            ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
            ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
            ctx.setTransform(a, b, c, d, tx, ty);
            return [rWidth, rHeight];
          }
          if (a === 0 && d === 0) {
            const tlX = destY * c + tx;
            const rTlX = Math.round(tlX);
            const tlY = destX * b + ty;
            const rTlY = Math.round(tlY);
            const brX = (destY + destH) * c + tx;
            const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
            const brY = (destX + destW) * b + ty;
            const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
            ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
            ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
            ctx.setTransform(a, b, c, d, tx, ty);
            return [rHeight, rWidth];
          }
          ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
          const scaleX = Math.hypot(a, b);
          const scaleY = Math.hypot(c, d);
          return [scaleX * destW, scaleY * destH];
        }
        class CanvasExtraState {
          alphaIsShape = false;
          fontSize = 0;
          fontSizeScale = 1;
          textMatrix = null;
          textMatrixScale = 1;
          fontMatrix = FONT_IDENTITY_MATRIX;
          leading = 0;
          x = 0;
          y = 0;
          lineX = 0;
          lineY = 0;
          charSpacing = 0;
          wordSpacing = 0;
          textHScale = 1;
          textRenderingMode = TextRenderingMode.FILL;
          textRise = 0;
          fillColor = "#000000";
          strokeColor = "#000000";
          patternFill = false;
          patternStroke = false;
          fillAlpha = 1;
          strokeAlpha = 1;
          lineWidth = 1;
          activeSMask = null;
          transferMaps = "none";
          constructor(width, height, preInit) {
            preInit?.(this);
            this.clipBox = new Float32Array([0, 0, width, height]);
            this.minMax = MIN_MAX_INIT.slice();
          }
          clone() {
            const clone = Object.create(this);
            clone.clipBox = this.clipBox.slice();
            clone.minMax = this.minMax.slice();
            return clone;
          }
          getPathBoundingBox(pathType = PathType.FILL, transform = null) {
            const box = this.minMax.slice();
            if (pathType === PathType.STROKE) {
              if (!transform) {
                unreachable("Stroke bounding box must include transform.");
              }
              Util.singularValueDecompose2dScale(transform, XY);
              const xStrokePad = XY[0] * this.lineWidth / 2;
              const yStrokePad = XY[1] * this.lineWidth / 2;
              box[0] -= xStrokePad;
              box[1] -= yStrokePad;
              box[2] += xStrokePad;
              box[3] += yStrokePad;
            }
            return box;
          }
          updateClipFromPath() {
            const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
            this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
          }
          isEmptyClip() {
            return this.minMax[0] === Infinity;
          }
          startNewPathAndClipBox(box) {
            this.clipBox.set(box, 0);
            this.minMax.set(MIN_MAX_INIT, 0);
          }
          getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
            return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
          }
        }
        function putBinaryImageData(ctx, imgData) {
          if (imgData instanceof ImageData) {
            ctx.putImageData(imgData, 0, 0);
            return;
          }
          const height = imgData.height,
            width = imgData.width;
          const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
          const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
          const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
          const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
          let srcPos = 0,
            destPos;
          const src = imgData.data;
          const dest = chunkImgData.data;
          let i, j, thisChunkHeight, elemsInThisChunk;
          if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {
            const srcLength = src.byteLength;
            const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
            const dest32DataLength = dest32.length;
            const fullSrcDiff = width + 7 >> 3;
            const white = 0xffffffff;
            const black = util_FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;
            for (i = 0; i < totalChunks; i++) {
              thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
              destPos = 0;
              for (j = 0; j < thisChunkHeight; j++) {
                const srcDiff = srcLength - srcPos;
                let k = 0;
                const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
                const kEndUnrolled = kEnd & ~7;
                let mask = 0;
                let srcByte = 0;
                for (; k < kEndUnrolled; k += 8) {
                  srcByte = src[srcPos++];
                  dest32[destPos++] = srcByte & 128 ? white : black;
                  dest32[destPos++] = srcByte & 64 ? white : black;
                  dest32[destPos++] = srcByte & 32 ? white : black;
                  dest32[destPos++] = srcByte & 16 ? white : black;
                  dest32[destPos++] = srcByte & 8 ? white : black;
                  dest32[destPos++] = srcByte & 4 ? white : black;
                  dest32[destPos++] = srcByte & 2 ? white : black;
                  dest32[destPos++] = srcByte & 1 ? white : black;
                }
                for (; k < kEnd; k++) {
                  if (mask === 0) {
                    srcByte = src[srcPos++];
                    mask = 128;
                  }
                  dest32[destPos++] = srcByte & mask ? white : black;
                  mask >>= 1;
                }
              }
              while (destPos < dest32DataLength) {
                dest32[destPos++] = 0;
              }
              ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
            }
          } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {
            j = 0;
            elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
            for (i = 0; i < fullChunks; i++) {
              dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
              srcPos += elemsInThisChunk;
              ctx.putImageData(chunkImgData, 0, j);
              j += FULL_CHUNK_HEIGHT;
            }
            if (i < totalChunks) {
              elemsInThisChunk = width * partialChunkHeight * 4;
              dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
              ctx.putImageData(chunkImgData, 0, j);
            }
          } else if (imgData.kind === util_ImageKind.RGB_24BPP) {
            thisChunkHeight = FULL_CHUNK_HEIGHT;
            elemsInThisChunk = width * thisChunkHeight;
            for (i = 0; i < totalChunks; i++) {
              if (i >= fullChunks) {
                thisChunkHeight = partialChunkHeight;
                elemsInThisChunk = width * thisChunkHeight;
              }
              destPos = 0;
              for (j = elemsInThisChunk; j--;) {
                dest[destPos++] = src[srcPos++];
                dest[destPos++] = src[srcPos++];
                dest[destPos++] = src[srcPos++];
                dest[destPos++] = 255;
              }
              ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
            }
          } else {
            throw new Error(`bad image kind: ${imgData.kind}`);
          }
        }
        function putBinaryImageMask(ctx, imgData) {
          if (imgData.bitmap) {
            ctx.drawImage(imgData.bitmap, 0, 0);
            return;
          }
          const height = imgData.height,
            width = imgData.width;
          const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
          const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
          const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
          const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
          let srcPos = 0;
          const src = imgData.data;
          const dest = chunkImgData.data;
          for (let i = 0; i < totalChunks; i++) {
            const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
            ({
              srcPos
            } = convertBlackAndWhiteToRGBA({
              src,
              srcPos,
              dest,
              width,
              height: thisChunkHeight,
              nonBlackColor: 0
            }));
            ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
          }
        }
        function copyCtxState(sourceCtx, destCtx) {
          const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
          for (const property of properties) {
            if (sourceCtx[property] !== undefined) {
              destCtx[property] = sourceCtx[property];
            }
          }
          if (sourceCtx.setLineDash !== undefined) {
            destCtx.setLineDash(sourceCtx.getLineDash());
            destCtx.lineDashOffset = sourceCtx.lineDashOffset;
          }
        }
        function resetCtxToDefault(ctx) {
          ctx.strokeStyle = ctx.fillStyle = "#000000";
          ctx.fillRule = "nonzero";
          ctx.globalAlpha = 1;
          ctx.lineWidth = 1;
          ctx.lineCap = "butt";
          ctx.lineJoin = "miter";
          ctx.miterLimit = 10;
          ctx.globalCompositeOperation = "source-over";
          ctx.font = "10px sans-serif";
          if (ctx.setLineDash !== undefined) {
            ctx.setLineDash([]);
            ctx.lineDashOffset = 0;
          }
          const {
            filter
          } = ctx;
          if (filter !== "none" && filter !== "") {
            ctx.filter = "none";
          }
        }
        function getImageSmoothingEnabled(transform, interpolate) {
          if (interpolate) {
            return true;
          }
          Util.singularValueDecompose2dScale(transform, XY);
          const actualScale = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);
          return XY[0] <= actualScale && XY[1] <= actualScale;
        }
        const LINE_CAP_STYLES = ["butt", "round", "square"];
        const LINE_JOIN_STYLES = ["miter", "round", "bevel"];
        const NORMAL_CLIP = {};
        const EO_CLIP = {};
        class CanvasGraphics {
          constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {
            optionalContentConfig,
            markedContentStack = null
          }, annotationCanvasMap, pageColors, dependencyTracker) {
            this.ctx = canvasCtx;
            this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
            this.stateStack = [];
            this.pendingClip = null;
            this.pendingEOFill = false;
            this.res = null;
            this.xobjs = null;
            this.commonObjs = commonObjs;
            this.objs = objs;
            this.canvasFactory = canvasFactory;
            this.filterFactory = filterFactory;
            this.groupStack = [];
            this.baseTransform = null;
            this.baseTransformStack = [];
            this.groupLevel = 0;
            this.smaskStack = [];
            this.smaskCounter = 0;
            this.tempSMask = null;
            this.suspendedCtx = null;
            this.contentVisible = true;
            this.markedContentStack = markedContentStack || [];
            this.optionalContentConfig = optionalContentConfig;
            this.cachedCanvases = new CachedCanvases(this.canvasFactory);
            this.cachedPatterns = new Map();
            this.annotationCanvasMap = annotationCanvasMap;
            this.viewportScale = 1;
            this.outputScaleX = 1;
            this.outputScaleY = 1;
            this.pageColors = pageColors;
            this._cachedScaleForStroking = [-1, 0];
            this._cachedGetSinglePixelWidth = null;
            this._cachedBitmapsMap = new Map();
            this.dependencyTracker = dependencyTracker ?? null;
          }
          getObject(opIdx, data, fallback = null) {
            if (typeof data === "string") {
              this.dependencyTracker?.recordNamedDependency(opIdx, data);
              return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
            }
            return fallback;
          }
          beginDrawing({
            transform,
            viewport,
            transparency = false,
            background = null
          }) {
            const width = this.ctx.canvas.width;
            const height = this.ctx.canvas.height;
            const savedFillStyle = this.ctx.fillStyle;
            this.ctx.fillStyle = background || "#ffffff";
            this.ctx.fillRect(0, 0, width, height);
            this.ctx.fillStyle = savedFillStyle;
            if (transparency) {
              const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
              this.compositeCtx = this.ctx;
              this.transparentCanvas = transparentCanvas.canvas;
              this.ctx = transparentCanvas.context;
              this.ctx.save();
              this.ctx.transform(...getCurrentTransform(this.compositeCtx));
            }
            this.ctx.save();
            resetCtxToDefault(this.ctx);
            if (transform) {
              this.ctx.transform(...transform);
              this.outputScaleX = transform[0];
              this.outputScaleY = transform[0];
            }
            this.ctx.transform(...viewport.transform);
            this.viewportScale = viewport.scale;
            this.baseTransform = getCurrentTransform(this.ctx);
          }
          executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper, operationsFilter) {
            const argsArray = operatorList.argsArray;
            const fnArray = operatorList.fnArray;
            let i = executionStartIdx || 0;
            const argsArrayLen = argsArray.length;
            if (argsArrayLen === i) {
              return i;
            }
            const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
            const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
            let steps = 0;
            const commonObjs = this.commonObjs;
            const objs = this.objs;
            let fnId, fnArgs;
            while (true) {
              if (stepper !== undefined && i === stepper.nextBreakPoint) {
                stepper.breakIt(i, continueCallback);
                return i;
              }
              if (!operationsFilter || operationsFilter(i)) {
                fnId = fnArray[i];
                fnArgs = argsArray[i] ?? null;
                if (fnId !== OPS.dependency) {
                  if (fnArgs === null) {
                    this[fnId](i);
                  } else {
                    this[fnId](i, ...fnArgs);
                  }
                } else {
                  for (const depObjId of fnArgs) {
                    this.dependencyTracker?.recordNamedData(depObjId, i);
                    const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                    if (!objsPool.has(depObjId)) {
                      objsPool.get(depObjId, continueCallback);
                      return i;
                    }
                  }
                }
              }
              i++;
              if (i === argsArrayLen) {
                return i;
              }
              if (chunkOperations && ++steps > EXECUTION_STEPS) {
                if (Date.now() > endTime) {
                  continueCallback();
                  return i;
                }
                steps = 0;
              }
            }
          }
          #restoreInitialState() {
            while (this.stateStack.length || this.inSMaskMode) {
              this.restore();
            }
            this.current.activeSMask = null;
            this.ctx.restore();
            if (this.transparentCanvas) {
              this.ctx = this.compositeCtx;
              this.ctx.save();
              this.ctx.setTransform(1, 0, 0, 1, 0, 0);
              this.ctx.drawImage(this.transparentCanvas, 0, 0);
              this.ctx.restore();
              this.transparentCanvas = null;
            }
          }
          endDrawing() {
            this.#restoreInitialState();
            this.cachedCanvases.clear();
            this.cachedPatterns.clear();
            for (const cache of this._cachedBitmapsMap.values()) {
              for (const canvas of cache.values()) {
                if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
                  canvas.width = canvas.height = 0;
                }
              }
              cache.clear();
            }
            this._cachedBitmapsMap.clear();
            this.#drawFilter();
          }
          #drawFilter() {
            if (this.pageColors) {
              const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
              if (hcmFilterId !== "none") {
                const savedFilter = this.ctx.filter;
                this.ctx.filter = hcmFilterId;
                this.ctx.drawImage(this.ctx.canvas, 0, 0);
                this.ctx.filter = savedFilter;
              }
            }
          }
          _scaleImage(img, inverseTransform) {
            const width = img.width ?? img.displayWidth;
            const height = img.height ?? img.displayHeight;
            let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
            let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
            let paintWidth = width,
              paintHeight = height;
            let tmpCanvasId = "prescale1";
            let tmpCanvas, tmpCtx;
            while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
              let newWidth = paintWidth,
                newHeight = paintHeight;
              if (widthScale > 2 && paintWidth > 1) {
                newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
                widthScale /= paintWidth / newWidth;
              }
              if (heightScale > 2 && paintHeight > 1) {
                newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
                heightScale /= paintHeight / newHeight;
              }
              tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
              tmpCtx = tmpCanvas.context;
              tmpCtx.clearRect(0, 0, newWidth, newHeight);
              tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
              img = tmpCanvas.canvas;
              paintWidth = newWidth;
              paintHeight = newHeight;
              tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
            }
            return {
              img,
              paintWidth,
              paintHeight
            };
          }
          _createMaskCanvas(opIdx, img) {
            const ctx = this.ctx;
            const {
              width,
              height
            } = img;
            const fillColor = this.current.fillColor;
            const isPatternFill = this.current.patternFill;
            const currentTransform = getCurrentTransform(ctx);
            let cache, cacheKey, scaled, maskCanvas;
            if ((img.bitmap || img.data) && img.count > 1) {
              const mainKey = img.bitmap || img.data.buffer;
              cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);
              cache = this._cachedBitmapsMap.get(mainKey);
              if (!cache) {
                cache = new Map();
                this._cachedBitmapsMap.set(mainKey, cache);
              }
              const cachedImage = cache.get(cacheKey);
              if (cachedImage && !isPatternFill) {
                const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
                const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
                this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);
                return {
                  canvas: cachedImage,
                  offsetX,
                  offsetY
                };
              }
              scaled = cachedImage;
            }
            if (!scaled) {
              maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
              putBinaryImageMask(maskCanvas.context, img);
            }
            let maskToCanvas = Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
            maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
            const minMax = MIN_MAX_INIT.slice();
            Util.axialAlignedBoundingBox([0, 0, width, height], maskToCanvas, minMax);
            const [minX, minY, maxX, maxY] = minMax;
            const drawnWidth = Math.round(maxX - minX) || 1;
            const drawnHeight = Math.round(maxY - minY) || 1;
            const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
            const fillCtx = fillCanvas.context;
            const offsetX = minX;
            const offsetY = minY;
            fillCtx.translate(-offsetX, -offsetY);
            fillCtx.transform(...maskToCanvas);
            if (!scaled) {
              scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));
              scaled = scaled.img;
              if (cache && isPatternFill) {
                cache.set(cacheKey, scaled);
              }
            }
            fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);
            drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
            fillCtx.globalCompositeOperation = "source-in";
            const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
            fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL, opIdx) : fillColor;
            fillCtx.fillRect(0, 0, width, height);
            if (cache && !isPatternFill) {
              this.cachedCanvases.delete("fillCanvas");
              cache.set(cacheKey, fillCanvas.canvas);
            }
            this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);
            return {
              canvas: fillCanvas.canvas,
              offsetX: Math.round(offsetX),
              offsetY: Math.round(offsetY)
            };
          }
          setLineWidth(opIdx, width) {
            this.dependencyTracker?.recordSimpleData("lineWidth", opIdx);
            if (width !== this.current.lineWidth) {
              this._cachedScaleForStroking[0] = -1;
            }
            this.current.lineWidth = width;
            this.ctx.lineWidth = width;
          }
          setLineCap(opIdx, style) {
            this.dependencyTracker?.recordSimpleData("lineCap", opIdx);
            this.ctx.lineCap = LINE_CAP_STYLES[style];
          }
          setLineJoin(opIdx, style) {
            this.dependencyTracker?.recordSimpleData("lineJoin", opIdx);
            this.ctx.lineJoin = LINE_JOIN_STYLES[style];
          }
          setMiterLimit(opIdx, limit) {
            this.dependencyTracker?.recordSimpleData("miterLimit", opIdx);
            this.ctx.miterLimit = limit;
          }
          setDash(opIdx, dashArray, dashPhase) {
            this.dependencyTracker?.recordSimpleData("dash", opIdx);
            const ctx = this.ctx;
            if (ctx.setLineDash !== undefined) {
              ctx.setLineDash(dashArray);
              ctx.lineDashOffset = dashPhase;
            }
          }
          setRenderingIntent(opIdx, intent) { }
          setFlatness(opIdx, flatness) { }
          setGState(opIdx, states) {
            for (const [key, value] of states) {
              switch (key) {
                case "LW":
                  this.setLineWidth(opIdx, value);
                  break;
                case "LC":
                  this.setLineCap(opIdx, value);
                  break;
                case "LJ":
                  this.setLineJoin(opIdx, value);
                  break;
                case "ML":
                  this.setMiterLimit(opIdx, value);
                  break;
                case "D":
                  this.setDash(opIdx, value[0], value[1]);
                  break;
                case "RI":
                  this.setRenderingIntent(opIdx, value);
                  break;
                case "FL":
                  this.setFlatness(opIdx, value);
                  break;
                case "Font":
                  this.setFont(opIdx, value[0], value[1]);
                  break;
                case "CA":
                  this.dependencyTracker?.recordSimpleData("strokeAlpha", opIdx);
                  this.current.strokeAlpha = value;
                  break;
                case "ca":
                  this.dependencyTracker?.recordSimpleData("fillAlpha", opIdx);
                  this.ctx.globalAlpha = this.current.fillAlpha = value;
                  break;
                case "BM":
                  this.dependencyTracker?.recordSimpleData("globalCompositeOperation", opIdx);
                  this.ctx.globalCompositeOperation = value;
                  break;
                case "SMask":
                  this.dependencyTracker?.recordSimpleData("SMask", opIdx);
                  this.current.activeSMask = value ? this.tempSMask : null;
                  this.tempSMask = null;
                  this.checkSMaskState();
                  break;
                case "TR":
                  this.dependencyTracker?.recordSimpleData("filter", opIdx);
                  this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
                  break;
              }
            }
          }
          get inSMaskMode() {
            return !!this.suspendedCtx;
          }
          checkSMaskState() {
            const inSMaskMode = this.inSMaskMode;
            if (this.current.activeSMask && !inSMaskMode) {
              this.beginSMaskMode();
            } else if (!this.current.activeSMask && inSMaskMode) {
              this.endSMaskMode();
            }
          }
          beginSMaskMode(opIdx) {
            if (this.inSMaskMode) {
              throw new Error("beginSMaskMode called while already in smask mode");
            }
            const drawnWidth = this.ctx.canvas.width;
            const drawnHeight = this.ctx.canvas.height;
            const cacheId = "smaskGroupAt" + this.groupLevel;
            const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
            this.suspendedCtx = this.ctx;
            const ctx = this.ctx = scratchCanvas.context;
            ctx.setTransform(this.suspendedCtx.getTransform());
            copyCtxState(this.suspendedCtx, ctx);
            mirrorContextOperations(ctx, this.suspendedCtx);
            this.setGState(opIdx, [["BM", "source-over"]]);
          }
          endSMaskMode() {
            if (!this.inSMaskMode) {
              throw new Error("endSMaskMode called while not in smask mode");
            }
            this.ctx._removeMirroring();
            copyCtxState(this.ctx, this.suspendedCtx);
            this.ctx = this.suspendedCtx;
            this.suspendedCtx = null;
          }
          compose(dirtyBox) {
            if (!this.current.activeSMask) {
              return;
            }
            if (!dirtyBox) {
              dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
            } else {
              dirtyBox[0] = Math.floor(dirtyBox[0]);
              dirtyBox[1] = Math.floor(dirtyBox[1]);
              dirtyBox[2] = Math.ceil(dirtyBox[2]);
              dirtyBox[3] = Math.ceil(dirtyBox[3]);
            }
            const smask = this.current.activeSMask;
            const suspendedCtx = this.suspendedCtx;
            this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
            this.ctx.save();
            this.ctx.setTransform(1, 0, 0, 1, 0, 0);
            this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
            this.ctx.restore();
          }
          composeSMask(ctx, smask, layerCtx, layerBox) {
            const layerOffsetX = layerBox[0];
            const layerOffsetY = layerBox[1];
            const layerWidth = layerBox[2] - layerOffsetX;
            const layerHeight = layerBox[3] - layerOffsetY;
            if (layerWidth === 0 || layerHeight === 0) {
              return;
            }
            this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
            ctx.save();
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = "source-over";
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.drawImage(layerCtx.canvas, 0, 0);
            ctx.restore();
          }
          genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
            let maskCanvas = maskCtx.canvas;
            let maskX = layerOffsetX - maskOffsetX;
            let maskY = layerOffsetY - maskOffsetY;
            if (backdrop) {
              if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {
                const canvas = this.cachedCanvases.getCanvas("maskExtension", width, height);
                const ctx = canvas.context;
                ctx.drawImage(maskCanvas, -maskX, -maskY);
                ctx.globalCompositeOperation = "destination-atop";
                ctx.fillStyle = backdrop;
                ctx.fillRect(0, 0, width, height);
                ctx.globalCompositeOperation = "source-over";
                maskCanvas = canvas.canvas;
                maskX = maskY = 0;
              } else {
                maskCtx.save();
                maskCtx.globalAlpha = 1;
                maskCtx.setTransform(1, 0, 0, 1, 0, 0);
                const clip = new Path2D();
                clip.rect(maskX, maskY, width, height);
                maskCtx.clip(clip);
                maskCtx.globalCompositeOperation = "destination-atop";
                maskCtx.fillStyle = backdrop;
                maskCtx.fillRect(maskX, maskY, width, height);
                maskCtx.restore();
              }
            }
            layerCtx.save();
            layerCtx.globalAlpha = 1;
            layerCtx.setTransform(1, 0, 0, 1, 0, 0);
            if (subtype === "Alpha" && transferMap) {
              layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
            } else if (subtype === "Luminosity") {
              layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
            }
            const clip = new Path2D();
            clip.rect(layerOffsetX, layerOffsetY, width, height);
            layerCtx.clip(clip);
            layerCtx.globalCompositeOperation = "destination-in";
            layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);
            layerCtx.restore();
          }
          save(opIdx) {
            if (this.inSMaskMode) {
              copyCtxState(this.ctx, this.suspendedCtx);
            }
            this.ctx.save();
            const old = this.current;
            this.stateStack.push(old);
            this.current = old.clone();
            this.dependencyTracker?.save(opIdx);
          }
          restore(opIdx) {
            this.dependencyTracker?.restore(opIdx);
            if (this.stateStack.length === 0) {
              if (this.inSMaskMode) {
                this.endSMaskMode();
              }
              return;
            }
            this.current = this.stateStack.pop();
            this.ctx.restore();
            if (this.inSMaskMode) {
              copyCtxState(this.suspendedCtx, this.ctx);
            }
            this.checkSMaskState();
            this.pendingClip = null;
            this._cachedScaleForStroking[0] = -1;
            this._cachedGetSinglePixelWidth = null;
          }
          transform(opIdx, a, b, c, d, e, f) {
            this.dependencyTracker?.recordIncrementalData("transform", opIdx);
            this.ctx.transform(a, b, c, d, e, f);
            this._cachedScaleForStroking[0] = -1;
            this._cachedGetSinglePixelWidth = null;
          }
          constructPath(opIdx, op, data, minMax) {
            let [path] = data;
            if (!minMax) {
              path ||= data[0] = new Path2D();
              this[op](opIdx, path);
              return;
            }
            if (this.dependencyTracker !== null) {
              const outerExtraSize = op === OPS.stroke ? this.current.lineWidth / 2 : 0;
              this.dependencyTracker.resetBBox(opIdx).recordBBox(opIdx, this.ctx, minMax[0] - outerExtraSize, minMax[2] + outerExtraSize, minMax[1] - outerExtraSize, minMax[3] + outerExtraSize).recordDependencies(opIdx, ["transform"]);
            }
            if (!(path instanceof Path2D)) {
              path = data[0] = makePathFromDrawOPS(path);
            }
            Util.axialAlignedBoundingBox(minMax, getCurrentTransform(this.ctx), this.current.minMax);
            this[op](opIdx, path);
            this._pathStartIdx = opIdx;
          }
          closePath(opIdx) {
            this.ctx.closePath();
          }
          stroke(opIdx, path, consumePath = true) {
            const ctx = this.ctx;
            const strokeColor = this.current.strokeColor;
            ctx.globalAlpha = this.current.strokeAlpha;
            if (this.contentVisible) {
              if (typeof strokeColor === "object" && strokeColor?.getPattern) {
                const baseTransform = strokeColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;
                ctx.save();
                ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);
                if (baseTransform) {
                  const newPath = new Path2D();
                  newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));
                  path = newPath;
                }
                this.rescaleAndStroke(path, false);
                ctx.restore();
              } else {
                this.rescaleAndStroke(path, true);
              }
            }
            this.dependencyTracker?.recordDependencies(opIdx, Dependencies.stroke);
            if (consumePath) {
              this.consumePath(opIdx, path, this.current.getClippedPathBoundingBox(PathType.STROKE, getCurrentTransform(this.ctx)));
            }
            ctx.globalAlpha = this.current.fillAlpha;
          }
          closeStroke(opIdx, path) {
            this.stroke(opIdx, path);
          }
          fill(opIdx, path, consumePath = true) {
            const ctx = this.ctx;
            const fillColor = this.current.fillColor;
            const isPatternFill = this.current.patternFill;
            let needRestore = false;
            if (isPatternFill) {
              const baseTransform = fillColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;
              this.dependencyTracker?.save(opIdx);
              ctx.save();
              ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);
              if (baseTransform) {
                const newPath = new Path2D();
                newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));
                path = newPath;
              }
              needRestore = true;
            }
            const intersect = this.current.getClippedPathBoundingBox();
            if (this.contentVisible && intersect !== null) {
              if (this.pendingEOFill) {
                ctx.fill(path, "evenodd");
                this.pendingEOFill = false;
              } else {
                ctx.fill(path);
              }
            }
            this.dependencyTracker?.recordDependencies(opIdx, Dependencies.fill);
            if (needRestore) {
              ctx.restore();
              this.dependencyTracker?.restore(opIdx);
            }
            if (consumePath) {
              this.consumePath(opIdx, path, intersect);
            }
          }
          eoFill(opIdx, path) {
            this.pendingEOFill = true;
            this.fill(opIdx, path);
          }
          fillStroke(opIdx, path) {
            this.fill(opIdx, path, false);
            this.stroke(opIdx, path, false);
            this.consumePath(opIdx, path);
          }
          eoFillStroke(opIdx, path) {
            this.pendingEOFill = true;
            this.fillStroke(opIdx, path);
          }
          closeFillStroke(opIdx, path) {
            this.fillStroke(opIdx, path);
          }
          closeEOFillStroke(opIdx, path) {
            this.pendingEOFill = true;
            this.fillStroke(opIdx, path);
          }
          endPath(opIdx, path) {
            this.consumePath(opIdx, path);
          }
          rawFillPath(opIdx, path) {
            this.ctx.fill(path);
            this.dependencyTracker?.recordDependencies(opIdx, Dependencies.rawFillPath).recordOperation(opIdx);
          }
          clip(opIdx) {
            this.dependencyTracker?.recordFutureForcedDependency("clipMode", opIdx);
            this.pendingClip = NORMAL_CLIP;
          }
          eoClip(opIdx) {
            this.dependencyTracker?.recordFutureForcedDependency("clipMode", opIdx);
            this.pendingClip = EO_CLIP;
          }
          beginText(opIdx) {
            this.current.textMatrix = null;
            this.current.textMatrixScale = 1;
            this.current.x = this.current.lineX = 0;
            this.current.y = this.current.lineY = 0;
            this.dependencyTracker?.recordOpenMarker(opIdx).resetIncrementalData("sameLineText").resetIncrementalData("moveText", opIdx);
          }
          endText(opIdx) {
            const paths = this.pendingTextPaths;
            const ctx = this.ctx;
            if (this.dependencyTracker) {
              const {
                dependencyTracker
              } = this;
              if (paths !== undefined) {
                dependencyTracker.recordFutureForcedDependency("textClip", dependencyTracker.getOpenMarker()).recordFutureForcedDependency("textClip", opIdx);
              }
              dependencyTracker.recordCloseMarker(opIdx);
            }
            if (paths !== undefined) {
              const newPath = new Path2D();
              const invTransf = ctx.getTransform().invertSelf();
              for (const {
                transform,
                x,
                y,
                fontSize,
                path
              } of paths) {
                if (!path) {
                  continue;
                }
                newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));
              }
              ctx.clip(newPath);
            }
            delete this.pendingTextPaths;
          }
          setCharSpacing(opIdx, spacing) {
            this.dependencyTracker?.recordSimpleData("charSpacing", opIdx);
            this.current.charSpacing = spacing;
          }
          setWordSpacing(opIdx, spacing) {
            this.dependencyTracker?.recordSimpleData("wordSpacing", opIdx);
            this.current.wordSpacing = spacing;
          }
          setHScale(opIdx, scale) {
            this.dependencyTracker?.recordSimpleData("hScale", opIdx);
            this.current.textHScale = scale / 100;
          }
          setLeading(opIdx, leading) {
            this.dependencyTracker?.recordSimpleData("leading", opIdx);
            this.current.leading = -leading;
          }
          setFont(opIdx, fontRefName, size) {
            this.dependencyTracker?.recordSimpleData("font", opIdx).recordSimpleDataFromNamed("fontObj", fontRefName, opIdx);
            const fontObj = this.commonObjs.get(fontRefName);
            const current = this.current;
            if (!fontObj) {
              throw new Error(`Can't find font for ${fontRefName}`);
            }
            current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
            if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
              warn("Invalid font matrix for font " + fontRefName);
            }
            if (size < 0) {
              size = -size;
              current.fontDirection = -1;
            } else {
              current.fontDirection = 1;
            }
            this.current.font = fontObj;
            this.current.fontSize = size;
            if (fontObj.isType3Font) {
              return;
            }
            const name = fontObj.loadedName || "sans-serif";
            const typeface = fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
            let bold = "normal";
            if (fontObj.black) {
              bold = "900";
            } else if (fontObj.bold) {
              bold = "bold";
            }
            const italic = fontObj.italic ? "italic" : "normal";
            let browserFontSize = size;
            if (size < MIN_FONT_SIZE) {
              browserFontSize = MIN_FONT_SIZE;
            } else if (size > MAX_FONT_SIZE) {
              browserFontSize = MAX_FONT_SIZE;
            }
            this.current.fontSizeScale = size / browserFontSize;
            this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
          }
          setTextRenderingMode(opIdx, mode) {
            this.dependencyTracker?.recordSimpleData("textRenderingMode", opIdx);
            this.current.textRenderingMode = mode;
          }
          setTextRise(opIdx, rise) {
            this.dependencyTracker?.recordSimpleData("textRise", opIdx);
            this.current.textRise = rise;
          }
          moveText(opIdx, x, y) {
            this.dependencyTracker?.resetIncrementalData("sameLineText").recordIncrementalData("moveText", opIdx);
            this.current.x = this.current.lineX += x;
            this.current.y = this.current.lineY += y;
          }
          setLeadingMoveText(opIdx, x, y) {
            this.setLeading(opIdx, -y);
            this.moveText(opIdx, x, y);
          }
          setTextMatrix(opIdx, matrix) {
            this.dependencyTracker?.resetIncrementalData("sameLineText").recordSimpleData("textMatrix", opIdx);
            const {
              current
            } = this;
            current.textMatrix = matrix;
            current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);
            current.x = current.lineX = 0;
            current.y = current.lineY = 0;
          }
          nextLine(opIdx) {
            this.moveText(opIdx, 0, this.current.leading);
            this.dependencyTracker?.recordIncrementalData("moveText", this.dependencyTracker.getSimpleIndex("leading") ?? opIdx);
          }
          #getScaledPath(path, currentTransform, transform) {
            const newPath = new Path2D();
            newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));
            return newPath;
          }
          paintChar(opIdx, character, x, y, patternFillTransform, patternStrokeTransform) {
            const ctx = this.ctx;
            const current = this.current;
            const font = current.font;
            const textRenderingMode = current.textRenderingMode;
            const fontSize = current.fontSize / current.fontSizeScale;
            const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
            const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);
            const patternFill = current.patternFill && !font.missingFile;
            const patternStroke = current.patternStroke && !font.missingFile;
            let path;
            if ((font.disableFontFace || isAddToPathSet || patternFill || patternStroke) && !font.missingFile) {
              path = font.getPathGenerator(this.commonObjs, character);
            }
            if (path && (font.disableFontFace || patternFill || patternStroke)) {
              ctx.save();
              ctx.translate(x, y);
              ctx.scale(fontSize, -fontSize);
              this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font);
              let currentTransform;
              if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
                if (patternFillTransform) {
                  currentTransform = ctx.getTransform();
                  ctx.setTransform(...patternFillTransform);
                  const scaledPath = this.#getScaledPath(path, currentTransform, patternFillTransform);
                  ctx.fill(scaledPath);
                } else {
                  ctx.fill(path);
                }
              }
              if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
                if (patternStrokeTransform) {
                  currentTransform ||= ctx.getTransform();
                  ctx.setTransform(...patternStrokeTransform);
                  const {
                    a,
                    b,
                    c,
                    d
                  } = currentTransform;
                  const invPatternTransform = Util.inverseTransform(patternStrokeTransform);
                  const transf = Util.transform([a, b, c, d, 0, 0], invPatternTransform);
                  Util.singularValueDecompose2dScale(transf, XY);
                  ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;
                  ctx.stroke(this.#getScaledPath(path, currentTransform, patternStrokeTransform));
                } else {
                  ctx.lineWidth /= fontSize;
                  ctx.stroke(path);
                }
              }
              ctx.restore();
            } else {
              if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
                ctx.fillText(character, x, y);
                this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character));
              }
              if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
                if (this.dependencyTracker) {
                  this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character)).recordDependencies(opIdx, Dependencies.stroke);
                }
                ctx.strokeText(character, x, y);
              }
            }
            if (isAddToPathSet) {
              const paths = this.pendingTextPaths ||= [];
              paths.push({
                transform: getCurrentTransform(ctx),
                x,
                y,
                fontSize,
                path
              });
              this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y);
            }
          }
          get isFontSubpixelAAEnabled() {
            const {
              context: ctx
            } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
            ctx.scale(1.5, 1);
            ctx.fillText("I", 0, 10);
            const data = ctx.getImageData(0, 0, 10, 10).data;
            let enabled = false;
            for (let i = 3; i < data.length; i += 4) {
              if (data[i] > 0 && data[i] < 255) {
                enabled = true;
                break;
              }
            }
            return shadow(this, "isFontSubpixelAAEnabled", enabled);
          }
          showText(opIdx, glyphs) {
            if (this.dependencyTracker) {
              this.dependencyTracker.recordDependencies(opIdx, Dependencies.showText).resetBBox(opIdx);
              if (this.current.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG) {
                this.dependencyTracker.recordFutureForcedDependency("textClip", opIdx).inheritPendingDependenciesAsFutureForcedDependencies();
              }
            }
            const current = this.current;
            const font = current.font;
            if (font.isType3Font) {
              this.showType3Text(opIdx, glyphs);
              this.dependencyTracker?.recordShowTextOperation(opIdx);
              return undefined;
            }
            const fontSize = current.fontSize;
            if (fontSize === 0) {
              this.dependencyTracker?.recordOperation(opIdx);
              return undefined;
            }
            const ctx = this.ctx;
            const fontSizeScale = current.fontSizeScale;
            const charSpacing = current.charSpacing;
            const wordSpacing = current.wordSpacing;
            const fontDirection = current.fontDirection;
            const textHScale = current.textHScale * fontDirection;
            const glyphsLength = glyphs.length;
            const vertical = font.vertical;
            const spacingDir = vertical ? 1 : -1;
            const defaultVMetrics = font.defaultVMetrics;
            const widthAdvanceScale = fontSize * current.fontMatrix[0];
            const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
            ctx.save();
            if (current.textMatrix) {
              ctx.transform(...current.textMatrix);
            }
            ctx.translate(current.x, current.y + current.textRise);
            if (fontDirection > 0) {
              ctx.scale(textHScale, -1);
            } else {
              ctx.scale(textHScale, 1);
            }
            let patternFillTransform, patternStrokeTransform;
            if (current.patternFill) {
              ctx.save();
              const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);
              patternFillTransform = getCurrentTransform(ctx);
              ctx.restore();
              ctx.fillStyle = pattern;
            }
            if (current.patternStroke) {
              ctx.save();
              const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);
              patternStrokeTransform = getCurrentTransform(ctx);
              ctx.restore();
              ctx.strokeStyle = pattern;
            }
            let lineWidth = current.lineWidth;
            const scale = current.textMatrixScale;
            if (scale === 0 || lineWidth === 0) {
              const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
              if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
                lineWidth = this.getSinglePixelWidth();
              }
            } else {
              lineWidth /= scale;
            }
            if (fontSizeScale !== 1.0) {
              ctx.scale(fontSizeScale, fontSizeScale);
              lineWidth /= fontSizeScale;
            }
            ctx.lineWidth = lineWidth;
            if (font.isInvalidPDFjsFont) {
              const chars = [];
              let width = 0;
              for (const glyph of glyphs) {
                chars.push(glyph.unicode);
                width += glyph.width;
              }
              const joinedChars = chars.join("");
              ctx.fillText(joinedChars, 0, 0);
              if (this.dependencyTracker !== null) {
                const measure = ctx.measureText(joinedChars);
                this.dependencyTracker.recordBBox(opIdx, this.ctx, -measure.actualBoundingBoxLeft, measure.actualBoundingBoxRight, -measure.actualBoundingBoxAscent, measure.actualBoundingBoxDescent).recordShowTextOperation(opIdx);
              }
              current.x += width * widthAdvanceScale * textHScale;
              ctx.restore();
              this.compose();
              return undefined;
            }
            let x = 0,
              i;
            for (i = 0; i < glyphsLength; ++i) {
              const glyph = glyphs[i];
              if (typeof glyph === "number") {
                x += spacingDir * glyph * fontSize / 1000;
                continue;
              }
              let restoreNeeded = false;
              const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
              const character = glyph.fontChar;
              const accent = glyph.accent;
              let scaledX, scaledY;
              let width = glyph.width;
              if (vertical) {
                const vmetric = glyph.vmetric || defaultVMetrics;
                const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
                const vy = vmetric[2] * widthAdvanceScale;
                width = vmetric ? -vmetric[0] : width;
                scaledX = vx / fontSizeScale;
                scaledY = (x + vy) / fontSizeScale;
              } else {
                scaledX = x / fontSizeScale;
                scaledY = 0;
              }
              let measure;
              if (font.remeasure && width > 0) {
                measure = ctx.measureText(character);
                const measuredWidth = measure.width * 1000 / fontSize * fontSizeScale;
                if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
                  const characterScaleX = width / measuredWidth;
                  restoreNeeded = true;
                  ctx.save();
                  ctx.scale(characterScaleX, 1);
                  scaledX /= characterScaleX;
                } else if (width !== measuredWidth) {
                  scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;
                }
              }
              if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
                if (simpleFillText && !accent) {
                  ctx.fillText(character, scaledX, scaledY);
                  this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, measure ? {
                    bbox: null
                  } : font, fontSize / fontSizeScale, scaledX, scaledY, () => measure ?? ctx.measureText(character));
                } else {
                  this.paintChar(opIdx, character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);
                  if (accent) {
                    const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                    const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                    this.paintChar(opIdx, accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);
                  }
                }
              }
              const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
              x += charWidth;
              if (restoreNeeded) {
                ctx.restore();
              }
            }
            if (vertical) {
              current.y -= x;
            } else {
              current.x += x * textHScale;
            }
            ctx.restore();
            this.compose();
            this.dependencyTracker?.recordShowTextOperation(opIdx);
            return undefined;
          }
          showType3Text(opIdx, glyphs) {
            const ctx = this.ctx;
            const current = this.current;
            const font = current.font;
            const fontSize = current.fontSize;
            const fontDirection = current.fontDirection;
            const spacingDir = font.vertical ? 1 : -1;
            const charSpacing = current.charSpacing;
            const wordSpacing = current.wordSpacing;
            const textHScale = current.textHScale * fontDirection;
            const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
            const glyphsLength = glyphs.length;
            const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;
            let i, glyph, width, spacingLength;
            if (isTextInvisible || fontSize === 0) {
              return;
            }
            this._cachedScaleForStroking[0] = -1;
            this._cachedGetSinglePixelWidth = null;
            ctx.save();
            if (current.textMatrix) {
              ctx.transform(...current.textMatrix);
            }
            ctx.translate(current.x, current.y + current.textRise);
            ctx.scale(textHScale, fontDirection);
            const dependencyTracker = this.dependencyTracker;
            this.dependencyTracker = dependencyTracker ? new CanvasNestedDependencyTracker(dependencyTracker, opIdx) : null;
            for (i = 0; i < glyphsLength; ++i) {
              glyph = glyphs[i];
              if (typeof glyph === "number") {
                spacingLength = spacingDir * glyph * fontSize / 1000;
                this.ctx.translate(spacingLength, 0);
                current.x += spacingLength * textHScale;
                continue;
              }
              const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
              const operatorList = font.charProcOperatorList[glyph.operatorListId];
              if (!operatorList) {
                warn(`Type3 character "${glyph.operatorListId}" is not available.`);
              } else if (this.contentVisible) {
                this.save();
                ctx.scale(fontSize, fontSize);
                ctx.transform(...fontMatrix);
                this.executeOperatorList(operatorList);
                this.restore();
              }
              const p = [glyph.width, 0];
              Util.applyTransform(p, fontMatrix);
              width = p[0] * fontSize + spacing;
              ctx.translate(width, 0);
              current.x += width * textHScale;
            }
            ctx.restore();
            if (dependencyTracker) {
              this.dependencyTracker = dependencyTracker;
            }
          }
          setCharWidth(opIdx, xWidth, yWidth) { }
          setCharWidthAndBounds(opIdx, xWidth, yWidth, llx, lly, urx, ury) {
            const clip = new Path2D();
            clip.rect(llx, lly, urx - llx, ury - lly);
            this.ctx.clip(clip);
            this.dependencyTracker?.recordBBox(opIdx, this.ctx, llx, urx, lly, ury).recordClipBox(opIdx, this.ctx, llx, urx, lly, ury);
            this.endPath(opIdx);
          }
          getColorN_Pattern(opIdx, IR) {
            let pattern;
            if (IR[0] === "TilingPattern") {
              const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
              const canvasGraphicsFactory = {
                createCanvasGraphics: (ctx, renderingOpIdx) => new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
                  optionalContentConfig: this.optionalContentConfig,
                  markedContentStack: this.markedContentStack
                }, undefined, undefined, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, renderingOpIdx, true) : null)
              };
              pattern = new TilingPattern(IR, this.ctx, canvasGraphicsFactory, baseTransform);
            } else {
              pattern = this._getPattern(opIdx, IR[1], IR[2]);
            }
            return pattern;
          }
          setStrokeColorN(opIdx, ...args) {
            this.dependencyTracker?.recordSimpleData("strokeColor", opIdx);
            this.current.strokeColor = this.getColorN_Pattern(opIdx, args);
            this.current.patternStroke = true;
          }
          setFillColorN(opIdx, ...args) {
            this.dependencyTracker?.recordSimpleData("fillColor", opIdx);
            this.current.fillColor = this.getColorN_Pattern(opIdx, args);
            this.current.patternFill = true;
          }
          setStrokeRGBColor(opIdx, color) {
            this.dependencyTracker?.recordSimpleData("strokeColor", opIdx);
            this.ctx.strokeStyle = this.current.strokeColor = color;
            this.current.patternStroke = false;
          }
          setStrokeTransparent(opIdx) {
            this.dependencyTracker?.recordSimpleData("strokeColor", opIdx);
            this.ctx.strokeStyle = this.current.strokeColor = "transparent";
            this.current.patternStroke = false;
          }
          setFillRGBColor(opIdx, color) {
            this.dependencyTracker?.recordSimpleData("fillColor", opIdx);
            this.ctx.fillStyle = this.current.fillColor = color;
            this.current.patternFill = false;
          }
          setFillTransparent(opIdx) {
            this.dependencyTracker?.recordSimpleData("fillColor", opIdx);
            this.ctx.fillStyle = this.current.fillColor = "transparent";
            this.current.patternFill = false;
          }
          _getPattern(opIdx, objId, matrix = null) {
            let pattern;
            if (this.cachedPatterns.has(objId)) {
              pattern = this.cachedPatterns.get(objId);
            } else {
              pattern = getShadingPattern(this.getObject(opIdx, objId));
              this.cachedPatterns.set(objId, pattern);
            }
            if (matrix) {
              pattern.matrix = matrix;
            }
            return pattern;
          }
          shadingFill(opIdx, objId) {
            if (!this.contentVisible) {
              return;
            }
            const ctx = this.ctx;
            this.save(opIdx);
            const pattern = this._getPattern(opIdx, objId);
            ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING, opIdx);
            const inv = getCurrentTransformInverse(ctx);
            if (inv) {
              const {
                width,
                height
              } = ctx.canvas;
              const minMax = MIN_MAX_INIT.slice();
              Util.axialAlignedBoundingBox([0, 0, width, height], inv, minMax);
              const [x0, y0, x1, y1] = minMax;
              this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
            } else {
              this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
            }
            this.dependencyTracker?.resetBBox(opIdx).recordFullPageBBox(opIdx).recordDependencies(opIdx, Dependencies.transform).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);
            this.compose(this.current.getClippedPathBoundingBox());
            this.restore(opIdx);
          }
          beginInlineImage() {
            unreachable("Should not call beginInlineImage");
          }
          beginImageData() {
            unreachable("Should not call beginImageData");
          }
          paintFormXObjectBegin(opIdx, matrix, bbox) {
            if (!this.contentVisible) {
              return;
            }
            this.save(opIdx);
            this.baseTransformStack.push(this.baseTransform);
            if (matrix) {
              this.transform(opIdx, ...matrix);
            }
            this.baseTransform = getCurrentTransform(this.ctx);
            if (bbox) {
              Util.axialAlignedBoundingBox(bbox, this.baseTransform, this.current.minMax);
              const [x0, y0, x1, y1] = bbox;
              const clip = new Path2D();
              clip.rect(x0, y0, x1 - x0, y1 - y0);
              this.ctx.clip(clip);
              this.dependencyTracker?.recordClipBox(opIdx, this.ctx, x0, x1, y0, y1);
              this.endPath(opIdx);
            }
          }
          paintFormXObjectEnd(opIdx) {
            if (!this.contentVisible) {
              return;
            }
            this.restore(opIdx);
            this.baseTransform = this.baseTransformStack.pop();
          }
          beginGroup(opIdx, group) {
            if (!this.contentVisible) {
              return;
            }
            this.save(opIdx);
            if (this.inSMaskMode) {
              this.endSMaskMode();
              this.current.activeSMask = null;
            }
            const currentCtx = this.ctx;
            if (!group.isolated) {
              info("TODO: Support non-isolated groups.");
            }
            if (group.knockout) {
              warn("Knockout groups not supported.");
            }
            const currentTransform = getCurrentTransform(currentCtx);
            if (group.matrix) {
              currentCtx.transform(...group.matrix);
            }
            if (!group.bbox) {
              throw new Error("Bounding box is required.");
            }
            let bounds = MIN_MAX_INIT.slice();
            Util.axialAlignedBoundingBox(group.bbox, getCurrentTransform(currentCtx), bounds);
            const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
            bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
            const offsetX = Math.floor(bounds[0]);
            const offsetY = Math.floor(bounds[1]);
            const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
            const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
            this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
            let cacheId = "groupAt" + this.groupLevel;
            if (group.smask) {
              cacheId += "_smask_" + this.smaskCounter++ % 2;
            }
            const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
            const groupCtx = scratchCanvas.context;
            groupCtx.translate(-offsetX, -offsetY);
            groupCtx.transform(...currentTransform);
            let clip = new Path2D();
            const [x0, y0, x1, y1] = group.bbox;
            clip.rect(x0, y0, x1 - x0, y1 - y0);
            if (group.matrix) {
              const path = new Path2D();
              path.addPath(clip, new DOMMatrix(group.matrix));
              clip = path;
            }
            groupCtx.clip(clip);
            if (group.smask) {
              this.smaskStack.push({
                canvas: scratchCanvas.canvas,
                context: groupCtx,
                offsetX,
                offsetY,
                subtype: group.smask.subtype,
                backdrop: group.smask.backdrop,
                transferMap: group.smask.transferMap || null,
                startTransformInverse: null
              });
            }
            if (!group.smask || this.dependencyTracker) {
              currentCtx.setTransform(1, 0, 0, 1, 0, 0);
              currentCtx.translate(offsetX, offsetY);
              currentCtx.save();
            }
            copyCtxState(currentCtx, groupCtx);
            this.ctx = groupCtx;
            this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies(["fillAlpha", "strokeAlpha", "globalCompositeOperation"]).pushBaseTransform(currentCtx);
            this.setGState(opIdx, [["BM", "source-over"], ["ca", 1], ["CA", 1]]);
            this.groupStack.push(currentCtx);
            this.groupLevel++;
          }
          endGroup(opIdx, group) {
            if (!this.contentVisible) {
              return;
            }
            this.groupLevel--;
            const groupCtx = this.ctx;
            const ctx = this.groupStack.pop();
            this.ctx = ctx;
            this.ctx.imageSmoothingEnabled = false;
            this.dependencyTracker?.popBaseTransform();
            if (group.smask) {
              this.tempSMask = this.smaskStack.pop();
              this.restore(opIdx);
              if (this.dependencyTracker) {
                this.ctx.restore();
              }
            } else {
              this.ctx.restore();
              const currentMtx = getCurrentTransform(this.ctx);
              this.restore(opIdx);
              this.ctx.save();
              this.ctx.setTransform(...currentMtx);
              const dirtyBox = MIN_MAX_INIT.slice();
              Util.axialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx, dirtyBox);
              this.ctx.drawImage(groupCtx.canvas, 0, 0);
              this.ctx.restore();
              this.compose(dirtyBox);
            }
          }
          beginAnnotation(opIdx, id, rect, transform, matrix, hasOwnCanvas) {
            this.#restoreInitialState();
            resetCtxToDefault(this.ctx);
            this.ctx.save();
            this.save(opIdx);
            if (this.baseTransform) {
              this.ctx.setTransform(...this.baseTransform);
            }
            if (rect) {
              const width = rect[2] - rect[0];
              const height = rect[3] - rect[1];
              if (hasOwnCanvas && this.annotationCanvasMap) {
                transform = transform.slice();
                transform[4] -= rect[0];
                transform[5] -= rect[1];
                rect = rect.slice();
                rect[0] = rect[1] = 0;
                rect[2] = width;
                rect[3] = height;
                Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);
                const {
                  viewportScale
                } = this;
                const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
                const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
                this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
                const {
                  canvas,
                  context
                } = this.annotationCanvas;
                this.annotationCanvasMap.set(id, canvas);
                this.annotationCanvas.savedCtx = this.ctx;
                this.ctx = context;
                this.ctx.save();
                this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);
                resetCtxToDefault(this.ctx);
              } else {
                resetCtxToDefault(this.ctx);
                this.endPath(opIdx);
                const clip = new Path2D();
                clip.rect(rect[0], rect[1], width, height);
                this.ctx.clip(clip);
              }
            }
            this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
            this.transform(opIdx, ...transform);
            this.transform(opIdx, ...matrix);
          }
          endAnnotation(opIdx) {
            if (this.annotationCanvas) {
              this.ctx.restore();
              this.#drawFilter();
              this.ctx = this.annotationCanvas.savedCtx;
              delete this.annotationCanvas.savedCtx;
              delete this.annotationCanvas;
            }
          }
          paintImageMaskXObject(opIdx, img) {
            if (!this.contentVisible) {
              return;
            }
            const count = img.count;
            img = this.getObject(opIdx, img.data, img);
            img.count = count;
            const ctx = this.ctx;
            const mask = this._createMaskCanvas(opIdx, img);
            const maskCanvas = mask.canvas;
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
            this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, mask.offsetX, mask.offsetX + maskCanvas.width, mask.offsetY, mask.offsetY + maskCanvas.height).recordOperation(opIdx);
            ctx.restore();
            this.compose();
          }
          paintImageMaskXObjectRepeat(opIdx, img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
            if (!this.contentVisible) {
              return;
            }
            img = this.getObject(opIdx, img.data, img);
            const ctx = this.ctx;
            ctx.save();
            const currentTransform = getCurrentTransform(ctx);
            ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
            const mask = this._createMaskCanvas(opIdx, img);
            ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
            this.dependencyTracker?.resetBBox(opIdx);
            for (let i = 0, ii = positions.length; i < ii; i += 2) {
              const trans = Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
              ctx.drawImage(mask.canvas, trans[4], trans[5]);
              this.dependencyTracker?.recordBBox(opIdx, this.ctx, trans[4], trans[4] + mask.canvas.width, trans[5], trans[5] + mask.canvas.height);
            }
            ctx.restore();
            this.compose();
            this.dependencyTracker?.recordOperation(opIdx);
          }
          paintImageMaskXObjectGroup(opIdx, images) {
            if (!this.contentVisible) {
              return;
            }
            const ctx = this.ctx;
            const fillColor = this.current.fillColor;
            const isPatternFill = this.current.patternFill;
            this.dependencyTracker?.resetBBox(opIdx).recordDependencies(opIdx, Dependencies.transformAndFill);
            for (const image of images) {
              const {
                data,
                width,
                height,
                transform
              } = image;
              const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
              const maskCtx = maskCanvas.context;
              maskCtx.save();
              const img = this.getObject(opIdx, data, image);
              putBinaryImageMask(maskCtx, img);
              maskCtx.globalCompositeOperation = "source-in";
              maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx) : fillColor;
              maskCtx.fillRect(0, 0, width, height);
              maskCtx.restore();
              ctx.save();
              ctx.transform(...transform);
              ctx.scale(1, -1);
              drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
              this.dependencyTracker?.recordBBox(opIdx, ctx, 0, width, 0, height);
              ctx.restore();
            }
            this.compose();
            this.dependencyTracker?.recordOperation(opIdx);
          }
          paintImageXObject(opIdx, objId) {
            if (!this.contentVisible) {
              return;
            }
            const imgData = this.getObject(opIdx, objId);
            if (!imgData) {
              warn("Dependent image isn't ready yet");
              return;
            }
            this.paintInlineImageXObject(opIdx, imgData);
          }
          paintImageXObjectRepeat(opIdx, objId, scaleX, scaleY, positions) {
            if (!this.contentVisible) {
              return;
            }
            const imgData = this.getObject(opIdx, objId);
            if (!imgData) {
              warn("Dependent image isn't ready yet");
              return;
            }
            const width = imgData.width;
            const height = imgData.height;
            const map = [];
            for (let i = 0, ii = positions.length; i < ii; i += 2) {
              map.push({
                transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
                x: 0,
                y: 0,
                w: width,
                h: height
              });
            }
            this.paintInlineImageXObjectGroup(opIdx, imgData, map);
          }
          applyTransferMapsToCanvas(ctx) {
            if (this.current.transferMaps !== "none") {
              ctx.filter = this.current.transferMaps;
              ctx.drawImage(ctx.canvas, 0, 0);
              ctx.filter = "none";
            }
            return ctx.canvas;
          }
          applyTransferMapsToBitmap(imgData) {
            if (this.current.transferMaps === "none") {
              return imgData.bitmap;
            }
            const {
              bitmap,
              width,
              height
            } = imgData;
            const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
            const tmpCtx = tmpCanvas.context;
            tmpCtx.filter = this.current.transferMaps;
            tmpCtx.drawImage(bitmap, 0, 0);
            tmpCtx.filter = "none";
            return tmpCanvas.canvas;
          }
          paintInlineImageXObject(opIdx, imgData) {
            if (!this.contentVisible) {
              return;
            }
            const width = imgData.width;
            const height = imgData.height;
            const ctx = this.ctx;
            this.save(opIdx);
            const {
              filter
            } = ctx;
            if (filter !== "none" && filter !== "") {
              ctx.filter = "none";
            }
            ctx.scale(1 / width, -1 / height);
            let imgToPaint;
            if (imgData.bitmap) {
              imgToPaint = this.applyTransferMapsToBitmap(imgData);
            } else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
              imgToPaint = imgData;
            } else {
              const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
              const tmpCtx = tmpCanvas.context;
              putBinaryImageData(tmpCtx, imgData);
              imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
            }
            const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));
            ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);
            this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, ctx, 0, width, -height, 0).recordDependencies(opIdx, Dependencies.imageXObject).recordOperation(opIdx);
            drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
            this.compose();
            this.restore(opIdx);
          }
          paintInlineImageXObjectGroup(opIdx, imgData, map) {
            if (!this.contentVisible) {
              return;
            }
            const ctx = this.ctx;
            let imgToPaint;
            if (imgData.bitmap) {
              imgToPaint = imgData.bitmap;
            } else {
              const w = imgData.width;
              const h = imgData.height;
              const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
              const tmpCtx = tmpCanvas.context;
              putBinaryImageData(tmpCtx, imgData);
              imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
            }
            this.dependencyTracker?.resetBBox(opIdx);
            for (const entry of map) {
              ctx.save();
              ctx.transform(...entry.transform);
              ctx.scale(1, -1);
              drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
              this.dependencyTracker?.recordBBox(opIdx, ctx, 0, 1, -1, 0);
              ctx.restore();
            }
            this.dependencyTracker?.recordOperation(opIdx);
            this.compose();
          }
          paintSolidColorImageMask(opIdx) {
            if (!this.contentVisible) {
              return;
            }
            this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, 0, 1, 0, 1).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);
            this.ctx.fillRect(0, 0, 1, 1);
            this.compose();
          }
          markPoint(opIdx, tag) { }
          markPointProps(opIdx, tag, properties) { }
          beginMarkedContent(opIdx, tag) {
            this.dependencyTracker?.beginMarkedContent(opIdx);
            this.markedContentStack.push({
              visible: true
            });
          }
          beginMarkedContentProps(opIdx, tag, properties) {
            this.dependencyTracker?.beginMarkedContent(opIdx);
            if (tag === "OC") {
              this.markedContentStack.push({
                visible: this.optionalContentConfig.isVisible(properties)
              });
            } else {
              this.markedContentStack.push({
                visible: true
              });
            }
            this.contentVisible = this.isContentVisible();
          }
          endMarkedContent(opIdx) {
            this.dependencyTracker?.endMarkedContent(opIdx);
            this.markedContentStack.pop();
            this.contentVisible = this.isContentVisible();
          }
          beginCompat(opIdx) { }
          endCompat(opIdx) { }
          consumePath(opIdx, path, clipBox) {
            const isEmpty = this.current.isEmptyClip();
            if (this.pendingClip) {
              this.current.updateClipFromPath();
            }
            if (!this.pendingClip) {
              this.compose(clipBox);
            }
            const ctx = this.ctx;
            if (this.pendingClip) {
              if (!isEmpty) {
                if (this.pendingClip === EO_CLIP) {
                  ctx.clip(path, "evenodd");
                } else {
                  ctx.clip(path);
                }
              }
              this.pendingClip = null;
              this.dependencyTracker?.bboxToClipBoxDropOperation(opIdx).recordFutureForcedDependency("clipPath", opIdx);
            } else {
              this.dependencyTracker?.recordOperation(opIdx);
            }
            this.current.startNewPathAndClipBox(this.current.clipBox);
          }
          getSinglePixelWidth() {
            if (!this._cachedGetSinglePixelWidth) {
              const m = getCurrentTransform(this.ctx);
              if (m[1] === 0 && m[2] === 0) {
                this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
              } else {
                const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
                const normX = Math.hypot(m[0], m[2]);
                const normY = Math.hypot(m[1], m[3]);
                this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
              }
            }
            return this._cachedGetSinglePixelWidth;
          }
          getScaleForStroking() {
            if (this._cachedScaleForStroking[0] === -1) {
              const {
                lineWidth
              } = this.current;
              const {
                a,
                b,
                c,
                d
              } = this.ctx.getTransform();
              let scaleX, scaleY;
              if (b === 0 && c === 0) {
                const normX = Math.abs(a);
                const normY = Math.abs(d);
                if (normX === normY) {
                  if (lineWidth === 0) {
                    scaleX = scaleY = 1 / normX;
                  } else {
                    const scaledLineWidth = normX * lineWidth;
                    scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
                  }
                } else if (lineWidth === 0) {
                  scaleX = 1 / normX;
                  scaleY = 1 / normY;
                } else {
                  const scaledXLineWidth = normX * lineWidth;
                  const scaledYLineWidth = normY * lineWidth;
                  scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
                  scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
                }
              } else {
                const absDet = Math.abs(a * d - b * c);
                const normX = Math.hypot(a, b);
                const normY = Math.hypot(c, d);
                if (lineWidth === 0) {
                  scaleX = normY / absDet;
                  scaleY = normX / absDet;
                } else {
                  const baseArea = lineWidth * absDet;
                  scaleX = normY > baseArea ? normY / baseArea : 1;
                  scaleY = normX > baseArea ? normX / baseArea : 1;
                }
              }
              this._cachedScaleForStroking[0] = scaleX;
              this._cachedScaleForStroking[1] = scaleY;
            }
            return this._cachedScaleForStroking;
          }
          rescaleAndStroke(path, saveRestore) {
            const {
              ctx,
              current: {
                lineWidth
              }
            } = this;
            const [scaleX, scaleY] = this.getScaleForStroking();
            if (scaleX === scaleY) {
              ctx.lineWidth = (lineWidth || 1) * scaleX;
              ctx.stroke(path);
              return;
            }
            const dashes = ctx.getLineDash();
            if (saveRestore) {
              ctx.save();
            }
            ctx.scale(scaleX, scaleY);
            SCALE_MATRIX.a = 1 / scaleX;
            SCALE_MATRIX.d = 1 / scaleY;
            const newPath = new Path2D();
            newPath.addPath(path, SCALE_MATRIX);
            if (dashes.length > 0) {
              const scale = Math.max(scaleX, scaleY);
              ctx.setLineDash(dashes.map(x => x / scale));
              ctx.lineDashOffset /= scale;
            }
            ctx.lineWidth = lineWidth || 1;
            ctx.stroke(newPath);
            if (saveRestore) {
              ctx.restore();
            }
          }
          isContentVisible() {
            for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
              if (!this.markedContentStack[i].visible) {
                return false;
              }
            }
            return true;
          }
        }
        for (const op in OPS) {
          if (CanvasGraphics.prototype[op] !== undefined) {
            CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
          }
        }

        ;// ./src/display/worker_options.js
        class GlobalWorkerOptions {
          static #port = null;
          static #src = "";
          static get workerPort() {
            return this.#port;
          }
          static set workerPort(val) {
            if (!(typeof Worker !== "undefined" && val instanceof Worker) && val !== null) {
              throw new Error("Invalid `workerPort` type.");
            }
            this.#port = val;
          }
          static get workerSrc() {
            return this.#src;
          }
          static set workerSrc(val) {
            if (typeof val !== "string") {
              throw new Error("Invalid `workerSrc` type.");
            }
            this.#src = val;
          }
        }

        ;// ./src/display/metadata.js
        class Metadata {
          #map;
          #data;
          constructor({
            parsedData,
            rawData
          }) {
            this.#map = parsedData;
            this.#data = rawData;
          }
          getRaw() {
            return this.#data;
          }
          get(name) {
            return this.#map.get(name) ?? null;
          }
          [Symbol.iterator]() {
            return this.#map.entries();
          }
        }

        ;// ./src/display/optional_content_config.js


        const INTERNAL = Symbol("INTERNAL");
        class OptionalContentGroup {
          #isDisplay = false;
          #isPrint = false;
          #userSet = false;
          #visible = true;
          constructor(renderingIntent, {
            name,
            intent,
            usage,
            rbGroups
          }) {
            this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);
            this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
            this.name = name;
            this.intent = intent;
            this.usage = usage;
            this.rbGroups = rbGroups;
          }
          get visible() {
            if (this.#userSet) {
              return this.#visible;
            }
            if (!this.#visible) {
              return false;
            }
            const {
              print,
              view
            } = this.usage;
            if (this.#isDisplay) {
              return view?.viewState !== "OFF";
            } else if (this.#isPrint) {
              return print?.printState !== "OFF";
            }
            return true;
          }
          _setVisible(internal, visible, userSet = false) {
            if (internal !== INTERNAL) {
              unreachable("Internal method `_setVisible` called.");
            }
            this.#userSet = userSet;
            this.#visible = visible;
          }
        }
        class OptionalContentConfig {
          #cachedGetHash = null;
          #groups = new Map();
          #initialHash = null;
          #order = null;
          constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY) {
            this.renderingIntent = renderingIntent;
            this.name = null;
            this.creator = null;
            if (data === null) {
              return;
            }
            this.name = data.name;
            this.creator = data.creator;
            this.#order = data.order;
            for (const group of data.groups) {
              this.#groups.set(group.id, new OptionalContentGroup(renderingIntent, group));
            }
            if (data.baseState === "OFF") {
              for (const group of this.#groups.values()) {
                group._setVisible(INTERNAL, false);
              }
            }
            for (const on of data.on) {
              this.#groups.get(on)._setVisible(INTERNAL, true);
            }
            for (const off of data.off) {
              this.#groups.get(off)._setVisible(INTERNAL, false);
            }
            this.#initialHash = this.getHash();
          }
          #evaluateVisibilityExpression(array) {
            const length = array.length;
            if (length < 2) {
              return true;
            }
            const operator = array[0];
            for (let i = 1; i < length; i++) {
              const element = array[i];
              let state;
              if (Array.isArray(element)) {
                state = this.#evaluateVisibilityExpression(element);
              } else if (this.#groups.has(element)) {
                state = this.#groups.get(element).visible;
              } else {
                warn(`Optional content group not found: ${element}`);
                return true;
              }
              switch (operator) {
                case "And":
                  if (!state) {
                    return false;
                  }
                  break;
                case "Or":
                  if (state) {
                    return true;
                  }
                  break;
                case "Not":
                  return !state;
                default:
                  return true;
              }
            }
            return operator === "And";
          }
          isVisible(group) {
            if (this.#groups.size === 0) {
              return true;
            }
            if (!group) {
              info("Optional content group not defined.");
              return true;
            }
            if (group.type === "OCG") {
              if (!this.#groups.has(group.id)) {
                warn(`Optional content group not found: ${group.id}`);
                return true;
              }
              return this.#groups.get(group.id).visible;
            } else if (group.type === "OCMD") {
              if (group.expression) {
                return this.#evaluateVisibilityExpression(group.expression);
              }
              if (!group.policy || group.policy === "AnyOn") {
                for (const id of group.ids) {
                  if (!this.#groups.has(id)) {
                    warn(`Optional content group not found: ${id}`);
                    return true;
                  }
                  if (this.#groups.get(id).visible) {
                    return true;
                  }
                }
                return false;
              } else if (group.policy === "AllOn") {
                for (const id of group.ids) {
                  if (!this.#groups.has(id)) {
                    warn(`Optional content group not found: ${id}`);
                    return true;
                  }
                  if (!this.#groups.get(id).visible) {
                    return false;
                  }
                }
                return true;
              } else if (group.policy === "AnyOff") {
                for (const id of group.ids) {
                  if (!this.#groups.has(id)) {
                    warn(`Optional content group not found: ${id}`);
                    return true;
                  }
                  if (!this.#groups.get(id).visible) {
                    return true;
                  }
                }
                return false;
              } else if (group.policy === "AllOff") {
                for (const id of group.ids) {
                  if (!this.#groups.has(id)) {
                    warn(`Optional content group not found: ${id}`);
                    return true;
                  }
                  if (this.#groups.get(id).visible) {
                    return false;
                  }
                }
                return true;
              }
              warn(`Unknown optional content policy ${group.policy}.`);
              return true;
            }
            warn(`Unknown group type ${group.type}.`);
            return true;
          }
          setVisibility(id, visible = true, preserveRB = true) {
            const group = this.#groups.get(id);
            if (!group) {
              warn(`Optional content group not found: ${id}`);
              return;
            }
            if (preserveRB && visible && group.rbGroups.length) {
              for (const rbGroup of group.rbGroups) {
                for (const otherId of rbGroup) {
                  if (otherId !== id) {
                    this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);
                  }
                }
              }
            }
            group._setVisible(INTERNAL, !!visible, true);
            this.#cachedGetHash = null;
          }
          setOCGState({
            state,
            preserveRB
          }) {
            let operator;
            for (const elem of state) {
              switch (elem) {
                case "ON":
                case "OFF":
                case "Toggle":
                  operator = elem;
                  continue;
              }
              const group = this.#groups.get(elem);
              if (!group) {
                continue;
              }
              switch (operator) {
                case "ON":
                  this.setVisibility(elem, true, preserveRB);
                  break;
                case "OFF":
                  this.setVisibility(elem, false, preserveRB);
                  break;
                case "Toggle":
                  this.setVisibility(elem, !group.visible, preserveRB);
                  break;
              }
            }
            this.#cachedGetHash = null;
          }
          get hasInitialVisibility() {
            return this.#initialHash === null || this.getHash() === this.#initialHash;
          }
          getOrder() {
            if (!this.#groups.size) {
              return null;
            }
            if (this.#order) {
              return this.#order.slice();
            }
            return [...this.#groups.keys()];
          }
          getGroup(id) {
            return this.#groups.get(id) || null;
          }
          getHash() {
            if (this.#cachedGetHash !== null) {
              return this.#cachedGetHash;
            }
            const hash = new MurmurHash3_64();
            for (const [id, group] of this.#groups) {
              hash.update(`${id}:${group.visible}`);
            }
            return this.#cachedGetHash = hash.hexdigest();
          }
          [Symbol.iterator]() {
            return this.#groups.entries();
          }
        }

        ;// ./src/display/transport_stream.js


        class PDFDataTransportStream {
          constructor(pdfDataRangeTransport, {
            disableRange = false,
            disableStream = false
          }) {
            assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
            const {
              length,
              initialData,
              progressiveDone,
              contentDispositionFilename
            } = pdfDataRangeTransport;
            this._queuedChunks = [];
            this._progressiveDone = progressiveDone;
            this._contentDispositionFilename = contentDispositionFilename;
            if (initialData?.length > 0) {
              const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
              this._queuedChunks.push(buffer);
            }
            this._pdfDataRangeTransport = pdfDataRangeTransport;
            this._isStreamingSupported = !disableStream;
            this._isRangeSupported = !disableRange;
            this._contentLength = length;
            this._fullRequestReader = null;
            this._rangeReaders = [];
            pdfDataRangeTransport.addRangeListener((begin, chunk) => {
              this._onReceiveData({
                begin,
                chunk
              });
            });
            pdfDataRangeTransport.addProgressListener((loaded, total) => {
              this._onProgress({
                loaded,
                total
              });
            });
            pdfDataRangeTransport.addProgressiveReadListener(chunk => {
              this._onReceiveData({
                chunk
              });
            });
            pdfDataRangeTransport.addProgressiveDoneListener(() => {
              this._onProgressiveDone();
            });
            pdfDataRangeTransport.transportReady();
          }
          _onReceiveData({
            begin,
            chunk
          }) {
            const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;
            if (begin === undefined) {
              if (this._fullRequestReader) {
                this._fullRequestReader._enqueue(buffer);
              } else {
                this._queuedChunks.push(buffer);
              }
            } else {
              const found = this._rangeReaders.some(function (rangeReader) {
                if (rangeReader._begin !== begin) {
                  return false;
                }
                rangeReader._enqueue(buffer);
                return true;
              });
              assert(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
            }
          }
          get _progressiveDataLength() {
            return this._fullRequestReader?._loaded ?? 0;
          }
          _onProgress(evt) {
            if (evt.total === undefined) {
              this._rangeReaders[0]?.onProgress?.({
                loaded: evt.loaded
              });
            } else {
              this._fullRequestReader?.onProgress?.({
                loaded: evt.loaded,
                total: evt.total
              });
            }
          }
          _onProgressiveDone() {
            this._fullRequestReader?.progressiveDone();
            this._progressiveDone = true;
          }
          _removeRangeReader(reader) {
            const i = this._rangeReaders.indexOf(reader);
            if (i >= 0) {
              this._rangeReaders.splice(i, 1);
            }
          }
          getFullReader() {
            assert(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
            const queuedChunks = this._queuedChunks;
            this._queuedChunks = null;
            return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
          }
          getRangeReader(begin, end) {
            if (end <= this._progressiveDataLength) {
              return null;
            }
            const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
            this._pdfDataRangeTransport.requestDataRange(begin, end);
            this._rangeReaders.push(reader);
            return reader;
          }
          cancelAllRequests(reason) {
            this._fullRequestReader?.cancel(reason);
            for (const reader of this._rangeReaders.slice(0)) {
              reader.cancel(reason);
            }
            this._pdfDataRangeTransport.abort();
          }
        }
        class PDFDataTransportStreamReader {
          constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
            this._stream = stream;
            this._done = progressiveDone || false;
            this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;
            this._queuedChunks = queuedChunks || [];
            this._loaded = 0;
            for (const chunk of this._queuedChunks) {
              this._loaded += chunk.byteLength;
            }
            this._requests = [];
            this._headersReady = Promise.resolve();
            stream._fullRequestReader = this;
            this.onProgress = null;
          }
          _enqueue(chunk) {
            if (this._done) {
              return;
            }
            if (this._requests.length > 0) {
              const requestCapability = this._requests.shift();
              requestCapability.resolve({
                value: chunk,
                done: false
              });
            } else {
              this._queuedChunks.push(chunk);
            }
            this._loaded += chunk.byteLength;
          }
          get headersReady() {
            return this._headersReady;
          }
          get filename() {
            return this._filename;
          }
          get isRangeSupported() {
            return this._stream._isRangeSupported;
          }
          get isStreamingSupported() {
            return this._stream._isStreamingSupported;
          }
          get contentLength() {
            return this._stream._contentLength;
          }
          async read() {
            if (this._queuedChunks.length > 0) {
              const chunk = this._queuedChunks.shift();
              return {
                value: chunk,
                done: false
              };
            }
            if (this._done) {
              return {
                value: undefined,
                done: true
              };
            }
            const requestCapability = Promise.withResolvers();
            this._requests.push(requestCapability);
            return requestCapability.promise;
          }
          cancel(reason) {
            this._done = true;
            for (const requestCapability of this._requests) {
              requestCapability.resolve({
                value: undefined,
                done: true
              });
            }
            this._requests.length = 0;
          }
          progressiveDone() {
            if (this._done) {
              return;
            }
            this._done = true;
          }
        }
        class PDFDataTransportStreamRangeReader {
          constructor(stream, begin, end) {
            this._stream = stream;
            this._begin = begin;
            this._end = end;
            this._queuedChunk = null;
            this._requests = [];
            this._done = false;
            this.onProgress = null;
          }
          _enqueue(chunk) {
            if (this._done) {
              return;
            }
            if (this._requests.length === 0) {
              this._queuedChunk = chunk;
            } else {
              const requestsCapability = this._requests.shift();
              requestsCapability.resolve({
                value: chunk,
                done: false
              });
              for (const requestCapability of this._requests) {
                requestCapability.resolve({
                  value: undefined,
                  done: true
                });
              }
              this._requests.length = 0;
            }
            this._done = true;
            this._stream._removeRangeReader(this);
          }
          get isStreamingSupported() {
            return false;
          }
          async read() {
            if (this._queuedChunk) {
              const chunk = this._queuedChunk;
              this._queuedChunk = null;
              return {
                value: chunk,
                done: false
              };
            }
            if (this._done) {
              return {
                value: undefined,
                done: true
              };
            }
            const requestCapability = Promise.withResolvers();
            this._requests.push(requestCapability);
            return requestCapability.promise;
          }
          cancel(reason) {
            this._done = true;
            for (const requestCapability of this._requests) {
              requestCapability.resolve({
                value: undefined,
                done: true
              });
            }
            this._requests.length = 0;
            this._stream._removeRangeReader(this);
          }
        }

        ;// ./src/display/content_disposition.js

        function getFilenameFromContentDispositionHeader(contentDisposition) {
          let needsEncodingFixup = true;
          let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
          if (tmp) {
            tmp = tmp[1];
            let filename = rfc2616unquote(tmp);
            filename = unescape(filename);
            filename = rfc5987decode(filename);
            filename = rfc2047decode(filename);
            return fixupEncoding(filename);
          }
          tmp = rfc2231getparam(contentDisposition);
          if (tmp) {
            const filename = rfc2047decode(tmp);
            return fixupEncoding(filename);
          }
          tmp = toParamRegExp("filename", "i").exec(contentDisposition);
          if (tmp) {
            tmp = tmp[1];
            let filename = rfc2616unquote(tmp);
            filename = rfc2047decode(filename);
            return fixupEncoding(filename);
          }
          function toParamRegExp(attributePattern, flags) {
            return new RegExp("(?:^|;)\\s*" + attributePattern + "\\s*=\\s*" + "(" + '[^";\\s][^;\\s]*' + "|" + '"(?:[^"\\\\]|\\\\"?)+"?' + ")", flags);
          }
          function textdecode(encoding, value) {
            if (encoding) {
              if (!/^[\x00-\xFF]+$/.test(value)) {
                return value;
              }
              try {
                const decoder = new TextDecoder(encoding, {
                  fatal: true
                });
                const buffer = stringToBytes(value);
                value = decoder.decode(buffer);
                needsEncodingFixup = false;
              } catch { }
            }
            return value;
          }
          function fixupEncoding(value) {
            if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
              value = textdecode("utf-8", value);
              if (needsEncodingFixup) {
                value = textdecode("iso-8859-1", value);
              }
            }
            return value;
          }
          function rfc2231getparam(contentDispositionStr) {
            const matches = [];
            let match;
            const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
            while ((match = iter.exec(contentDispositionStr)) !== null) {
              let [, n, quot, part] = match;
              n = parseInt(n, 10);
              if (n in matches) {
                if (n === 0) {
                  break;
                }
                continue;
              }
              matches[n] = [quot, part];
            }
            const parts = [];
            for (let n = 0; n < matches.length; ++n) {
              if (!(n in matches)) {
                break;
              }
              let [quot, part] = matches[n];
              part = rfc2616unquote(part);
              if (quot) {
                part = unescape(part);
                if (n === 0) {
                  part = rfc5987decode(part);
                }
              }
              parts.push(part);
            }
            return parts.join("");
          }
          function rfc2616unquote(value) {
            if (value.startsWith('"')) {
              const parts = value.slice(1).split('\\"');
              for (let i = 0; i < parts.length; ++i) {
                const quotindex = parts[i].indexOf('"');
                if (quotindex !== -1) {
                  parts[i] = parts[i].slice(0, quotindex);
                  parts.length = i + 1;
                }
                parts[i] = parts[i].replaceAll(/\\(.)/g, "$1");
              }
              value = parts.join('"');
            }
            return value;
          }
          function rfc5987decode(extvalue) {
            const encodingend = extvalue.indexOf("'");
            if (encodingend === -1) {
              return extvalue;
            }
            const encoding = extvalue.slice(0, encodingend);
            const langvalue = extvalue.slice(encodingend + 1);
            const value = langvalue.replace(/^[^']*'/, "");
            return textdecode(encoding, value);
          }
          function rfc2047decode(value) {
            if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
              return value;
            }
            return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (matches, charset, encoding, text) {
              if (encoding === "q" || encoding === "Q") {
                text = text.replaceAll("_", " ");
                text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function (match, hex) {
                  return String.fromCharCode(parseInt(hex, 16));
                });
                return textdecode(charset, text);
              }
              try {
                text = atob(text);
              } catch { }
              return textdecode(charset, text);
            });
          }
          return "";
        }

        ;// ./src/display/network_utils.js



        function createHeaders(isHttp, httpHeaders) {
          const headers = new Headers();
          if (!isHttp || !httpHeaders || typeof httpHeaders !== "object") {
            return headers;
          }
          for (const key in httpHeaders) {
            const val = httpHeaders[key];
            if (val !== undefined) {
              headers.append(key, val);
            }
          }
          return headers;
        }
        function getResponseOrigin(url) {
          return URL.parse(url)?.origin ?? null;
        }
        function validateRangeRequestCapabilities({
          responseHeaders,
          isHttp,
          rangeChunkSize,
          disableRange
        }) {
          const returnValues = {
            allowRangeRequests: false,
            suggestedLength: undefined
          };
          const length = parseInt(responseHeaders.get("Content-Length"), 10);
          if (!Number.isInteger(length)) {
            return returnValues;
          }
          returnValues.suggestedLength = length;
          if (length <= 2 * rangeChunkSize) {
            return returnValues;
          }
          if (disableRange || !isHttp) {
            return returnValues;
          }
          if (responseHeaders.get("Accept-Ranges") !== "bytes") {
            return returnValues;
          }
          const contentEncoding = responseHeaders.get("Content-Encoding") || "identity";
          if (contentEncoding !== "identity") {
            return returnValues;
          }
          returnValues.allowRangeRequests = true;
          return returnValues;
        }
        function extractFilenameFromHeader(responseHeaders) {
          const contentDisposition = responseHeaders.get("Content-Disposition");
          if (contentDisposition) {
            let filename = getFilenameFromContentDispositionHeader(contentDisposition);
            if (filename.includes("%")) {
              try {
                filename = decodeURIComponent(filename);
              } catch { }
            }
            if (isPdfFile(filename)) {
              return filename;
            }
          }
          return null;
        }
        function createResponseError(status, url) {
          return new ResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status, status === 404 || status === 0 && url.startsWith("file:"));
        }
        function validateResponseStatus(status) {
          return status === 200 || status === 206;
        }

        ;// ./src/display/fetch_stream.js


        function createFetchOptions(headers, withCredentials, abortController) {
          return {
            method: "GET",
            headers,
            signal: abortController.signal,
            mode: "cors",
            credentials: withCredentials ? "include" : "same-origin",
            redirect: "follow"
          };
        }
        function getArrayBuffer(val) {
          if (val instanceof Uint8Array) {
            return val.buffer;
          }
          if (val instanceof ArrayBuffer) {
            return val;
          }
          warn(`getArrayBuffer - unexpected data format: ${val}`);
          return new Uint8Array(val).buffer;
        }
        class PDFFetchStream {
          _responseOrigin = null;
          constructor(source) {
            this.source = source;
            this.isHttp = /^https?:/i.test(source.url);
            this.headers = createHeaders(this.isHttp, source.httpHeaders);
            this._fullRequestReader = null;
            this._rangeRequestReaders = [];
          }
          get _progressiveDataLength() {
            return this._fullRequestReader?._loaded ?? 0;
          }
          getFullReader() {
            assert(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
            this._fullRequestReader = new PDFFetchStreamReader(this);
            return this._fullRequestReader;
          }
          getRangeReader(begin, end) {
            if (end <= this._progressiveDataLength) {
              return null;
            }
            const reader = new PDFFetchStreamRangeReader(this, begin, end);
            this._rangeRequestReaders.push(reader);
            return reader;
          }
          cancelAllRequests(reason) {
            this._fullRequestReader?.cancel(reason);
            for (const reader of this._rangeRequestReaders.slice(0)) {
              reader.cancel(reason);
            }
          }
        }
        class PDFFetchStreamReader {
          constructor(stream) {
            this._stream = stream;
            this._reader = null;
            this._loaded = 0;
            this._filename = null;
            const source = stream.source;
            this._withCredentials = source.withCredentials || false;
            this._contentLength = source.length;
            this._headersCapability = Promise.withResolvers();
            this._disableRange = source.disableRange || false;
            this._rangeChunkSize = source.rangeChunkSize;
            if (!this._rangeChunkSize && !this._disableRange) {
              this._disableRange = true;
            }
            this._abortController = new AbortController();
            this._isStreamingSupported = !source.disableStream;
            this._isRangeSupported = !source.disableRange;
            const headers = new Headers(stream.headers);
            const url = source.url;
            fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then(response => {
              stream._responseOrigin = getResponseOrigin(response.url);
              if (!validateResponseStatus(response.status)) {
                throw createResponseError(response.status, url);
              }
              this._reader = response.body.getReader();
              this._headersCapability.resolve();
              const responseHeaders = response.headers;
              const {
                allowRangeRequests,
                suggestedLength
              } = validateRangeRequestCapabilities({
                responseHeaders,
                isHttp: stream.isHttp,
                rangeChunkSize: this._rangeChunkSize,
                disableRange: this._disableRange
              });
              this._isRangeSupported = allowRangeRequests;
              this._contentLength = suggestedLength || this._contentLength;
              this._filename = extractFilenameFromHeader(responseHeaders);
              if (!this._isStreamingSupported && this._isRangeSupported) {
                this.cancel(new AbortException("Streaming is disabled."));
              }
            }).catch(this._headersCapability.reject);
            this.onProgress = null;
          }
          get headersReady() {
            return this._headersCapability.promise;
          }
          get filename() {
            return this._filename;
          }
          get contentLength() {
            return this._contentLength;
          }
          get isRangeSupported() {
            return this._isRangeSupported;
          }
          get isStreamingSupported() {
            return this._isStreamingSupported;
          }
          async read() {
            await this._headersCapability.promise;
            const {
              value,
              done
            } = await this._reader.read();
            if (done) {
              return {
                value,
                done
              };
            }
            this._loaded += value.byteLength;
            this.onProgress?.({
              loaded: this._loaded,
              total: this._contentLength
            });
            return {
              value: getArrayBuffer(value),
              done: false
            };
          }
          cancel(reason) {
            this._reader?.cancel(reason);
            this._abortController.abort();
          }
        }
        class PDFFetchStreamRangeReader {
          constructor(stream, begin, end) {
            this._stream = stream;
            this._reader = null;
            this._loaded = 0;
            const source = stream.source;
            this._withCredentials = source.withCredentials || false;
            this._readCapability = Promise.withResolvers();
            this._isStreamingSupported = !source.disableStream;
            this._abortController = new AbortController();
            const headers = new Headers(stream.headers);
            headers.append("Range", `bytes=${begin}-${end - 1}`);
            const url = source.url;
            fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then(response => {
              const responseOrigin = getResponseOrigin(response.url);
              if (responseOrigin !== stream._responseOrigin) {
                throw new Error(`Expected range response-origin "${responseOrigin}" to match "${stream._responseOrigin}".`);
              }
              if (!validateResponseStatus(response.status)) {
                throw createResponseError(response.status, url);
              }
              this._readCapability.resolve();
              this._reader = response.body.getReader();
            }).catch(this._readCapability.reject);
            this.onProgress = null;
          }
          get isStreamingSupported() {
            return this._isStreamingSupported;
          }
          async read() {
            await this._readCapability.promise;
            const {
              value,
              done
            } = await this._reader.read();
            if (done) {
              return {
                value,
                done
              };
            }
            this._loaded += value.byteLength;
            this.onProgress?.({
              loaded: this._loaded
            });
            return {
              value: getArrayBuffer(value),
              done: false
            };
          }
          cancel(reason) {
            this._reader?.cancel(reason);
            this._abortController.abort();
          }
        }

        ;// ./src/display/network.js


        const OK_RESPONSE = 200;
        const PARTIAL_CONTENT_RESPONSE = 206;
        function network_getArrayBuffer(xhr) {
          const data = xhr.response;
          if (typeof data !== "string") {
            return data;
          }
          return stringToBytes(data).buffer;
        }
        class NetworkManager {
          _responseOrigin = null;
          constructor({
            url,
            httpHeaders,
            withCredentials
          }) {
            this.url = url;
            this.isHttp = /^https?:/i.test(url);
            this.headers = createHeaders(this.isHttp, httpHeaders);
            this.withCredentials = withCredentials || false;
            this.currXhrId = 0;
            this.pendingRequests = Object.create(null);
          }
          request(args) {
            const xhr = new XMLHttpRequest();
            const xhrId = this.currXhrId++;
            const pendingRequest = this.pendingRequests[xhrId] = {
              xhr
            };
            xhr.open("GET", this.url);
            xhr.withCredentials = this.withCredentials;
            for (const [key, val] of this.headers) {
              xhr.setRequestHeader(key, val);
            }
            if (this.isHttp && "begin" in args && "end" in args) {
              xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
              pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
            } else {
              pendingRequest.expectedStatus = OK_RESPONSE;
            }
            xhr.responseType = "arraybuffer";
            assert(args.onError, "Expected `onError` callback to be provided.");
            xhr.onerror = () => {
              args.onError(xhr.status);
            };
            xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
            xhr.onprogress = this.onProgress.bind(this, xhrId);
            pendingRequest.onHeadersReceived = args.onHeadersReceived;
            pendingRequest.onDone = args.onDone;
            pendingRequest.onError = args.onError;
            pendingRequest.onProgress = args.onProgress;
            xhr.send(null);
            return xhrId;
          }
          onProgress(xhrId, evt) {
            const pendingRequest = this.pendingRequests[xhrId];
            if (!pendingRequest) {
              return;
            }
            pendingRequest.onProgress?.(evt);
          }
          onStateChange(xhrId, evt) {
            const pendingRequest = this.pendingRequests[xhrId];
            if (!pendingRequest) {
              return;
            }
            const xhr = pendingRequest.xhr;
            if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
              pendingRequest.onHeadersReceived();
              delete pendingRequest.onHeadersReceived;
            }
            if (xhr.readyState !== 4) {
              return;
            }
            if (!(xhrId in this.pendingRequests)) {
              return;
            }
            delete this.pendingRequests[xhrId];
            if (xhr.status === 0 && this.isHttp) {
              pendingRequest.onError(xhr.status);
              return;
            }
            const xhrStatus = xhr.status || OK_RESPONSE;
            const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
            if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
              pendingRequest.onError(xhr.status);
              return;
            }
            const chunk = network_getArrayBuffer(xhr);
            if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
              const rangeHeader = xhr.getResponseHeader("Content-Range");
              const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
              if (matches) {
                pendingRequest.onDone({
                  begin: parseInt(matches[1], 10),
                  chunk
                });
              } else {
                warn(`Missing or invalid "Content-Range" header.`);
                pendingRequest.onError(0);
              }
            } else if (chunk) {
              pendingRequest.onDone({
                begin: 0,
                chunk
              });
            } else {
              pendingRequest.onError(xhr.status);
            }
          }
          getRequestXhr(xhrId) {
            return this.pendingRequests[xhrId].xhr;
          }
          isPendingRequest(xhrId) {
            return xhrId in this.pendingRequests;
          }
          abortRequest(xhrId) {
            const xhr = this.pendingRequests[xhrId].xhr;
            delete this.pendingRequests[xhrId];
            xhr.abort();
          }
        }
        class PDFNetworkStream {
          constructor(source) {
            this._source = source;
            this._manager = new NetworkManager(source);
            this._rangeChunkSize = source.rangeChunkSize;
            this._fullRequestReader = null;
            this._rangeRequestReaders = [];
          }
          _onRangeRequestReaderClosed(reader) {
            const i = this._rangeRequestReaders.indexOf(reader);
            if (i >= 0) {
              this._rangeRequestReaders.splice(i, 1);
            }
          }
          getFullReader() {
            assert(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
            this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
            return this._fullRequestReader;
          }
          getRangeReader(begin, end) {
            const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
            reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
            this._rangeRequestReaders.push(reader);
            return reader;
          }
          cancelAllRequests(reason) {
            this._fullRequestReader?.cancel(reason);
            for (const reader of this._rangeRequestReaders.slice(0)) {
              reader.cancel(reason);
            }
          }
        }
        class PDFNetworkStreamFullRequestReader {
          constructor(manager, source) {
            this._manager = manager;
            this._url = source.url;
            this._fullRequestId = manager.request({
              onHeadersReceived: this._onHeadersReceived.bind(this),
              onDone: this._onDone.bind(this),
              onError: this._onError.bind(this),
              onProgress: this._onProgress.bind(this)
            });
            this._headersCapability = Promise.withResolvers();
            this._disableRange = source.disableRange || false;
            this._contentLength = source.length;
            this._rangeChunkSize = source.rangeChunkSize;
            if (!this._rangeChunkSize && !this._disableRange) {
              this._disableRange = true;
            }
            this._isStreamingSupported = false;
            this._isRangeSupported = false;
            this._cachedChunks = [];
            this._requests = [];
            this._done = false;
            this._storedError = undefined;
            this._filename = null;
            this.onProgress = null;
          }
          _onHeadersReceived() {
            const fullRequestXhrId = this._fullRequestId;
            const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
            this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);
            const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();
            const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\S ]+$/, "").split(/[\r\n]+/).map(x => {
              const [key, ...val] = x.split(": ");
              return [key, val.join(": ")];
            }) : []);
            const {
              allowRangeRequests,
              suggestedLength
            } = validateRangeRequestCapabilities({
              responseHeaders,
              isHttp: this._manager.isHttp,
              rangeChunkSize: this._rangeChunkSize,
              disableRange: this._disableRange
            });
            if (allowRangeRequests) {
              this._isRangeSupported = true;
            }
            this._contentLength = suggestedLength || this._contentLength;
            this._filename = extractFilenameFromHeader(responseHeaders);
            if (this._isRangeSupported) {
              this._manager.abortRequest(fullRequestXhrId);
            }
            this._headersCapability.resolve();
          }
          _onDone(data) {
            if (data) {
              if (this._requests.length > 0) {
                const requestCapability = this._requests.shift();
                requestCapability.resolve({
                  value: data.chunk,
                  done: false
                });
              } else {
                this._cachedChunks.push(data.chunk);
              }
            }
            this._done = true;
            if (this._cachedChunks.length > 0) {
              return;
            }
            for (const requestCapability of this._requests) {
              requestCapability.resolve({
                value: undefined,
                done: true
              });
            }
            this._requests.length = 0;
          }
          _onError(status) {
            this._storedError = createResponseError(status, this._url);
            this._headersCapability.reject(this._storedError);
            for (const requestCapability of this._requests) {
              requestCapability.reject(this._storedError);
            }
            this._requests.length = 0;
            this._cachedChunks.length = 0;
          }
          _onProgress(evt) {
            this.onProgress?.({
              loaded: evt.loaded,
              total: evt.lengthComputable ? evt.total : this._contentLength
            });
          }
          get filename() {
            return this._filename;
          }
          get isRangeSupported() {
            return this._isRangeSupported;
          }
          get isStreamingSupported() {
            return this._isStreamingSupported;
          }
          get contentLength() {
            return this._contentLength;
          }
          get headersReady() {
            return this._headersCapability.promise;
          }
          async read() {
            await this._headersCapability.promise;
            if (this._storedError) {
              throw this._storedError;
            }
            if (this._cachedChunks.length > 0) {
              const chunk = this._cachedChunks.shift();
              return {
                value: chunk,
                done: false
              };
            }
            if (this._done) {
              return {
                value: undefined,
                done: true
              };
            }
            const requestCapability = Promise.withResolvers();
            this._requests.push(requestCapability);
            return requestCapability.promise;
          }
          cancel(reason) {
            this._done = true;
            this._headersCapability.reject(reason);
            for (const requestCapability of this._requests) {
              requestCapability.resolve({
                value: undefined,
                done: true
              });
            }
            this._requests.length = 0;
            if (this._manager.isPendingRequest(this._fullRequestId)) {
              this._manager.abortRequest(this._fullRequestId);
            }
            this._fullRequestReader = null;
          }
        }
        class PDFNetworkStreamRangeRequestReader {
          constructor(manager, begin, end) {
            this._manager = manager;
            this._url = manager.url;
            this._requestId = manager.request({
              begin,
              end,
              onHeadersReceived: this._onHeadersReceived.bind(this),
              onDone: this._onDone.bind(this),
              onError: this._onError.bind(this),
              onProgress: this._onProgress.bind(this)
            });
            this._requests = [];
            this._queuedChunk = null;
            this._done = false;
            this._storedError = undefined;
            this.onProgress = null;
            this.onClosed = null;
          }
          _onHeadersReceived() {
            const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);
            if (responseOrigin !== this._manager._responseOrigin) {
              this._storedError = new Error(`Expected range response-origin "${responseOrigin}" to match "${this._manager._responseOrigin}".`);
              this._onError(0);
            }
          }
          _close() {
            this.onClosed?.(this);
          }
          _onDone(data) {
            const chunk = data.chunk;
            if (this._requests.length > 0) {
              const requestCapability = this._requests.shift();
              requestCapability.resolve({
                value: chunk,
                done: false
              });
            } else {
              this._queuedChunk = chunk;
            }
            this._done = true;
            for (const requestCapability of this._requests) {
              requestCapability.resolve({
                value: undefined,
                done: true
              });
            }
            this._requests.length = 0;
            this._close();
          }
          _onError(status) {
            this._storedError ??= createResponseError(status, this._url);
            for (const requestCapability of this._requests) {
              requestCapability.reject(this._storedError);
            }
            this._requests.length = 0;
            this._queuedChunk = null;
          }
          _onProgress(evt) {
            if (!this.isStreamingSupported) {
              this.onProgress?.({
                loaded: evt.loaded
              });
            }
          }
          get isStreamingSupported() {
            return false;
          }
          async read() {
            if (this._storedError) {
              throw this._storedError;
            }
            if (this._queuedChunk !== null) {
              const chunk = this._queuedChunk;
              this._queuedChunk = null;
              return {
                value: chunk,
                done: false
              };
            }
            if (this._done) {
              return {
                value: undefined,
                done: true
              };
            }
            const requestCapability = Promise.withResolvers();
            this._requests.push(requestCapability);
            return requestCapability.promise;
          }
          cancel(reason) {
            this._done = true;
            for (const requestCapability of this._requests) {
              requestCapability.resolve({
                value: undefined,
                done: true
              });
            }
            this._requests.length = 0;
            if (this._manager.isPendingRequest(this._requestId)) {
              this._manager.abortRequest(this._requestId);
            }
            this._close();
          }
        }

        ;// ./src/display/node_stream.js


        const urlRegex = /^[a-z][a-z0-9\-+.]+:/i;
        function parseUrlOrPath(sourceUrl) {
          if (urlRegex.test(sourceUrl)) {
            return new URL(sourceUrl);
          }
          const url = process.getBuiltinModule("url");
          return new URL(url.pathToFileURL(sourceUrl));
        }
        class PDFNodeStream {
          constructor(source) {
            this.source = source;
            this.url = parseUrlOrPath(source.url);
            assert(this.url.protocol === "file:", "PDFNodeStream only supports file:// URLs.");
            this._fullRequestReader = null;
            this._rangeRequestReaders = [];
          }
          get _progressiveDataLength() {
            return this._fullRequestReader?._loaded ?? 0;
          }
          getFullReader() {
            assert(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
            this._fullRequestReader = new PDFNodeStreamFsFullReader(this);
            return this._fullRequestReader;
          }
          getRangeReader(start, end) {
            if (end <= this._progressiveDataLength) {
              return null;
            }
            const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);
            this._rangeRequestReaders.push(rangeReader);
            return rangeReader;
          }
          cancelAllRequests(reason) {
            this._fullRequestReader?.cancel(reason);
            for (const reader of this._rangeRequestReaders.slice(0)) {
              reader.cancel(reason);
            }
          }
        }
        class PDFNodeStreamFsFullReader {
          constructor(stream) {
            this._url = stream.url;
            this._done = false;
            this._storedError = null;
            this.onProgress = null;
            const source = stream.source;
            this._contentLength = source.length;
            this._loaded = 0;
            this._filename = null;
            this._disableRange = source.disableRange || false;
            this._rangeChunkSize = source.rangeChunkSize;
            if (!this._rangeChunkSize && !this._disableRange) {
              this._disableRange = true;
            }
            this._isStreamingSupported = !source.disableStream;
            this._isRangeSupported = !source.disableRange;
            this._readableStream = null;
            this._readCapability = Promise.withResolvers();
            this._headersCapability = Promise.withResolvers();
            const fs = process.getBuiltinModule("fs");
            fs.promises.lstat(this._url).then(stat => {
              this._contentLength = stat.size;
              this._setReadableStream(fs.createReadStream(this._url));
              this._headersCapability.resolve();
            }, error => {
              if (error.code === "ENOENT") {
                error = createResponseError(0, this._url.href);
              }
              this._storedError = error;
              this._headersCapability.reject(error);
            });
          }
          get headersReady() {
            return this._headersCapability.promise;
          }
          get filename() {
            return this._filename;
          }
          get contentLength() {
            return this._contentLength;
          }
          get isRangeSupported() {
            return this._isRangeSupported;
          }
          get isStreamingSupported() {
            return this._isStreamingSupported;
          }
          async read() {
            await this._readCapability.promise;
            if (this._done) {
              return {
                value: undefined,
                done: true
              };
            }
            if (this._storedError) {
              throw this._storedError;
            }
            const chunk = this._readableStream.read();
            if (chunk === null) {
              this._readCapability = Promise.withResolvers();
              return this.read();
            }
            this._loaded += chunk.length;
            this.onProgress?.({
              loaded: this._loaded,
              total: this._contentLength
            });
            const buffer = new Uint8Array(chunk).buffer;
            return {
              value: buffer,
              done: false
            };
          }
          cancel(reason) {
            if (!this._readableStream) {
              this._error(reason);
              return;
            }
            this._readableStream.destroy(reason);
          }
          _error(reason) {
            this._storedError = reason;
            this._readCapability.resolve();
          }
          _setReadableStream(readableStream) {
            this._readableStream = readableStream;
            readableStream.on("readable", () => {
              this._readCapability.resolve();
            });
            readableStream.on("end", () => {
              readableStream.destroy();
              this._done = true;
              this._readCapability.resolve();
            });
            readableStream.on("error", reason => {
              this._error(reason);
            });
            if (!this._isStreamingSupported && this._isRangeSupported) {
              this._error(new AbortException("streaming is disabled"));
            }
            if (this._storedError) {
              this._readableStream.destroy(this._storedError);
            }
          }
        }
        class PDFNodeStreamFsRangeReader {
          constructor(stream, start, end) {
            this._url = stream.url;
            this._done = false;
            this._storedError = null;
            this.onProgress = null;
            this._loaded = 0;
            this._readableStream = null;
            this._readCapability = Promise.withResolvers();
            const source = stream.source;
            this._isStreamingSupported = !source.disableStream;
            const fs = process.getBuiltinModule("fs");
            this._setReadableStream(fs.createReadStream(this._url, {
              start,
              end: end - 1
            }));
          }
          get isStreamingSupported() {
            return this._isStreamingSupported;
          }
          async read() {
            await this._readCapability.promise;
            if (this._done) {
              return {
                value: undefined,
                done: true
              };
            }
            if (this._storedError) {
              throw this._storedError;
            }
            const chunk = this._readableStream.read();
            if (chunk === null) {
              this._readCapability = Promise.withResolvers();
              return this.read();
            }
            this._loaded += chunk.length;
            this.onProgress?.({
              loaded: this._loaded
            });
            const buffer = new Uint8Array(chunk).buffer;
            return {
              value: buffer,
              done: false
            };
          }
          cancel(reason) {
            if (!this._readableStream) {
              this._error(reason);
              return;
            }
            this._readableStream.destroy(reason);
          }
          _error(reason) {
            this._storedError = reason;
            this._readCapability.resolve();
          }
          _setReadableStream(readableStream) {
            this._readableStream = readableStream;
            readableStream.on("readable", () => {
              this._readCapability.resolve();
            });
            readableStream.on("end", () => {
              readableStream.destroy();
              this._done = true;
              this._readCapability.resolve();
            });
            readableStream.on("error", reason => {
              this._error(reason);
            });
            if (this._storedError) {
              this._readableStream.destroy(this._storedError);
            }
          }
        }

        ;// ./src/display/pdf_objects.js
        const INITIAL_DATA = Symbol("INITIAL_DATA");
        class PDFObjects {
          #objs = Object.create(null);
          #ensureObj(objId) {
            return this.#objs[objId] ||= {
              ...Promise.withResolvers(),
              data: INITIAL_DATA
            };
          }
          get(objId, callback = null) {
            if (callback) {
              const obj = this.#ensureObj(objId);
              obj.promise.then(() => callback(obj.data));
              return null;
            }
            const obj = this.#objs[objId];
            if (!obj || obj.data === INITIAL_DATA) {
              throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
            }
            return obj.data;
          }
          has(objId) {
            const obj = this.#objs[objId];
            return !!obj && obj.data !== INITIAL_DATA;
          }
          delete(objId) {
            const obj = this.#objs[objId];
            if (!obj || obj.data === INITIAL_DATA) {
              return false;
            }
            delete this.#objs[objId];
            return true;
          }
          resolve(objId, data = null) {
            const obj = this.#ensureObj(objId);
            obj.data = data;
            obj.resolve();
          }
          clear() {
            for (const objId in this.#objs) {
              const {
                data
              } = this.#objs[objId];
              data?.bitmap?.close();
            }
            this.#objs = Object.create(null);
          }
          *[Symbol.iterator]() {
            for (const objId in this.#objs) {
              const {
                data
              } = this.#objs[objId];
              if (data === INITIAL_DATA) {
                continue;
              }
              yield [objId, data];
            }
          }
        }

        ;// ./src/display/text_layer.js


        const MAX_TEXT_DIVS_TO_RENDER = 100000;
        const DEFAULT_FONT_SIZE = 30;
        class TextLayer {
          #capability = Promise.withResolvers();
          #container = null;
          #disableProcessItems = false;
          #fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
          #lang = null;
          #layoutTextParams = null;
          #pageHeight = 0;
          #pageWidth = 0;
          #reader = null;
          #rootContainer = null;
          #rotation = 0;
          #scale = 0;
          #styleCache = Object.create(null);
          #textContentItemsStr = [];
          #textContentSource = null;
          #textDivs = [];
          #textDivProperties = new WeakMap();
          #transform = null;
          static #ascentCache = new Map();
          static #canvasContexts = new Map();
          static #canvasCtxFonts = new WeakMap();
          static #minFontSize = null;
          static #pendingTextLayers = new Set();
          constructor({
            textContentSource,
            container,
            viewport
          }) {
            if (textContentSource instanceof ReadableStream) {
              this.#textContentSource = textContentSource;
            } else if (typeof textContentSource === "object") {
              this.#textContentSource = new ReadableStream({
                start(controller) {
                  controller.enqueue(textContentSource);
                  controller.close();
                }
              });
            } else {
              throw new Error('No "textContentSource" parameter specified.');
            }
            this.#container = this.#rootContainer = container;
            this.#scale = viewport.scale * OutputScale.pixelRatio;
            this.#rotation = viewport.rotation;
            this.#layoutTextParams = {
              div: null,
              properties: null,
              ctx: null
            };
            const {
              pageWidth,
              pageHeight,
              pageX,
              pageY
            } = viewport.rawDims;
            this.#transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];
            this.#pageWidth = pageWidth;
            this.#pageHeight = pageHeight;
            TextLayer.#ensureMinFontSizeComputed();
            setLayerDimensions(container, viewport);
            this.#capability.promise.finally(() => {
              TextLayer.#pendingTextLayers.delete(this);
              this.#layoutTextParams = null;
              this.#styleCache = null;
            }).catch(() => { });
          }
          static get fontFamilyMap() {
            const {
              isWindows,
              isFirefox
            } = util_FeatureTest.platform;
            return shadow(this, "fontFamilyMap", new Map([["sans-serif", `${isWindows && isFirefox ? "Calibri, " : ""}sans-serif`], ["monospace", `${isWindows && isFirefox ? "Lucida Console, " : ""}monospace`]]));
          }
          render() {
            const pump = () => {
              this.#reader.read().then(({
                value,
                done
              }) => {
                if (done) {
                  this.#capability.resolve();
                  return;
                }
                this.#lang ??= value.lang;
                Object.assign(this.#styleCache, value.styles);
                this.#processItems(value.items);
                pump();
              }, this.#capability.reject);
            };
            this.#reader = this.#textContentSource.getReader();
            TextLayer.#pendingTextLayers.add(this);
            pump();
            return this.#capability.promise;
          }
          update({
            viewport,
            onBefore = null
          }) {
            const scale = viewport.scale * OutputScale.pixelRatio;
            const rotation = viewport.rotation;
            if (rotation !== this.#rotation) {
              onBefore?.();
              this.#rotation = rotation;
              setLayerDimensions(this.#rootContainer, {
                rotation
              });
            }
            if (scale !== this.#scale) {
              onBefore?.();
              this.#scale = scale;
              const params = {
                div: null,
                properties: null,
                ctx: TextLayer.#getCtx(this.#lang)
              };
              for (const div of this.#textDivs) {
                params.properties = this.#textDivProperties.get(div);
                params.div = div;
                this.#layout(params);
              }
            }
          }
          cancel() {
            const abortEx = new AbortException("TextLayer task cancelled.");
            this.#reader?.cancel(abortEx).catch(() => { });
            this.#reader = null;
            this.#capability.reject(abortEx);
          }
          get textDivs() {
            return this.#textDivs;
          }
          get textContentItemsStr() {
            return this.#textContentItemsStr;
          }
          #processItems(items) {
            if (this.#disableProcessItems) {
              return;
            }
            this.#layoutTextParams.ctx ??= TextLayer.#getCtx(this.#lang);
            const textDivs = this.#textDivs,
              textContentItemsStr = this.#textContentItemsStr;
            for (const item of items) {
              if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {
                warn("Ignoring additional textDivs for performance reasons.");
                this.#disableProcessItems = true;
                return;
              }
              if (item.str === undefined) {
                if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
                  const parent = this.#container;
                  this.#container = document.createElement("span");
                  this.#container.classList.add("markedContent");
                  if (item.id) {
                    this.#container.setAttribute("id", `${item.id}`);
                  }
                  parent.append(this.#container);
                } else if (item.type === "endMarkedContent") {
                  this.#container = this.#container.parentNode;
                }
                continue;
              }
              textContentItemsStr.push(item.str);
              this.#appendText(item);
            }
          }
          #appendText(geom) {
            const textDiv = document.createElement("span");
            const textDivProperties = {
              angle: 0,
              canvasWidth: 0,
              hasText: geom.str !== "",
              hasEOL: geom.hasEOL,
              fontSize: 0
            };
            this.#textDivs.push(textDiv);
            const tx = Util.transform(this.#transform, geom.transform);
            let angle = Math.atan2(tx[1], tx[0]);
            const style = this.#styleCache[geom.fontName];
            if (style.vertical) {
              angle += Math.PI / 2;
            }
            let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;
            fontFamily = TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;
            const fontHeight = Math.hypot(tx[2], tx[3]);
            const fontAscent = fontHeight * TextLayer.#getAscent(fontFamily, style, this.#lang);
            let left, top;
            if (angle === 0) {
              left = tx[4];
              top = tx[5] - fontAscent;
            } else {
              left = tx[4] + fontAscent * Math.sin(angle);
              top = tx[5] - fontAscent * Math.cos(angle);
            }
            const scaleFactorStr = "calc(var(--total-scale-factor) *";
            const divStyle = textDiv.style;
            if (this.#container === this.#rootContainer) {
              divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;
              divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;
            } else {
              divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;
              divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;
            }
            divStyle.fontSize = `${scaleFactorStr}${(TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;
            divStyle.fontFamily = fontFamily;
            textDivProperties.fontSize = fontHeight;
            textDiv.setAttribute("role", "presentation");
            textDiv.textContent = geom.str;
            textDiv.dir = geom.dir;
            if (this.#fontInspectorEnabled) {
              textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;
            }
            if (angle !== 0) {
              textDivProperties.angle = angle * (180 / Math.PI);
            }
            let shouldScaleText = false;
            if (geom.str.length > 1) {
              shouldScaleText = true;
            } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
              const absScaleX = Math.abs(geom.transform[0]),
                absScaleY = Math.abs(geom.transform[3]);
              if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
                shouldScaleText = true;
              }
            }
            if (shouldScaleText) {
              textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;
            }
            this.#textDivProperties.set(textDiv, textDivProperties);
            this.#layoutTextParams.div = textDiv;
            this.#layoutTextParams.properties = textDivProperties;
            this.#layout(this.#layoutTextParams);
            if (textDivProperties.hasText) {
              this.#container.append(textDiv);
            }
            if (textDivProperties.hasEOL) {
              const br = document.createElement("br");
              br.setAttribute("role", "presentation");
              this.#container.append(br);
            }
          }
          #layout(params) {
            const {
              div,
              properties,
              ctx
            } = params;
            const {
              style
            } = div;
            let transform = "";
            if (TextLayer.#minFontSize > 1) {
              transform = `scale(${1 / TextLayer.#minFontSize})`;
            }
            if (properties.canvasWidth !== 0 && properties.hasText) {
              const {
                fontFamily
              } = style;
              const {
                canvasWidth,
                fontSize
              } = properties;
              TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);
              const {
                width
              } = ctx.measureText(div.textContent);
              if (width > 0) {
                transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;
              }
            }
            if (properties.angle !== 0) {
              transform = `rotate(${properties.angle}deg) ${transform}`;
            }
            if (transform.length > 0) {
              style.transform = transform;
            }
          }
          static cleanup() {
            if (this.#pendingTextLayers.size > 0) {
              return;
            }
            this.#ascentCache.clear();
            for (const {
              canvas
            } of this.#canvasContexts.values()) {
              canvas.remove();
            }
            this.#canvasContexts.clear();
          }
          static #getCtx(lang = null) {
            let ctx = this.#canvasContexts.get(lang ||= "");
            if (!ctx) {
              const canvas = document.createElement("canvas");
              canvas.className = "hiddenCanvasElement";
              canvas.lang = lang;
              document.body.append(canvas);
              ctx = canvas.getContext("2d", {
                alpha: false,
                willReadFrequently: true
              });
              this.#canvasContexts.set(lang, ctx);
              this.#canvasCtxFonts.set(ctx, {
                size: 0,
                family: ""
              });
            }
            return ctx;
          }
          static #ensureCtxFont(ctx, size, family) {
            const cached = this.#canvasCtxFonts.get(ctx);
            if (size === cached.size && family === cached.family) {
              return;
            }
            ctx.font = `${size}px ${family}`;
            cached.size = size;
            cached.family = family;
          }
          static #ensureMinFontSizeComputed() {
            if (this.#minFontSize !== null) {
              return;
            }
            const div = document.createElement("div");
            div.style.opacity = 0;
            div.style.lineHeight = 1;
            div.style.fontSize = "1px";
            div.style.position = "absolute";
            div.textContent = "X";
            document.body.append(div);
            this.#minFontSize = div.getBoundingClientRect().height;
            div.remove();
          }
          static #getAscent(fontFamily, style, lang) {
            const cachedAscent = this.#ascentCache.get(fontFamily);
            if (cachedAscent) {
              return cachedAscent;
            }
            const ctx = this.#getCtx(lang);
            ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;
            this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);
            const metrics = ctx.measureText("");
            const ascent = metrics.fontBoundingBoxAscent;
            const descent = Math.abs(metrics.fontBoundingBoxDescent);
            ctx.canvas.width = ctx.canvas.height = 0;
            let ratio = 0.8;
            if (ascent) {
              ratio = ascent / (ascent + descent);
            } else {
              if (util_FeatureTest.platform.isFirefox) {
                warn("Enable the `dom.textMetrics.fontBoundingBox.enabled` preference " + "in `about:config` to improve TextLayer rendering.");
              }
              if (style.ascent) {
                ratio = style.ascent;
              } else if (style.descent) {
                ratio = 1 + style.descent;
              }
            }
            this.#ascentCache.set(fontFamily, ratio);
            return ratio;
          }
        }

        ;// ./src/display/api.js

























        const RENDERING_CANCELLED_TIMEOUT = 100;
        function getDocument(src = {}) {
          if (typeof src === "string" || src instanceof URL) {
            src = {
              url: src
            };
          } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {
            src = {
              data: src
            };
          }
          const task = new PDFDocumentLoadingTask();
          const {
            docId
          } = task;
          const url = src.url ? getUrlProp(src.url) : null;
          const data = src.data ? getDataProp(src.data) : null;
          const httpHeaders = src.httpHeaders || null;
          const withCredentials = src.withCredentials === true;
          const password = src.password ?? null;
          const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;
          const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : 2 ** 16;
          let worker = src.worker instanceof PDFWorker ? src.worker : null;
          const verbosity = src.verbosity;
          const docBaseUrl = typeof src.docBaseUrl === "string" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;
          const cMapUrl = getFactoryUrlProp(src.cMapUrl);
          const cMapPacked = src.cMapPacked !== false;
          const CMapReaderFactory = src.CMapReaderFactory || (isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory);
          const iccUrl = getFactoryUrlProp(src.iccUrl);
          const standardFontDataUrl = getFactoryUrlProp(src.standardFontDataUrl);
          const StandardFontDataFactory = src.StandardFontDataFactory || (isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory);
          const wasmUrl = getFactoryUrlProp(src.wasmUrl);
          const WasmFactory = src.WasmFactory || (isNodeJS ? NodeWasmFactory : DOMWasmFactory);
          const ignoreErrors = src.stopAtErrors !== true;
          const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
          const isEvalSupported = src.isEvalSupported !== false;
          const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !isNodeJS;
          const isImageDecoderSupported = typeof src.isImageDecoderSupported === "boolean" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);
          const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
          const disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : isNodeJS;
          const fontExtraProperties = src.fontExtraProperties === true;
          const enableXfa = src.enableXfa === true;
          const ownerDocument = src.ownerDocument || globalThis.document;
          const disableRange = src.disableRange === true;
          const disableStream = src.disableStream === true;
          const disableAutoFetch = src.disableAutoFetch === true;
          const pdfBug = src.pdfBug === true;
          const CanvasFactory = src.CanvasFactory || (isNodeJS ? NodeCanvasFactory : DOMCanvasFactory);
          const FilterFactory = src.FilterFactory || (isNodeJS ? NodeFilterFactory : DOMFilterFactory);
          const enableHWA = src.enableHWA === true;
          const useWasm = src.useWasm !== false;
          const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;
          const useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !isNodeJS && !disableFontFace;
          const useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : !!(CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && WasmFactory === DOMWasmFactory && cMapUrl && standardFontDataUrl && wasmUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI) && isValidFetchUrl(wasmUrl, document.baseURI));
          const styleElement = null;
          setVerbosityLevel(verbosity);
          const transportFactory = {
            canvasFactory: new CanvasFactory({
              ownerDocument,
              enableHWA
            }),
            filterFactory: new FilterFactory({
              docId,
              ownerDocument
            }),
            cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({
              baseUrl: cMapUrl,
              isCompressed: cMapPacked
            }),
            standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({
              baseUrl: standardFontDataUrl
            }),
            wasmFactory: useWorkerFetch ? null : new WasmFactory({
              baseUrl: wasmUrl
            })
          };
          if (!worker) {
            worker = PDFWorker.create({
              verbosity,
              port: GlobalWorkerOptions.workerPort
            });
            task._worker = worker;
          }
          const docParams = {
            docId,
            apiVersion: "5.4.394",
            data,
            password,
            disableAutoFetch,
            rangeChunkSize,
            length,
            docBaseUrl,
            enableXfa,
            evaluatorOptions: {
              maxImageSize,
              disableFontFace,
              ignoreErrors,
              isEvalSupported,
              isOffscreenCanvasSupported,
              isImageDecoderSupported,
              canvasMaxAreaInBytes,
              fontExtraProperties,
              useSystemFonts,
              useWasm,
              useWorkerFetch,
              cMapUrl,
              iccUrl,
              standardFontDataUrl,
              wasmUrl
            }
          };
          const transportParams = {
            ownerDocument,
            pdfBug,
            styleElement,
            loadingParams: {
              disableAutoFetch,
              enableXfa
            }
          };
          worker.promise.then(function () {
            if (task.destroyed) {
              throw new Error("Loading aborted");
            }
            if (worker.destroyed) {
              throw new Error("Worker was destroyed");
            }
            const workerIdPromise = worker.messageHandler.sendWithPromise("GetDocRequest", docParams, data ? [data.buffer] : null);
            let networkStream;
            if (rangeTransport) {
              networkStream = new PDFDataTransportStream(rangeTransport, {
                disableRange,
                disableStream
              });
            } else if (!data) {
              if (!url) {
                throw new Error("getDocument - no `url` parameter provided.");
              }
              const NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : isNodeJS ? PDFNodeStream : PDFNetworkStream;
              networkStream = new NetworkStream({
                url,
                length,
                httpHeaders,
                withCredentials,
                rangeChunkSize,
                disableRange,
                disableStream
              });
            }
            return workerIdPromise.then(workerId => {
              if (task.destroyed) {
                throw new Error("Loading aborted");
              }
              if (worker.destroyed) {
                throw new Error("Worker was destroyed");
              }
              const messageHandler = new MessageHandler(docId, workerId, worker.port);
              const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory, enableHWA);
              task._transport = transport;
              messageHandler.send("Ready", null);
            });
          }).catch(task._capability.reject);
          return task;
        }
        class PDFDocumentLoadingTask {
          static #docId = 0;
          _capability = Promise.withResolvers();
          _transport = null;
          _worker = null;
          docId = `d${PDFDocumentLoadingTask.#docId++}`;
          destroyed = false;
          onPassword = null;
          onProgress = null;
          get promise() {
            return this._capability.promise;
          }
          async destroy() {
            this.destroyed = true;
            try {
              if (this._worker?.port) {
                this._worker._pendingDestroy = true;
              }
              await this._transport?.destroy();
            } catch (ex) {
              if (this._worker?.port) {
                delete this._worker._pendingDestroy;
              }
              throw ex;
            }
            this._transport = null;
            this._worker?.destroy();
            this._worker = null;
          }
          async getData() {
            return this._transport.getData();
          }
        }
        class PDFDataRangeTransport {
          #capability = Promise.withResolvers();
          #progressiveDoneListeners = [];
          #progressiveReadListeners = [];
          #progressListeners = [];
          #rangeListeners = [];
          constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
            this.length = length;
            this.initialData = initialData;
            this.progressiveDone = progressiveDone;
            this.contentDispositionFilename = contentDispositionFilename;
          }
          addRangeListener(listener) {
            this.#rangeListeners.push(listener);
          }
          addProgressListener(listener) {
            this.#progressListeners.push(listener);
          }
          addProgressiveReadListener(listener) {
            this.#progressiveReadListeners.push(listener);
          }
          addProgressiveDoneListener(listener) {
            this.#progressiveDoneListeners.push(listener);
          }
          onDataRange(begin, chunk) {
            for (const listener of this.#rangeListeners) {
              listener(begin, chunk);
            }
          }
          onDataProgress(loaded, total) {
            this.#capability.promise.then(() => {
              for (const listener of this.#progressListeners) {
                listener(loaded, total);
              }
            });
          }
          onDataProgressiveRead(chunk) {
            this.#capability.promise.then(() => {
              for (const listener of this.#progressiveReadListeners) {
                listener(chunk);
              }
            });
          }
          onDataProgressiveDone() {
            this.#capability.promise.then(() => {
              for (const listener of this.#progressiveDoneListeners) {
                listener();
              }
            });
          }
          transportReady() {
            this.#capability.resolve();
          }
          requestDataRange(begin, end) {
            unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
          }
          abort() { }
        }
        class PDFDocumentProxy {
          constructor(pdfInfo, transport) {
            this._pdfInfo = pdfInfo;
            this._transport = transport;
          }
          get annotationStorage() {
            return this._transport.annotationStorage;
          }
          get canvasFactory() {
            return this._transport.canvasFactory;
          }
          get filterFactory() {
            return this._transport.filterFactory;
          }
          get numPages() {
            return this._pdfInfo.numPages;
          }
          get fingerprints() {
            return this._pdfInfo.fingerprints;
          }
          get isPureXfa() {
            return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
          }
          get allXfaHtml() {
            return this._transport._htmlForXfa;
          }
          getPage(pageNumber) {
            return this._transport.getPage(pageNumber);
          }
          getPageIndex(ref) {
            return this._transport.getPageIndex(ref);
          }
          getDestinations() {
            return this._transport.getDestinations();
          }
          getDestination(id) {
            return this._transport.getDestination(id);
          }
          getPageLabels() {
            return this._transport.getPageLabels();
          }
          getPageLayout() {
            return this._transport.getPageLayout();
          }
          getPageMode() {
            return this._transport.getPageMode();
          }
          getViewerPreferences() {
            return this._transport.getViewerPreferences();
          }
          getOpenAction() {
            return this._transport.getOpenAction();
          }
          getAttachments() {
            return this._transport.getAttachments();
          }
          getAnnotationsByType(types, pageIndexesToSkip) {
            return this._transport.getAnnotationsByType(types, pageIndexesToSkip);
          }
          getJSActions() {
            return this._transport.getDocJSActions();
          }
          getOutline() {
            return this._transport.getOutline();
          }
          getOptionalContentConfig({
            intent = "display"
          } = {}) {
            const {
              renderingIntent
            } = this._transport.getRenderingIntent(intent);
            return this._transport.getOptionalContentConfig(renderingIntent);
          }
          getPermissions() {
            return this._transport.getPermissions();
          }
          getMetadata() {
            return this._transport.getMetadata();
          }
          getMarkInfo() {
            return this._transport.getMarkInfo();
          }
          getData() {
            return this._transport.getData();
          }
          saveDocument() {
            return this._transport.saveDocument();
          }
          getDownloadInfo() {
            return this._transport.downloadInfoCapability.promise;
          }
          cleanup(keepLoadedFonts = false) {
            return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
          }
          destroy() {
            return this.loadingTask.destroy();
          }
          cachedPageNumber(ref) {
            return this._transport.cachedPageNumber(ref);
          }
          get loadingParams() {
            return this._transport.loadingParams;
          }
          get loadingTask() {
            return this._transport.loadingTask;
          }
          getFieldObjects() {
            return this._transport.getFieldObjects();
          }
          hasJSActions() {
            return this._transport.hasJSActions();
          }
          getCalculationOrderIds() {
            return this._transport.getCalculationOrderIds();
          }
        }
        class PDFPageProxy {
          #pendingCleanup = false;
          constructor(pageIndex, pageInfo, transport, pdfBug = false) {
            this._pageIndex = pageIndex;
            this._pageInfo = pageInfo;
            this._transport = transport;
            this._stats = pdfBug ? new StatTimer() : null;
            this._pdfBug = pdfBug;
            this.commonObjs = transport.commonObjs;
            this.objs = new PDFObjects();
            this._intentStates = new Map();
            this.destroyed = false;
            this.recordedBBoxes = null;
          }
          get pageNumber() {
            return this._pageIndex + 1;
          }
          get rotate() {
            return this._pageInfo.rotate;
          }
          get ref() {
            return this._pageInfo.ref;
          }
          get userUnit() {
            return this._pageInfo.userUnit;
          }
          get view() {
            return this._pageInfo.view;
          }
          getViewport({
            scale,
            rotation = this.rotate,
            offsetX = 0,
            offsetY = 0,
            dontFlip = false
          } = {}) {
            return new PageViewport({
              viewBox: this.view,
              userUnit: this.userUnit,
              scale,
              rotation,
              offsetX,
              offsetY,
              dontFlip
            });
          }
          getAnnotations({
            intent = "display"
          } = {}) {
            const {
              renderingIntent
            } = this._transport.getRenderingIntent(intent);
            return this._transport.getAnnotations(this._pageIndex, renderingIntent);
          }
          getJSActions() {
            return this._transport.getPageJSActions(this._pageIndex);
          }
          get filterFactory() {
            return this._transport.filterFactory;
          }
          get isPureXfa() {
            return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
          }
          async getXfa() {
            return this._transport._htmlForXfa?.children[this._pageIndex] || null;
          }
          render({
            canvasContext,
            canvas = canvasContext.canvas,
            viewport,
            intent = "display",
            annotationMode = AnnotationMode.ENABLE,
            transform = null,
            background = null,
            optionalContentConfigPromise = null,
            annotationCanvasMap = null,
            pageColors = null,
            printAnnotationStorage = null,
            isEditing = false,
            recordOperations = false,
            operationsFilter = null
          }) {
            this._stats?.time("Overall");
            const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);
            const {
              renderingIntent,
              cacheKey
            } = intentArgs;
            this.#pendingCleanup = false;
            optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);
            let intentState = this._intentStates.get(cacheKey);
            if (!intentState) {
              intentState = Object.create(null);
              this._intentStates.set(cacheKey, intentState);
            }
            if (intentState.streamReaderCancelTimeout) {
              clearTimeout(intentState.streamReaderCancelTimeout);
              intentState.streamReaderCancelTimeout = null;
            }
            const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
            if (!intentState.displayReadyCapability) {
              intentState.displayReadyCapability = Promise.withResolvers();
              intentState.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: false,
                separateAnnots: null
              };
              this._stats?.time("Page Request");
              this._pumpOperatorList(intentArgs);
            }
            const recordForDebugger = Boolean(this._pdfBug && globalThis.StepperManager?.enabled);
            const shouldRecordOperations = !this.recordedBBoxes && (recordOperations || recordForDebugger);
            const complete = error => {
              intentState.renderTasks.delete(internalRenderTask);
              if (shouldRecordOperations) {
                const recordedBBoxes = internalRenderTask.gfx?.dependencyTracker.take();
                if (recordedBBoxes) {
                  if (internalRenderTask.stepper) {
                    internalRenderTask.stepper.setOperatorBBoxes(recordedBBoxes, internalRenderTask.gfx.dependencyTracker.takeDebugMetadata());
                  }
                  if (recordOperations) {
                    this.recordedBBoxes = recordedBBoxes;
                  }
                }
              }
              if (intentPrint) {
                this.#pendingCleanup = true;
              }
              this.#tryCleanup();
              if (error) {
                internalRenderTask.capability.reject(error);
                this._abortOperatorList({
                  intentState,
                  reason: error instanceof Error ? error : new Error(error)
                });
              } else {
                internalRenderTask.capability.resolve();
              }
              if (this._stats) {
                this._stats.timeEnd("Rendering");
                this._stats.timeEnd("Overall");
                if (globalThis.Stats?.enabled) {
                  globalThis.Stats.add(this.pageNumber, this._stats);
                }
              }
            };
            const internalRenderTask = new InternalRenderTask({
              callback: complete,
              params: {
                canvas,
                canvasContext,
                dependencyTracker: shouldRecordOperations ? new CanvasDependencyTracker(canvas, intentState.operatorList.length, recordForDebugger) : null,
                viewport,
                transform,
                background
              },
              objs: this.objs,
              commonObjs: this.commonObjs,
              annotationCanvasMap,
              operatorList: intentState.operatorList,
              pageIndex: this._pageIndex,
              canvasFactory: this._transport.canvasFactory,
              filterFactory: this._transport.filterFactory,
              useRequestAnimationFrame: !intentPrint,
              pdfBug: this._pdfBug,
              pageColors,
              enableHWA: this._transport.enableHWA,
              operationsFilter
            });
            (intentState.renderTasks ||= new Set()).add(internalRenderTask);
            const renderTask = internalRenderTask.task;
            Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
              if (this.destroyed) {
                complete();
                return;
              }
              this._stats?.time("Rendering");
              if (!(optionalContentConfig.renderingIntent & renderingIntent)) {
                throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` " + "and `PDFDocumentProxy.getOptionalContentConfig` methods.");
              }
              internalRenderTask.initializeGraphics({
                transparency,
                optionalContentConfig
              });
              internalRenderTask.operatorListChanged();
            }).catch(complete);
            return renderTask;
          }
          getOperatorList({
            intent = "display",
            annotationMode = AnnotationMode.ENABLE,
            printAnnotationStorage = null,
            isEditing = false
          } = {}) {
            function operatorListChanged() {
              if (intentState.operatorList.lastChunk) {
                intentState.opListReadCapability.resolve(intentState.operatorList);
                intentState.renderTasks.delete(opListTask);
              }
            }
            const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);
            let intentState = this._intentStates.get(intentArgs.cacheKey);
            if (!intentState) {
              intentState = Object.create(null);
              this._intentStates.set(intentArgs.cacheKey, intentState);
            }
            let opListTask;
            if (!intentState.opListReadCapability) {
              opListTask = Object.create(null);
              opListTask.operatorListChanged = operatorListChanged;
              intentState.opListReadCapability = Promise.withResolvers();
              (intentState.renderTasks ||= new Set()).add(opListTask);
              intentState.operatorList = {
                fnArray: [],
                argsArray: [],
                lastChunk: false,
                separateAnnots: null
              };
              this._stats?.time("Page Request");
              this._pumpOperatorList(intentArgs);
            }
            return intentState.opListReadCapability.promise;
          }
          streamTextContent({
            includeMarkedContent = false,
            disableNormalization = false
          } = {}) {
            const TEXT_CONTENT_CHUNK_SIZE = 100;
            return this._transport.messageHandler.sendWithStream("GetTextContent", {
              pageIndex: this._pageIndex,
              includeMarkedContent: includeMarkedContent === true,
              disableNormalization: disableNormalization === true
            }, {
              highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
              size(textContent) {
                return textContent.items.length;
              }
            });
          }
          getTextContent(params = {}) {
            if (this._transport._htmlForXfa) {
              return this.getXfa().then(xfa => XfaText.textContent(xfa));
            }
            const readableStream = this.streamTextContent(params);
            return new Promise(function (resolve, reject) {
              function pump() {
                reader.read().then(function ({
                  value,
                  done
                }) {
                  if (done) {
                    resolve(textContent);
                    return;
                  }
                  textContent.lang ??= value.lang;
                  Object.assign(textContent.styles, value.styles);
                  textContent.items.push(...value.items);
                  pump();
                }, reject);
              }
              const reader = readableStream.getReader();
              const textContent = {
                items: [],
                styles: Object.create(null),
                lang: null
              };
              pump();
            });
          }
          getStructTree() {
            return this._transport.getStructTree(this._pageIndex);
          }
          _destroy() {
            this.destroyed = true;
            const waitOn = [];
            for (const intentState of this._intentStates.values()) {
              this._abortOperatorList({
                intentState,
                reason: new Error("Page was destroyed."),
                force: true
              });
              if (intentState.opListReadCapability) {
                continue;
              }
              for (const internalRenderTask of intentState.renderTasks) {
                waitOn.push(internalRenderTask.completed);
                internalRenderTask.cancel();
              }
            }
            this.objs.clear();
            this.#pendingCleanup = false;
            return Promise.all(waitOn);
          }
          cleanup(resetStats = false) {
            this.#pendingCleanup = true;
            const success = this.#tryCleanup();
            if (resetStats && success) {
              this._stats &&= new StatTimer();
            }
            return success;
          }
          #tryCleanup() {
            if (!this.#pendingCleanup || this.destroyed) {
              return false;
            }
            for (const {
              renderTasks,
              operatorList
            } of this._intentStates.values()) {
              if (renderTasks.size > 0 || !operatorList.lastChunk) {
                return false;
              }
            }
            this._intentStates.clear();
            this.objs.clear();
            this.#pendingCleanup = false;
            return true;
          }
          _startRenderPage(transparency, cacheKey) {
            const intentState = this._intentStates.get(cacheKey);
            if (!intentState) {
              return;
            }
            this._stats?.timeEnd("Page Request");
            intentState.displayReadyCapability?.resolve(transparency);
          }
          _renderPageChunk(operatorListChunk, intentState) {
            for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
              intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
              intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
            }
            intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
            intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
            for (const internalRenderTask of intentState.renderTasks) {
              internalRenderTask.operatorListChanged();
            }
            if (operatorListChunk.lastChunk) {
              this.#tryCleanup();
            }
          }
          _pumpOperatorList({
            renderingIntent,
            cacheKey,
            annotationStorageSerializable,
            modifiedIds
          }) {
            const {
              map,
              transfer
            } = annotationStorageSerializable;
            const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
              pageIndex: this._pageIndex,
              intent: renderingIntent,
              cacheKey,
              annotationStorage: map,
              modifiedIds
            }, transfer);
            const reader = readableStream.getReader();
            const intentState = this._intentStates.get(cacheKey);
            intentState.streamReader = reader;
            const pump = () => {
              reader.read().then(({
                value,
                done
              }) => {
                if (done) {
                  intentState.streamReader = null;
                  return;
                }
                if (this._transport.destroyed) {
                  return;
                }
                this._renderPageChunk(value, intentState);
                pump();
              }, reason => {
                intentState.streamReader = null;
                if (this._transport.destroyed) {
                  return;
                }
                if (intentState.operatorList) {
                  intentState.operatorList.lastChunk = true;
                  for (const internalRenderTask of intentState.renderTasks) {
                    internalRenderTask.operatorListChanged();
                  }
                  this.#tryCleanup();
                }
                if (intentState.displayReadyCapability) {
                  intentState.displayReadyCapability.reject(reason);
                } else if (intentState.opListReadCapability) {
                  intentState.opListReadCapability.reject(reason);
                } else {
                  throw reason;
                }
              });
            };
            pump();
          }
          _abortOperatorList({
            intentState,
            reason,
            force = false
          }) {
            if (!intentState.streamReader) {
              return;
            }
            if (intentState.streamReaderCancelTimeout) {
              clearTimeout(intentState.streamReaderCancelTimeout);
              intentState.streamReaderCancelTimeout = null;
            }
            if (!force) {
              if (intentState.renderTasks.size > 0) {
                return;
              }
              if (reason instanceof RenderingCancelledException) {
                let delay = RENDERING_CANCELLED_TIMEOUT;
                if (reason.extraDelay > 0 && reason.extraDelay < 1000) {
                  delay += reason.extraDelay;
                }
                intentState.streamReaderCancelTimeout = setTimeout(() => {
                  intentState.streamReaderCancelTimeout = null;
                  this._abortOperatorList({
                    intentState,
                    reason,
                    force: true
                  });
                }, delay);
                return;
              }
            }
            intentState.streamReader.cancel(new AbortException(reason.message)).catch(() => { });
            intentState.streamReader = null;
            if (this._transport.destroyed) {
              return;
            }
            for (const [curCacheKey, curIntentState] of this._intentStates) {
              if (curIntentState === intentState) {
                this._intentStates.delete(curCacheKey);
                break;
              }
            }
            this.cleanup();
          }
          get stats() {
            return this._stats;
          }
        }
        class PDFWorker {
          #capability = Promise.withResolvers();
          #messageHandler = null;
          #port = null;
          #webWorker = null;
          static #fakeWorkerId = 0;
          static #isWorkerDisabled = false;
          static #workerPorts = new WeakMap();
          static {
            if (isNodeJS) {
              this.#isWorkerDisabled = true;
              GlobalWorkerOptions.workerSrc ||= "./pdf.worker.mjs";
            }
            this._isSameOrigin = (baseUrl, otherUrl) => {
              const base = URL.parse(baseUrl);
              if (!base?.origin || base.origin === "null") {
                return false;
              }
              const other = new URL(otherUrl, base);
              return base.origin === other.origin;
            };
            this._createCDNWrapper = url => {
              const wrapper = `await import("${url}");`;
              return URL.createObjectURL(new Blob([wrapper], {
                type: "text/javascript"
              }));
            };
            this.fromPort = params => {
              deprecated("`PDFWorker.fromPort` - please use `PDFWorker.create` instead.");
              if (!params?.port) {
                throw new Error("PDFWorker.fromPort - invalid method signature.");
              }
              return this.create(params);
            };
          }
          constructor({
            name = null,
            port = null,
            verbosity = getVerbosityLevel()
          } = {}) {
            this.name = name;
            this.destroyed = false;
            this.verbosity = verbosity;
            if (port) {
              if (PDFWorker.#workerPorts.has(port)) {
                throw new Error("Cannot use more than one PDFWorker per port.");
              }
              PDFWorker.#workerPorts.set(port, this);
              this.#initializeFromPort(port);
            } else {
              this.#initialize();
            }
          }
          get promise() {
            return this.#capability.promise;
          }
          #resolve() {
            this.#capability.resolve();
            this.#messageHandler.send("configure", {
              verbosity: this.verbosity
            });
          }
          get port() {
            return this.#port;
          }
          get messageHandler() {
            return this.#messageHandler;
          }
          #initializeFromPort(port) {
            this.#port = port;
            this.#messageHandler = new MessageHandler("main", "worker", port);
            this.#messageHandler.on("ready", () => { });
            this.#resolve();
          }
          #initialize() {
            if (PDFWorker.#isWorkerDisabled || PDFWorker.#mainThreadWorkerMessageHandler) {
              this.#setupFakeWorker();
              return;
            }
            let {
              workerSrc
            } = PDFWorker;
            try {
              if (!PDFWorker._isSameOrigin(window.location, workerSrc)) {
                workerSrc = PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);
              }
              const worker = new Worker(workerSrc, {
                type: "module"
              });
              const messageHandler = new MessageHandler("main", "worker", worker);
              const terminateEarly = () => {
                ac.abort();
                messageHandler.destroy();
                worker.terminate();
                if (this.destroyed) {
                  this.#capability.reject(new Error("Worker was destroyed"));
                } else {
                  this.#setupFakeWorker();
                }
              };
              const ac = new AbortController();
              worker.addEventListener("error", () => {
                if (!this.#webWorker) {
                  terminateEarly();
                }
              }, {
                signal: ac.signal
              });
              messageHandler.on("test", data => {
                ac.abort();
                if (this.destroyed || !data) {
                  terminateEarly();
                  return;
                }
                this.#messageHandler = messageHandler;
                this.#port = worker;
                this.#webWorker = worker;
                this.#resolve();
              });
              messageHandler.on("ready", data => {
                ac.abort();
                if (this.destroyed) {
                  terminateEarly();
                  return;
                }
                try {
                  sendTest();
                } catch {
                  this.#setupFakeWorker();
                }
              });
              const sendTest = () => {
                const testObj = new Uint8Array();
                messageHandler.send("test", testObj, [testObj.buffer]);
              };
              sendTest();
              return;
            } catch {
              info("The worker has been disabled.");
            }
            this.#setupFakeWorker();
          }
          #setupFakeWorker() {
            if (!PDFWorker.#isWorkerDisabled) {
              warn("Setting up fake worker.");
              PDFWorker.#isWorkerDisabled = true;
            }
            PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {
              if (this.destroyed) {
                this.#capability.reject(new Error("Worker was destroyed"));
                return;
              }
              const port = new LoopbackPort();
              this.#port = port;
              const id = `fake${PDFWorker.#fakeWorkerId++}`;
              const workerHandler = new MessageHandler(id + "_worker", id, port);
              WorkerMessageHandler.setup(workerHandler, port);
              this.#messageHandler = new MessageHandler(id, id + "_worker", port);
              this.#resolve();
            }).catch(reason => {
              this.#capability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
            });
          }
          destroy() {
            this.destroyed = true;
            this.#webWorker?.terminate();
            this.#webWorker = null;
            PDFWorker.#workerPorts.delete(this.#port);
            this.#port = null;
            this.#messageHandler?.destroy();
            this.#messageHandler = null;
          }
          static create(params) {
            const cachedPort = this.#workerPorts.get(params?.port);
            if (cachedPort) {
              if (cachedPort._pendingDestroy) {
                throw new Error("PDFWorker.create - the worker is being destroyed.\n" + "Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
              }
              return cachedPort;
            }
            return new PDFWorker(params);
          }
          static get workerSrc() {
            if (GlobalWorkerOptions.workerSrc) {
              return GlobalWorkerOptions.workerSrc;
            }
            throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
          }
          static get #mainThreadWorkerMessageHandler() {
            try {
              return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
            } catch {
              return null;
            }
          }
          static get _setupFakeWorkerGlobal() {
            const loader = async () => {
              if (this.#mainThreadWorkerMessageHandler) {
                return this.#mainThreadWorkerMessageHandler;
              }
              const worker = await import(
                /*webpackIgnore: true*/
                /*@vite-ignore*/
                this.workerSrc);
              return worker.WorkerMessageHandler;
            };
            return shadow(this, "_setupFakeWorkerGlobal", loader());
          }
        }
        class WorkerTransport {
          #methodPromises = new Map();
          #pageCache = new Map();
          #pagePromises = new Map();
          #pageRefCache = new Map();
          #passwordCapability = null;
          constructor(messageHandler, loadingTask, networkStream, params, factory, enableHWA) {
            this.messageHandler = messageHandler;
            this.loadingTask = loadingTask;
            this.commonObjs = new PDFObjects();
            this.fontLoader = new FontLoader({
              ownerDocument: params.ownerDocument,
              styleElement: params.styleElement
            });
            this.loadingParams = params.loadingParams;
            this._params = params;
            this.canvasFactory = factory.canvasFactory;
            this.filterFactory = factory.filterFactory;
            this.cMapReaderFactory = factory.cMapReaderFactory;
            this.standardFontDataFactory = factory.standardFontDataFactory;
            this.wasmFactory = factory.wasmFactory;
            this.destroyed = false;
            this.destroyCapability = null;
            this._networkStream = networkStream;
            this._fullReader = null;
            this._lastProgress = null;
            this.downloadInfoCapability = Promise.withResolvers();
            this.enableHWA = enableHWA;
            this.setupMessageHandler();
          }
          #cacheSimpleMethod(name, data = null) {
            const cachedPromise = this.#methodPromises.get(name);
            if (cachedPromise) {
              return cachedPromise;
            }
            const promise = this.messageHandler.sendWithPromise(name, data);
            this.#methodPromises.set(name, promise);
            return promise;
          }
          get annotationStorage() {
            return shadow(this, "annotationStorage", new AnnotationStorage());
          }
          getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {
            let renderingIntent = RenderingIntentFlag.DISPLAY;
            let annotationStorageSerializable = SerializableEmpty;
            switch (intent) {
              case "any":
                renderingIntent = RenderingIntentFlag.ANY;
                break;
              case "display":
                break;
              case "print":
                renderingIntent = RenderingIntentFlag.PRINT;
                break;
              default:
                warn(`getRenderingIntent - invalid intent: ${intent}`);
            }
            const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
            switch (annotationMode) {
              case AnnotationMode.DISABLE:
                renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;
                break;
              case AnnotationMode.ENABLE:
                break;
              case AnnotationMode.ENABLE_FORMS:
                renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;
                break;
              case AnnotationMode.ENABLE_STORAGE:
                renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;
                annotationStorageSerializable = annotationStorage.serializable;
                break;
              default:
                warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
            }
            if (isEditing) {
              renderingIntent += RenderingIntentFlag.IS_EDITING;
            }
            if (isOpList) {
              renderingIntent += RenderingIntentFlag.OPLIST;
            }
            const {
              ids: modifiedIds,
              hash: modifiedIdsHash
            } = annotationStorage.modifiedIds;
            const cacheKeyBuf = [renderingIntent, annotationStorageSerializable.hash, modifiedIdsHash];
            return {
              renderingIntent,
              cacheKey: cacheKeyBuf.join("_"),
              annotationStorageSerializable,
              modifiedIds
            };
          }
          destroy() {
            if (this.destroyCapability) {
              return this.destroyCapability.promise;
            }
            this.destroyed = true;
            this.destroyCapability = Promise.withResolvers();
            this.#passwordCapability?.reject(new Error("Worker was destroyed during onPassword callback"));
            const waitOn = [];
            for (const page of this.#pageCache.values()) {
              waitOn.push(page._destroy());
            }
            this.#pageCache.clear();
            this.#pagePromises.clear();
            this.#pageRefCache.clear();
            if (this.hasOwnProperty("annotationStorage")) {
              this.annotationStorage.resetModified();
            }
            const terminated = this.messageHandler.sendWithPromise("Terminate", null);
            waitOn.push(terminated);
            Promise.all(waitOn).then(() => {
              this.commonObjs.clear();
              this.fontLoader.clear();
              this.#methodPromises.clear();
              this.filterFactory.destroy();
              TextLayer.cleanup();
              this._networkStream?.cancelAllRequests(new AbortException("Worker was terminated."));
              this.messageHandler?.destroy();
              this.messageHandler = null;
              this.destroyCapability.resolve();
            }, this.destroyCapability.reject);
            return this.destroyCapability.promise;
          }
          setupMessageHandler() {
            const {
              messageHandler,
              loadingTask
            } = this;
            messageHandler.on("GetReader", (data, sink) => {
              assert(this._networkStream, "GetReader - no `IPDFStream` instance available.");
              this._fullReader = this._networkStream.getFullReader();
              this._fullReader.onProgress = evt => {
                this._lastProgress = {
                  loaded: evt.loaded,
                  total: evt.total
                };
              };
              sink.onPull = () => {
                this._fullReader.read().then(function ({
                  value,
                  done
                }) {
                  if (done) {
                    sink.close();
                    return;
                  }
                  assert(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
                  sink.enqueue(new Uint8Array(value), 1, [value]);
                }).catch(reason => {
                  sink.error(reason);
                });
              };
              sink.onCancel = reason => {
                this._fullReader.cancel(reason);
                sink.ready.catch(readyReason => {
                  if (this.destroyed) {
                    return;
                  }
                  throw readyReason;
                });
              };
            });
            messageHandler.on("ReaderHeadersReady", async data => {
              await this._fullReader.headersReady;
              const {
                isStreamingSupported,
                isRangeSupported,
                contentLength
              } = this._fullReader;
              if (!isStreamingSupported || !isRangeSupported) {
                if (this._lastProgress) {
                  loadingTask.onProgress?.(this._lastProgress);
                }
                this._fullReader.onProgress = evt => {
                  loadingTask.onProgress?.({
                    loaded: evt.loaded,
                    total: evt.total
                  });
                };
              }
              return {
                isStreamingSupported,
                isRangeSupported,
                contentLength
              };
            });
            messageHandler.on("GetRangeReader", (data, sink) => {
              assert(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
              const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
              if (!rangeReader) {
                sink.close();
                return;
              }
              sink.onPull = () => {
                rangeReader.read().then(function ({
                  value,
                  done
                }) {
                  if (done) {
                    sink.close();
                    return;
                  }
                  assert(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
                  sink.enqueue(new Uint8Array(value), 1, [value]);
                }).catch(reason => {
                  sink.error(reason);
                });
              };
              sink.onCancel = reason => {
                rangeReader.cancel(reason);
                sink.ready.catch(readyReason => {
                  if (this.destroyed) {
                    return;
                  }
                  throw readyReason;
                });
              };
            });
            messageHandler.on("GetDoc", ({
              pdfInfo
            }) => {
              this._numPages = pdfInfo.numPages;
              this._htmlForXfa = pdfInfo.htmlForXfa;
              delete pdfInfo.htmlForXfa;
              loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
            });
            messageHandler.on("DocException", ex => {
              loadingTask._capability.reject(wrapReason(ex));
            });
            messageHandler.on("PasswordRequest", ex => {
              this.#passwordCapability = Promise.withResolvers();
              try {
                if (!loadingTask.onPassword) {
                  throw wrapReason(ex);
                }
                const updatePassword = password => {
                  if (password instanceof Error) {
                    this.#passwordCapability.reject(password);
                  } else {
                    this.#passwordCapability.resolve({
                      password
                    });
                  }
                };
                loadingTask.onPassword(updatePassword, ex.code);
              } catch (err) {
                this.#passwordCapability.reject(err);
              }
              return this.#passwordCapability.promise;
            });
            messageHandler.on("DataLoaded", data => {
              loadingTask.onProgress?.({
                loaded: data.length,
                total: data.length
              });
              this.downloadInfoCapability.resolve(data);
            });
            messageHandler.on("StartRenderPage", data => {
              if (this.destroyed) {
                return;
              }
              const page = this.#pageCache.get(data.pageIndex);
              page._startRenderPage(data.transparency, data.cacheKey);
            });
            messageHandler.on("commonobj", ([id, type, exportedData]) => {
              if (this.destroyed) {
                return null;
              }
              if (this.commonObjs.has(id)) {
                return null;
              }
              switch (type) {
                case "Font":
                  if ("error" in exportedData) {
                    const exportedError = exportedData.error;
                    warn(`Error during font loading: ${exportedError}`);
                    this.commonObjs.resolve(id, exportedError);
                    break;
                  }
                  const fontData = new FontInfo(exportedData);
                  const inspectFont = this._params.pdfBug && globalThis.FontInspector?.enabled ? (font, url) => globalThis.FontInspector.fontAdded(font, url) : null;
                  const font = new FontFaceObject(fontData, inspectFont, exportedData.extra, exportedData.charProcOperatorList);
                  this.fontLoader.bind(font).catch(() => messageHandler.sendWithPromise("FontFallback", {
                    id
                  })).finally(() => {
                    if (!font.fontExtraProperties && font.data) {
                      font.clearData();
                    }
                    this.commonObjs.resolve(id, font);
                  });
                  break;
                case "CopyLocalImage":
                  const {
                    imageRef
                  } = exportedData;
                  assert(imageRef, "The imageRef must be defined.");
                  for (const pageProxy of this.#pageCache.values()) {
                    for (const [, data] of pageProxy.objs) {
                      if (data?.ref !== imageRef) {
                        continue;
                      }
                      if (!data.dataLen) {
                        return null;
                      }
                      this.commonObjs.resolve(id, structuredClone(data));
                      return data.dataLen;
                    }
                  }
                  break;
                case "FontPath":
                case "Image":
                  this.commonObjs.resolve(id, exportedData);
                  break;
                case "Pattern":
                  const pattern = new PatternInfo(exportedData);
                  this.commonObjs.resolve(id, pattern.getIR());
                  break;
                default:
                  throw new Error(`Got unknown common object type ${type}`);
              }
              return null;
            });
            messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
              if (this.destroyed) {
                return;
              }
              const pageProxy = this.#pageCache.get(pageIndex);
              if (pageProxy.objs.has(id)) {
                return;
              }
              if (pageProxy._intentStates.size === 0) {
                imageData?.bitmap?.close();
                return;
              }
              switch (type) {
                case "Image":
                case "Pattern":
                  pageProxy.objs.resolve(id, imageData);
                  break;
                default:
                  throw new Error(`Got unknown object type ${type}`);
              }
            });
            messageHandler.on("DocProgress", data => {
              if (this.destroyed) {
                return;
              }
              loadingTask.onProgress?.({
                loaded: data.loaded,
                total: data.total
              });
            });
            messageHandler.on("FetchBinaryData", async data => {
              if (this.destroyed) {
                throw new Error("Worker was destroyed.");
              }
              const factory = this[data.type];
              if (!factory) {
                throw new Error(`${data.type} not initialized, see the \`useWorkerFetch\` parameter.`);
              }
              return factory.fetch(data);
            });
          }
          getData() {
            return this.messageHandler.sendWithPromise("GetData", null);
          }
          saveDocument() {
            if (this.annotationStorage.size <= 0) {
              warn("saveDocument called while `annotationStorage` is empty, " + "please use the getData-method instead.");
            }
            const {
              map,
              transfer
            } = this.annotationStorage.serializable;
            return this.messageHandler.sendWithPromise("SaveDocument", {
              isPureXfa: !!this._htmlForXfa,
              numPages: this._numPages,
              annotationStorage: map,
              filename: this._fullReader?.filename ?? null
            }, transfer).finally(() => {
              this.annotationStorage.resetModified();
            });
          }
          getPage(pageNumber) {
            if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
              return Promise.reject(new Error("Invalid page request."));
            }
            const pageIndex = pageNumber - 1,
              cachedPromise = this.#pagePromises.get(pageIndex);
            if (cachedPromise) {
              return cachedPromise;
            }
            const promise = this.messageHandler.sendWithPromise("GetPage", {
              pageIndex
            }).then(pageInfo => {
              if (this.destroyed) {
                throw new Error("Transport destroyed");
              }
              if (pageInfo.refStr) {
                this.#pageRefCache.set(pageInfo.refStr, pageNumber);
              }
              const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
              this.#pageCache.set(pageIndex, page);
              return page;
            });
            this.#pagePromises.set(pageIndex, promise);
            return promise;
          }
          getPageIndex(ref) {
            if (!isRefProxy(ref)) {
              return Promise.reject(new Error("Invalid pageIndex request."));
            }
            return this.messageHandler.sendWithPromise("GetPageIndex", {
              num: ref.num,
              gen: ref.gen
            });
          }
          getAnnotations(pageIndex, intent) {
            return this.messageHandler.sendWithPromise("GetAnnotations", {
              pageIndex,
              intent
            });
          }
          getFieldObjects() {
            return this.#cacheSimpleMethod("GetFieldObjects");
          }
          hasJSActions() {
            return this.#cacheSimpleMethod("HasJSActions");
          }
          getCalculationOrderIds() {
            return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
          }
          getDestinations() {
            return this.messageHandler.sendWithPromise("GetDestinations", null);
          }
          getDestination(id) {
            if (typeof id !== "string") {
              return Promise.reject(new Error("Invalid destination request."));
            }
            return this.messageHandler.sendWithPromise("GetDestination", {
              id
            });
          }
          getPageLabels() {
            return this.messageHandler.sendWithPromise("GetPageLabels", null);
          }
          getPageLayout() {
            return this.messageHandler.sendWithPromise("GetPageLayout", null);
          }
          getPageMode() {
            return this.messageHandler.sendWithPromise("GetPageMode", null);
          }
          getViewerPreferences() {
            return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
          }
          getOpenAction() {
            return this.messageHandler.sendWithPromise("GetOpenAction", null);
          }
          getAttachments() {
            return this.messageHandler.sendWithPromise("GetAttachments", null);
          }
          getAnnotationsByType(types, pageIndexesToSkip) {
            return this.messageHandler.sendWithPromise("GetAnnotationsByType", {
              types,
              pageIndexesToSkip
            });
          }
          getDocJSActions() {
            return this.#cacheSimpleMethod("GetDocJSActions");
          }
          getPageJSActions(pageIndex) {
            return this.messageHandler.sendWithPromise("GetPageJSActions", {
              pageIndex
            });
          }
          getStructTree(pageIndex) {
            return this.messageHandler.sendWithPromise("GetStructTree", {
              pageIndex
            });
          }
          getOutline() {
            return this.messageHandler.sendWithPromise("GetOutline", null);
          }
          getOptionalContentConfig(renderingIntent) {
            return this.#cacheSimpleMethod("GetOptionalContentConfig").then(data => new OptionalContentConfig(data, renderingIntent));
          }
          getPermissions() {
            return this.messageHandler.sendWithPromise("GetPermissions", null);
          }
          getMetadata() {
            const name = "GetMetadata",
              cachedPromise = this.#methodPromises.get(name);
            if (cachedPromise) {
              return cachedPromise;
            }
            const promise = this.messageHandler.sendWithPromise(name, null).then(results => ({
              info: results[0],
              metadata: results[1] ? new Metadata(results[1]) : null,
              contentDispositionFilename: this._fullReader?.filename ?? null,
              contentLength: this._fullReader?.contentLength ?? null
            }));
            this.#methodPromises.set(name, promise);
            return promise;
          }
          getMarkInfo() {
            return this.messageHandler.sendWithPromise("GetMarkInfo", null);
          }
          async startCleanup(keepLoadedFonts = false) {
            if (this.destroyed) {
              return;
            }
            await this.messageHandler.sendWithPromise("Cleanup", null);
            for (const page of this.#pageCache.values()) {
              const cleanupSuccessful = page.cleanup();
              if (!cleanupSuccessful) {
                throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
              }
            }
            this.commonObjs.clear();
            if (!keepLoadedFonts) {
              this.fontLoader.clear();
            }
            this.#methodPromises.clear();
            this.filterFactory.destroy(true);
            TextLayer.cleanup();
          }
          cachedPageNumber(ref) {
            if (!isRefProxy(ref)) {
              return null;
            }
            const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;
            return this.#pageRefCache.get(refStr) ?? null;
          }
        }
        class RenderTask {
          #internalRenderTask = null;
          onContinue = null;
          onError = null;
          constructor(internalRenderTask) {
            this.#internalRenderTask = internalRenderTask;
          }
          get promise() {
            return this.#internalRenderTask.capability.promise;
          }
          cancel(extraDelay = 0) {
            this.#internalRenderTask.cancel(null, extraDelay);
          }
          get separateAnnots() {
            const {
              separateAnnots
            } = this.#internalRenderTask.operatorList;
            if (!separateAnnots) {
              return false;
            }
            const {
              annotationCanvasMap
            } = this.#internalRenderTask;
            return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;
          }
        }
        class InternalRenderTask {
          #rAF = null;
          static #canvasInUse = new WeakSet();
          constructor({
            callback,
            params,
            objs,
            commonObjs,
            annotationCanvasMap,
            operatorList,
            pageIndex,
            canvasFactory,
            filterFactory,
            useRequestAnimationFrame = false,
            pdfBug = false,
            pageColors = null,
            enableHWA = false,
            operationsFilter = null
          }) {
            this.callback = callback;
            this.params = params;
            this.objs = objs;
            this.commonObjs = commonObjs;
            this.annotationCanvasMap = annotationCanvasMap;
            this.operatorListIdx = null;
            this.operatorList = operatorList;
            this._pageIndex = pageIndex;
            this.canvasFactory = canvasFactory;
            this.filterFactory = filterFactory;
            this._pdfBug = pdfBug;
            this.pageColors = pageColors;
            this.running = false;
            this.graphicsReadyCallback = null;
            this.graphicsReady = false;
            this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
            this.cancelled = false;
            this.capability = Promise.withResolvers();
            this.task = new RenderTask(this);
            this._cancelBound = this.cancel.bind(this);
            this._continueBound = this._continue.bind(this);
            this._scheduleNextBound = this._scheduleNext.bind(this);
            this._nextBound = this._next.bind(this);
            this._canvas = params.canvas;
            this._canvasContext = params.canvas ? null : params.canvasContext;
            this._enableHWA = enableHWA;
            this._dependencyTracker = params.dependencyTracker;
            this._operationsFilter = operationsFilter;
          }
          get completed() {
            return this.capability.promise.catch(function () { });
          }
          initializeGraphics({
            transparency = false,
            optionalContentConfig
          }) {
            if (this.cancelled) {
              return;
            }
            if (this._canvas) {
              if (InternalRenderTask.#canvasInUse.has(this._canvas)) {
                throw new Error("Cannot use the same canvas during multiple render() operations. " + "Use different canvas or ensure previous operations were " + "cancelled or completed.");
              }
              InternalRenderTask.#canvasInUse.add(this._canvas);
            }
            if (this._pdfBug && globalThis.StepperManager?.enabled) {
              this.stepper = globalThis.StepperManager.create(this._pageIndex);
              this.stepper.init(this.operatorList);
              this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
            }
            const {
              viewport,
              transform,
              background,
              dependencyTracker
            } = this.params;
            const canvasContext = this._canvasContext || this._canvas.getContext("2d", {
              alpha: false,
              willReadFrequently: !this._enableHWA
            });
            this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
              optionalContentConfig
            }, this.annotationCanvasMap, this.pageColors, dependencyTracker);
            this.gfx.beginDrawing({
              transform,
              viewport,
              transparency,
              background
            });
            this.operatorListIdx = 0;
            this.graphicsReady = true;
            this.graphicsReadyCallback?.();
          }
          cancel(error = null, extraDelay = 0) {
            this.running = false;
            this.cancelled = true;
            this.gfx?.endDrawing();
            if (this.#rAF) {
              window.cancelAnimationFrame(this.#rAF);
              this.#rAF = null;
            }
            InternalRenderTask.#canvasInUse.delete(this._canvas);
            error ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay);
            this.callback(error);
            this.task.onError?.(error);
          }
          operatorListChanged() {
            if (!this.graphicsReady) {
              this.graphicsReadyCallback ||= this._continueBound;
              return;
            }
            this.gfx.dependencyTracker?.growOperationsCount(this.operatorList.fnArray.length);
            this.stepper?.updateOperatorList(this.operatorList);
            if (this.running) {
              return;
            }
            this._continue();
          }
          _continue() {
            this.running = true;
            if (this.cancelled) {
              return;
            }
            if (this.task.onContinue) {
              this.task.onContinue(this._scheduleNextBound);
            } else {
              this._scheduleNext();
            }
          }
          _scheduleNext() {
            if (this._useRequestAnimationFrame) {
              this.#rAF = window.requestAnimationFrame(() => {
                this.#rAF = null;
                this._nextBound().catch(this._cancelBound);
              });
            } else {
              Promise.resolve().then(this._nextBound).catch(this._cancelBound);
            }
          }
          async _next() {
            if (this.cancelled) {
              return;
            }
            this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._operationsFilter);
            if (this.operatorListIdx === this.operatorList.argsArray.length) {
              this.running = false;
              if (this.operatorList.lastChunk) {
                this.gfx.endDrawing();
                InternalRenderTask.#canvasInUse.delete(this._canvas);
                this.callback();
              }
            }
          }
        }
        const version = "5.4.394";
        const build = "2cc809ade";

        ;// ./src/display/editor/color_picker.js



        class ColorPicker {
          #button = null;
          #buttonSwatch = null;
          #defaultColor;
          #dropdown = null;
          #dropdownWasFromKeyboard = false;
          #isMainColorPicker = false;
          #editor = null;
          #eventBus;
          #openDropdownAC = null;
          #uiManager = null;
          static #l10nColor = null;
          static get _keyboardManager() {
            return shadow(this, "_keyboardManager", new KeyboardManager([[["Escape", "mac+Escape"], ColorPicker.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], ColorPicker.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], ColorPicker.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], ColorPicker.prototype._moveToPrevious], [["Home", "mac+Home"], ColorPicker.prototype._moveToBeginning], [["End", "mac+End"], ColorPicker.prototype._moveToEnd]]));
          }
          constructor({
            editor = null,
            uiManager = null
          }) {
            if (editor) {
              this.#isMainColorPicker = false;
              this.#editor = editor;
            } else {
              this.#isMainColorPicker = true;
            }
            this.#uiManager = editor?._uiManager || uiManager;
            this.#eventBus = this.#uiManager._eventBus;
            this.#defaultColor = editor?.color?.toUpperCase() || this.#uiManager?.highlightColors.values().next().value || "#FFFF98";
            ColorPicker.#l10nColor ||= Object.freeze({
              blue: "pdfjs-editor-colorpicker-blue",
              green: "pdfjs-editor-colorpicker-green",
              pink: "pdfjs-editor-colorpicker-pink",
              red: "pdfjs-editor-colorpicker-red",
              yellow: "pdfjs-editor-colorpicker-yellow"
            });
          }
          renderButton() {
            const button = this.#button = document.createElement("button");
            button.className = "colorPicker";
            button.tabIndex = "0";
            button.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button");
            button.ariaHasPopup = "true";
            if (this.#editor) {
              button.ariaControls = `${this.#editor.id}_colorpicker_dropdown`;
            }
            const signal = this.#uiManager._signal;
            button.addEventListener("click", this.#openDropdown.bind(this), {
              signal
            });
            button.addEventListener("keydown", this.#keyDown.bind(this), {
              signal
            });
            const swatch = this.#buttonSwatch = document.createElement("span");
            swatch.className = "swatch";
            swatch.ariaHidden = "true";
            swatch.style.backgroundColor = this.#defaultColor;
            button.append(swatch);
            return button;
          }
          renderMainDropdown() {
            const dropdown = this.#dropdown = this.#getDropdownRoot();
            dropdown.ariaOrientation = "horizontal";
            dropdown.ariaLabelledBy = "highlightColorPickerLabel";
            return dropdown;
          }
          #getDropdownRoot() {
            const div = document.createElement("div");
            const signal = this.#uiManager._signal;
            div.addEventListener("contextmenu", noContextMenu, {
              signal
            });
            div.className = "dropdown";
            div.role = "listbox";
            div.ariaMultiSelectable = "false";
            div.ariaOrientation = "vertical";
            div.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
            if (this.#editor) {
              div.id = `${this.#editor.id}_colorpicker_dropdown`;
            }
            for (const [name, color] of this.#uiManager.highlightColors) {
              const button = document.createElement("button");
              button.tabIndex = "0";
              button.role = "option";
              button.setAttribute("data-color", color);
              button.title = name;
              button.setAttribute("data-l10n-id", ColorPicker.#l10nColor[name]);
              const swatch = document.createElement("span");
              button.append(swatch);
              swatch.className = "swatch";
              swatch.style.backgroundColor = color;
              button.ariaSelected = color === this.#defaultColor;
              button.addEventListener("click", this.#colorSelect.bind(this, color), {
                signal
              });
              div.append(button);
            }
            div.addEventListener("keydown", this.#keyDown.bind(this), {
              signal
            });
            return div;
          }
          #colorSelect(color, event) {
            event.stopPropagation();
            this.#eventBus.dispatch("switchannotationeditorparams", {
              source: this,
              type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
              value: color
            });
            this.updateColor(color);
          }
          _colorSelectFromKeyboard(event) {
            if (event.target === this.#button) {
              this.#openDropdown(event);
              return;
            }
            const color = event.target.getAttribute("data-color");
            if (!color) {
              return;
            }
            this.#colorSelect(color, event);
          }
          _moveToNext(event) {
            if (!this.#isDropdownVisible) {
              this.#openDropdown(event);
              return;
            }
            if (event.target === this.#button) {
              this.#dropdown.firstChild?.focus();
              return;
            }
            event.target.nextSibling?.focus();
          }
          _moveToPrevious(event) {
            if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {
              if (this.#isDropdownVisible) {
                this._hideDropdownFromKeyboard();
              }
              return;
            }
            if (!this.#isDropdownVisible) {
              this.#openDropdown(event);
            }
            event.target.previousSibling?.focus();
          }
          _moveToBeginning(event) {
            if (!this.#isDropdownVisible) {
              this.#openDropdown(event);
              return;
            }
            this.#dropdown.firstChild?.focus();
          }
          _moveToEnd(event) {
            if (!this.#isDropdownVisible) {
              this.#openDropdown(event);
              return;
            }
            this.#dropdown.lastChild?.focus();
          }
          #keyDown(event) {
            ColorPicker._keyboardManager.exec(this, event);
          }
          #openDropdown(event) {
            if (this.#isDropdownVisible) {
              this.hideDropdown();
              return;
            }
            this.#dropdownWasFromKeyboard = event.detail === 0;
            if (!this.#openDropdownAC) {
              this.#openDropdownAC = new AbortController();
              window.addEventListener("pointerdown", this.#pointerDown.bind(this), {
                signal: this.#uiManager.combinedSignal(this.#openDropdownAC)
              });
            }
            this.#button.ariaExpanded = "true";
            if (this.#dropdown) {
              this.#dropdown.classList.remove("hidden");
              return;
            }
            const root = this.#dropdown = this.#getDropdownRoot();
            this.#button.append(root);
          }
          #pointerDown(event) {
            if (this.#dropdown?.contains(event.target)) {
              return;
            }
            this.hideDropdown();
          }
          hideDropdown() {
            this.#dropdown?.classList.add("hidden");
            this.#button.ariaExpanded = "false";
            this.#openDropdownAC?.abort();
            this.#openDropdownAC = null;
          }
          get #isDropdownVisible() {
            return this.#dropdown && !this.#dropdown.classList.contains("hidden");
          }
          _hideDropdownFromKeyboard() {
            if (this.#isMainColorPicker) {
              return;
            }
            if (!this.#isDropdownVisible) {
              this.#editor?.unselect();
              return;
            }
            this.hideDropdown();
            this.#button.focus({
              preventScroll: true,
              focusVisible: this.#dropdownWasFromKeyboard
            });
          }
          updateColor(color) {
            if (this.#buttonSwatch) {
              this.#buttonSwatch.style.backgroundColor = color;
            }
            if (!this.#dropdown) {
              return;
            }
            const i = this.#uiManager.highlightColors.values();
            for (const child of this.#dropdown.children) {
              child.ariaSelected = i.next().value === color.toUpperCase();
            }
          }
          destroy() {
            this.#button?.remove();
            this.#button = null;
            this.#buttonSwatch = null;
            this.#dropdown?.remove();
            this.#dropdown = null;
          }
        }
        class BasicColorPicker {
          #input = null;
          #editor = null;
          #uiManager = null;
          static #l10nColor = null;
          constructor(editor) {
            this.#editor = editor;
            this.#uiManager = editor._uiManager;
            BasicColorPicker.#l10nColor ||= Object.freeze({
              freetext: "pdfjs-editor-color-picker-free-text-input",
              ink: "pdfjs-editor-color-picker-ink-input"
            });
          }
          renderButton() {
            if (this.#input) {
              return this.#input;
            }
            const {
              editorType,
              colorType,
              color
            } = this.#editor;
            const input = this.#input = document.createElement("input");
            input.type = "color";
            input.value = color || "#000000";
            input.className = "basicColorPicker";
            input.tabIndex = 0;
            input.setAttribute("data-l10n-id", BasicColorPicker.#l10nColor[editorType]);
            input.addEventListener("input", () => {
              this.#uiManager.updateParams(colorType, input.value);
            }, {
              signal: this.#uiManager._signal
            });
            return input;
          }
          update(value) {
            if (!this.#input) {
              return;
            }
            this.#input.value = value;
          }
          destroy() {
            this.#input?.remove();
            this.#input = null;
          }
          hideDropdown() { }
        }

        ;// ./src/shared/scripting_utils.js
        function makeColorComp(n) {
          return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
        }
        function scaleAndClamp(x) {
          return Math.max(0, Math.min(255, 255 * x));
        }
        class ColorConverters {
          static CMYK_G([c, y, m, k]) {
            return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
          }
          static G_CMYK([g]) {
            return ["CMYK", 0, 0, 0, 1 - g];
          }
          static G_RGB([g]) {
            return ["RGB", g, g, g];
          }
          static G_rgb([g]) {
            g = scaleAndClamp(g);
            return [g, g, g];
          }
          static G_HTML([g]) {
            const G = makeColorComp(g);
            return `#${G}${G}${G}`;
          }
          static RGB_G([r, g, b]) {
            return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
          }
          static RGB_rgb(color) {
            return color.map(scaleAndClamp);
          }
          static RGB_HTML(color) {
            return `#${color.map(makeColorComp).join("")}`;
          }
          static T_HTML() {
            return "#00000000";
          }
          static T_rgb() {
            return [null];
          }
          static CMYK_RGB([c, y, m, k]) {
            return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
          }
          static CMYK_rgb([c, y, m, k]) {
            return [scaleAndClamp(1 - Math.min(1, c + k)), scaleAndClamp(1 - Math.min(1, m + k)), scaleAndClamp(1 - Math.min(1, y + k))];
          }
          static CMYK_HTML(components) {
            const rgb = this.CMYK_RGB(components).slice(1);
            return this.RGB_HTML(rgb);
          }
          static RGB_CMYK([r, g, b]) {
            const c = 1 - r;
            const m = 1 - g;
            const y = 1 - b;
            const k = Math.min(c, m, y);
            return ["CMYK", c, m, y, k];
          }
        }
        const DateFormats = (/* unused pure expression or super */ null && (0));
        const TimeFormats = (/* unused pure expression or super */ null && (0));

        ;// ./src/display/svg_factory.js


        class BaseSVGFactory {
          create(width, height, skipDimensions = false) {
            if (width <= 0 || height <= 0) {
              throw new Error("Invalid SVG dimensions");
            }
            const svg = this._createSVG("svg:svg");
            svg.setAttribute("version", "1.1");
            if (!skipDimensions) {
              svg.setAttribute("width", `${width}px`);
              svg.setAttribute("height", `${height}px`);
            }
            svg.setAttribute("preserveAspectRatio", "none");
            svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
            return svg;
          }
          createElement(type) {
            if (typeof type !== "string") {
              throw new Error("Invalid SVG element type");
            }
            return this._createSVG(type);
          }
          _createSVG(type) {
            unreachable("Abstract method `_createSVG` called.");
          }
        }
        class DOMSVGFactory extends BaseSVGFactory {
          _createSVG(type) {
            return document.createElementNS(SVG_NS, type);
          }
        }

        ;// ./src/display/annotation_layer.js





        const annotation_layer_DEFAULT_FONT_SIZE = 9;
        const GetElementsByNameSet = new WeakSet();
        const TIMEZONE_OFFSET = new Date().getTimezoneOffset() * 60 * 1000;
        class AnnotationElementFactory {
          static create(parameters) {
            const subtype = parameters.data.annotationType;
            switch (subtype) {
              case AnnotationType.LINK:
                return new LinkAnnotationElement(parameters);
              case AnnotationType.TEXT:
                return new TextAnnotationElement(parameters);
              case AnnotationType.WIDGET:
                const fieldType = parameters.data.fieldType;
                switch (fieldType) {
                  case "Tx":
                    return new TextWidgetAnnotationElement(parameters);
                  case "Btn":
                    if (parameters.data.radioButton) {
                      return new RadioButtonWidgetAnnotationElement(parameters);
                    } else if (parameters.data.checkBox) {
                      return new CheckboxWidgetAnnotationElement(parameters);
                    }
                    return new PushButtonWidgetAnnotationElement(parameters);
                  case "Ch":
                    return new ChoiceWidgetAnnotationElement(parameters);
                  case "Sig":
                    return new SignatureWidgetAnnotationElement(parameters);
                }
                return new WidgetAnnotationElement(parameters);
              case AnnotationType.POPUP:
                return new PopupAnnotationElement(parameters);
              case AnnotationType.FREETEXT:
                return new FreeTextAnnotationElement(parameters);
              case AnnotationType.LINE:
                return new LineAnnotationElement(parameters);
              case AnnotationType.SQUARE:
                return new SquareAnnotationElement(parameters);
              case AnnotationType.CIRCLE:
                return new CircleAnnotationElement(parameters);
              case AnnotationType.POLYLINE:
                return new PolylineAnnotationElement(parameters);
              case AnnotationType.CARET:
                return new CaretAnnotationElement(parameters);
              case AnnotationType.INK:
                return new InkAnnotationElement(parameters);
              case AnnotationType.POLYGON:
                return new PolygonAnnotationElement(parameters);
              case AnnotationType.HIGHLIGHT:
                return new HighlightAnnotationElement(parameters);
              case AnnotationType.UNDERLINE:
                return new UnderlineAnnotationElement(parameters);
              case AnnotationType.SQUIGGLY:
                return new SquigglyAnnotationElement(parameters);
              case AnnotationType.STRIKEOUT:
                return new StrikeOutAnnotationElement(parameters);
              case AnnotationType.STAMP:
                return new StampAnnotationElement(parameters);
              case AnnotationType.FILEATTACHMENT:
                return new FileAttachmentAnnotationElement(parameters);
              default:
                return new AnnotationElement(parameters);
            }
          }
        }
        class AnnotationElement {
          #updates = null;
          #hasBorder = false;
          #popupElement = null;
          constructor(parameters, {
            isRenderable = false,
            ignoreBorder = false,
            createQuadrilaterals = false
          } = {}) {
            this.isRenderable = isRenderable;
            this.data = parameters.data;
            this.layer = parameters.layer;
            this.linkService = parameters.linkService;
            this.downloadManager = parameters.downloadManager;
            this.imageResourcesPath = parameters.imageResourcesPath;
            this.renderForms = parameters.renderForms;
            this.svgFactory = parameters.svgFactory;
            this.annotationStorage = parameters.annotationStorage;
            this.enableComment = parameters.enableComment;
            this.enableScripting = parameters.enableScripting;
            this.hasJSActions = parameters.hasJSActions;
            this._fieldObjects = parameters.fieldObjects;
            this.parent = parameters.parent;
            this.hasOwnCommentButton = false;
            if (isRenderable) {
              this.contentElement = this.container = this._createContainer(ignoreBorder);
            }
            if (createQuadrilaterals) {
              this._createQuadrilaterals();
            }
          }
          static _hasPopupData({
            contentsObj,
            richText
          }) {
            return !!(contentsObj?.str || richText?.str);
          }
          get _isEditable() {
            return this.data.isEditable;
          }
          get hasPopupData() {
            return AnnotationElement._hasPopupData(this.data) || this.enableComment && !!this.commentText;
          }
          get commentData() {
            const {
              data
            } = this;
            const editor = this.annotationStorage?.getEditor(data.id);
            if (editor) {
              return editor.getData();
            }
            return data;
          }
          get hasCommentButton() {
            return this.enableComment && this.hasPopupElement;
          }
          get commentButtonPosition() {
            const editor = this.annotationStorage?.getEditor(this.data.id);
            if (editor) {
              return editor.commentButtonPositionInPage;
            }
            const {
              quadPoints,
              inkLists,
              rect
            } = this.data;
            let maxX = -Infinity;
            let maxY = -Infinity;
            if (quadPoints?.length >= 8) {
              for (let i = 0; i < quadPoints.length; i += 8) {
                if (quadPoints[i + 1] > maxY) {
                  maxY = quadPoints[i + 1];
                  maxX = quadPoints[i + 2];
                } else if (quadPoints[i + 1] === maxY) {
                  maxX = Math.max(maxX, quadPoints[i + 2]);
                }
              }
              return [maxX, maxY];
            }
            if (inkLists?.length >= 1) {
              for (const inkList of inkLists) {
                for (let i = 0, ii = inkList.length; i < ii; i += 2) {
                  if (inkList[i + 1] > maxY) {
                    maxY = inkList[i + 1];
                    maxX = inkList[i];
                  } else if (inkList[i + 1] === maxY) {
                    maxX = Math.max(maxX, inkList[i]);
                  }
                }
              }
              if (maxX !== Infinity) {
                return [maxX, maxY];
              }
            }
            if (rect) {
              return [rect[2], rect[3]];
            }
            return null;
          }
          _normalizePoint(point) {
            const {
              page: {
                view
              },
              viewport: {
                rawDims: {
                  pageWidth,
                  pageHeight,
                  pageX,
                  pageY
                }
              }
            } = this.parent;
            point[1] = view[3] - point[1] + view[1];
            point[0] = 100 * (point[0] - pageX) / pageWidth;
            point[1] = 100 * (point[1] - pageY) / pageHeight;
            return point;
          }
          get commentText() {
            const {
              data
            } = this;
            return this.annotationStorage.getRawValue(`${AnnotationEditorPrefix}${data.id}`)?.popup?.contents || data.contentsObj?.str || "";
          }
          set commentText(text) {
            const {
              data
            } = this;
            const popup = {
              deleted: !text,
              contents: text || ""
            };
            if (!this.annotationStorage.updateEditor(data.id, {
              popup
            })) {
              this.annotationStorage.setValue(`${AnnotationEditorPrefix}${data.id}`, {
                id: data.id,
                annotationType: data.annotationType,
                pageIndex: this.parent.page._pageIndex,
                popup,
                popupRef: data.popupRef,
                modificationDate: new Date()
              });
            }
            if (!text) {
              this.removePopup();
            }
          }
          removePopup() {
            (this.#popupElement?.popup || this.popup)?.remove();
            this.#popupElement = this.popup = null;
          }
          updateEdited(params) {
            if (!this.container) {
              return;
            }
            if (params.rect) {
              this.#updates ||= {
                rect: this.data.rect.slice(0)
              };
            }
            const {
              rect,
              popup: newPopup
            } = params;
            if (rect) {
              this.#setRectEdited(rect);
            }
            let popup = this.#popupElement?.popup || this.popup;
            if (!popup && newPopup?.text) {
              this._createPopup(newPopup);
              popup = this.#popupElement.popup;
            }
            if (!popup) {
              return;
            }
            popup.updateEdited(params);
            if (newPopup?.deleted) {
              popup.remove();
              this.#popupElement = null;
              this.popup = null;
            }
          }
          resetEdited() {
            if (!this.#updates) {
              return;
            }
            this.#setRectEdited(this.#updates.rect);
            this.#popupElement?.popup.resetEdited();
            this.#updates = null;
          }
          #setRectEdited(rect) {
            const {
              container: {
                style
              },
              data: {
                rect: currentRect,
                rotation
              },
              parent: {
                viewport: {
                  rawDims: {
                    pageWidth,
                    pageHeight,
                    pageX,
                    pageY
                  }
                }
              }
            } = this;
            currentRect?.splice(0, 4, ...rect);
            style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
            style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;
            if (rotation === 0) {
              style.width = `${100 * (rect[2] - rect[0]) / pageWidth}%`;
              style.height = `${100 * (rect[3] - rect[1]) / pageHeight}%`;
            } else {
              this.setRotation(rotation);
            }
          }
          _createContainer(ignoreBorder) {
            const {
              data,
              parent: {
                page,
                viewport
              }
            } = this;
            const container = document.createElement("section");
            container.setAttribute("data-annotation-id", data.id);
            if (!(this instanceof WidgetAnnotationElement) && !(this instanceof LinkAnnotationElement)) {
              container.tabIndex = 0;
            }
            const {
              style
            } = container;
            style.zIndex = this.parent.zIndex;
            this.parent.zIndex += 2;
            if (data.alternativeText) {
              container.title = data.alternativeText;
            }
            if (data.noRotate) {
              container.classList.add("norotate");
            }
            if (!data.rect || this instanceof PopupAnnotationElement) {
              const {
                rotation
              } = data;
              if (!data.hasOwnCanvas && rotation !== 0) {
                this.setRotation(rotation, container);
              }
              return container;
            }
            const {
              width,
              height
            } = this;
            if (!ignoreBorder && data.borderStyle.width > 0) {
              style.borderWidth = `${data.borderStyle.width}px`;
              const horizontalRadius = data.borderStyle.horizontalCornerRadius;
              const verticalRadius = data.borderStyle.verticalCornerRadius;
              if (horizontalRadius > 0 || verticalRadius > 0) {
                const radius = `calc(${horizontalRadius}px * var(--total-scale-factor)) / calc(${verticalRadius}px * var(--total-scale-factor))`;
                style.borderRadius = radius;
              } else if (this instanceof RadioButtonWidgetAnnotationElement) {
                const radius = `calc(${width}px * var(--total-scale-factor)) / calc(${height}px * var(--total-scale-factor))`;
                style.borderRadius = radius;
              }
              switch (data.borderStyle.style) {
                case AnnotationBorderStyleType.SOLID:
                  style.borderStyle = "solid";
                  break;
                case AnnotationBorderStyleType.DASHED:
                  style.borderStyle = "dashed";
                  break;
                case AnnotationBorderStyleType.BEVELED:
                  warn("Unimplemented border style: beveled");
                  break;
                case AnnotationBorderStyleType.INSET:
                  warn("Unimplemented border style: inset");
                  break;
                case AnnotationBorderStyleType.UNDERLINE:
                  style.borderBottomStyle = "solid";
                  break;
                default:
                  break;
              }
              const borderColor = data.borderColor || null;
              if (borderColor) {
                this.#hasBorder = true;
                style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
              } else {
                style.borderWidth = 0;
              }
            }
            const rect = Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
            const {
              pageWidth,
              pageHeight,
              pageX,
              pageY
            } = viewport.rawDims;
            style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
            style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;
            const {
              rotation
            } = data;
            if (data.hasOwnCanvas || rotation === 0) {
              style.width = `${100 * width / pageWidth}%`;
              style.height = `${100 * height / pageHeight}%`;
            } else {
              this.setRotation(rotation, container);
            }
            return container;
          }
          setRotation(angle, container = this.container) {
            if (!this.data.rect) {
              return;
            }
            const {
              pageWidth,
              pageHeight
            } = this.parent.viewport.rawDims;
            let {
              width,
              height
            } = this;
            if (angle % 180 !== 0) {
              [width, height] = [height, width];
            }
            container.style.width = `${100 * width / pageWidth}%`;
            container.style.height = `${100 * height / pageHeight}%`;
            container.setAttribute("data-main-rotation", (360 - angle) % 360);
          }
          get _commonActions() {
            const setColor = (jsName, styleName, event) => {
              const color = event.detail[jsName];
              const colorType = color[0];
              const colorArray = color.slice(1);
              event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);
              this.annotationStorage.setValue(this.data.id, {
                [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)
              });
            };
            return shadow(this, "_commonActions", {
              display: event => {
                const {
                  display
                } = event.detail;
                const hidden = display % 2 === 1;
                this.container.style.visibility = hidden ? "hidden" : "visible";
                this.annotationStorage.setValue(this.data.id, {
                  noView: hidden,
                  noPrint: display === 1 || display === 2
                });
              },
              print: event => {
                this.annotationStorage.setValue(this.data.id, {
                  noPrint: !event.detail.print
                });
              },
              hidden: event => {
                const {
                  hidden
                } = event.detail;
                this.container.style.visibility = hidden ? "hidden" : "visible";
                this.annotationStorage.setValue(this.data.id, {
                  noPrint: hidden,
                  noView: hidden
                });
              },
              focus: event => {
                setTimeout(() => event.target.focus({
                  preventScroll: false
                }), 0);
              },
              userName: event => {
                event.target.title = event.detail.userName;
              },
              readonly: event => {
                event.target.disabled = event.detail.readonly;
              },
              required: event => {
                this._setRequired(event.target, event.detail.required);
              },
              bgColor: event => {
                setColor("bgColor", "backgroundColor", event);
              },
              fillColor: event => {
                setColor("fillColor", "backgroundColor", event);
              },
              fgColor: event => {
                setColor("fgColor", "color", event);
              },
              textColor: event => {
                setColor("textColor", "color", event);
              },
              borderColor: event => {
                setColor("borderColor", "borderColor", event);
              },
              strokeColor: event => {
                setColor("strokeColor", "borderColor", event);
              },
              rotation: event => {
                const angle = event.detail.rotation;
                this.setRotation(angle);
                this.annotationStorage.setValue(this.data.id, {
                  rotation: angle
                });
              }
            });
          }
          _dispatchEventFromSandbox(actions, jsEvent) {
            const commonActions = this._commonActions;
            for (const name of Object.keys(jsEvent.detail)) {
              const action = actions[name] || commonActions[name];
              action?.(jsEvent);
            }
          }
          _setDefaultPropertiesFromJS(element) {
            if (!this.enableScripting) {
              return;
            }
            const storedData = this.annotationStorage.getRawValue(this.data.id);
            if (!storedData) {
              return;
            }
            const commonActions = this._commonActions;
            for (const [actionName, detail] of Object.entries(storedData)) {
              const action = commonActions[actionName];
              if (action) {
                const eventProxy = {
                  detail: {
                    [actionName]: detail
                  },
                  target: element
                };
                action(eventProxy);
                delete storedData[actionName];
              }
            }
          }
          _createQuadrilaterals() {
            if (!this.container) {
              return;
            }
            const {
              quadPoints
            } = this.data;
            if (!quadPoints) {
              return;
            }
            const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map(x => Math.fround(x));
            if (quadPoints.length === 8) {
              const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);
              if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {
                return;
              }
            }
            const {
              style
            } = this.container;
            let svgBuffer;
            if (this.#hasBorder) {
              const {
                borderColor,
                borderWidth
              } = style;
              style.borderWidth = 0;
              svgBuffer = ["url('data:image/svg+xml;utf8,", `<svg xmlns="http://www.w3.org/2000/svg"`, ` preserveAspectRatio="none" viewBox="0 0 1 1">`, `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`];
              this.container.classList.add("hasBorder");
            }
            const width = rectTrX - rectBlX;
            const height = rectTrY - rectBlY;
            const {
              svgFactory
            } = this;
            const svg = svgFactory.createElement("svg");
            svg.classList.add("quadrilateralsContainer");
            svg.setAttribute("width", 0);
            svg.setAttribute("height", 0);
            svg.role = "none";
            const defs = svgFactory.createElement("defs");
            svg.append(defs);
            const clipPath = svgFactory.createElement("clipPath");
            const id = `clippath_${this.data.id}`;
            clipPath.setAttribute("id", id);
            clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
            defs.append(clipPath);
            for (let i = 2, ii = quadPoints.length; i < ii; i += 8) {
              const trX = quadPoints[i];
              const trY = quadPoints[i + 1];
              const blX = quadPoints[i + 2];
              const blY = quadPoints[i + 3];
              const rect = svgFactory.createElement("rect");
              const x = (blX - rectBlX) / width;
              const y = (rectTrY - trY) / height;
              const rectWidth = (trX - blX) / width;
              const rectHeight = (trY - blY) / height;
              rect.setAttribute("x", x);
              rect.setAttribute("y", y);
              rect.setAttribute("width", rectWidth);
              rect.setAttribute("height", rectHeight);
              clipPath.append(rect);
              svgBuffer?.push(`<rect vector-effect="non-scaling-stroke" x="${x}" y="${y}" width="${rectWidth}" height="${rectHeight}"/>`);
            }
            if (this.#hasBorder) {
              svgBuffer.push(`</g></svg>')`);
              style.backgroundImage = svgBuffer.join("");
            }
            this.container.append(svg);
            this.container.style.clipPath = `url(#${id})`;
          }
          _createPopup(popupData = null) {
            const {
              data
            } = this;
            let contentsObj, modificationDate;
            if (popupData) {
              contentsObj = {
                str: popupData.text
              };
              modificationDate = popupData.date;
            } else {
              contentsObj = data.contentsObj;
              modificationDate = data.modificationDate;
            }
            this.#popupElement = new PopupAnnotationElement({
              data: {
                color: data.color,
                titleObj: data.titleObj,
                modificationDate,
                contentsObj,
                richText: data.richText,
                parentRect: data.rect,
                borderStyle: 0,
                id: `popup_${data.id}`,
                rotation: data.rotation,
                noRotate: true
              },
              linkService: this.linkService,
              parent: this.parent,
              elements: [this]
            });
          }
          get hasPopupElement() {
            return !!(this.#popupElement || this.popup || this.data.popupRef);
          }
          get extraPopupElement() {
            return this.#popupElement;
          }
          render() {
            unreachable("Abstract method `AnnotationElement.render` called");
          }
          _getElementsByName(name, skipId = null) {
            const fields = [];
            if (this._fieldObjects) {
              const fieldObj = this._fieldObjects[name];
              if (fieldObj) {
                for (const {
                  page,
                  id,
                  exportValues
                } of fieldObj) {
                  if (page === -1) {
                    continue;
                  }
                  if (id === skipId) {
                    continue;
                  }
                  const exportValue = typeof exportValues === "string" ? exportValues : null;
                  const domElement = document.querySelector(`[data-element-id="${id}"]`);
                  if (domElement && !GetElementsByNameSet.has(domElement)) {
                    warn(`_getElementsByName - element not allowed: ${id}`);
                    continue;
                  }
                  fields.push({
                    id,
                    exportValue,
                    domElement
                  });
                }
              }
              return fields;
            }
            for (const domElement of document.getElementsByName(name)) {
              const {
                exportValue
              } = domElement;
              const id = domElement.getAttribute("data-element-id");
              if (id === skipId) {
                continue;
              }
              if (!GetElementsByNameSet.has(domElement)) {
                continue;
              }
              fields.push({
                id,
                exportValue,
                domElement
              });
            }
            return fields;
          }
          show() {
            if (this.container) {
              this.container.hidden = false;
            }
            this.popup?.maybeShow();
          }
          hide() {
            if (this.container) {
              this.container.hidden = true;
            }
            this.popup?.forceHide();
          }
          getElementsToTriggerPopup() {
            return this.container;
          }
          addHighlightArea() {
            const triggers = this.getElementsToTriggerPopup();
            if (Array.isArray(triggers)) {
              for (const element of triggers) {
                element.classList.add("highlightArea");
              }
            } else {
              triggers.classList.add("highlightArea");
            }
          }
          _editOnDoubleClick() {
            if (!this._isEditable) {
              return;
            }
            const {
              annotationEditorType: mode,
              data: {
                id: editId
              }
            } = this;
            this.container.addEventListener("dblclick", () => {
              this.linkService.eventBus?.dispatch("switchannotationeditormode", {
                source: this,
                mode,
                editId,
                mustEnterInEditMode: true
              });
            });
          }
          get width() {
            return this.data.rect[2] - this.data.rect[0];
          }
          get height() {
            return this.data.rect[3] - this.data.rect[1];
          }
        }
        class EditorAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: true
            });
            this.editor = parameters.editor;
          }
          render() {
            this.container.className = "editorAnnotation";
            return this.container;
          }
          createOrUpdatePopup() {
            const {
              editor
            } = this;
            if (!editor.hasComment) {
              return;
            }
            this._createPopup(editor.comment);
          }
          get hasCommentButton() {
            return this.enableComment && this.editor.hasComment;
          }
          get commentButtonPosition() {
            return this.editor.commentButtonPositionInPage;
          }
          get commentText() {
            return this.editor.comment.text;
          }
          set commentText(text) {
            this.editor.comment = text;
            if (!text) {
              this.removePopup();
            }
          }
          get commentData() {
            return this.editor.getData();
          }
          remove() {
            this.parent.removeAnnotation(this.data.id);
            this.container.remove();
            this.container = null;
            this.removePopup();
          }
        }
        class LinkAnnotationElement extends AnnotationElement {
          constructor(parameters, options = null) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: !!options?.ignoreBorder,
              createQuadrilaterals: true
            });
            this.isTooltipOnly = parameters.data.isTooltipOnly;
          }
          render() {
            const {
              data,
              linkService
            } = this;
            const link = document.createElement("a");
            link.setAttribute("data-element-id", data.id);
            let isBound = false;
            if (data.url) {
              linkService.addLinkAttributes(link, data.url, data.newWindow);
              isBound = true;
            } else if (data.action) {
              this._bindNamedAction(link, data.action, data.overlaidText);
              isBound = true;
            } else if (data.attachment) {
              this.#bindAttachment(link, data.attachment, data.overlaidText, data.attachmentDest);
              isBound = true;
            } else if (data.setOCGState) {
              this.#bindSetOCGState(link, data.setOCGState, data.overlaidText);
              isBound = true;
            } else if (data.dest) {
              this._bindLink(link, data.dest, data.overlaidText);
              isBound = true;
            } else {
              if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
                this._bindJSAction(link, data);
                isBound = true;
              }
              if (data.resetForm) {
                this._bindResetFormAction(link, data.resetForm);
                isBound = true;
              } else if (this.isTooltipOnly && !isBound) {
                this._bindLink(link, "");
                isBound = true;
              }
            }
            this.container.classList.add("linkAnnotation");
            if (isBound) {
              this.contentElement = link;
              this.container.append(link);
            }
            return this.container;
          }
          #setInternalLink() {
            this.container.setAttribute("data-internal-link", "");
          }
          _bindLink(link, destination, overlaidText = "") {
            link.href = this.linkService.getDestinationHash(destination);
            link.onclick = () => {
              if (destination) {
                this.linkService.goToDestination(destination);
              }
              return false;
            };
            if (destination || destination === "") {
              this.#setInternalLink();
            }
            if (overlaidText) {
              link.title = overlaidText;
            }
          }
          _bindNamedAction(link, action, overlaidText = "") {
            link.href = this.linkService.getAnchorUrl("");
            link.onclick = () => {
              this.linkService.executeNamedAction(action);
              return false;
            };
            if (overlaidText) {
              link.title = overlaidText;
            }
            this.#setInternalLink();
          }
          #bindAttachment(link, attachment, overlaidText = "", dest = null) {
            link.href = this.linkService.getAnchorUrl("");
            if (attachment.description) {
              link.title = attachment.description;
            } else if (overlaidText) {
              link.title = overlaidText;
            }
            link.onclick = () => {
              this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);
              return false;
            };
            this.#setInternalLink();
          }
          #bindSetOCGState(link, action, overlaidText = "") {
            link.href = this.linkService.getAnchorUrl("");
            link.onclick = () => {
              this.linkService.executeSetOCGState(action);
              return false;
            };
            if (overlaidText) {
              link.title = overlaidText;
            }
            this.#setInternalLink();
          }
          _bindJSAction(link, data) {
            link.href = this.linkService.getAnchorUrl("");
            const map = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
            for (const name of Object.keys(data.actions)) {
              const jsName = map.get(name);
              if (!jsName) {
                continue;
              }
              link[jsName] = () => {
                this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: data.id,
                    name
                  }
                });
                return false;
              };
            }
            if (data.overlaidText) {
              link.title = data.overlaidText;
            }
            if (!link.onclick) {
              link.onclick = () => false;
            }
            this.#setInternalLink();
          }
          _bindResetFormAction(link, resetForm) {
            const otherClickAction = link.onclick;
            if (!otherClickAction) {
              link.href = this.linkService.getAnchorUrl("");
            }
            this.#setInternalLink();
            if (!this._fieldObjects) {
              warn(`_bindResetFormAction - "resetForm" action not supported, ` + "ensure that the `fieldObjects` parameter is provided.");
              if (!otherClickAction) {
                link.onclick = () => false;
              }
              return;
            }
            link.onclick = () => {
              otherClickAction?.();
              const {
                fields: resetFormFields,
                refs: resetFormRefs,
                include
              } = resetForm;
              const allFields = [];
              if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
                const fieldIds = new Set(resetFormRefs);
                for (const fieldName of resetFormFields) {
                  const fields = this._fieldObjects[fieldName] || [];
                  for (const {
                    id
                  } of fields) {
                    fieldIds.add(id);
                  }
                }
                for (const fields of Object.values(this._fieldObjects)) {
                  for (const field of fields) {
                    if (fieldIds.has(field.id) === include) {
                      allFields.push(field);
                    }
                  }
                }
              } else {
                for (const fields of Object.values(this._fieldObjects)) {
                  allFields.push(...fields);
                }
              }
              const storage = this.annotationStorage;
              const allIds = [];
              for (const field of allFields) {
                const {
                  id
                } = field;
                allIds.push(id);
                switch (field.type) {
                  case "text":
                    {
                      const value = field.defaultValue || "";
                      storage.setValue(id, {
                        value
                      });
                      break;
                    }
                  case "checkbox":
                  case "radiobutton":
                    {
                      const value = field.defaultValue === field.exportValues;
                      storage.setValue(id, {
                        value
                      });
                      break;
                    }
                  case "combobox":
                  case "listbox":
                    {
                      const value = field.defaultValue || "";
                      storage.setValue(id, {
                        value
                      });
                      break;
                    }
                  default:
                    continue;
                }
                const domElement = document.querySelector(`[data-element-id="${id}"]`);
                if (!domElement) {
                  continue;
                } else if (!GetElementsByNameSet.has(domElement)) {
                  warn(`_bindResetFormAction - element not allowed: ${id}`);
                  continue;
                }
                domElement.dispatchEvent(new Event("resetform"));
              }
              if (this.enableScripting) {
                this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: "app",
                    ids: allIds,
                    name: "ResetForm"
                  }
                });
              }
              return false;
            };
          }
        }
        class TextAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: true
            });
          }
          render() {
            this.container.classList.add("textAnnotation");
            const image = document.createElement("img");
            image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
            image.setAttribute("data-l10n-id", "pdfjs-text-annotation-type");
            image.setAttribute("data-l10n-args", JSON.stringify({
              type: this.data.name
            }));
            if (!this.data.popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            }
            this.container.append(image);
            return this.container;
          }
        }
        class WidgetAnnotationElement extends AnnotationElement {
          render() {
            return this.container;
          }
          showElementAndHideCanvas(element) {
            if (this.data.hasOwnCanvas) {
              if (element.previousSibling?.nodeName === "CANVAS") {
                element.previousSibling.hidden = true;
              }
              element.hidden = false;
            }
          }
          _getKeyModifier(event) {
            return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;
          }
          _setEventListener(element, elementData, baseName, eventName, valueGetter) {
            if (baseName.includes("mouse")) {
              element.addEventListener(baseName, event => {
                this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: eventName,
                    value: valueGetter(event),
                    shift: event.shiftKey,
                    modifier: this._getKeyModifier(event)
                  }
                });
              });
            } else {
              element.addEventListener(baseName, event => {
                if (baseName === "blur") {
                  if (!elementData.focused || !event.relatedTarget) {
                    return;
                  }
                  elementData.focused = false;
                } else if (baseName === "focus") {
                  if (elementData.focused) {
                    return;
                  }
                  elementData.focused = true;
                }
                if (!valueGetter) {
                  return;
                }
                this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id: this.data.id,
                    name: eventName,
                    value: valueGetter(event)
                  }
                });
              });
            }
          }
          _setEventListeners(element, elementData, names, getter) {
            for (const [baseName, eventName] of names) {
              if (eventName === "Action" || this.data.actions?.[eventName]) {
                if (eventName === "Focus" || eventName === "Blur") {
                  elementData ||= {
                    focused: false
                  };
                }
                this._setEventListener(element, elementData, baseName, eventName, getter);
                if (eventName === "Focus" && !this.data.actions?.Blur) {
                  this._setEventListener(element, elementData, "blur", "Blur", null);
                } else if (eventName === "Blur" && !this.data.actions?.Focus) {
                  this._setEventListener(element, elementData, "focus", "Focus", null);
                }
              }
            }
          }
          _setBackgroundColor(element) {
            const color = this.data.backgroundColor || null;
            element.style.backgroundColor = color === null ? "transparent" : Util.makeHexColor(color[0], color[1], color[2]);
          }
          _setTextStyle(element) {
            const TEXT_ALIGNMENT = ["left", "center", "right"];
            const {
              fontColor
            } = this.data.defaultAppearanceData;
            const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;
            const style = element.style;
            let computedFontSize;
            const BORDER_SIZE = 2;
            const roundToOneDecimal = x => Math.round(10 * x) / 10;
            if (this.data.multiLine) {
              const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
              const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;
              const lineHeight = height / numberOfLines;
              computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));
            } else {
              const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
              computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));
            }
            style.fontSize = `calc(${computedFontSize}px * var(--total-scale-factor))`;
            style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
            if (this.data.textAlignment !== null) {
              style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
            }
          }
          _setRequired(element, isRequired) {
            if (isRequired) {
              element.setAttribute("required", true);
            } else {
              element.removeAttribute("required");
            }
            element.setAttribute("aria-required", isRequired);
          }
        }
        class TextWidgetAnnotationElement extends WidgetAnnotationElement {
          constructor(parameters) {
            const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
            super(parameters, {
              isRenderable
            });
          }
          setPropertyOnSiblings(base, key, value, keyInStorage) {
            const storage = this.annotationStorage;
            for (const element of this._getElementsByName(base.name, base.id)) {
              if (element.domElement) {
                element.domElement[key] = value;
              }
              storage.setValue(element.id, {
                [keyInStorage]: value
              });
            }
          }
          render() {
            const storage = this.annotationStorage;
            const id = this.data.id;
            this.container.classList.add("textWidgetAnnotation");
            let element = null;
            if (this.renderForms) {
              const storedData = storage.getValue(id, {
                value: this.data.fieldValue
              });
              let textContent = storedData.value || "";
              const maxLen = storage.getValue(id, {
                charLimit: this.data.maxLen
              }).charLimit;
              if (maxLen && textContent.length > maxLen) {
                textContent = textContent.slice(0, maxLen);
              }
              let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join("\n") || null;
              if (fieldFormattedValues && this.data.comb) {
                fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
              }
              const elementData = {
                userValue: textContent,
                formattedValue: fieldFormattedValues,
                lastCommittedValue: null,
                commitKey: 1,
                focused: false
              };
              if (this.data.multiLine) {
                element = document.createElement("textarea");
                element.textContent = fieldFormattedValues ?? textContent;
                if (this.data.doNotScroll) {
                  element.style.overflowY = "hidden";
                }
              } else {
                element = document.createElement("input");
                element.type = this.data.password ? "password" : "text";
                element.setAttribute("value", fieldFormattedValues ?? textContent);
                if (this.data.doNotScroll) {
                  element.style.overflowX = "hidden";
                }
              }
              if (this.data.hasOwnCanvas) {
                element.hidden = true;
              }
              GetElementsByNameSet.add(element);
              this.contentElement = element;
              element.setAttribute("data-element-id", id);
              element.disabled = this.data.readOnly;
              element.name = this.data.fieldName;
              element.tabIndex = 0;
              const {
                datetimeFormat,
                datetimeType,
                timeStep
              } = this.data;
              const hasDateOrTime = !!datetimeType && this.enableScripting;
              if (datetimeFormat) {
                element.title = datetimeFormat;
              }
              this._setRequired(element, this.data.required);
              if (maxLen) {
                element.maxLength = maxLen;
              }
              element.addEventListener("input", event => {
                storage.setValue(id, {
                  value: event.target.value
                });
                this.setPropertyOnSiblings(element, "value", event.target.value, "value");
                elementData.formattedValue = null;
              });
              element.addEventListener("resetform", event => {
                const defaultValue = this.data.defaultFieldValue ?? "";
                element.value = elementData.userValue = defaultValue;
                elementData.formattedValue = null;
              });
              let blurListener = event => {
                const {
                  formattedValue
                } = elementData;
                if (formattedValue !== null && formattedValue !== undefined) {
                  event.target.value = formattedValue;
                }
                event.target.scrollLeft = 0;
              };
              if (this.enableScripting && this.hasJSActions) {
                element.addEventListener("focus", event => {
                  if (elementData.focused) {
                    return;
                  }
                  const {
                    target
                  } = event;
                  if (hasDateOrTime) {
                    target.type = datetimeType;
                    if (timeStep) {
                      target.step = timeStep;
                    }
                  }
                  if (elementData.userValue) {
                    const value = elementData.userValue;
                    if (hasDateOrTime) {
                      if (datetimeType === "time") {
                        const date = new Date(value);
                        const parts = [date.getHours(), date.getMinutes(), date.getSeconds()];
                        target.value = parts.map(v => v.toString().padStart(2, "0")).join(":");
                      } else {
                        target.value = new Date(value - TIMEZONE_OFFSET).toISOString().split(datetimeType === "date" ? "T" : ".", 1)[0];
                      }
                    } else {
                      target.value = value;
                    }
                  }
                  elementData.lastCommittedValue = target.value;
                  elementData.commitKey = 1;
                  if (!this.data.actions?.Focus) {
                    elementData.focused = true;
                  }
                });
                element.addEventListener("updatefromsandbox", jsEvent => {
                  this.showElementAndHideCanvas(jsEvent.target);
                  const actions = {
                    value(event) {
                      elementData.userValue = event.detail.value ?? "";
                      if (!hasDateOrTime) {
                        storage.setValue(id, {
                          value: elementData.userValue.toString()
                        });
                      }
                      event.target.value = elementData.userValue;
                    },
                    formattedValue(event) {
                      const {
                        formattedValue
                      } = event.detail;
                      elementData.formattedValue = formattedValue;
                      if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {
                        event.target.value = formattedValue;
                      }
                      const data = {
                        formattedValue
                      };
                      if (hasDateOrTime) {
                        data.value = formattedValue;
                      }
                      storage.setValue(id, data);
                    },
                    selRange(event) {
                      event.target.setSelectionRange(...event.detail.selRange);
                    },
                    charLimit: event => {
                      const {
                        charLimit
                      } = event.detail;
                      const {
                        target
                      } = event;
                      if (charLimit === 0) {
                        target.removeAttribute("maxLength");
                        return;
                      }
                      target.setAttribute("maxLength", charLimit);
                      let value = elementData.userValue;
                      if (!value || value.length <= charLimit) {
                        return;
                      }
                      value = value.slice(0, charLimit);
                      target.value = elementData.userValue = value;
                      storage.setValue(id, {
                        value
                      });
                      this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                        source: this,
                        detail: {
                          id,
                          name: "Keystroke",
                          value,
                          willCommit: true,
                          commitKey: 1,
                          selStart: target.selectionStart,
                          selEnd: target.selectionEnd
                        }
                      });
                    }
                  };
                  this._dispatchEventFromSandbox(actions, jsEvent);
                });
                element.addEventListener("keydown", event => {
                  elementData.commitKey = 1;
                  let commitKey = -1;
                  if (event.key === "Escape") {
                    commitKey = 0;
                  } else if (event.key === "Enter" && !this.data.multiLine) {
                    commitKey = 2;
                  } else if (event.key === "Tab") {
                    elementData.commitKey = 3;
                  }
                  if (commitKey === -1) {
                    return;
                  }
                  const {
                    value
                  } = event.target;
                  if (elementData.lastCommittedValue === value) {
                    return;
                  }
                  elementData.lastCommittedValue = value;
                  elementData.userValue = value;
                  this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id,
                      name: "Keystroke",
                      value,
                      willCommit: true,
                      commitKey,
                      selStart: event.target.selectionStart,
                      selEnd: event.target.selectionEnd
                    }
                  });
                });
                const _blurListener = blurListener;
                blurListener = null;
                element.addEventListener("blur", event => {
                  if (!elementData.focused || !event.relatedTarget) {
                    return;
                  }
                  if (!this.data.actions?.Blur) {
                    elementData.focused = false;
                  }
                  const {
                    target
                  } = event;
                  let {
                    value
                  } = target;
                  if (hasDateOrTime) {
                    if (value && datetimeType === "time") {
                      const parts = value.split(":").map(v => parseInt(v, 10));
                      value = new Date(2000, 0, 1, parts[0], parts[1], parts[2] || 0).valueOf();
                      target.step = "";
                    } else {
                      if (!value.includes("T")) {
                        value = `${value}T00:00`;
                      }
                      value = new Date(value).valueOf();
                    }
                    target.type = "text";
                  }
                  elementData.userValue = value;
                  if (elementData.lastCommittedValue !== value) {
                    this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id,
                        name: "Keystroke",
                        value,
                        willCommit: true,
                        commitKey: elementData.commitKey,
                        selStart: event.target.selectionStart,
                        selEnd: event.target.selectionEnd
                      }
                    });
                  }
                  _blurListener(event);
                });
                if (this.data.actions?.Keystroke) {
                  element.addEventListener("beforeinput", event => {
                    elementData.lastCommittedValue = null;
                    const {
                      data,
                      target
                    } = event;
                    const {
                      value,
                      selectionStart,
                      selectionEnd
                    } = target;
                    let selStart = selectionStart,
                      selEnd = selectionEnd;
                    switch (event.inputType) {
                      case "deleteWordBackward":
                        {
                          const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                          if (match) {
                            selStart -= match[0].length;
                          }
                          break;
                        }
                      case "deleteWordForward":
                        {
                          const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                          if (match) {
                            selEnd += match[0].length;
                          }
                          break;
                        }
                      case "deleteContentBackward":
                        if (selectionStart === selectionEnd) {
                          selStart -= 1;
                        }
                        break;
                      case "deleteContentForward":
                        if (selectionStart === selectionEnd) {
                          selEnd += 1;
                        }
                        break;
                    }
                    event.preventDefault();
                    this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                      source: this,
                      detail: {
                        id,
                        name: "Keystroke",
                        value,
                        change: data || "",
                        willCommit: false,
                        selStart,
                        selEnd
                      }
                    });
                  });
                }
                this._setEventListeners(element, elementData, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.value);
              }
              if (blurListener) {
                element.addEventListener("blur", blurListener);
              }
              if (this.data.comb) {
                const fieldWidth = this.data.rect[2] - this.data.rect[0];
                const combWidth = fieldWidth / maxLen;
                element.classList.add("comb");
                element.style.letterSpacing = `calc(${combWidth}px * var(--total-scale-factor) - 1ch)`;
              }
            } else {
              element = document.createElement("div");
              element.textContent = this.data.fieldValue;
              element.style.verticalAlign = "middle";
              element.style.display = "table-cell";
              if (this.data.hasOwnCanvas) {
                element.hidden = true;
              }
            }
            this._setTextStyle(element);
            this._setBackgroundColor(element);
            this._setDefaultPropertiesFromJS(element);
            this.container.append(element);
            return this.container;
          }
        }
        class SignatureWidgetAnnotationElement extends WidgetAnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: !!parameters.data.hasOwnCanvas
            });
          }
        }
        class CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: parameters.renderForms
            });
          }
          render() {
            const storage = this.annotationStorage;
            const data = this.data;
            const id = data.id;
            let value = storage.getValue(id, {
              value: data.exportValue === data.fieldValue
            }).value;
            if (typeof value === "string") {
              value = value !== "Off";
              storage.setValue(id, {
                value
              });
            }
            this.container.classList.add("buttonWidgetAnnotation", "checkBox");
            const element = document.createElement("input");
            GetElementsByNameSet.add(element);
            element.setAttribute("data-element-id", id);
            element.disabled = data.readOnly;
            this._setRequired(element, this.data.required);
            element.type = "checkbox";
            element.name = data.fieldName;
            if (value) {
              element.setAttribute("checked", true);
            }
            element.setAttribute("exportValue", data.exportValue);
            element.tabIndex = 0;
            element.addEventListener("change", event => {
              const {
                name,
                checked
              } = event.target;
              for (const checkbox of this._getElementsByName(name, id)) {
                const curChecked = checked && checkbox.exportValue === data.exportValue;
                if (checkbox.domElement) {
                  checkbox.domElement.checked = curChecked;
                }
                storage.setValue(checkbox.id, {
                  value: curChecked
                });
              }
              storage.setValue(id, {
                value: checked
              });
            });
            element.addEventListener("resetform", event => {
              const defaultValue = data.defaultFieldValue || "Off";
              event.target.checked = defaultValue === data.exportValue;
            });
            if (this.enableScripting && this.hasJSActions) {
              element.addEventListener("updatefromsandbox", jsEvent => {
                const actions = {
                  value(event) {
                    event.target.checked = event.detail.value !== "Off";
                    storage.setValue(id, {
                      value: event.target.checked
                    });
                  }
                };
                this._dispatchEventFromSandbox(actions, jsEvent);
              });
              this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
            }
            this._setBackgroundColor(element);
            this._setDefaultPropertiesFromJS(element);
            this.container.append(element);
            return this.container;
          }
        }
        class RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: parameters.renderForms
            });
          }
          render() {
            this.container.classList.add("buttonWidgetAnnotation", "radioButton");
            const storage = this.annotationStorage;
            const data = this.data;
            const id = data.id;
            let value = storage.getValue(id, {
              value: data.fieldValue === data.buttonValue
            }).value;
            if (typeof value === "string") {
              value = value !== data.buttonValue;
              storage.setValue(id, {
                value
              });
            }
            if (value) {
              for (const radio of this._getElementsByName(data.fieldName, id)) {
                storage.setValue(radio.id, {
                  value: false
                });
              }
            }
            const element = document.createElement("input");
            GetElementsByNameSet.add(element);
            element.setAttribute("data-element-id", id);
            element.disabled = data.readOnly;
            this._setRequired(element, this.data.required);
            element.type = "radio";
            element.name = data.fieldName;
            if (value) {
              element.setAttribute("checked", true);
            }
            element.tabIndex = 0;
            element.addEventListener("change", event => {
              const {
                name,
                checked
              } = event.target;
              for (const radio of this._getElementsByName(name, id)) {
                storage.setValue(radio.id, {
                  value: false
                });
              }
              storage.setValue(id, {
                value: checked
              });
            });
            element.addEventListener("resetform", event => {
              const defaultValue = data.defaultFieldValue;
              event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;
            });
            if (this.enableScripting && this.hasJSActions) {
              const pdfButtonValue = data.buttonValue;
              element.addEventListener("updatefromsandbox", jsEvent => {
                const actions = {
                  value: event => {
                    const checked = pdfButtonValue === event.detail.value;
                    for (const radio of this._getElementsByName(event.target.name)) {
                      const curChecked = checked && radio.id === id;
                      if (radio.domElement) {
                        radio.domElement.checked = curChecked;
                      }
                      storage.setValue(radio.id, {
                        value: curChecked
                      });
                    }
                  }
                };
                this._dispatchEventFromSandbox(actions, jsEvent);
              });
              this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], event => event.target.checked);
            }
            this._setBackgroundColor(element);
            this._setDefaultPropertiesFromJS(element);
            this.container.append(element);
            return this.container;
          }
        }
        class PushButtonWidgetAnnotationElement extends LinkAnnotationElement {
          constructor(parameters) {
            super(parameters, {
              ignoreBorder: parameters.data.hasAppearance
            });
          }
          render() {
            const container = super.render();
            container.classList.add("buttonWidgetAnnotation", "pushButton");
            const linkElement = container.lastChild;
            if (this.enableScripting && this.hasJSActions && linkElement) {
              this._setDefaultPropertiesFromJS(linkElement);
              linkElement.addEventListener("updatefromsandbox", jsEvent => {
                this._dispatchEventFromSandbox({}, jsEvent);
              });
            }
            return container;
          }
        }
        class ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: parameters.renderForms
            });
          }
          render() {
            this.container.classList.add("choiceWidgetAnnotation");
            const storage = this.annotationStorage;
            const id = this.data.id;
            const storedData = storage.getValue(id, {
              value: this.data.fieldValue
            });
            const selectElement = document.createElement("select");
            GetElementsByNameSet.add(selectElement);
            selectElement.setAttribute("data-element-id", id);
            selectElement.disabled = this.data.readOnly;
            this._setRequired(selectElement, this.data.required);
            selectElement.name = this.data.fieldName;
            selectElement.tabIndex = 0;
            let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
            if (!this.data.combo) {
              selectElement.size = this.data.options.length;
              if (this.data.multiSelect) {
                selectElement.multiple = true;
              }
            }
            selectElement.addEventListener("resetform", event => {
              const defaultValue = this.data.defaultFieldValue;
              for (const option of selectElement.options) {
                option.selected = option.value === defaultValue;
              }
            });
            for (const option of this.data.options) {
              const optionElement = document.createElement("option");
              optionElement.textContent = option.displayValue;
              optionElement.value = option.exportValue;
              if (storedData.value.includes(option.exportValue)) {
                optionElement.setAttribute("selected", true);
                addAnEmptyEntry = false;
              }
              selectElement.append(optionElement);
            }
            let removeEmptyEntry = null;
            if (addAnEmptyEntry) {
              const noneOptionElement = document.createElement("option");
              noneOptionElement.value = " ";
              noneOptionElement.setAttribute("hidden", true);
              noneOptionElement.setAttribute("selected", true);
              selectElement.prepend(noneOptionElement);
              removeEmptyEntry = () => {
                noneOptionElement.remove();
                selectElement.removeEventListener("input", removeEmptyEntry);
                removeEmptyEntry = null;
              };
              selectElement.addEventListener("input", removeEmptyEntry);
            }
            const getValue = isExport => {
              const name = isExport ? "value" : "textContent";
              const {
                options,
                multiple
              } = selectElement;
              if (!multiple) {
                return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
              }
              return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);
            };
            let selectedValues = getValue(false);
            const getItems = event => {
              const options = event.target.options;
              return Array.prototype.map.call(options, option => ({
                displayValue: option.textContent,
                exportValue: option.value
              }));
            };
            if (this.enableScripting && this.hasJSActions) {
              selectElement.addEventListener("updatefromsandbox", jsEvent => {
                const actions = {
                  value(event) {
                    removeEmptyEntry?.();
                    const value = event.detail.value;
                    const values = new Set(Array.isArray(value) ? value : [value]);
                    for (const option of selectElement.options) {
                      option.selected = values.has(option.value);
                    }
                    storage.setValue(id, {
                      value: getValue(true)
                    });
                    selectedValues = getValue(false);
                  },
                  multipleSelection(event) {
                    selectElement.multiple = true;
                  },
                  remove(event) {
                    const options = selectElement.options;
                    const index = event.detail.remove;
                    options[index].selected = false;
                    selectElement.remove(index);
                    if (options.length > 0) {
                      const i = Array.prototype.findIndex.call(options, option => option.selected);
                      if (i === -1) {
                        options[0].selected = true;
                      }
                    }
                    storage.setValue(id, {
                      value: getValue(true),
                      items: getItems(event)
                    });
                    selectedValues = getValue(false);
                  },
                  clear(event) {
                    while (selectElement.length !== 0) {
                      selectElement.remove(0);
                    }
                    storage.setValue(id, {
                      value: null,
                      items: []
                    });
                    selectedValues = getValue(false);
                  },
                  insert(event) {
                    const {
                      index,
                      displayValue,
                      exportValue
                    } = event.detail.insert;
                    const selectChild = selectElement.children[index];
                    const optionElement = document.createElement("option");
                    optionElement.textContent = displayValue;
                    optionElement.value = exportValue;
                    if (selectChild) {
                      selectChild.before(optionElement);
                    } else {
                      selectElement.append(optionElement);
                    }
                    storage.setValue(id, {
                      value: getValue(true),
                      items: getItems(event)
                    });
                    selectedValues = getValue(false);
                  },
                  items(event) {
                    const {
                      items
                    } = event.detail;
                    while (selectElement.length !== 0) {
                      selectElement.remove(0);
                    }
                    for (const item of items) {
                      const {
                        displayValue,
                        exportValue
                      } = item;
                      const optionElement = document.createElement("option");
                      optionElement.textContent = displayValue;
                      optionElement.value = exportValue;
                      selectElement.append(optionElement);
                    }
                    if (selectElement.options.length > 0) {
                      selectElement.options[0].selected = true;
                    }
                    storage.setValue(id, {
                      value: getValue(true),
                      items: getItems(event)
                    });
                    selectedValues = getValue(false);
                  },
                  indices(event) {
                    const indices = new Set(event.detail.indices);
                    for (const option of event.target.options) {
                      option.selected = indices.has(option.index);
                    }
                    storage.setValue(id, {
                      value: getValue(true)
                    });
                    selectedValues = getValue(false);
                  },
                  editable(event) {
                    event.target.disabled = !event.detail.editable;
                  }
                };
                this._dispatchEventFromSandbox(actions, jsEvent);
              });
              selectElement.addEventListener("input", event => {
                const exportValue = getValue(true);
                const change = getValue(false);
                storage.setValue(id, {
                  value: exportValue
                });
                event.preventDefault();
                this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id,
                    name: "Keystroke",
                    value: selectedValues,
                    change,
                    changeEx: exportValue,
                    willCommit: false,
                    commitKey: 1,
                    keyDown: false
                  }
                });
              });
              this._setEventListeners(selectElement, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], event => event.target.value);
            } else {
              selectElement.addEventListener("input", function (event) {
                storage.setValue(id, {
                  value: getValue(true)
                });
              });
            }
            if (this.data.combo) {
              this._setTextStyle(selectElement);
            } else { }
            this._setBackgroundColor(selectElement);
            this._setDefaultPropertiesFromJS(selectElement);
            this.container.append(selectElement);
            return this.container;
          }
        }
        class PopupAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            const {
              data,
              elements,
              parent
            } = parameters;
            const hasCommentManager = !!parent._commentManager;
            super(parameters, {
              isRenderable: !hasCommentManager && AnnotationElement._hasPopupData(data)
            });
            this.elements = elements;
            if (hasCommentManager && AnnotationElement._hasPopupData(data)) {
              const popup = this.popup = this.#createPopup();
              for (const element of elements) {
                element.popup = popup;
              }
            } else {
              this.popup = null;
            }
          }
          #createPopup() {
            return new PopupElement({
              container: this.container,
              color: this.data.color,
              titleObj: this.data.titleObj,
              modificationDate: this.data.modificationDate || this.data.creationDate,
              contentsObj: this.data.contentsObj,
              richText: this.data.richText,
              rect: this.data.rect,
              parentRect: this.data.parentRect || null,
              parent: this.parent,
              elements: this.elements,
              open: this.data.open,
              commentManager: this.parent._commentManager
            });
          }
          render() {
            const {
              container
            } = this;
            container.classList.add("popupAnnotation");
            container.role = "comment";
            const popup = this.popup = this.#createPopup();
            const elementIds = [];
            for (const element of this.elements) {
              element.popup = popup;
              element.container.ariaHasPopup = "dialog";
              elementIds.push(element.data.id);
              element.addHighlightArea();
            }
            this.container.setAttribute("aria-controls", elementIds.map(id => `${AnnotationPrefix}${id}`).join(","));
            return this.container;
          }
        }
        class PopupElement {
          #commentManager = null;
          #boundKeyDown = this.#keyDown.bind(this);
          #boundHide = this.#hide.bind(this);
          #boundShow = this.#show.bind(this);
          #boundToggle = this.#toggle.bind(this);
          #color = null;
          #container = null;
          #contentsObj = null;
          #dateObj = null;
          #elements = null;
          #parent = null;
          #parentRect = null;
          #pinned = false;
          #popup = null;
          #popupAbortController = null;
          #position = null;
          #commentButton = null;
          #commentButtonPosition = null;
          #popupPosition = null;
          #rect = null;
          #richText = null;
          #titleObj = null;
          #updates = null;
          #wasVisible = false;
          #firstElement = null;
          #commentText = null;
          constructor({
            container,
            color,
            elements,
            titleObj,
            modificationDate,
            contentsObj,
            richText,
            parent,
            rect,
            parentRect,
            open,
            commentManager = null
          }) {
            this.#container = container;
            this.#titleObj = titleObj;
            this.#contentsObj = contentsObj;
            this.#richText = richText;
            this.#parent = parent;
            this.#color = color;
            this.#rect = rect;
            this.#parentRect = parentRect;
            this.#elements = elements;
            this.#commentManager = commentManager;
            this.#firstElement = elements[0];
            this.#dateObj = PDFDateString.toDateObject(modificationDate);
            this.trigger = elements.flatMap(e => e.getElementsToTriggerPopup());
            if (!commentManager) {
              this.#addEventListeners();
              this.#container.hidden = true;
              if (open) {
                this.#toggle();
              }
            }
          }
          #addEventListeners() {
            if (this.#popupAbortController) {
              return;
            }
            this.#popupAbortController = new AbortController();
            const {
              signal
            } = this.#popupAbortController;
            for (const element of this.trigger) {
              element.addEventListener("click", this.#boundToggle, {
                signal
              });
              element.addEventListener("pointerenter", this.#boundShow, {
                signal
              });
              element.addEventListener("pointerleave", this.#boundHide, {
                signal
              });
              element.classList.add("popupTriggerArea");
            }
            for (const element of this.#elements) {
              element.container?.addEventListener("keydown", this.#boundKeyDown, {
                signal
              });
            }
          }
          #setCommentButtonPosition() {
            const element = this.#elements.find(e => e.hasCommentButton);
            if (!element) {
              return;
            }
            this.#commentButtonPosition = element._normalizePoint(element.commentButtonPosition);
          }
          renderCommentButton() {
            if (this.#commentButton) {
              if (!this.#commentButton.parentNode) {
                this.#firstElement.container.after(this.#commentButton);
              }
              return;
            }
            if (!this.#commentButtonPosition) {
              this.#setCommentButtonPosition();
            }
            if (!this.#commentButtonPosition) {
              return;
            }
            const {
              signal
            } = this.#popupAbortController = new AbortController();
            const hasOwnButton = this.#firstElement.hasOwnCommentButton;
            const togglePopup = () => {
              this.#commentManager.toggleCommentPopup(this, true, undefined, !hasOwnButton);
            };
            const showPopup = () => {
              this.#commentManager.toggleCommentPopup(this, false, true, !hasOwnButton);
            };
            const hidePopup = () => {
              this.#commentManager.toggleCommentPopup(this, false, false);
            };
            if (!hasOwnButton) {
              const button = this.#commentButton = document.createElement("button");
              button.className = "annotationCommentButton";
              const parentContainer = this.#firstElement.container;
              button.style.zIndex = parentContainer.style.zIndex + 1;
              button.tabIndex = 0;
              button.ariaHasPopup = "dialog";
              button.ariaControls = "commentPopup";
              button.setAttribute("data-l10n-id", "pdfjs-show-comment-button");
              this.#updateColor();
              this.#updateCommentButtonPosition();
              button.addEventListener("keydown", this.#boundKeyDown, {
                signal
              });
              button.addEventListener("click", togglePopup, {
                signal
              });
              button.addEventListener("pointerenter", showPopup, {
                signal
              });
              button.addEventListener("pointerleave", hidePopup, {
                signal
              });
              parentContainer.after(button);
            } else {
              this.#commentButton = this.#firstElement.container;
              for (const element of this.trigger) {
                element.ariaHasPopup = "dialog";
                element.ariaControls = "commentPopup";
                element.addEventListener("keydown", this.#boundKeyDown, {
                  signal
                });
                element.addEventListener("click", togglePopup, {
                  signal
                });
                element.addEventListener("pointerenter", showPopup, {
                  signal
                });
                element.addEventListener("pointerleave", hidePopup, {
                  signal
                });
                element.classList.add("popupTriggerArea");
              }
            }
          }
          #updateCommentButtonPosition() {
            if (this.#firstElement.extraPopupElement && !this.#firstElement.editor) {
              return;
            }
            if (!this.#commentButton) {
              this.renderCommentButton();
            }
            const [x, y] = this.#commentButtonPosition;
            const {
              style
            } = this.#commentButton;
            style.left = `calc(${x}%)`;
            style.top = `calc(${y}% - var(--comment-button-dim))`;
          }
          #updateColor() {
            if (this.#firstElement.extraPopupElement) {
              return;
            }
            if (!this.#commentButton) {
              this.renderCommentButton();
            }
            this.#commentButton.style.backgroundColor = this.commentButtonColor || "";
          }
          get commentButtonColor() {
            const {
              color,
              opacity
            } = this.#firstElement.commentData;
            if (!color) {
              return null;
            }
            return this.#parent._commentManager.makeCommentColor(color, opacity);
          }
          focusCommentButton() {
            setTimeout(() => {
              this.#commentButton?.focus();
            }, 0);
          }
          getData() {
            const {
              richText,
              color,
              opacity,
              creationDate,
              modificationDate
            } = this.#firstElement.commentData;
            return {
              contentsObj: {
                str: this.comment
              },
              richText,
              color,
              opacity,
              creationDate,
              modificationDate
            };
          }
          get elementBeforePopup() {
            return this.#commentButton;
          }
          get comment() {
            this.#commentText ||= this.#firstElement.commentText;
            return this.#commentText;
          }
          set comment(text) {
            if (text === this.comment) {
              return;
            }
            this.#firstElement.commentText = this.#commentText = text;
          }
          focus() {
            this.#firstElement.container?.focus();
          }
          get parentBoundingClientRect() {
            return this.#firstElement.layer.getBoundingClientRect();
          }
          setCommentButtonStates({
            selected,
            hasPopup
          }) {
            if (!this.#commentButton) {
              return;
            }
            this.#commentButton.classList.toggle("selected", selected);
            this.#commentButton.ariaExpanded = hasPopup;
          }
          setSelectedCommentButton(selected) {
            this.#commentButton.classList.toggle("selected", selected);
          }
          get commentPopupPosition() {
            if (this.#popupPosition) {
              return this.#popupPosition;
            }
            const {
              x,
              y,
              height
            } = this.#commentButton.getBoundingClientRect();
            const {
              x: parentX,
              y: parentY,
              width: parentWidth,
              height: parentHeight
            } = this.#firstElement.layer.getBoundingClientRect();
            return [(x - parentX) / parentWidth, (y + height - parentY) / parentHeight];
          }
          set commentPopupPosition(pos) {
            this.#popupPosition = pos;
          }
          hasDefaultPopupPosition() {
            return this.#popupPosition === null;
          }
          get commentButtonPosition() {
            return this.#commentButtonPosition;
          }
          get commentButtonWidth() {
            return this.#commentButton.getBoundingClientRect().width / this.parentBoundingClientRect.width;
          }
          editComment(options) {
            const [posX, posY] = this.#popupPosition || this.commentButtonPosition.map(x => x / 100);
            const parentDimensions = this.parentBoundingClientRect;
            const {
              x: parentX,
              y: parentY,
              width: parentWidth,
              height: parentHeight
            } = parentDimensions;
            this.#commentManager.showDialog(null, this, parentX + posX * parentWidth, parentY + posY * parentHeight, {
              ...options,
              parentDimensions
            });
          }
          render() {
            if (this.#popup) {
              return;
            }
            const popup = this.#popup = document.createElement("div");
            popup.className = "popup";
            if (this.#color) {
              const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);
              popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
            }
            const header = document.createElement("span");
            header.className = "header";
            if (this.#titleObj?.str) {
              const title = document.createElement("span");
              title.className = "title";
              header.append(title);
              ({
                dir: title.dir,
                str: title.textContent
              } = this.#titleObj);
            }
            popup.append(header);
            if (this.#dateObj) {
              const modificationDate = document.createElement("time");
              modificationDate.className = "popupDate";
              modificationDate.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string");
              modificationDate.setAttribute("data-l10n-args", JSON.stringify({
                dateObj: this.#dateObj.valueOf()
              }));
              modificationDate.dateTime = this.#dateObj.toISOString();
              header.append(modificationDate);
            }
            renderRichText({
              html: this.#html || this.#contentsObj.str,
              dir: this.#contentsObj?.dir,
              className: "popupContent"
            }, popup);
            this.#container.append(popup);
          }
          get #html() {
            const richText = this.#richText;
            const contentsObj = this.#contentsObj;
            if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {
              return this.#richText.html || null;
            }
            return null;
          }
          get #fontSize() {
            return this.#html?.attributes?.style?.fontSize || 0;
          }
          get #fontColor() {
            return this.#html?.attributes?.style?.color || null;
          }
          #makePopupContent(text) {
            const popupLines = [];
            const popupContent = {
              str: text,
              html: {
                name: "div",
                attributes: {
                  dir: "auto"
                },
                children: [{
                  name: "p",
                  children: popupLines
                }]
              }
            };
            const lineAttributes = {
              style: {
                color: this.#fontColor,
                fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--total-scale-factor))` : ""
              }
            };
            for (const line of text.split("\n")) {
              popupLines.push({
                name: "span",
                value: line,
                attributes: lineAttributes
              });
            }
            return popupContent;
          }
          #keyDown(event) {
            if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
              return;
            }
            if (event.key === "Enter" || event.key === "Escape" && this.#pinned) {
              this.#toggle();
            }
          }
          updateEdited({
            rect,
            popup,
            deleted
          }) {
            if (this.#commentManager) {
              if (deleted) {
                this.remove();
                this.#commentText = null;
              } else if (popup) {
                if (popup.deleted) {
                  this.remove();
                } else {
                  this.#updateColor();
                  this.#commentText = popup.text;
                }
              }
              if (rect) {
                this.#commentButtonPosition = null;
                this.#setCommentButtonPosition();
                this.#updateCommentButtonPosition();
              }
              return;
            }
            if (deleted || popup?.deleted) {
              this.remove();
              return;
            }
            this.#addEventListeners();
            this.#updates ||= {
              contentsObj: this.#contentsObj,
              richText: this.#richText
            };
            if (rect) {
              this.#position = null;
            }
            if (popup && popup.text) {
              this.#richText = this.#makePopupContent(popup.text);
              this.#dateObj = PDFDateString.toDateObject(popup.date);
              this.#contentsObj = null;
            }
            this.#popup?.remove();
            this.#popup = null;
          }
          resetEdited() {
            if (!this.#updates) {
              return;
            }
            ({
              contentsObj: this.#contentsObj,
              richText: this.#richText
            } = this.#updates);
            this.#updates = null;
            this.#popup?.remove();
            this.#popup = null;
            this.#position = null;
          }
          remove() {
            this.#popupAbortController?.abort();
            this.#popupAbortController = null;
            this.#popup?.remove();
            this.#popup = null;
            this.#wasVisible = false;
            this.#pinned = false;
            this.#commentButton?.remove();
            this.#commentButton = null;
            if (this.trigger) {
              for (const element of this.trigger) {
                element.classList.remove("popupTriggerArea");
              }
            }
          }
          #setPosition() {
            if (this.#position !== null) {
              return;
            }
            const {
              page: {
                view
              },
              viewport: {
                rawDims: {
                  pageWidth,
                  pageHeight,
                  pageX,
                  pageY
                }
              }
            } = this.#parent;
            let useParentRect = !!this.#parentRect;
            let rect = useParentRect ? this.#parentRect : this.#rect;
            for (const element of this.#elements) {
              if (!rect || Util.intersect(element.data.rect, rect) !== null) {
                rect = element.data.rect;
                useParentRect = true;
                break;
              }
            }
            const normalizedRect = Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);
            const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
            const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
            const popupLeft = normalizedRect[0] + parentWidth;
            const popupTop = normalizedRect[1];
            this.#position = [100 * (popupLeft - pageX) / pageWidth, 100 * (popupTop - pageY) / pageHeight];
            const {
              style
            } = this.#container;
            style.left = `${this.#position[0]}%`;
            style.top = `${this.#position[1]}%`;
          }
          #toggle() {
            if (this.#commentManager) {
              this.#commentManager.toggleCommentPopup(this, false);
              return;
            }
            this.#pinned = !this.#pinned;
            if (this.#pinned) {
              this.#show();
              this.#container.addEventListener("click", this.#boundToggle);
              this.#container.addEventListener("keydown", this.#boundKeyDown);
            } else {
              this.#hide();
              this.#container.removeEventListener("click", this.#boundToggle);
              this.#container.removeEventListener("keydown", this.#boundKeyDown);
            }
          }
          #show() {
            if (!this.#popup) {
              this.render();
            }
            if (!this.isVisible) {
              this.#setPosition();
              this.#container.hidden = false;
              this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;
            } else if (this.#pinned) {
              this.#container.classList.add("focused");
            }
          }
          #hide() {
            this.#container.classList.remove("focused");
            if (this.#pinned || !this.isVisible) {
              return;
            }
            this.#container.hidden = true;
            this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;
          }
          forceHide() {
            this.#wasVisible = this.isVisible;
            if (!this.#wasVisible) {
              return;
            }
            this.#container.hidden = true;
          }
          maybeShow() {
            if (this.#commentManager) {
              return;
            }
            this.#addEventListeners();
            if (!this.#wasVisible) {
              return;
            }
            if (!this.#popup) {
              this.#show();
            }
            this.#wasVisible = false;
            this.#container.hidden = false;
          }
          get isVisible() {
            if (this.#commentManager) {
              return false;
            }
            return this.#container.hidden === false;
          }
        }
        class FreeTextAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: true
            });
            this.textContent = parameters.data.textContent;
            this.textPosition = parameters.data.textPosition;
            this.annotationEditorType = AnnotationEditorType.FREETEXT;
          }
          render() {
            this.container.classList.add("freeTextAnnotation");
            if (this.textContent) {
              const content = this.contentElement = document.createElement("div");
              content.classList.add("annotationTextContent");
              content.setAttribute("role", "comment");
              for (const line of this.textContent) {
                const lineSpan = document.createElement("span");
                lineSpan.textContent = line;
                content.append(lineSpan);
              }
              this.container.append(content);
            }
            if (!this.data.popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            }
            this._editOnDoubleClick();
            return this.container;
          }
        }
        class LineAnnotationElement extends AnnotationElement {
          #line = null;
          constructor(parameters) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: true
            });
          }
          render() {
            this.container.classList.add("lineAnnotation");
            const {
              data,
              width,
              height
            } = this;
            const svg = this.svgFactory.create(width, height, true);
            const line = this.#line = this.svgFactory.createElement("svg:line");
            line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
            line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
            line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
            line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
            line.setAttribute("stroke-width", data.borderStyle.width || 1);
            line.setAttribute("stroke", "transparent");
            line.setAttribute("fill", "transparent");
            svg.append(line);
            this.container.append(svg);
            if (!data.popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            }
            return this.container;
          }
          getElementsToTriggerPopup() {
            return this.#line;
          }
          addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }
        class SquareAnnotationElement extends AnnotationElement {
          #square = null;
          constructor(parameters) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: true
            });
          }
          render() {
            this.container.classList.add("squareAnnotation");
            const {
              data,
              width,
              height
            } = this;
            const svg = this.svgFactory.create(width, height, true);
            const borderWidth = data.borderStyle.width;
            const square = this.#square = this.svgFactory.createElement("svg:rect");
            square.setAttribute("x", borderWidth / 2);
            square.setAttribute("y", borderWidth / 2);
            square.setAttribute("width", width - borderWidth);
            square.setAttribute("height", height - borderWidth);
            square.setAttribute("stroke-width", borderWidth || 1);
            square.setAttribute("stroke", "transparent");
            square.setAttribute("fill", "transparent");
            svg.append(square);
            this.container.append(svg);
            if (!data.popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            }
            return this.container;
          }
          getElementsToTriggerPopup() {
            return this.#square;
          }
          addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }
        class CircleAnnotationElement extends AnnotationElement {
          #circle = null;
          constructor(parameters) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: true
            });
          }
          render() {
            this.container.classList.add("circleAnnotation");
            const {
              data,
              width,
              height
            } = this;
            const svg = this.svgFactory.create(width, height, true);
            const borderWidth = data.borderStyle.width;
            const circle = this.#circle = this.svgFactory.createElement("svg:ellipse");
            circle.setAttribute("cx", width / 2);
            circle.setAttribute("cy", height / 2);
            circle.setAttribute("rx", width / 2 - borderWidth / 2);
            circle.setAttribute("ry", height / 2 - borderWidth / 2);
            circle.setAttribute("stroke-width", borderWidth || 1);
            circle.setAttribute("stroke", "transparent");
            circle.setAttribute("fill", "transparent");
            svg.append(circle);
            this.container.append(svg);
            if (!data.popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            }
            return this.container;
          }
          getElementsToTriggerPopup() {
            return this.#circle;
          }
          addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }
        class PolylineAnnotationElement extends AnnotationElement {
          #polyline = null;
          constructor(parameters) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: true
            });
            this.containerClassName = "polylineAnnotation";
            this.svgElementName = "svg:polyline";
          }
          render() {
            this.container.classList.add(this.containerClassName);
            const {
              data: {
                rect,
                vertices,
                borderStyle,
                popupRef
              },
              width,
              height
            } = this;
            if (!vertices) {
              return this.container;
            }
            const svg = this.svgFactory.create(width, height, true);
            let points = [];
            for (let i = 0, ii = vertices.length; i < ii; i += 2) {
              const x = vertices[i] - rect[0];
              const y = rect[3] - vertices[i + 1];
              points.push(`${x},${y}`);
            }
            points = points.join(" ");
            const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);
            polyline.setAttribute("points", points);
            polyline.setAttribute("stroke-width", borderStyle.width || 1);
            polyline.setAttribute("stroke", "transparent");
            polyline.setAttribute("fill", "transparent");
            svg.append(polyline);
            this.container.append(svg);
            if (!popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            }
            return this.container;
          }
          getElementsToTriggerPopup() {
            return this.#polyline;
          }
          addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }
        class PolygonAnnotationElement extends PolylineAnnotationElement {
          constructor(parameters) {
            super(parameters);
            this.containerClassName = "polygonAnnotation";
            this.svgElementName = "svg:polygon";
          }
        }
        class CaretAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: true
            });
          }
          render() {
            this.container.classList.add("caretAnnotation");
            if (!this.data.popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            }
            return this.container;
          }
        }
        class InkAnnotationElement extends AnnotationElement {
          #polylinesGroupElement = null;
          #polylines = [];
          constructor(parameters) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: true
            });
            this.containerClassName = "inkAnnotation";
            this.svgElementName = "svg:polyline";
            this.annotationEditorType = this.data.it === "InkHighlight" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;
          }
          #getTransform(rotation, rect) {
            switch (rotation) {
              case 90:
                return {
                  transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,
                  width: rect[3] - rect[1],
                  height: rect[2] - rect[0]
                };
              case 180:
                return {
                  transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,
                  width: rect[2] - rect[0],
                  height: rect[3] - rect[1]
                };
              case 270:
                return {
                  transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,
                  width: rect[3] - rect[1],
                  height: rect[2] - rect[0]
                };
              default:
                return {
                  transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,
                  width: rect[2] - rect[0],
                  height: rect[3] - rect[1]
                };
            }
          }
          render() {
            this.container.classList.add(this.containerClassName);
            const {
              data: {
                rect,
                rotation,
                inkLists,
                borderStyle,
                popupRef
              }
            } = this;
            const {
              transform,
              width,
              height
            } = this.#getTransform(rotation, rect);
            const svg = this.svgFactory.create(width, height, true);
            const g = this.#polylinesGroupElement = this.svgFactory.createElement("svg:g");
            svg.append(g);
            g.setAttribute("stroke-width", borderStyle.width || 1);
            g.setAttribute("stroke-linecap", "round");
            g.setAttribute("stroke-linejoin", "round");
            g.setAttribute("stroke-miterlimit", 10);
            g.setAttribute("stroke", "transparent");
            g.setAttribute("fill", "transparent");
            g.setAttribute("transform", transform);
            for (let i = 0, ii = inkLists.length; i < ii; i++) {
              const polyline = this.svgFactory.createElement(this.svgElementName);
              this.#polylines.push(polyline);
              polyline.setAttribute("points", inkLists[i].join(","));
              g.append(polyline);
            }
            if (!popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            }
            this.container.append(svg);
            this._editOnDoubleClick();
            return this.container;
          }
          updateEdited(params) {
            super.updateEdited(params);
            const {
              thickness,
              points,
              rect
            } = params;
            const g = this.#polylinesGroupElement;
            if (thickness >= 0) {
              g.setAttribute("stroke-width", thickness || 1);
            }
            if (points) {
              for (let i = 0, ii = this.#polylines.length; i < ii; i++) {
                this.#polylines[i].setAttribute("points", points[i].join(","));
              }
            }
            if (rect) {
              const {
                transform,
                width,
                height
              } = this.#getTransform(this.data.rotation, rect);
              const root = g.parentElement;
              root.setAttribute("viewBox", `0 0 ${width} ${height}`);
              g.setAttribute("transform", transform);
            }
          }
          getElementsToTriggerPopup() {
            return this.#polylines;
          }
          addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
        }
        class HighlightAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: true,
              createQuadrilaterals: true
            });
            this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;
          }
          render() {
            const {
              data: {
                overlaidText,
                popupRef
              }
            } = this;
            if (!popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            }
            this.container.classList.add("highlightAnnotation");
            this._editOnDoubleClick();
            if (overlaidText) {
              const mark = document.createElement("mark");
              mark.classList.add("overlaidText");
              mark.textContent = overlaidText;
              this.container.append(mark);
            }
            return this.container;
          }
        }
        class UnderlineAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: true,
              createQuadrilaterals: true
            });
          }
          render() {
            const {
              data: {
                overlaidText,
                popupRef
              }
            } = this;
            if (!popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            }
            this.container.classList.add("underlineAnnotation");
            if (overlaidText) {
              const underline = document.createElement("u");
              underline.classList.add("overlaidText");
              underline.textContent = overlaidText;
              this.container.append(underline);
            }
            return this.container;
          }
        }
        class SquigglyAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: true,
              createQuadrilaterals: true
            });
          }
          render() {
            const {
              data: {
                overlaidText,
                popupRef
              }
            } = this;
            if (!popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            }
            this.container.classList.add("squigglyAnnotation");
            if (overlaidText) {
              const underline = document.createElement("u");
              underline.classList.add("overlaidText");
              underline.textContent = overlaidText;
              this.container.append(underline);
            }
            return this.container;
          }
        }
        class StrikeOutAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: true,
              createQuadrilaterals: true
            });
          }
          render() {
            const {
              data: {
                overlaidText,
                popupRef
              }
            } = this;
            if (!popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            }
            this.container.classList.add("strikeoutAnnotation");
            if (overlaidText) {
              const strikeout = document.createElement("s");
              strikeout.classList.add("overlaidText");
              strikeout.textContent = overlaidText;
              this.container.append(strikeout);
            }
            return this.container;
          }
        }
        class StampAnnotationElement extends AnnotationElement {
          constructor(parameters) {
            super(parameters, {
              isRenderable: true,
              ignoreBorder: true
            });
            this.annotationEditorType = AnnotationEditorType.STAMP;
          }
          render() {
            this.container.classList.add("stampAnnotation");
            this.container.setAttribute("role", "img");
            if (!this.data.popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            }
            this._editOnDoubleClick();
            return this.container;
          }
        }
        class FileAttachmentAnnotationElement extends AnnotationElement {
          #trigger = null;
          constructor(parameters) {
            super(parameters, {
              isRenderable: true
            });
            const {
              file
            } = this.data;
            this.filename = file.filename;
            this.content = file.content;
            this.linkService.eventBus?.dispatch("fileattachmentannotation", {
              source: this,
              ...file
            });
          }
          render() {
            this.container.classList.add("fileAttachmentAnnotation");
            const {
              container,
              data
            } = this;
            let trigger;
            if (data.hasAppearance || data.fillAlpha === 0) {
              trigger = document.createElement("div");
            } else {
              trigger = document.createElement("img");
              trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? "paperclip" : "pushpin"}.svg`;
              if (data.fillAlpha && data.fillAlpha < 1) {
                trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;
              }
            }
            trigger.addEventListener("dblclick", this.#download.bind(this));
            this.#trigger = trigger;
            const {
              isMac
            } = util_FeatureTest.platform;
            container.addEventListener("keydown", evt => {
              if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
                this.#download();
              }
            });
            if (!data.popupRef && this.hasPopupData) {
              this.hasOwnCommentButton = true;
              this._createPopup();
            } else {
              trigger.classList.add("popupTriggerArea");
            }
            container.append(trigger);
            return container;
          }
          getElementsToTriggerPopup() {
            return this.#trigger;
          }
          addHighlightArea() {
            this.container.classList.add("highlightArea");
          }
          #download() {
            this.downloadManager?.openOrDownloadData(this.content, this.filename);
          }
        }
        class AnnotationLayer {
          #accessibilityManager = null;
          #annotationCanvasMap = null;
          #annotationStorage = null;
          #editableAnnotations = new Map();
          #structTreeLayer = null;
          #linkService = null;
          #elements = [];
          #hasAriaAttributesFromStructTree = false;
          constructor({
            div,
            accessibilityManager,
            annotationCanvasMap,
            annotationEditorUIManager,
            page,
            viewport,
            structTreeLayer,
            commentManager,
            linkService,
            annotationStorage
          }) {
            this.div = div;
            this.#accessibilityManager = accessibilityManager;
            this.#annotationCanvasMap = annotationCanvasMap;
            this.#structTreeLayer = structTreeLayer || null;
            this.#linkService = linkService || null;
            this.#annotationStorage = annotationStorage || new AnnotationStorage();
            this.page = page;
            this.viewport = viewport;
            this.zIndex = 0;
            this._annotationEditorUIManager = annotationEditorUIManager;
            this._commentManager = commentManager || null;
          }
          hasEditableAnnotations() {
            return this.#editableAnnotations.size > 0;
          }
          async render(params) {
            const {
              annotations
            } = params;
            const layer = this.div;
            setLayerDimensions(layer, this.viewport);
            const popupToElements = new Map();
            const popupAnnotations = [];
            const elementParams = {
              data: null,
              layer,
              linkService: this.#linkService,
              downloadManager: params.downloadManager,
              imageResourcesPath: params.imageResourcesPath || "",
              renderForms: params.renderForms !== false,
              svgFactory: new DOMSVGFactory(),
              annotationStorage: this.#annotationStorage,
              enableComment: params.enableComment === true,
              enableScripting: params.enableScripting === true,
              hasJSActions: params.hasJSActions,
              fieldObjects: params.fieldObjects,
              parent: this,
              elements: null
            };
            for (const data of annotations) {
              if (data.noHTML) {
                continue;
              }
              const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;
              if (!isPopupAnnotation) {
                if (data.rect[2] === data.rect[0] || data.rect[3] === data.rect[1]) {
                  continue;
                }
              } else {
                const elements = popupToElements.get(data.id);
                if (!elements) {
                  continue;
                }
                if (!this._commentManager) {
                  popupAnnotations.push(data);
                  continue;
                }
                elementParams.elements = elements;
              }
              elementParams.data = data;
              const element = AnnotationElementFactory.create(elementParams);
              if (!element.isRenderable) {
                continue;
              }
              if (!isPopupAnnotation) {
                this.#elements.push(element);
                if (data.popupRef) {
                  const elements = popupToElements.get(data.popupRef);
                  if (!elements) {
                    popupToElements.set(data.popupRef, [element]);
                  } else {
                    elements.push(element);
                  }
                }
              }
              const rendered = element.render();
              if (data.hidden) {
                rendered.style.visibility = "hidden";
              }
              if (element._isEditable) {
                this.#editableAnnotations.set(element.data.id, element);
                this._annotationEditorUIManager?.renderAnnotationElement(element);
              }
            }
            await this.#addElementsToDOM();
            for (const data of popupAnnotations) {
              const elements = elementParams.elements = popupToElements.get(data.id);
              elementParams.data = data;
              const element = AnnotationElementFactory.create(elementParams);
              if (!element.isRenderable) {
                continue;
              }
              const rendered = element.render();
              element.contentElement.id = `${AnnotationPrefix}${data.id}`;
              if (data.hidden) {
                rendered.style.visibility = "hidden";
              }
              elements.at(-1).container.after(rendered);
            }
            this.#setAnnotationCanvasMap();
          }
          async #addElementsToDOM() {
            if (this.#elements.length === 0) {
              return;
            }
            this.div.replaceChildren();
            const promises = [];
            if (!this.#hasAriaAttributesFromStructTree) {
              this.#hasAriaAttributesFromStructTree = true;
              for (const {
                contentElement,
                data: {
                  id
                }
              } of this.#elements) {
                const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;
                promises.push(this.#structTreeLayer?.getAriaAttributes(annotationId).then(ariaAttributes => {
                  if (ariaAttributes) {
                    for (const [key, value] of ariaAttributes) {
                      contentElement.setAttribute(key, value);
                    }
                  }
                }));
              }
            }
            this.#elements.sort(({
              data: {
                rect: [a0, a1, a2, a3]
              }
            }, {
              data: {
                rect: [b0, b1, b2, b3]
              }
            }) => {
              if (a0 === a2 && a1 === a3) {
                return +1;
              }
              if (b0 === b2 && b1 === b3) {
                return -1;
              }
              const top1 = a3;
              const bot1 = a1;
              const mid1 = (a1 + a3) / 2;
              const top2 = b3;
              const bot2 = b1;
              const mid2 = (b1 + b3) / 2;
              if (mid1 >= top2 && mid2 <= bot1) {
                return -1;
              }
              if (mid2 >= top1 && mid1 <= bot2) {
                return +1;
              }
              const centerX1 = (a0 + a2) / 2;
              const centerX2 = (b0 + b2) / 2;
              return centerX1 - centerX2;
            });
            const fragment = document.createDocumentFragment();
            for (const element of this.#elements) {
              fragment.append(element.container);
              if (this._commentManager) {
                (element.extraPopupElement?.popup || element.popup)?.renderCommentButton();
              } else if (element.extraPopupElement) {
                fragment.append(element.extraPopupElement.render());
              }
            }
            this.div.append(fragment);
            await Promise.all(promises);
            if (this.#accessibilityManager) {
              for (const element of this.#elements) {
                this.#accessibilityManager.addPointerInTextLayer(element.contentElement, false);
              }
            }
          }
          async addLinkAnnotations(annotations) {
            const elementParams = {
              data: null,
              layer: this.div,
              linkService: this.#linkService,
              svgFactory: new DOMSVGFactory(),
              parent: this
            };
            for (const data of annotations) {
              data.borderStyle ||= AnnotationLayer._defaultBorderStyle;
              elementParams.data = data;
              const element = AnnotationElementFactory.create(elementParams);
              if (!element.isRenderable) {
                continue;
              }
              element.render();
              element.contentElement.id = `${AnnotationPrefix}${data.id}`;
              this.#elements.push(element);
            }
            await this.#addElementsToDOM();
          }
          update({
            viewport
          }) {
            const layer = this.div;
            this.viewport = viewport;
            setLayerDimensions(layer, {
              rotation: viewport.rotation
            });
            this.#setAnnotationCanvasMap();
            layer.hidden = false;
          }
          #setAnnotationCanvasMap() {
            if (!this.#annotationCanvasMap) {
              return;
            }
            const layer = this.div;
            for (const [id, canvas] of this.#annotationCanvasMap) {
              const element = layer.querySelector(`[data-annotation-id="${id}"]`);
              if (!element) {
                continue;
              }
              canvas.className = "annotationContent";
              const {
                firstChild
              } = element;
              if (!firstChild) {
                element.append(canvas);
              } else if (firstChild.nodeName === "CANVAS") {
                firstChild.replaceWith(canvas);
              } else if (!firstChild.classList.contains("annotationContent")) {
                firstChild.before(canvas);
              } else {
                firstChild.after(canvas);
              }
              const editableAnnotation = this.#editableAnnotations.get(id);
              if (!editableAnnotation) {
                continue;
              }
              if (editableAnnotation._hasNoCanvas) {
                this._annotationEditorUIManager?.setMissingCanvas(id, element.id, canvas);
                editableAnnotation._hasNoCanvas = false;
              } else {
                editableAnnotation.canvas = canvas;
              }
            }
            this.#annotationCanvasMap.clear();
          }
          getEditableAnnotations() {
            return Array.from(this.#editableAnnotations.values());
          }
          getEditableAnnotation(id) {
            return this.#editableAnnotations.get(id);
          }
          addFakeAnnotation(editor) {
            const {
              div
            } = this;
            const {
              id,
              rotation
            } = editor;
            const element = new EditorAnnotationElement({
              data: {
                id,
                rect: editor.getPDFRect(),
                rotation
              },
              editor,
              layer: div,
              parent: this,
              enableComment: !!this._commentManager,
              linkService: this.#linkService,
              annotationStorage: this.#annotationStorage
            });
            element.render();
            element.contentElement.id = `${AnnotationPrefix}${id}`;
            element.createOrUpdatePopup();
            this.#elements.push(element);
            return element;
          }
          removeAnnotation(id) {
            const index = this.#elements.findIndex(el => el.data.id === id);
            if (index < 0) {
              return;
            }
            const [element] = this.#elements.splice(index, 1);
            this.#accessibilityManager?.removePointerInTextLayer(element.contentElement);
          }
          updateFakeAnnotations(editors) {
            if (editors.length === 0) {
              return;
            }
            for (const editor of editors) {
              editor.updateFakeAnnotationElement(this);
            }
            this.#addElementsToDOM();
          }
          togglePointerEvents(enabled = false) {
            this.div.classList.toggle("disabled", !enabled);
          }
          static get _defaultBorderStyle() {
            return shadow(this, "_defaultBorderStyle", Object.freeze({
              width: 1,
              rawWidth: 1,
              style: AnnotationBorderStyleType.SOLID,
              dashArray: [3],
              horizontalCornerRadius: 0,
              verticalCornerRadius: 0
            }));
          }
        }

        ;// ./src/display/editor/freetext.js





        const EOL_PATTERN = /\r\n?|\n/g;
        class FreeTextEditor extends AnnotationEditor {
          #content = "";
          #editorDivId = `${this.id}-editor`;
          #editModeAC = null;
          #fontSize;
          _colorPicker = null;
          static _freeTextDefaultContent = "";
          static _internalPadding = 0;
          static _defaultColor = null;
          static _defaultFontSize = 10;
          static get _keyboardManager() {
            const proto = FreeTextEditor.prototype;
            const arrowChecker = self => self.isEmpty();
            const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
            const big = AnnotationEditorUIManager.TRANSLATE_BIG;
            return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], proto.commitOrRemove, {
              bubbles: true
            }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], proto.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], proto._translateEmpty, {
              args: [-small, 0],
              checker: arrowChecker
            }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto._translateEmpty, {
              args: [-big, 0],
              checker: arrowChecker
            }], [["ArrowRight", "mac+ArrowRight"], proto._translateEmpty, {
              args: [small, 0],
              checker: arrowChecker
            }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto._translateEmpty, {
              args: [big, 0],
              checker: arrowChecker
            }], [["ArrowUp", "mac+ArrowUp"], proto._translateEmpty, {
              args: [0, -small],
              checker: arrowChecker
            }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto._translateEmpty, {
              args: [0, -big],
              checker: arrowChecker
            }], [["ArrowDown", "mac+ArrowDown"], proto._translateEmpty, {
              args: [0, small],
              checker: arrowChecker
            }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto._translateEmpty, {
              args: [0, big],
              checker: arrowChecker
            }]]));
          }
          static _type = "freetext";
          static _editorType = AnnotationEditorType.FREETEXT;
          constructor(params) {
            super({
              ...params,
              name: "freeTextEditor"
            });
            this.color = params.color || FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;
            this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;
            if (!this.annotationElementId) {
              this._uiManager.a11yAlert("pdfjs-editor-freetext-added-alert");
            }
            this.canAddComment = false;
          }
          static initialize(l10n, uiManager) {
            AnnotationEditor.initialize(l10n, uiManager);
            const style = getComputedStyle(document.documentElement);
            this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
          }
          static updateDefaultParams(type, value) {
            switch (type) {
              case AnnotationEditorParamsType.FREETEXT_SIZE:
                FreeTextEditor._defaultFontSize = value;
                break;
              case AnnotationEditorParamsType.FREETEXT_COLOR:
                FreeTextEditor._defaultColor = value;
                break;
            }
          }
          updateParams(type, value) {
            switch (type) {
              case AnnotationEditorParamsType.FREETEXT_SIZE:
                this.#updateFontSize(value);
                break;
              case AnnotationEditorParamsType.FREETEXT_COLOR:
                this.#updateColor(value);
                break;
            }
          }
          static get defaultPropertiesToUpdate() {
            return [[AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];
          }
          get propertiesToUpdate() {
            return [[AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, this.color]];
          }
          get toolbarButtons() {
            this._colorPicker ||= new BasicColorPicker(this);
            return [["colorPicker", this._colorPicker]];
          }
          get colorType() {
            return AnnotationEditorParamsType.FREETEXT_COLOR;
          }
          #updateFontSize(fontSize) {
            const setFontsize = size => {
              this.editorDiv.style.fontSize = `calc(${size}px * var(--total-scale-factor))`;
              this.translate(0, -(size - this.#fontSize) * this.parentScale);
              this.#fontSize = size;
              this.#setEditorDimensions();
            };
            const savedFontsize = this.#fontSize;
            this.addCommands({
              cmd: setFontsize.bind(this, fontSize),
              undo: setFontsize.bind(this, savedFontsize),
              post: this._uiManager.updateUI.bind(this._uiManager, this),
              mustExec: true,
              type: AnnotationEditorParamsType.FREETEXT_SIZE,
              overwriteIfSameType: true,
              keepUndo: true
            });
          }
          onUpdatedColor() {
            this.editorDiv.style.color = this.color;
            this._colorPicker?.update(this.color);
            super.onUpdatedColor();
          }
          #updateColor(color) {
            const setColor = col => {
              this.color = col;
              this.onUpdatedColor();
            };
            const savedColor = this.color;
            this.addCommands({
              cmd: setColor.bind(this, color),
              undo: setColor.bind(this, savedColor),
              post: this._uiManager.updateUI.bind(this._uiManager, this),
              mustExec: true,
              type: AnnotationEditorParamsType.FREETEXT_COLOR,
              overwriteIfSameType: true,
              keepUndo: true
            });
          }
          _translateEmpty(x, y) {
            this._uiManager.translateSelectedEditors(x, y, true);
          }
          getInitialTranslation() {
            const scale = this.parentScale;
            return [-FreeTextEditor._internalPadding * scale, -(FreeTextEditor._internalPadding + this.#fontSize) * scale];
          }
          rebuild() {
            if (!this.parent) {
              return;
            }
            super.rebuild();
            if (this.div === null) {
              return;
            }
            if (!this.isAttachedToDOM) {
              this.parent.add(this);
            }
          }
          enableEditMode() {
            if (!super.enableEditMode()) {
              return false;
            }
            this.overlayDiv.classList.remove("enabled");
            this.editorDiv.contentEditable = true;
            this._isDraggable = false;
            this.div.removeAttribute("aria-activedescendant");
            this.#editModeAC = new AbortController();
            const signal = this._uiManager.combinedSignal(this.#editModeAC);
            this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), {
              signal
            });
            this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
              signal
            });
            this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
              signal
            });
            this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
              signal
            });
            this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
              signal
            });
            return true;
          }
          disableEditMode() {
            if (!super.disableEditMode()) {
              return false;
            }
            this.overlayDiv.classList.add("enabled");
            this.editorDiv.contentEditable = false;
            this.div.setAttribute("aria-activedescendant", this.#editorDivId);
            this._isDraggable = true;
            this.#editModeAC?.abort();
            this.#editModeAC = null;
            this.div.focus({
              preventScroll: true
            });
            this.isEditing = false;
            this.parent.div.classList.add("freetextEditing");
            return true;
          }
          focusin(event) {
            if (!this._focusEventsAllowed) {
              return;
            }
            super.focusin(event);
            if (event.target !== this.editorDiv) {
              this.editorDiv.focus();
            }
          }
          onceAdded(focus) {
            if (this.width) {
              return;
            }
            this.enableEditMode();
            if (focus) {
              this.editorDiv.focus();
            }
            if (this._initialOptions?.isCentered) {
              this.center();
            }
            this._initialOptions = null;
          }
          isEmpty() {
            return !this.editorDiv || this.editorDiv.innerText.trim() === "";
          }
          remove() {
            this.isEditing = false;
            if (this.parent) {
              this.parent.setEditingState(true);
              this.parent.div.classList.add("freetextEditing");
            }
            super.remove();
          }
          #extractText() {
            const buffer = [];
            this.editorDiv.normalize();
            let prevChild = null;
            for (const child of this.editorDiv.childNodes) {
              if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === "BR") {
                continue;
              }
              buffer.push(FreeTextEditor.#getNodeContent(child));
              prevChild = child;
            }
            return buffer.join("\n");
          }
          #setEditorDimensions() {
            const [parentWidth, parentHeight] = this.parentDimensions;
            let rect;
            if (this.isAttachedToDOM) {
              rect = this.div.getBoundingClientRect();
            } else {
              const {
                currentLayer,
                div
              } = this;
              const savedDisplay = div.style.display;
              const savedVisibility = div.classList.contains("hidden");
              div.classList.remove("hidden");
              div.style.display = "hidden";
              currentLayer.div.append(this.div);
              rect = div.getBoundingClientRect();
              div.remove();
              div.style.display = savedDisplay;
              div.classList.toggle("hidden", savedVisibility);
            }
            if (this.rotation % 180 === this.parentRotation % 180) {
              this.width = rect.width / parentWidth;
              this.height = rect.height / parentHeight;
            } else {
              this.width = rect.height / parentWidth;
              this.height = rect.width / parentHeight;
            }
            this.fixAndSetPosition();
          }
          commit() {
            if (!this.isInEditMode()) {
              return;
            }
            super.commit();
            this.disableEditMode();
            const savedText = this.#content;
            const newText = this.#content = this.#extractText().trimEnd();
            if (savedText === newText) {
              return;
            }
            const setText = text => {
              this.#content = text;
              if (!text) {
                this.remove();
                return;
              }
              this.#setContent();
              this._uiManager.rebuild(this);
              this.#setEditorDimensions();
            };
            this.addCommands({
              cmd: () => {
                setText(newText);
              },
              undo: () => {
                setText(savedText);
              },
              mustExec: false
            });
            this.#setEditorDimensions();
          }
          shouldGetKeyboardEvents() {
            return this.isInEditMode();
          }
          enterInEditMode() {
            this.enableEditMode();
            this.editorDiv.focus();
          }
          keydown(event) {
            if (event.target === this.div && event.key === "Enter") {
              this.enterInEditMode();
              event.preventDefault();
            }
          }
          editorDivKeydown(event) {
            FreeTextEditor._keyboardManager.exec(this, event);
          }
          editorDivFocus(event) {
            this.isEditing = true;
          }
          editorDivBlur(event) {
            this.isEditing = false;
          }
          editorDivInput(event) {
            this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
          }
          disableEditing() {
            this.editorDiv.setAttribute("role", "comment");
            this.editorDiv.removeAttribute("aria-multiline");
          }
          enableEditing() {
            this.editorDiv.setAttribute("role", "textbox");
            this.editorDiv.setAttribute("aria-multiline", true);
          }
          get canChangeContent() {
            return true;
          }
          render() {
            if (this.div) {
              return this.div;
            }
            let baseX, baseY;
            if (this._isCopy || this.annotationElementId) {
              baseX = this.x;
              baseY = this.y;
            }
            super.render();
            this.editorDiv = document.createElement("div");
            this.editorDiv.className = "internal";
            this.editorDiv.setAttribute("id", this.#editorDivId);
            this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2");
            this.editorDiv.setAttribute("data-l10n-attrs", "default-content");
            this.enableEditing();
            this.editorDiv.contentEditable = true;
            const {
              style
            } = this.editorDiv;
            style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;
            style.color = this.color;
            this.div.append(this.editorDiv);
            this.overlayDiv = document.createElement("div");
            this.overlayDiv.classList.add("overlay", "enabled");
            this.div.append(this.overlayDiv);
            if (this._isCopy || this.annotationElementId) {
              const [parentWidth, parentHeight] = this.parentDimensions;
              if (this.annotationElementId) {
                const {
                  position
                } = this._initialData;
                let [tx, ty] = this.getInitialTranslation();
                [tx, ty] = this.pageTranslationToScreen(tx, ty);
                const [pageWidth, pageHeight] = this.pageDimensions;
                const [pageX, pageY] = this.pageTranslation;
                let posX, posY;
                switch (this.rotation) {
                  case 0:
                    posX = baseX + (position[0] - pageX) / pageWidth;
                    posY = baseY + this.height - (position[1] - pageY) / pageHeight;
                    break;
                  case 90:
                    posX = baseX + (position[0] - pageX) / pageWidth;
                    posY = baseY - (position[1] - pageY) / pageHeight;
                    [tx, ty] = [ty, -tx];
                    break;
                  case 180:
                    posX = baseX - this.width + (position[0] - pageX) / pageWidth;
                    posY = baseY - (position[1] - pageY) / pageHeight;
                    [tx, ty] = [-tx, -ty];
                    break;
                  case 270:
                    posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;
                    posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;
                    [tx, ty] = [-ty, tx];
                    break;
                }
                this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
              } else {
                this._moveAfterPaste(baseX, baseY);
              }
              this.#setContent();
              this._isDraggable = true;
              this.editorDiv.contentEditable = false;
            } else {
              this._isDraggable = false;
              this.editorDiv.contentEditable = true;
            }
            return this.div;
          }
          static #getNodeContent(node) {
            return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, "");
          }
          editorDivPaste(event) {
            const clipboardData = event.clipboardData || window.clipboardData;
            const {
              types
            } = clipboardData;
            if (types.length === 1 && types[0] === "text/plain") {
              return;
            }
            event.preventDefault();
            const paste = FreeTextEditor.#deserializeContent(clipboardData.getData("text") || "").replaceAll(EOL_PATTERN, "\n");
            if (!paste) {
              return;
            }
            const selection = window.getSelection();
            if (!selection.rangeCount) {
              return;
            }
            this.editorDiv.normalize();
            selection.deleteFromDocument();
            const range = selection.getRangeAt(0);
            if (!paste.includes("\n")) {
              range.insertNode(document.createTextNode(paste));
              this.editorDiv.normalize();
              selection.collapseToStart();
              return;
            }
            const {
              startContainer,
              startOffset
            } = range;
            const bufferBefore = [];
            const bufferAfter = [];
            if (startContainer.nodeType === Node.TEXT_NODE) {
              const parent = startContainer.parentElement;
              bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, ""));
              if (parent !== this.editorDiv) {
                let buffer = bufferBefore;
                for (const child of this.editorDiv.childNodes) {
                  if (child === parent) {
                    buffer = bufferAfter;
                    continue;
                  }
                  buffer.push(FreeTextEditor.#getNodeContent(child));
                }
              }
              bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, ""));
            } else if (startContainer === this.editorDiv) {
              let buffer = bufferBefore;
              let i = 0;
              for (const child of this.editorDiv.childNodes) {
                if (i++ === startOffset) {
                  buffer = bufferAfter;
                }
                buffer.push(FreeTextEditor.#getNodeContent(child));
              }
            }
            this.#content = `${bufferBefore.join("\n")}${paste}${bufferAfter.join("\n")}`;
            this.#setContent();
            const newRange = new Range();
            let beforeLength = Math.sumPrecise(bufferBefore.map(line => line.length));
            for (const {
              firstChild
            } of this.editorDiv.childNodes) {
              if (firstChild.nodeType === Node.TEXT_NODE) {
                const length = firstChild.nodeValue.length;
                if (beforeLength <= length) {
                  newRange.setStart(firstChild, beforeLength);
                  newRange.setEnd(firstChild, beforeLength);
                  break;
                }
                beforeLength -= length;
              }
            }
            selection.removeAllRanges();
            selection.addRange(newRange);
          }
          #setContent() {
            this.editorDiv.replaceChildren();
            if (!this.#content) {
              return;
            }
            for (const line of this.#content.split("\n")) {
              const div = document.createElement("div");
              div.append(line ? document.createTextNode(line) : document.createElement("br"));
              this.editorDiv.append(div);
            }
          }
          #serializeContent() {
            return this.#content.replaceAll("\xa0", " ");
          }
          static #deserializeContent(content) {
            return content.replaceAll(" ", "\xa0");
          }
          get contentDiv() {
            return this.editorDiv;
          }
          getPDFRect() {
            const padding = FreeTextEditor._internalPadding * this.parentScale;
            return this.getRect(padding, padding);
          }
          static async deserialize(data, parent, uiManager) {
            let initialData = null;
            if (data instanceof FreeTextAnnotationElement) {
              const {
                data: {
                  defaultAppearanceData: {
                    fontSize,
                    fontColor
                  },
                  rect,
                  rotation,
                  id,
                  popupRef,
                  richText,
                  contentsObj,
                  creationDate,
                  modificationDate
                },
                textContent,
                textPosition,
                parent: {
                  page: {
                    pageNumber
                  }
                }
              } = data;
              if (!textContent || textContent.length === 0) {
                return null;
              }
              initialData = data = {
                annotationType: AnnotationEditorType.FREETEXT,
                color: Array.from(fontColor),
                fontSize,
                value: textContent.join("\n"),
                position: textPosition,
                pageIndex: pageNumber - 1,
                rect: rect.slice(0),
                rotation,
                annotationElementId: id,
                id,
                deleted: false,
                popupRef,
                comment: contentsObj?.str || null,
                richText,
                creationDate,
                modificationDate
              };
            }
            const editor = await super.deserialize(data, parent, uiManager);
            editor.#fontSize = data.fontSize;
            editor.color = Util.makeHexColor(...data.color);
            editor.#content = FreeTextEditor.#deserializeContent(data.value);
            editor._initialData = initialData;
            if (data.comment) {
              editor.setCommentData(data);
            }
            return editor;
          }
          serialize(isForCopying = false) {
            if (this.isEmpty()) {
              return null;
            }
            if (this.deleted) {
              return this.serializeDeleted();
            }
            const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.color);
            const serialized = Object.assign(super.serialize(isForCopying), {
              color,
              fontSize: this.#fontSize,
              value: this.#serializeContent()
            });
            this.addComment(serialized);
            if (isForCopying) {
              serialized.isCopy = true;
              return serialized;
            }
            if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
              return null;
            }
            serialized.id = this.annotationElementId;
            return serialized;
          }
          #hasElementChanged(serialized) {
            const {
              value,
              fontSize,
              color,
              pageIndex
            } = this._initialData;
            return this.hasEditedComment || this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i) => c !== color[i]) || serialized.pageIndex !== pageIndex;
          }
          renderAnnotationElement(annotation) {
            const content = super.renderAnnotationElement(annotation);
            if (!content) {
              return null;
            }
            const {
              style
            } = content;
            style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;
            style.color = this.color;
            content.replaceChildren();
            for (const line of this.#content.split("\n")) {
              const div = document.createElement("div");
              div.append(line ? document.createTextNode(line) : document.createElement("br"));
              content.append(div);
            }
            annotation.updateEdited({
              rect: this.getPDFRect(),
              popup: this._uiManager.hasCommentManager() || this.hasEditedComment ? this.comment : {
                text: this.#content
              }
            });
            return content;
          }
          resetAnnotationElement(annotation) {
            super.resetAnnotationElement(annotation);
            annotation.resetEdited();
          }
        }

        ;// ./src/display/editor/drawers/outline.js

        class Outline {
          static PRECISION = 1e-4;
          toSVGPath() {
            unreachable("Abstract method `toSVGPath` must be implemented.");
          }
          get box() {
            unreachable("Abstract getter `box` must be implemented.");
          }
          serialize(_bbox, _rotation) {
            unreachable("Abstract method `serialize` must be implemented.");
          }
          static _rescale(src, tx, ty, sx, sy, dest) {
            dest ||= new Float32Array(src.length);
            for (let i = 0, ii = src.length; i < ii; i += 2) {
              dest[i] = tx + src[i] * sx;
              dest[i + 1] = ty + src[i + 1] * sy;
            }
            return dest;
          }
          static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {
            dest ||= new Float32Array(src.length);
            for (let i = 0, ii = src.length; i < ii; i += 2) {
              dest[i] = tx + src[i + 1] * sx;
              dest[i + 1] = ty + src[i] * sy;
            }
            return dest;
          }
          static _translate(src, tx, ty, dest) {
            dest ||= new Float32Array(src.length);
            for (let i = 0, ii = src.length; i < ii; i += 2) {
              dest[i] = tx + src[i];
              dest[i + 1] = ty + src[i + 1];
            }
            return dest;
          }
          static svgRound(x) {
            return Math.round(x * 10000);
          }
          static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {
            switch (rotation) {
              case 90:
                return [1 - y / parentWidth, x / parentHeight];
              case 180:
                return [1 - x / parentWidth, 1 - y / parentHeight];
              case 270:
                return [y / parentWidth, 1 - x / parentHeight];
              default:
                return [x / parentWidth, y / parentHeight];
            }
          }
          static _normalizePagePoint(x, y, rotation) {
            switch (rotation) {
              case 90:
                return [1 - y, x];
              case 180:
                return [1 - x, 1 - y];
              case 270:
                return [y, 1 - x];
              default:
                return [x, y];
            }
          }
          static createBezierPoints(x1, y1, x2, y2, x3, y3) {
            return [(x1 + 5 * x2) / 6, (y1 + 5 * y2) / 6, (5 * x2 + x3) / 6, (5 * y2 + y3) / 6, (x2 + x3) / 2, (y2 + y3) / 2];
          }
        }

        ;// ./src/display/editor/drawers/freedraw.js


        class FreeDrawOutliner {
          #box;
          #bottom = [];
          #innerMargin;
          #isLTR;
          #top = [];
          #last = new Float32Array(18);
          #lastX;
          #lastY;
          #min;
          #min_dist;
          #scaleFactor;
          #thickness;
          #points = [];
          static #MIN_DIST = 8;
          static #MIN_DIFF = 2;
          static #MIN = FreeDrawOutliner.#MIN_DIST + FreeDrawOutliner.#MIN_DIFF;
          constructor({
            x,
            y
          }, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
            this.#box = box;
            this.#thickness = thickness * scaleFactor;
            this.#isLTR = isLTR;
            this.#last.set([NaN, NaN, NaN, NaN, x, y], 6);
            this.#innerMargin = innerMargin;
            this.#min_dist = FreeDrawOutliner.#MIN_DIST * scaleFactor;
            this.#min = FreeDrawOutliner.#MIN * scaleFactor;
            this.#scaleFactor = scaleFactor;
            this.#points.push(x, y);
          }
          isEmpty() {
            return isNaN(this.#last[8]);
          }
          #getLastCoords() {
            const lastTop = this.#last.subarray(4, 6);
            const lastBottom = this.#last.subarray(16, 18);
            const [x, y, width, height] = this.#box;
            return [(this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width, (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height, (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width, (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height];
          }
          add({
            x,
            y
          }) {
            this.#lastX = x;
            this.#lastY = y;
            const [layerX, layerY, layerWidth, layerHeight] = this.#box;
            let [x1, y1, x2, y2] = this.#last.subarray(8, 12);
            const diffX = x - x2;
            const diffY = y - y2;
            const d = Math.hypot(diffX, diffY);
            if (d < this.#min) {
              return false;
            }
            const diffD = d - this.#min_dist;
            const K = diffD / d;
            const shiftX = K * diffX;
            const shiftY = K * diffY;
            let x0 = x1;
            let y0 = y1;
            x1 = x2;
            y1 = y2;
            x2 += shiftX;
            y2 += shiftY;
            this.#points?.push(x, y);
            const nX = -shiftY / diffD;
            const nY = shiftX / diffD;
            const thX = nX * this.#thickness;
            const thY = nY * this.#thickness;
            this.#last.set(this.#last.subarray(2, 8), 0);
            this.#last.set([x2 + thX, y2 + thY], 4);
            this.#last.set(this.#last.subarray(14, 18), 12);
            this.#last.set([x2 - thX, y2 - thY], 16);
            if (isNaN(this.#last[6])) {
              if (this.#top.length === 0) {
                this.#last.set([x1 + thX, y1 + thY], 2);
                this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);
                this.#last.set([x1 - thX, y1 - thY], 14);
                this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);
              }
              this.#last.set([x0, y0, x1, y1, x2, y2], 6);
              return !this.isEmpty();
            }
            this.#last.set([x0, y0, x1, y1, x2, y2], 6);
            const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));
            if (angle < Math.PI / 2) {
              [x1, y1, x2, y2] = this.#last.subarray(2, 6);
              this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
              [x1, y1, x0, y0] = this.#last.subarray(14, 18);
              this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);
              return true;
            }
            [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);
            this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
            [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);
            this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
            return true;
          }
          toSVGPath() {
            if (this.isEmpty()) {
              return "";
            }
            const top = this.#top;
            const bottom = this.#bottom;
            if (isNaN(this.#last[6]) && !this.isEmpty()) {
              return this.#toSVGPathTwoPoints();
            }
            const buffer = [];
            buffer.push(`M${top[4]} ${top[5]}`);
            for (let i = 6; i < top.length; i += 6) {
              if (isNaN(top[i])) {
                buffer.push(`L${top[i + 4]} ${top[i + 5]}`);
              } else {
                buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);
              }
            }
            this.#toSVGPathEnd(buffer);
            for (let i = bottom.length - 6; i >= 6; i -= 6) {
              if (isNaN(bottom[i])) {
                buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);
              } else {
                buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);
              }
            }
            this.#toSVGPathStart(buffer);
            return buffer.join(" ");
          }
          #toSVGPathTwoPoints() {
            const [x, y, width, height] = this.#box;
            const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
            return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;
          }
          #toSVGPathStart(buffer) {
            const bottom = this.#bottom;
            buffer.push(`L${bottom[4]} ${bottom[5]} Z`);
          }
          #toSVGPathEnd(buffer) {
            const [x, y, width, height] = this.#box;
            const lastTop = this.#last.subarray(4, 6);
            const lastBottom = this.#last.subarray(16, 18);
            const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
            buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);
          }
          newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
            return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
          }
          getOutlines() {
            const top = this.#top;
            const bottom = this.#bottom;
            const last = this.#last;
            const [layerX, layerY, layerWidth, layerHeight] = this.#box;
            const points = new Float32Array((this.#points?.length ?? 0) + 2);
            for (let i = 0, ii = points.length - 2; i < ii; i += 2) {
              points[i] = (this.#points[i] - layerX) / layerWidth;
              points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;
            }
            points[points.length - 2] = (this.#lastX - layerX) / layerWidth;
            points[points.length - 1] = (this.#lastY - layerY) / layerHeight;
            if (isNaN(last[6]) && !this.isEmpty()) {
              return this.#getOutlineTwoPoints(points);
            }
            const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);
            let N = top.length;
            for (let i = 0; i < N; i += 2) {
              if (isNaN(top[i])) {
                outline[i] = outline[i + 1] = NaN;
                continue;
              }
              outline[i] = top[i];
              outline[i + 1] = top[i + 1];
            }
            N = this.#getOutlineEnd(outline, N);
            for (let i = bottom.length - 6; i >= 6; i -= 6) {
              for (let j = 0; j < 6; j += 2) {
                if (isNaN(bottom[i + j])) {
                  outline[N] = outline[N + 1] = NaN;
                  N += 2;
                  continue;
                }
                outline[N] = bottom[i + j];
                outline[N + 1] = bottom[i + j + 1];
                N += 2;
              }
            }
            this.#getOutlineStart(outline, N);
            return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
          }
          #getOutlineTwoPoints(points) {
            const last = this.#last;
            const [layerX, layerY, layerWidth, layerHeight] = this.#box;
            const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
            const outline = new Float32Array(36);
            outline.set([NaN, NaN, NaN, NaN, (last[2] - layerX) / layerWidth, (last[3] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[4] - layerX) / layerWidth, (last[5] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (last[16] - layerX) / layerWidth, (last[17] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last[14] - layerX) / layerWidth, (last[15] - layerY) / layerHeight], 0);
            return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
          }
          #getOutlineStart(outline, pos) {
            const bottom = this.#bottom;
            outline.set([NaN, NaN, NaN, NaN, bottom[4], bottom[5]], pos);
            return pos += 6;
          }
          #getOutlineEnd(outline, pos) {
            const lastTop = this.#last.subarray(4, 6);
            const lastBottom = this.#last.subarray(16, 18);
            const [layerX, layerY, layerWidth, layerHeight] = this.#box;
            const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
            outline.set([NaN, NaN, NaN, NaN, (lastTop[0] - layerX) / layerWidth, (lastTop[1] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (lastBottom[0] - layerX) / layerWidth, (lastBottom[1] - layerY) / layerHeight], pos);
            return pos += 24;
          }
        }
        class FreeDrawOutline extends Outline {
          #box;
          #bbox = new Float32Array(4);
          #innerMargin;
          #isLTR;
          #points;
          #scaleFactor;
          #outline;
          constructor(outline, points, box, scaleFactor, innerMargin, isLTR) {
            super();
            this.#outline = outline;
            this.#points = points;
            this.#box = box;
            this.#scaleFactor = scaleFactor;
            this.#innerMargin = innerMargin;
            this.#isLTR = isLTR;
            this.firstPoint = [NaN, NaN];
            this.lastPoint = [NaN, NaN];
            this.#computeMinMax(isLTR);
            const [x, y, width, height] = this.#bbox;
            for (let i = 0, ii = outline.length; i < ii; i += 2) {
              outline[i] = (outline[i] - x) / width;
              outline[i + 1] = (outline[i + 1] - y) / height;
            }
            for (let i = 0, ii = points.length; i < ii; i += 2) {
              points[i] = (points[i] - x) / width;
              points[i + 1] = (points[i + 1] - y) / height;
            }
          }
          toSVGPath() {
            const buffer = [`M${this.#outline[4]} ${this.#outline[5]}`];
            for (let i = 6, ii = this.#outline.length; i < ii; i += 6) {
              if (isNaN(this.#outline[i])) {
                buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);
                continue;
              }
              buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);
            }
            buffer.push("Z");
            return buffer.join(" ");
          }
          serialize([blX, blY, trX, trY], rotation) {
            const width = trX - blX;
            const height = trY - blY;
            let outline;
            let points;
            switch (rotation) {
              case 0:
                outline = Outline._rescale(this.#outline, blX, trY, width, -height);
                points = Outline._rescale(this.#points, blX, trY, width, -height);
                break;
              case 90:
                outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);
                points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);
                break;
              case 180:
                outline = Outline._rescale(this.#outline, trX, blY, -width, height);
                points = Outline._rescale(this.#points, trX, blY, -width, height);
                break;
              case 270:
                outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);
                points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);
                break;
            }
            return {
              outline: Array.from(outline),
              points: [Array.from(points)]
            };
          }
          #computeMinMax(isLTR) {
            const outline = this.#outline;
            let lastX = outline[4];
            let lastY = outline[5];
            const minMax = [lastX, lastY, lastX, lastY];
            let firstPointX = lastX;
            let firstPointY = lastY;
            let lastPointX = lastX;
            let lastPointY = lastY;
            const ltrCallback = isLTR ? Math.max : Math.min;
            const bezierBbox = new Float32Array(4);
            for (let i = 6, ii = outline.length; i < ii; i += 6) {
              const x = outline[i + 4],
                y = outline[i + 5];
              if (isNaN(outline[i])) {
                Util.pointBoundingBox(x, y, minMax);
                if (firstPointY > y) {
                  firstPointX = x;
                  firstPointY = y;
                } else if (firstPointY === y) {
                  firstPointX = ltrCallback(firstPointX, x);
                }
                if (lastPointY < y) {
                  lastPointX = x;
                  lastPointY = y;
                } else if (lastPointY === y) {
                  lastPointX = ltrCallback(lastPointX, x);
                }
              } else {
                bezierBbox[0] = bezierBbox[1] = Infinity;
                bezierBbox[2] = bezierBbox[3] = -Infinity;
                Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6), bezierBbox);
                Util.rectBoundingBox(bezierBbox[0], bezierBbox[1], bezierBbox[2], bezierBbox[3], minMax);
                if (firstPointY > bezierBbox[1]) {
                  firstPointX = bezierBbox[0];
                  firstPointY = bezierBbox[1];
                } else if (firstPointY === bezierBbox[1]) {
                  firstPointX = ltrCallback(firstPointX, bezierBbox[0]);
                }
                if (lastPointY < bezierBbox[3]) {
                  lastPointX = bezierBbox[2];
                  lastPointY = bezierBbox[3];
                } else if (lastPointY === bezierBbox[3]) {
                  lastPointX = ltrCallback(lastPointX, bezierBbox[2]);
                }
              }
              lastX = x;
              lastY = y;
            }
            const bbox = this.#bbox;
            bbox[0] = minMax[0] - this.#innerMargin;
            bbox[1] = minMax[1] - this.#innerMargin;
            bbox[2] = minMax[2] - minMax[0] + 2 * this.#innerMargin;
            bbox[3] = minMax[3] - minMax[1] + 2 * this.#innerMargin;
            this.firstPoint = [firstPointX, firstPointY];
            this.lastPoint = [lastPointX, lastPointY];
          }
          get box() {
            return this.#bbox;
          }
          newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
            return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
          }
          getNewOutline(thickness, innerMargin) {
            const [x, y, width, height] = this.#bbox;
            const [layerX, layerY, layerWidth, layerHeight] = this.#box;
            const sx = width * layerWidth;
            const sy = height * layerHeight;
            const tx = x * layerWidth + layerX;
            const ty = y * layerHeight + layerY;
            const outliner = this.newOutliner({
              x: this.#points[0] * sx + tx,
              y: this.#points[1] * sy + ty
            }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);
            for (let i = 2; i < this.#points.length; i += 2) {
              outliner.add({
                x: this.#points[i] * sx + tx,
                y: this.#points[i + 1] * sy + ty
              });
            }
            return outliner.getOutlines();
          }
        }

        ;// ./src/display/editor/drawers/highlight.js



        class HighlightOutliner {
          #box;
          #firstPoint;
          #lastPoint;
          #verticalEdges = [];
          #intervals = [];
          constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true) {
            const minMax = [Infinity, Infinity, -Infinity, -Infinity];
            const NUMBER_OF_DIGITS = 4;
            const EPSILON = 10 ** -NUMBER_OF_DIGITS;
            for (const {
              x,
              y,
              width,
              height
            } of boxes) {
              const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;
              const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;
              const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;
              const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;
              const left = [x1, y1, y2, true];
              const right = [x2, y1, y2, false];
              this.#verticalEdges.push(left, right);
              Util.rectBoundingBox(x1, y1, x2, y2, minMax);
            }
            const bboxWidth = minMax[2] - minMax[0] + 2 * innerMargin;
            const bboxHeight = minMax[3] - minMax[1] + 2 * innerMargin;
            const shiftedMinX = minMax[0] - innerMargin;
            const shiftedMinY = minMax[1] - innerMargin;
            let firstPointX = isLTR ? -Infinity : Infinity;
            let firstPointY = Infinity;
            const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);
            const lastPoint = [lastEdge[0], lastEdge[2]];
            for (const edge of this.#verticalEdges) {
              const [x, y1, y2, left] = edge;
              if (!left && isLTR) {
                if (y1 < firstPointY) {
                  firstPointY = y1;
                  firstPointX = x;
                } else if (y1 === firstPointY) {
                  firstPointX = Math.max(firstPointX, x);
                }
              } else if (left && !isLTR) {
                if (y1 < firstPointY) {
                  firstPointY = y1;
                  firstPointX = x;
                } else if (y1 === firstPointY) {
                  firstPointX = Math.min(firstPointX, x);
                }
              }
              edge[0] = (x - shiftedMinX) / bboxWidth;
              edge[1] = (y1 - shiftedMinY) / bboxHeight;
              edge[2] = (y2 - shiftedMinY) / bboxHeight;
            }
            this.#box = new Float32Array([shiftedMinX, shiftedMinY, bboxWidth, bboxHeight]);
            this.#firstPoint = [firstPointX, firstPointY];
            this.#lastPoint = lastPoint;
          }
          getOutlines() {
            this.#verticalEdges.sort((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);
            const outlineVerticalEdges = [];
            for (const edge of this.#verticalEdges) {
              if (edge[3]) {
                outlineVerticalEdges.push(...this.#breakEdge(edge));
                this.#insert(edge);
              } else {
                this.#remove(edge);
                outlineVerticalEdges.push(...this.#breakEdge(edge));
              }
            }
            return this.#getOutlines(outlineVerticalEdges);
          }
          #getOutlines(outlineVerticalEdges) {
            const edges = [];
            const allEdges = new Set();
            for (const edge of outlineVerticalEdges) {
              const [x, y1, y2] = edge;
              edges.push([x, y1, edge], [x, y2, edge]);
            }
            edges.sort((a, b) => a[1] - b[1] || a[0] - b[0]);
            for (let i = 0, ii = edges.length; i < ii; i += 2) {
              const edge1 = edges[i][2];
              const edge2 = edges[i + 1][2];
              edge1.push(edge2);
              edge2.push(edge1);
              allEdges.add(edge1);
              allEdges.add(edge2);
            }
            const outlines = [];
            let outline;
            while (allEdges.size > 0) {
              const edge = allEdges.values().next().value;
              let [x, y1, y2, edge1, edge2] = edge;
              allEdges.delete(edge);
              let lastPointX = x;
              let lastPointY = y1;
              outline = [x, y2];
              outlines.push(outline);
              while (true) {
                let e;
                if (allEdges.has(edge1)) {
                  e = edge1;
                } else if (allEdges.has(edge2)) {
                  e = edge2;
                } else {
                  break;
                }
                allEdges.delete(e);
                [x, y1, y2, edge1, edge2] = e;
                if (lastPointX !== x) {
                  outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);
                  lastPointX = x;
                }
                lastPointY = lastPointY === y1 ? y2 : y1;
              }
              outline.push(lastPointX, lastPointY);
            }
            return new HighlightOutline(outlines, this.#box, this.#firstPoint, this.#lastPoint);
          }
          #binarySearch(y) {
            const array = this.#intervals;
            let start = 0;
            let end = array.length - 1;
            while (start <= end) {
              const middle = start + end >> 1;
              const y1 = array[middle][0];
              if (y1 === y) {
                return middle;
              }
              if (y1 < y) {
                start = middle + 1;
              } else {
                end = middle - 1;
              }
            }
            return end + 1;
          }
          #insert([, y1, y2]) {
            const index = this.#binarySearch(y1);
            this.#intervals.splice(index, 0, [y1, y2]);
          }
          #remove([, y1, y2]) {
            const index = this.#binarySearch(y1);
            for (let i = index; i < this.#intervals.length; i++) {
              const [start, end] = this.#intervals[i];
              if (start !== y1) {
                break;
              }
              if (start === y1 && end === y2) {
                this.#intervals.splice(i, 1);
                return;
              }
            }
            for (let i = index - 1; i >= 0; i--) {
              const [start, end] = this.#intervals[i];
              if (start !== y1) {
                break;
              }
              if (start === y1 && end === y2) {
                this.#intervals.splice(i, 1);
                return;
              }
            }
          }
          #breakEdge(edge) {
            const [x, y1, y2] = edge;
            const results = [[x, y1, y2]];
            const index = this.#binarySearch(y2);
            for (let i = 0; i < index; i++) {
              const [start, end] = this.#intervals[i];
              for (let j = 0, jj = results.length; j < jj; j++) {
                const [, y3, y4] = results[j];
                if (end <= y3 || y4 <= start) {
                  continue;
                }
                if (y3 >= start) {
                  if (y4 > end) {
                    results[j][1] = end;
                  } else {
                    if (jj === 1) {
                      return [];
                    }
                    results.splice(j, 1);
                    j--;
                    jj--;
                  }
                  continue;
                }
                results[j][2] = start;
                if (y4 > end) {
                  results.push([x, end, y4]);
                }
              }
            }
            return results;
          }
        }
        class HighlightOutline extends Outline {
          #box;
          #outlines;
          constructor(outlines, box, firstPoint, lastPoint) {
            super();
            this.#outlines = outlines;
            this.#box = box;
            this.firstPoint = firstPoint;
            this.lastPoint = lastPoint;
          }
          toSVGPath() {
            const buffer = [];
            for (const polygon of this.#outlines) {
              let [prevX, prevY] = polygon;
              buffer.push(`M${prevX} ${prevY}`);
              for (let i = 2; i < polygon.length; i += 2) {
                const x = polygon[i];
                const y = polygon[i + 1];
                if (x === prevX) {
                  buffer.push(`V${y}`);
                  prevY = y;
                } else if (y === prevY) {
                  buffer.push(`H${x}`);
                  prevX = x;
                }
              }
              buffer.push("Z");
            }
            return buffer.join(" ");
          }
          serialize([blX, blY, trX, trY], _rotation) {
            const outlines = [];
            const width = trX - blX;
            const height = trY - blY;
            for (const outline of this.#outlines) {
              const points = new Array(outline.length);
              for (let i = 0; i < outline.length; i += 2) {
                points[i] = blX + outline[i] * width;
                points[i + 1] = trY - outline[i + 1] * height;
              }
              outlines.push(points);
            }
            return outlines;
          }
          get box() {
            return this.#box;
          }
          get classNamesForOutlining() {
            return ["highlightOutline"];
          }
        }
        class FreeHighlightOutliner extends FreeDrawOutliner {
          newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
            return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
          }
        }
        class FreeHighlightOutline extends FreeDrawOutline {
          newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
            return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
          }
        }

        ;// ./src/display/editor/highlight.js







        class HighlightEditor extends AnnotationEditor {
          #anchorNode = null;
          #anchorOffset = 0;
          #boxes;
          #clipPathId = null;
          #colorPicker = null;
          #focusOutlines = null;
          #focusNode = null;
          #focusOffset = 0;
          #highlightDiv = null;
          #highlightOutlines = null;
          #id = null;
          #isFreeHighlight = false;
          #firstPoint = null;
          #lastPoint = null;
          #outlineId = null;
          #text = "";
          #thickness;
          #methodOfCreation = "";
          static _defaultColor = null;
          static _defaultOpacity = 1;
          static _defaultThickness = 12;
          static _type = "highlight";
          static _editorType = AnnotationEditorType.HIGHLIGHT;
          static _freeHighlightId = -1;
          static _freeHighlight = null;
          static _freeHighlightClipId = "";
          static get _keyboardManager() {
            const proto = HighlightEditor.prototype;
            return shadow(this, "_keyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], proto._moveCaret, {
              args: [0]
            }], [["ArrowRight", "mac+ArrowRight"], proto._moveCaret, {
              args: [1]
            }], [["ArrowUp", "mac+ArrowUp"], proto._moveCaret, {
              args: [2]
            }], [["ArrowDown", "mac+ArrowDown"], proto._moveCaret, {
              args: [3]
            }]]));
          }
          constructor(params) {
            super({
              ...params,
              name: "highlightEditor"
            });
            this.color = params.color || HighlightEditor._defaultColor;
            this.#thickness = params.thickness || HighlightEditor._defaultThickness;
            this.opacity = params.opacity || HighlightEditor._defaultOpacity;
            this.#boxes = params.boxes || null;
            this.#methodOfCreation = params.methodOfCreation || "";
            this.#text = params.text || "";
            this._isDraggable = false;
            this.defaultL10nId = "pdfjs-editor-highlight-editor";
            if (params.highlightId > -1) {
              this.#isFreeHighlight = true;
              this.#createFreeOutlines(params);
              this.#addToDrawLayer();
            } else if (this.#boxes) {
              this.#anchorNode = params.anchorNode;
              this.#anchorOffset = params.anchorOffset;
              this.#focusNode = params.focusNode;
              this.#focusOffset = params.focusOffset;
              this.#createOutlines();
              this.#addToDrawLayer();
              this.rotate(this.rotation);
            }
            if (!this.annotationElementId) {
              this._uiManager.a11yAlert("pdfjs-editor-highlight-added-alert");
            }
          }
          get telemetryInitialData() {
            return {
              action: "added",
              type: this.#isFreeHighlight ? "free_highlight" : "highlight",
              color: this._uiManager.getNonHCMColorName(this.color),
              thickness: this.#thickness,
              methodOfCreation: this.#methodOfCreation
            };
          }
          get telemetryFinalData() {
            return {
              type: "highlight",
              color: this._uiManager.getNonHCMColorName(this.color)
            };
          }
          static computeTelemetryFinalData(data) {
            return {
              numberOfColors: data.get("color").size
            };
          }
          #createOutlines() {
            const outliner = new HighlightOutliner(this.#boxes, 0.001);
            this.#highlightOutlines = outliner.getOutlines();
            [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;
            const outlinerForOutline = new HighlightOutliner(this.#boxes, 0.0025, 0.001, this._uiManager.direction === "ltr");
            this.#focusOutlines = outlinerForOutline.getOutlines();
            const {
              firstPoint
            } = this.#highlightOutlines;
            this.#firstPoint = [(firstPoint[0] - this.x) / this.width, (firstPoint[1] - this.y) / this.height];
            const {
              lastPoint
            } = this.#focusOutlines;
            this.#lastPoint = [(lastPoint[0] - this.x) / this.width, (lastPoint[1] - this.y) / this.height];
          }
          #createFreeOutlines({
            highlightOutlines,
            highlightId,
            clipPathId
          }) {
            this.#highlightOutlines = highlightOutlines;
            const extraThickness = 1.5;
            this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 0.0025);
            if (highlightId >= 0) {
              this.#id = highlightId;
              this.#clipPathId = clipPathId;
              this.parent.drawLayer.finalizeDraw(highlightId, {
                bbox: highlightOutlines.box,
                path: {
                  d: highlightOutlines.toSVGPath()
                }
              });
              this.#outlineId = this.parent.drawLayer.drawOutline({
                rootClass: {
                  highlightOutline: true,
                  free: true
                },
                bbox: this.#focusOutlines.box,
                path: {
                  d: this.#focusOutlines.toSVGPath()
                }
              }, true);
            } else if (this.parent) {
              const angle = this.parent.viewport.rotation;
              this.parent.drawLayer.updateProperties(this.#id, {
                bbox: HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),
                path: {
                  d: highlightOutlines.toSVGPath()
                }
              });
              this.parent.drawLayer.updateProperties(this.#outlineId, {
                bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),
                path: {
                  d: this.#focusOutlines.toSVGPath()
                }
              });
            }
            const [x, y, width, height] = highlightOutlines.box;
            switch (this.rotation) {
              case 0:
                this.x = x;
                this.y = y;
                this.width = width;
                this.height = height;
                break;
              case 90:
                {
                  const [pageWidth, pageHeight] = this.parentDimensions;
                  this.x = y;
                  this.y = 1 - x;
                  this.width = width * pageHeight / pageWidth;
                  this.height = height * pageWidth / pageHeight;
                  break;
                }
              case 180:
                this.x = 1 - x;
                this.y = 1 - y;
                this.width = width;
                this.height = height;
                break;
              case 270:
                {
                  const [pageWidth, pageHeight] = this.parentDimensions;
                  this.x = 1 - y;
                  this.y = x;
                  this.width = width * pageHeight / pageWidth;
                  this.height = height * pageWidth / pageHeight;
                  break;
                }
            }
            const {
              firstPoint
            } = highlightOutlines;
            this.#firstPoint = [(firstPoint[0] - x) / width, (firstPoint[1] - y) / height];
            const {
              lastPoint
            } = this.#focusOutlines;
            this.#lastPoint = [(lastPoint[0] - x) / width, (lastPoint[1] - y) / height];
          }
          static initialize(l10n, uiManager) {
            AnnotationEditor.initialize(l10n, uiManager);
            HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || "#fff066";
          }
          static updateDefaultParams(type, value) {
            switch (type) {
              case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
                HighlightEditor._defaultColor = value;
                break;
              case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
                HighlightEditor._defaultThickness = value;
                break;
            }
          }
          translateInPage(x, y) { }
          get toolbarPosition() {
            return this.#lastPoint;
          }
          get commentButtonPosition() {
            return this.#firstPoint;
          }
          updateParams(type, value) {
            switch (type) {
              case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
                this.#updateColor(value);
                break;
              case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
                this.#updateThickness(value);
                break;
            }
          }
          static get defaultPropertiesToUpdate() {
            return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, HighlightEditor._defaultThickness]];
          }
          get propertiesToUpdate() {
            return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, this.color || HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, this.#thickness || HighlightEditor._defaultThickness], [AnnotationEditorParamsType.HIGHLIGHT_FREE, this.#isFreeHighlight]];
          }
          onUpdatedColor() {
            this.parent?.drawLayer.updateProperties(this.#id, {
              root: {
                fill: this.color,
                "fill-opacity": this.opacity
              }
            });
            this.#colorPicker?.updateColor(this.color);
            super.onUpdatedColor();
          }
          #updateColor(color) {
            const setColorAndOpacity = (col, opa) => {
              this.color = col;
              this.opacity = opa;
              this.onUpdatedColor();
            };
            const savedColor = this.color;
            const savedOpacity = this.opacity;
            this.addCommands({
              cmd: setColorAndOpacity.bind(this, color, HighlightEditor._defaultOpacity),
              undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),
              post: this._uiManager.updateUI.bind(this._uiManager, this),
              mustExec: true,
              type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
              overwriteIfSameType: true,
              keepUndo: true
            });
            this._reportTelemetry({
              action: "color_changed",
              color: this._uiManager.getNonHCMColorName(color)
            }, true);
          }
          #updateThickness(thickness) {
            const savedThickness = this.#thickness;
            const setThickness = th => {
              this.#thickness = th;
              this.#changeThickness(th);
            };
            this.addCommands({
              cmd: setThickness.bind(this, thickness),
              undo: setThickness.bind(this, savedThickness),
              post: this._uiManager.updateUI.bind(this._uiManager, this),
              mustExec: true,
              type: AnnotationEditorParamsType.INK_THICKNESS,
              overwriteIfSameType: true,
              keepUndo: true
            });
            this._reportTelemetry({
              action: "thickness_changed",
              thickness
            }, true);
          }
          get toolbarButtons() {
            if (this._uiManager.highlightColors) {
              const colorPicker = this.#colorPicker = new ColorPicker({
                editor: this
              });
              return [["colorPicker", colorPicker]];
            }
            return super.toolbarButtons;
          }
          disableEditing() {
            super.disableEditing();
            this.div.classList.toggle("disabled", true);
          }
          enableEditing() {
            super.enableEditing();
            this.div.classList.toggle("disabled", false);
          }
          fixAndSetPosition() {
            return super.fixAndSetPosition(this.#getRotation());
          }
          getBaseTranslation() {
            return [0, 0];
          }
          getRect(tx, ty) {
            return super.getRect(tx, ty, this.#getRotation());
          }
          onceAdded(focus) {
            if (!this.annotationElementId) {
              this.parent.addUndoableEditor(this);
            }
            if (focus) {
              this.div.focus();
            }
          }
          remove() {
            this.#cleanDrawLayer();
            this._reportTelemetry({
              action: "deleted"
            });
            super.remove();
          }
          rebuild() {
            if (!this.parent) {
              return;
            }
            super.rebuild();
            if (this.div === null) {
              return;
            }
            this.#addToDrawLayer();
            if (!this.isAttachedToDOM) {
              this.parent.add(this);
            }
          }
          setParent(parent) {
            let mustBeSelected = false;
            if (this.parent && !parent) {
              this.#cleanDrawLayer();
            } else if (parent) {
              this.#addToDrawLayer(parent);
              mustBeSelected = !this.parent && this.div?.classList.contains("selectedEditor");
            }
            super.setParent(parent);
            this.show(this._isVisible);
            if (mustBeSelected) {
              this.select();
            }
          }
          #changeThickness(thickness) {
            if (!this.#isFreeHighlight) {
              return;
            }
            this.#createFreeOutlines({
              highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)
            });
            this.fixAndSetPosition();
            this.setDims();
          }
          #cleanDrawLayer() {
            if (this.#id === null || !this.parent) {
              return;
            }
            this.parent.drawLayer.remove(this.#id);
            this.#id = null;
            this.parent.drawLayer.remove(this.#outlineId);
            this.#outlineId = null;
          }
          #addToDrawLayer(parent = this.parent) {
            if (this.#id !== null) {
              return;
            }
            ({
              id: this.#id,
              clipPathId: this.#clipPathId
            } = parent.drawLayer.draw({
              bbox: this.#highlightOutlines.box,
              root: {
                viewBox: "0 0 1 1",
                fill: this.color,
                "fill-opacity": this.opacity
              },
              rootClass: {
                highlight: true,
                free: this.#isFreeHighlight
              },
              path: {
                d: this.#highlightOutlines.toSVGPath()
              }
            }, false, true));
            this.#outlineId = parent.drawLayer.drawOutline({
              rootClass: {
                highlightOutline: true,
                free: this.#isFreeHighlight
              },
              bbox: this.#focusOutlines.box,
              path: {
                d: this.#focusOutlines.toSVGPath()
              }
            }, this.#isFreeHighlight);
            if (this.#highlightDiv) {
              this.#highlightDiv.style.clipPath = this.#clipPathId;
            }
          }
          static #rotateBbox([x, y, width, height], angle) {
            switch (angle) {
              case 90:
                return [1 - y - height, x, height, width];
              case 180:
                return [1 - x - width, 1 - y - height, width, height];
              case 270:
                return [y, 1 - x - width, height, width];
            }
            return [x, y, width, height];
          }
          rotate(angle) {
            const {
              drawLayer
            } = this.parent;
            let box;
            if (this.#isFreeHighlight) {
              angle = (angle - this.rotation + 360) % 360;
              box = HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);
            } else {
              box = HighlightEditor.#rotateBbox([this.x, this.y, this.width, this.height], angle);
            }
            drawLayer.updateProperties(this.#id, {
              bbox: box,
              root: {
                "data-main-rotation": angle
              }
            });
            drawLayer.updateProperties(this.#outlineId, {
              bbox: HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),
              root: {
                "data-main-rotation": angle
              }
            });
          }
          render() {
            if (this.div) {
              return this.div;
            }
            const div = super.render();
            if (this.#text) {
              div.setAttribute("aria-label", this.#text);
              div.setAttribute("role", "mark");
            }
            if (this.#isFreeHighlight) {
              div.classList.add("free");
            } else {
              this.div.addEventListener("keydown", this.#keydown.bind(this), {
                signal: this._uiManager._signal
              });
            }
            const highlightDiv = this.#highlightDiv = document.createElement("div");
            div.append(highlightDiv);
            highlightDiv.setAttribute("aria-hidden", "true");
            highlightDiv.className = "internal";
            highlightDiv.style.clipPath = this.#clipPathId;
            this.setDims();
            bindEvents(this, this.#highlightDiv, ["pointerover", "pointerleave"]);
            this.enableEditing();
            return div;
          }
          pointerover() {
            if (!this.isSelected) {
              this.parent?.drawLayer.updateProperties(this.#outlineId, {
                rootClass: {
                  hovered: true
                }
              });
            }
          }
          pointerleave() {
            if (!this.isSelected) {
              this.parent?.drawLayer.updateProperties(this.#outlineId, {
                rootClass: {
                  hovered: false
                }
              });
            }
          }
          #keydown(event) {
            HighlightEditor._keyboardManager.exec(this, event);
          }
          _moveCaret(direction) {
            this.parent.unselect(this);
            switch (direction) {
              case 0:
              case 2:
                this.#setCaret(true);
                break;
              case 1:
              case 3:
                this.#setCaret(false);
                break;
            }
          }
          #setCaret(start) {
            if (!this.#anchorNode) {
              return;
            }
            const selection = window.getSelection();
            if (start) {
              selection.setPosition(this.#anchorNode, this.#anchorOffset);
            } else {
              selection.setPosition(this.#focusNode, this.#focusOffset);
            }
          }
          select() {
            super.select();
            if (!this.#outlineId) {
              return;
            }
            this.parent?.drawLayer.updateProperties(this.#outlineId, {
              rootClass: {
                hovered: false,
                selected: true
              }
            });
          }
          unselect() {
            super.unselect();
            if (!this.#outlineId) {
              return;
            }
            this.parent?.drawLayer.updateProperties(this.#outlineId, {
              rootClass: {
                selected: false
              }
            });
            if (!this.#isFreeHighlight) {
              this.#setCaret(false);
            }
          }
          get _mustFixPosition() {
            return !this.#isFreeHighlight;
          }
          show(visible = this._isVisible) {
            super.show(visible);
            if (this.parent) {
              this.parent.drawLayer.updateProperties(this.#id, {
                rootClass: {
                  hidden: !visible
                }
              });
              this.parent.drawLayer.updateProperties(this.#outlineId, {
                rootClass: {
                  hidden: !visible
                }
              });
            }
          }
          #getRotation() {
            return this.#isFreeHighlight ? this.rotation : 0;
          }
          #serializeBoxes() {
            if (this.#isFreeHighlight) {
              return null;
            }
            const [pageWidth, pageHeight] = this.pageDimensions;
            const [pageX, pageY] = this.pageTranslation;
            const boxes = this.#boxes;
            const quadPoints = new Float32Array(boxes.length * 8);
            let i = 0;
            for (const {
              x,
              y,
              width,
              height
            } of boxes) {
              const sx = x * pageWidth + pageX;
              const sy = (1 - y) * pageHeight + pageY;
              quadPoints[i] = quadPoints[i + 4] = sx;
              quadPoints[i + 1] = quadPoints[i + 3] = sy;
              quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;
              quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;
              i += 8;
            }
            return quadPoints;
          }
          #serializeOutlines(rect) {
            return this.#highlightOutlines.serialize(rect, this.#getRotation());
          }
          static startHighlighting(parent, isLTR, {
            target: textLayer,
            x,
            y
          }) {
            const {
              x: layerX,
              y: layerY,
              width: parentWidth,
              height: parentHeight
            } = textLayer.getBoundingClientRect();
            const ac = new AbortController();
            const signal = parent.combinedSignal(ac);
            const pointerUpCallback = e => {
              ac.abort();
              this.#endHighlight(parent, e);
            };
            window.addEventListener("blur", pointerUpCallback, {
              signal
            });
            window.addEventListener("pointerup", pointerUpCallback, {
              signal
            });
            window.addEventListener("pointerdown", stopEvent, {
              capture: true,
              passive: false,
              signal
            });
            window.addEventListener("contextmenu", noContextMenu, {
              signal
            });
            textLayer.addEventListener("pointermove", this.#highlightMove.bind(this, parent), {
              signal
            });
            this._freeHighlight = new FreeHighlightOutliner({
              x,
              y
            }, [layerX, layerY, parentWidth, parentHeight], parent.scale, this._defaultThickness / 2, isLTR, 0.001);
            ({
              id: this._freeHighlightId,
              clipPathId: this._freeHighlightClipId
            } = parent.drawLayer.draw({
              bbox: [0, 0, 1, 1],
              root: {
                viewBox: "0 0 1 1",
                fill: this._defaultColor,
                "fill-opacity": this._defaultOpacity
              },
              rootClass: {
                highlight: true,
                free: true
              },
              path: {
                d: this._freeHighlight.toSVGPath()
              }
            }, true, true));
          }
          static #highlightMove(parent, event) {
            if (this._freeHighlight.add(event)) {
              parent.drawLayer.updateProperties(this._freeHighlightId, {
                path: {
                  d: this._freeHighlight.toSVGPath()
                }
              });
            }
          }
          static #endHighlight(parent, event) {
            if (!this._freeHighlight.isEmpty()) {
              parent.createAndAddNewEditor(event, false, {
                highlightId: this._freeHighlightId,
                highlightOutlines: this._freeHighlight.getOutlines(),
                clipPathId: this._freeHighlightClipId,
                methodOfCreation: "main_toolbar"
              });
            } else {
              parent.drawLayer.remove(this._freeHighlightId);
            }
            this._freeHighlightId = -1;
            this._freeHighlight = null;
            this._freeHighlightClipId = "";
          }
          static async deserialize(data, parent, uiManager) {
            let initialData = null;
            if (data instanceof HighlightAnnotationElement) {
              const {
                data: {
                  quadPoints,
                  rect,
                  rotation,
                  id,
                  color,
                  opacity,
                  popupRef,
                  richText,
                  contentsObj,
                  creationDate,
                  modificationDate
                },
                parent: {
                  page: {
                    pageNumber
                  }
                }
              } = data;
              initialData = data = {
                annotationType: AnnotationEditorType.HIGHLIGHT,
                color: Array.from(color),
                opacity,
                quadPoints,
                boxes: null,
                pageIndex: pageNumber - 1,
                rect: rect.slice(0),
                rotation,
                annotationElementId: id,
                id,
                deleted: false,
                popupRef,
                richText,
                comment: contentsObj?.str || null,
                creationDate,
                modificationDate
              };
            } else if (data instanceof InkAnnotationElement) {
              const {
                data: {
                  inkLists,
                  rect,
                  rotation,
                  id,
                  color,
                  borderStyle: {
                    rawWidth: thickness
                  },
                  popupRef,
                  richText,
                  contentsObj,
                  creationDate,
                  modificationDate
                },
                parent: {
                  page: {
                    pageNumber
                  }
                }
              } = data;
              initialData = data = {
                annotationType: AnnotationEditorType.HIGHLIGHT,
                color: Array.from(color),
                thickness,
                inkLists,
                boxes: null,
                pageIndex: pageNumber - 1,
                rect: rect.slice(0),
                rotation,
                annotationElementId: id,
                id,
                deleted: false,
                popupRef,
                richText,
                comment: contentsObj?.str || null,
                creationDate,
                modificationDate
              };
            }
            const {
              color,
              quadPoints,
              inkLists,
              opacity
            } = data;
            const editor = await super.deserialize(data, parent, uiManager);
            editor.color = Util.makeHexColor(...color);
            editor.opacity = opacity || 1;
            if (inkLists) {
              editor.#thickness = data.thickness;
            }
            editor._initialData = initialData;
            if (data.comment) {
              editor.setCommentData(data);
            }
            const [pageWidth, pageHeight] = editor.pageDimensions;
            const [pageX, pageY] = editor.pageTranslation;
            if (quadPoints) {
              const boxes = editor.#boxes = [];
              for (let i = 0; i < quadPoints.length; i += 8) {
                boxes.push({
                  x: (quadPoints[i] - pageX) / pageWidth,
                  y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,
                  width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,
                  height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight
                });
              }
              editor.#createOutlines();
              editor.#addToDrawLayer();
              editor.rotate(editor.rotation);
            } else if (inkLists) {
              editor.#isFreeHighlight = true;
              const points = inkLists[0];
              const point = {
                x: points[0] - pageX,
                y: pageHeight - (points[1] - pageY)
              };
              const outliner = new FreeHighlightOutliner(point, [0, 0, pageWidth, pageHeight], 1, editor.#thickness / 2, true, 0.001);
              for (let i = 0, ii = points.length; i < ii; i += 2) {
                point.x = points[i] - pageX;
                point.y = pageHeight - (points[i + 1] - pageY);
                outliner.add(point);
              }
              const {
                id,
                clipPathId
              } = parent.drawLayer.draw({
                bbox: [0, 0, 1, 1],
                root: {
                  viewBox: "0 0 1 1",
                  fill: editor.color,
                  "fill-opacity": editor._defaultOpacity
                },
                rootClass: {
                  highlight: true,
                  free: true
                },
                path: {
                  d: outliner.toSVGPath()
                }
              }, true, true);
              editor.#createFreeOutlines({
                highlightOutlines: outliner.getOutlines(),
                highlightId: id,
                clipPathId
              });
              editor.#addToDrawLayer();
              editor.rotate(editor.parentRotation);
            }
            return editor;
          }
          serialize(isForCopying = false) {
            if (this.isEmpty() || isForCopying) {
              return null;
            }
            if (this.deleted) {
              return this.serializeDeleted();
            }
            const color = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));
            const serialized = super.serialize(isForCopying);
            Object.assign(serialized, {
              color,
              opacity: this.opacity,
              thickness: this.#thickness,
              quadPoints: this.#serializeBoxes(),
              outlines: this.#serializeOutlines(serialized.rect)
            });
            this.addComment(serialized);
            if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
              return null;
            }
            serialized.id = this.annotationElementId;
            return serialized;
          }
          #hasElementChanged(serialized) {
            const {
              color
            } = this._initialData;
            return this.hasEditedComment || serialized.color.some((c, i) => c !== color[i]);
          }
          renderAnnotationElement(annotation) {
            if (this.deleted) {
              annotation.hide();
              return null;
            }
            annotation.updateEdited({
              rect: this.getPDFRect(),
              popup: this.comment
            });
            return null;
          }
          static canCreateNewEmptyEditor() {
            return false;
          }
        }

        ;// ./src/display/editor/draw.js




        class DrawingOptions {
          #svgProperties = Object.create(null);
          updateProperty(name, value) {
            this[name] = value;
            this.updateSVGProperty(name, value);
          }
          updateProperties(properties) {
            if (!properties) {
              return;
            }
            for (const [name, value] of Object.entries(properties)) {
              if (!name.startsWith("_")) {
                this.updateProperty(name, value);
              }
            }
          }
          updateSVGProperty(name, value) {
            this.#svgProperties[name] = value;
          }
          toSVGProperties() {
            const root = this.#svgProperties;
            this.#svgProperties = Object.create(null);
            return {
              root
            };
          }
          reset() {
            this.#svgProperties = Object.create(null);
          }
          updateAll(options = this) {
            this.updateProperties(options);
          }
          clone() {
            unreachable("Not implemented");
          }
        }
        class DrawingEditor extends AnnotationEditor {
          #drawOutlines = null;
          #mustBeCommitted;
          _colorPicker = null;
          _drawId = null;
          static _currentDrawId = -1;
          static _currentParent = null;
          static #currentDraw = null;
          static #currentDrawingAC = null;
          static #currentDrawingOptions = null;
          static _INNER_MARGIN = 3;
          constructor(params) {
            super(params);
            this.#mustBeCommitted = params.mustBeCommitted || false;
            this._addOutlines(params);
          }
          onUpdatedColor() {
            this._colorPicker?.update(this.color);
            super.onUpdatedColor();
          }
          _addOutlines(params) {
            if (params.drawOutlines) {
              this.#createDrawOutlines(params);
              this.#addToDrawLayer();
            }
          }
          #createDrawOutlines({
            drawOutlines,
            drawId,
            drawingOptions
          }) {
            this.#drawOutlines = drawOutlines;
            this._drawingOptions ||= drawingOptions;
            if (!this.annotationElementId) {
              this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`);
            }
            if (drawId >= 0) {
              this._drawId = drawId;
              this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);
            } else {
              this._drawId = this.#createDrawing(drawOutlines, this.parent);
            }
            this.#updateBbox(drawOutlines.box);
          }
          #createDrawing(drawOutlines, parent) {
            const {
              id
            } = parent.drawLayer.draw(DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);
            return id;
          }
          static _mergeSVGProperties(p1, p2) {
            const p1Keys = new Set(Object.keys(p1));
            for (const [key, value] of Object.entries(p2)) {
              if (p1Keys.has(key)) {
                Object.assign(p1[key], value);
              } else {
                p1[key] = value;
              }
            }
            return p1;
          }
          static getDefaultDrawingOptions(_options) {
            unreachable("Not implemented");
          }
          static get typesMap() {
            unreachable("Not implemented");
          }
          static get isDrawer() {
            return true;
          }
          static get supportMultipleDrawings() {
            return false;
          }
          static updateDefaultParams(type, value) {
            const propertyName = this.typesMap.get(type);
            if (propertyName) {
              this._defaultDrawingOptions.updateProperty(propertyName, value);
            }
            if (this._currentParent) {
              DrawingEditor.#currentDraw.updateProperty(propertyName, value);
              this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
            }
          }
          updateParams(type, value) {
            const propertyName = this.constructor.typesMap.get(type);
            if (propertyName) {
              this._updateProperty(type, propertyName, value);
            }
          }
          static get defaultPropertiesToUpdate() {
            const properties = [];
            const options = this._defaultDrawingOptions;
            for (const [type, name] of this.typesMap) {
              properties.push([type, options[name]]);
            }
            return properties;
          }
          get propertiesToUpdate() {
            const properties = [];
            const {
              _drawingOptions
            } = this;
            for (const [type, name] of this.constructor.typesMap) {
              properties.push([type, _drawingOptions[name]]);
            }
            return properties;
          }
          _updateProperty(type, name, value) {
            const options = this._drawingOptions;
            const savedValue = options[name];
            const setter = val => {
              options.updateProperty(name, val);
              const bbox = this.#drawOutlines.updateProperty(name, val);
              if (bbox) {
                this.#updateBbox(bbox);
              }
              this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());
              if (type === this.colorType) {
                this.onUpdatedColor();
              }
            };
            this.addCommands({
              cmd: setter.bind(this, value),
              undo: setter.bind(this, savedValue),
              post: this._uiManager.updateUI.bind(this._uiManager, this),
              mustExec: true,
              type,
              overwriteIfSameType: true,
              keepUndo: true
            });
          }
          _onResizing() {
            this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {
              bbox: this.#rotateBox()
            }));
          }
          _onResized() {
            this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {
              bbox: this.#rotateBox()
            }));
          }
          _onTranslating(_x, _y) {
            this.parent?.drawLayer.updateProperties(this._drawId, {
              bbox: this.#rotateBox()
            });
          }
          _onTranslated() {
            this.parent?.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {
              bbox: this.#rotateBox()
            }));
          }
          _onStartDragging() {
            this.parent?.drawLayer.updateProperties(this._drawId, {
              rootClass: {
                moving: true
              }
            });
          }
          _onStopDragging() {
            this.parent?.drawLayer.updateProperties(this._drawId, {
              rootClass: {
                moving: false
              }
            });
          }
          commit() {
            super.commit();
            this.disableEditMode();
            this.disableEditing();
          }
          disableEditing() {
            super.disableEditing();
            this.div.classList.toggle("disabled", true);
          }
          enableEditing() {
            super.enableEditing();
            this.div.classList.toggle("disabled", false);
          }
          getBaseTranslation() {
            return [0, 0];
          }
          get isResizable() {
            return true;
          }
          onceAdded(focus) {
            if (!this.annotationElementId) {
              this.parent.addUndoableEditor(this);
            }
            this._isDraggable = true;
            if (this.#mustBeCommitted) {
              this.#mustBeCommitted = false;
              this.commit();
              this.parent.setSelected(this);
              if (focus && this.isOnScreen) {
                this.div.focus();
              }
            }
          }
          remove() {
            this.#cleanDrawLayer();
            super.remove();
          }
          rebuild() {
            if (!this.parent) {
              return;
            }
            super.rebuild();
            if (this.div === null) {
              return;
            }
            this.#addToDrawLayer();
            this.#updateBbox(this.#drawOutlines.box);
            if (!this.isAttachedToDOM) {
              this.parent.add(this);
            }
          }
          setParent(parent) {
            let mustBeSelected = false;
            if (this.parent && !parent) {
              this._uiManager.removeShouldRescale(this);
              this.#cleanDrawLayer();
            } else if (parent) {
              this._uiManager.addShouldRescale(this);
              this.#addToDrawLayer(parent);
              mustBeSelected = !this.parent && this.div?.classList.contains("selectedEditor");
            }
            super.setParent(parent);
            if (mustBeSelected) {
              this.select();
            }
          }
          #cleanDrawLayer() {
            if (this._drawId === null || !this.parent) {
              return;
            }
            this.parent.drawLayer.remove(this._drawId);
            this._drawId = null;
            this._drawingOptions.reset();
          }
          #addToDrawLayer(parent = this.parent) {
            if (this._drawId !== null && this.parent === parent) {
              return;
            }
            if (this._drawId !== null) {
              this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);
              return;
            }
            this._drawingOptions.updateAll();
            this._drawId = this.#createDrawing(this.#drawOutlines, parent);
          }
          #convertToParentSpace([x, y, width, height]) {
            const {
              parentDimensions: [pW, pH],
              rotation
            } = this;
            switch (rotation) {
              case 90:
                return [y, 1 - x, width * (pH / pW), height * (pW / pH)];
              case 180:
                return [1 - x, 1 - y, width, height];
              case 270:
                return [1 - y, x, width * (pH / pW), height * (pW / pH)];
              default:
                return [x, y, width, height];
            }
          }
          #convertToDrawSpace() {
            const {
              x,
              y,
              width,
              height,
              parentDimensions: [pW, pH],
              rotation
            } = this;
            switch (rotation) {
              case 90:
                return [1 - y, x, width * (pW / pH), height * (pH / pW)];
              case 180:
                return [1 - x, 1 - y, width, height];
              case 270:
                return [y, 1 - x, width * (pW / pH), height * (pH / pW)];
              default:
                return [x, y, width, height];
            }
          }
          #updateBbox(bbox) {
            [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);
            if (this.div) {
              this.fixAndSetPosition();
              this.setDims();
            }
            this._onResized();
          }
          #rotateBox() {
            const {
              x,
              y,
              width,
              height,
              rotation,
              parentRotation,
              parentDimensions: [pW, pH]
            } = this;
            switch ((rotation * 4 + parentRotation) / 90) {
              case 1:
                return [1 - y - height, x, height, width];
              case 2:
                return [1 - x - width, 1 - y - height, width, height];
              case 3:
                return [y, 1 - x - width, height, width];
              case 4:
                return [x, y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];
              case 5:
                return [1 - y, x, width * (pW / pH), height * (pH / pW)];
              case 6:
                return [1 - x - height * (pH / pW), 1 - y, height * (pH / pW), width * (pW / pH)];
              case 7:
                return [y - width * (pW / pH), 1 - x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];
              case 8:
                return [x - width, y - height, width, height];
              case 9:
                return [1 - y, x - width, height, width];
              case 10:
                return [1 - x, 1 - y, width, height];
              case 11:
                return [y - height, 1 - x, height, width];
              case 12:
                return [x - height * (pH / pW), y, height * (pH / pW), width * (pW / pH)];
              case 13:
                return [1 - y - width * (pW / pH), x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];
              case 14:
                return [1 - x, 1 - y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];
              case 15:
                return [y, 1 - x, width * (pW / pH), height * (pH / pW)];
              default:
                return [x, y, width, height];
            }
          }
          rotate() {
            if (!this.parent) {
              return;
            }
            this.parent.drawLayer.updateProperties(this._drawId, DrawingEditor._mergeSVGProperties({
              bbox: this.#rotateBox()
            }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));
          }
          onScaleChanging() {
            if (!this.parent) {
              return;
            }
            this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));
          }
          static onScaleChangingWhenDrawing() { }
          render() {
            if (this.div) {
              return this.div;
            }
            let baseX, baseY;
            if (this._isCopy) {
              baseX = this.x;
              baseY = this.y;
            }
            const div = super.render();
            div.classList.add("draw");
            const drawDiv = document.createElement("div");
            div.append(drawDiv);
            drawDiv.setAttribute("aria-hidden", "true");
            drawDiv.className = "internal";
            this.setDims();
            this._uiManager.addShouldRescale(this);
            this.disableEditing();
            if (this._isCopy) {
              this._moveAfterPaste(baseX, baseY);
            }
            return div;
          }
          static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {
            unreachable("Not implemented");
          }
          static startDrawing(parent, uiManager, _isLTR, event) {
            const {
              target,
              offsetX: x,
              offsetY: y,
              pointerId,
              pointerType
            } = event;
            if (CurrentPointers.isInitializedAndDifferentPointerType(pointerType)) {
              return;
            }
            const {
              viewport: {
                rotation
              }
            } = parent;
            const {
              width: parentWidth,
              height: parentHeight
            } = target.getBoundingClientRect();
            const ac = DrawingEditor.#currentDrawingAC = new AbortController();
            const signal = parent.combinedSignal(ac);
            CurrentPointers.setPointer(pointerType, pointerId);
            window.addEventListener("pointerup", e => {
              if (CurrentPointers.isSamePointerIdOrRemove(e.pointerId)) {
                this._endDraw(e);
              }
            }, {
              signal
            });
            window.addEventListener("pointercancel", e => {
              if (CurrentPointers.isSamePointerIdOrRemove(e.pointerId)) {
                this._currentParent.endDrawingSession();
              }
            }, {
              signal
            });
            window.addEventListener("pointerdown", e => {
              if (!CurrentPointers.isSamePointerType(e.pointerType)) {
                return;
              }
              CurrentPointers.initializeAndAddPointerId(e.pointerId);
              if (DrawingEditor.#currentDraw.isCancellable()) {
                DrawingEditor.#currentDraw.removeLastElement();
                if (DrawingEditor.#currentDraw.isEmpty()) {
                  this._currentParent.endDrawingSession(true);
                } else {
                  this._endDraw(null);
                }
              }
            }, {
              capture: true,
              passive: false,
              signal
            });
            window.addEventListener("contextmenu", noContextMenu, {
              signal
            });
            target.addEventListener("pointermove", this._drawMove.bind(this), {
              signal
            });
            target.addEventListener("touchmove", e => {
              if (CurrentPointers.isSameTimeStamp(e.timeStamp)) {
                stopEvent(e);
              }
            }, {
              signal
            });
            parent.toggleDrawing();
            uiManager._editorUndoBar?.hide();
            if (DrawingEditor.#currentDraw) {
              parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.startNew(x, y, parentWidth, parentHeight, rotation));
              return;
            }
            uiManager.updateUIForDefaultProperties(this);
            DrawingEditor.#currentDraw = this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation);
            DrawingEditor.#currentDrawingOptions = this.getDefaultDrawingOptions();
            this._currentParent = parent;
            ({
              id: this._currentDrawId
            } = parent.drawLayer.draw(this._mergeSVGProperties(DrawingEditor.#currentDrawingOptions.toSVGProperties(), DrawingEditor.#currentDraw.defaultSVGProperties), true, false));
          }
          static _drawMove(event) {
            CurrentPointers.isSameTimeStamp(event.timeStamp);
            if (!DrawingEditor.#currentDraw) {
              return;
            }
            const {
              offsetX,
              offsetY,
              pointerId
            } = event;
            if (!CurrentPointers.isSamePointerId(pointerId)) {
              return;
            }
            if (CurrentPointers.isUsingMultiplePointers()) {
              this._endDraw(event);
              return;
            }
            this._currentParent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.add(offsetX, offsetY));
            CurrentPointers.setTimeStamp(event.timeStamp);
            stopEvent(event);
          }
          static _cleanup(all) {
            if (all) {
              this._currentDrawId = -1;
              this._currentParent = null;
              DrawingEditor.#currentDraw = null;
              DrawingEditor.#currentDrawingOptions = null;
              CurrentPointers.clearPointerType();
              CurrentPointers.clearTimeStamp();
            }
            if (DrawingEditor.#currentDrawingAC) {
              DrawingEditor.#currentDrawingAC.abort();
              DrawingEditor.#currentDrawingAC = null;
              CurrentPointers.clearPointerIds();
            }
          }
          static _endDraw(event) {
            const parent = this._currentParent;
            if (!parent) {
              return;
            }
            parent.toggleDrawing(true);
            this._cleanup(false);
            if (event?.target === parent.div) {
              parent.drawLayer.updateProperties(this._currentDrawId, DrawingEditor.#currentDraw.end(event.offsetX, event.offsetY));
            }
            if (this.supportMultipleDrawings) {
              const draw = DrawingEditor.#currentDraw;
              const drawId = this._currentDrawId;
              const lastElement = draw.getLastElement();
              parent.addCommands({
                cmd: () => {
                  parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));
                },
                undo: () => {
                  parent.drawLayer.updateProperties(drawId, draw.removeLastElement());
                },
                mustExec: false,
                type: AnnotationEditorParamsType.DRAW_STEP
              });
              return;
            }
            this.endDrawing(false);
          }
          static endDrawing(isAborted) {
            const parent = this._currentParent;
            if (!parent) {
              return null;
            }
            parent.toggleDrawing(true);
            parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);
            if (!DrawingEditor.#currentDraw.isEmpty()) {
              const {
                pageDimensions: [pageWidth, pageHeight],
                scale
              } = parent;
              const editor = parent.createAndAddNewEditor({
                offsetX: 0,
                offsetY: 0
              }, false, {
                drawId: this._currentDrawId,
                drawOutlines: DrawingEditor.#currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),
                drawingOptions: DrawingEditor.#currentDrawingOptions,
                mustBeCommitted: !isAborted
              });
              this._cleanup(true);
              return editor;
            }
            parent.drawLayer.remove(this._currentDrawId);
            this._cleanup(true);
            return null;
          }
          createDrawingOptions(_data) { }
          static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {
            unreachable("Not implemented");
          }
          static async deserialize(data, parent, uiManager) {
            const {
              rawDims: {
                pageWidth,
                pageHeight,
                pageX,
                pageY
              }
            } = parent.viewport;
            const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);
            const editor = await super.deserialize(data, parent, uiManager);
            editor.createDrawingOptions(data);
            editor.#createDrawOutlines({
              drawOutlines
            });
            editor.#addToDrawLayer();
            editor.onScaleChanging();
            editor.rotate();
            return editor;
          }
          serializeDraw(isForCopying) {
            const [pageX, pageY] = this.pageTranslation;
            const [pageWidth, pageHeight] = this.pageDimensions;
            return this.#drawOutlines.serialize([pageX, pageY, pageWidth, pageHeight], isForCopying);
          }
          renderAnnotationElement(annotation) {
            annotation.updateEdited({
              rect: this.getPDFRect()
            });
            return null;
          }
          static canCreateNewEmptyEditor() {
            return false;
          }
        }

        ;// ./src/display/editor/drawers/inkdraw.js


        class InkDrawOutliner {
          #last = new Float64Array(6);
          #line;
          #lines;
          #rotation;
          #thickness;
          #points;
          #lastSVGPath = "";
          #lastIndex = 0;
          #outlines = new InkDrawOutline();
          #parentWidth;
          #parentHeight;
          constructor(x, y, parentWidth, parentHeight, rotation, thickness) {
            this.#parentWidth = parentWidth;
            this.#parentHeight = parentHeight;
            this.#rotation = rotation;
            this.#thickness = thickness;
            [x, y] = this.#normalizePoint(x, y);
            const line = this.#line = [NaN, NaN, NaN, NaN, x, y];
            this.#points = [x, y];
            this.#lines = [{
              line,
              points: this.#points
            }];
            this.#last.set(line, 0);
          }
          updateProperty(name, value) {
            if (name === "stroke-width") {
              this.#thickness = value;
            }
          }
          #normalizePoint(x, y) {
            return Outline._normalizePoint(x, y, this.#parentWidth, this.#parentHeight, this.#rotation);
          }
          isEmpty() {
            return !this.#lines || this.#lines.length === 0;
          }
          isCancellable() {
            return this.#points.length <= 10;
          }
          add(x, y) {
            [x, y] = this.#normalizePoint(x, y);
            const [x1, y1, x2, y2] = this.#last.subarray(2, 6);
            const diffX = x - x2;
            const diffY = y - y2;
            const d = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);
            if (d <= 2) {
              return null;
            }
            this.#points.push(x, y);
            if (isNaN(x1)) {
              this.#last.set([x2, y2, x, y], 2);
              this.#line.push(NaN, NaN, NaN, NaN, x, y);
              return {
                path: {
                  d: this.toSVGPath()
                }
              };
            }
            if (isNaN(this.#last[0])) {
              this.#line.splice(6, 6);
            }
            this.#last.set([x1, y1, x2, y2, x, y], 0);
            this.#line.push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));
            return {
              path: {
                d: this.toSVGPath()
              }
            };
          }
          end(x, y) {
            const change = this.add(x, y);
            if (change) {
              return change;
            }
            if (this.#points.length === 2) {
              return {
                path: {
                  d: this.toSVGPath()
                }
              };
            }
            return null;
          }
          startNew(x, y, parentWidth, parentHeight, rotation) {
            this.#parentWidth = parentWidth;
            this.#parentHeight = parentHeight;
            this.#rotation = rotation;
            [x, y] = this.#normalizePoint(x, y);
            const line = this.#line = [NaN, NaN, NaN, NaN, x, y];
            this.#points = [x, y];
            const last = this.#lines.at(-1);
            if (last) {
              last.line = new Float32Array(last.line);
              last.points = new Float32Array(last.points);
            }
            this.#lines.push({
              line,
              points: this.#points
            });
            this.#last.set(line, 0);
            this.#lastIndex = 0;
            this.toSVGPath();
            return null;
          }
          getLastElement() {
            return this.#lines.at(-1);
          }
          setLastElement(element) {
            if (!this.#lines) {
              return this.#outlines.setLastElement(element);
            }
            this.#lines.push(element);
            this.#line = element.line;
            this.#points = element.points;
            this.#lastIndex = 0;
            return {
              path: {
                d: this.toSVGPath()
              }
            };
          }
          removeLastElement() {
            if (!this.#lines) {
              return this.#outlines.removeLastElement();
            }
            this.#lines.pop();
            this.#lastSVGPath = "";
            for (let i = 0, ii = this.#lines.length; i < ii; i++) {
              const {
                line,
                points
              } = this.#lines[i];
              this.#line = line;
              this.#points = points;
              this.#lastIndex = 0;
              this.toSVGPath();
            }
            return {
              path: {
                d: this.#lastSVGPath
              }
            };
          }
          toSVGPath() {
            const firstX = Outline.svgRound(this.#line[4]);
            const firstY = Outline.svgRound(this.#line[5]);
            if (this.#points.length === 2) {
              this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;
              return this.#lastSVGPath;
            }
            if (this.#points.length <= 6) {
              const i = this.#lastSVGPath.lastIndexOf("M");
              this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i)} M ${firstX} ${firstY}`;
              this.#lastIndex = 6;
            }
            if (this.#points.length === 4) {
              const secondX = Outline.svgRound(this.#line[10]);
              const secondY = Outline.svgRound(this.#line[11]);
              this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;
              this.#lastIndex = 12;
              return this.#lastSVGPath;
            }
            const buffer = [];
            if (this.#lastIndex === 0) {
              buffer.push(`M ${firstX} ${firstY}`);
              this.#lastIndex = 6;
            }
            for (let i = this.#lastIndex, ii = this.#line.length; i < ii; i += 6) {
              const [c1x, c1y, c2x, c2y, x, y] = this.#line.slice(i, i + 6).map(Outline.svgRound);
              buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);
            }
            this.#lastSVGPath += buffer.join(" ");
            this.#lastIndex = this.#line.length;
            return this.#lastSVGPath;
          }
          getOutlines(parentWidth, parentHeight, scale, innerMargin) {
            const last = this.#lines.at(-1);
            last.line = new Float32Array(last.line);
            last.points = new Float32Array(last.points);
            this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);
            this.#last = null;
            this.#line = null;
            this.#lines = null;
            this.#lastSVGPath = null;
            return this.#outlines;
          }
          get defaultSVGProperties() {
            return {
              root: {
                viewBox: "0 0 10000 10000"
              },
              rootClass: {
                draw: true
              },
              bbox: [0, 0, 1, 1]
            };
          }
        }
        class InkDrawOutline extends Outline {
          #bbox;
          #currentRotation = 0;
          #innerMargin;
          #lines;
          #parentWidth;
          #parentHeight;
          #parentScale;
          #rotation;
          #thickness;
          build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {
            this.#parentWidth = parentWidth;
            this.#parentHeight = parentHeight;
            this.#parentScale = parentScale;
            this.#rotation = rotation;
            this.#thickness = thickness;
            this.#innerMargin = innerMargin ?? 0;
            this.#lines = lines;
            this.#computeBbox();
          }
          get thickness() {
            return this.#thickness;
          }
          setLastElement(element) {
            this.#lines.push(element);
            return {
              path: {
                d: this.toSVGPath()
              }
            };
          }
          removeLastElement() {
            this.#lines.pop();
            return {
              path: {
                d: this.toSVGPath()
              }
            };
          }
          toSVGPath() {
            const buffer = [];
            for (const {
              line
            } of this.#lines) {
              buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);
              if (line.length === 6) {
                buffer.push("Z");
                continue;
              }
              if (line.length === 12 && isNaN(line[6])) {
                buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);
                continue;
              }
              for (let i = 6, ii = line.length; i < ii; i += 6) {
                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);
                buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);
              }
            }
            return buffer.join("");
          }
          serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {
            const serializedLines = [];
            const serializedPoints = [];
            const [x, y, width, height] = this.#getBBoxWithNoMargin();
            let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;
            switch (this.#rotation) {
              case 0:
                rescaleFn = Outline._rescale;
                tx = pageX;
                ty = pageY + pageHeight;
                sx = pageWidth;
                sy = -pageHeight;
                x1 = pageX + x * pageWidth;
                y1 = pageY + (1 - y - height) * pageHeight;
                x2 = pageX + (x + width) * pageWidth;
                y2 = pageY + (1 - y) * pageHeight;
                break;
              case 90:
                rescaleFn = Outline._rescaleAndSwap;
                tx = pageX;
                ty = pageY;
                sx = pageWidth;
                sy = pageHeight;
                x1 = pageX + y * pageWidth;
                y1 = pageY + x * pageHeight;
                x2 = pageX + (y + height) * pageWidth;
                y2 = pageY + (x + width) * pageHeight;
                break;
              case 180:
                rescaleFn = Outline._rescale;
                tx = pageX + pageWidth;
                ty = pageY;
                sx = -pageWidth;
                sy = pageHeight;
                x1 = pageX + (1 - x - width) * pageWidth;
                y1 = pageY + y * pageHeight;
                x2 = pageX + (1 - x) * pageWidth;
                y2 = pageY + (y + height) * pageHeight;
                break;
              case 270:
                rescaleFn = Outline._rescaleAndSwap;
                tx = pageX + pageWidth;
                ty = pageY + pageHeight;
                sx = -pageWidth;
                sy = -pageHeight;
                x1 = pageX + (1 - y - height) * pageWidth;
                y1 = pageY + (1 - x - width) * pageHeight;
                x2 = pageX + (1 - y) * pageWidth;
                y2 = pageY + (1 - x) * pageHeight;
                break;
            }
            for (const {
              line,
              points
            } of this.#lines) {
              serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));
              serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));
            }
            return {
              lines: serializedLines,
              points: serializedPoints,
              rect: [x1, y1, x2, y2]
            };
          }
          static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, {
            paths: {
              lines,
              points
            },
            rotation,
            thickness
          }) {
            const newLines = [];
            let tx, ty, sx, sy, rescaleFn;
            switch (rotation) {
              case 0:
                rescaleFn = Outline._rescale;
                tx = -pageX / pageWidth;
                ty = pageY / pageHeight + 1;
                sx = 1 / pageWidth;
                sy = -1 / pageHeight;
                break;
              case 90:
                rescaleFn = Outline._rescaleAndSwap;
                tx = -pageY / pageHeight;
                ty = -pageX / pageWidth;
                sx = 1 / pageHeight;
                sy = 1 / pageWidth;
                break;
              case 180:
                rescaleFn = Outline._rescale;
                tx = pageX / pageWidth + 1;
                ty = -pageY / pageHeight;
                sx = -1 / pageWidth;
                sy = 1 / pageHeight;
                break;
              case 270:
                rescaleFn = Outline._rescaleAndSwap;
                tx = pageY / pageHeight + 1;
                ty = pageX / pageWidth + 1;
                sx = -1 / pageHeight;
                sy = -1 / pageWidth;
                break;
            }
            if (!lines) {
              lines = [];
              for (const point of points) {
                const len = point.length;
                if (len === 2) {
                  lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1]]));
                  continue;
                }
                if (len === 4) {
                  lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1], NaN, NaN, NaN, NaN, point[2], point[3]]));
                  continue;
                }
                const line = new Float32Array(3 * (len - 2));
                lines.push(line);
                let [x1, y1, x2, y2] = point.subarray(0, 4);
                line.set([NaN, NaN, NaN, NaN, x1, y1], 0);
                for (let i = 4; i < len; i += 2) {
                  const x = point[i];
                  const y = point[i + 1];
                  line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);
                  [x1, y1, x2, y2] = [x2, y2, x, y];
                }
              }
            }
            for (let i = 0, ii = lines.length; i < ii; i++) {
              newLines.push({
                line: rescaleFn(lines[i].map(x => x ?? NaN), tx, ty, sx, sy),
                points: rescaleFn(points[i].map(x => x ?? NaN), tx, ty, sx, sy)
              });
            }
            const outlines = new this.prototype.constructor();
            outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);
            return outlines;
          }
          #getMarginComponents(thickness = this.#thickness) {
            const margin = this.#innerMargin + thickness / 2 * this.#parentScale;
            return this.#rotation % 180 === 0 ? [margin / this.#parentWidth, margin / this.#parentHeight] : [margin / this.#parentHeight, margin / this.#parentWidth];
          }
          #getBBoxWithNoMargin() {
            const [x, y, width, height] = this.#bbox;
            const [marginX, marginY] = this.#getMarginComponents(0);
            return [x + marginX, y + marginY, width - 2 * marginX, height - 2 * marginY];
          }
          #computeBbox() {
            const bbox = this.#bbox = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);
            for (const {
              line
            } of this.#lines) {
              if (line.length <= 12) {
                for (let i = 4, ii = line.length; i < ii; i += 6) {
                  Util.pointBoundingBox(line[i], line[i + 1], bbox);
                }
                continue;
              }
              let lastX = line[4],
                lastY = line[5];
              for (let i = 6, ii = line.length; i < ii; i += 6) {
                const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);
                Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);
                lastX = x;
                lastY = y;
              }
            }
            const [marginX, marginY] = this.#getMarginComponents();
            bbox[0] = MathClamp(bbox[0] - marginX, 0, 1);
            bbox[1] = MathClamp(bbox[1] - marginY, 0, 1);
            bbox[2] = MathClamp(bbox[2] + marginX, 0, 1);
            bbox[3] = MathClamp(bbox[3] + marginY, 0, 1);
            bbox[2] -= bbox[0];
            bbox[3] -= bbox[1];
          }
          get box() {
            return this.#bbox;
          }
          updateProperty(name, value) {
            if (name === "stroke-width") {
              return this.#updateThickness(value);
            }
            return null;
          }
          #updateThickness(thickness) {
            const [oldMarginX, oldMarginY] = this.#getMarginComponents();
            this.#thickness = thickness;
            const [newMarginX, newMarginY] = this.#getMarginComponents();
            const [diffMarginX, diffMarginY] = [newMarginX - oldMarginX, newMarginY - oldMarginY];
            const bbox = this.#bbox;
            bbox[0] -= diffMarginX;
            bbox[1] -= diffMarginY;
            bbox[2] += 2 * diffMarginX;
            bbox[3] += 2 * diffMarginY;
            return bbox;
          }
          updateParentDimensions([width, height], scale) {
            const [oldMarginX, oldMarginY] = this.#getMarginComponents();
            this.#parentWidth = width;
            this.#parentHeight = height;
            this.#parentScale = scale;
            const [newMarginX, newMarginY] = this.#getMarginComponents();
            const diffMarginX = newMarginX - oldMarginX;
            const diffMarginY = newMarginY - oldMarginY;
            const bbox = this.#bbox;
            bbox[0] -= diffMarginX;
            bbox[1] -= diffMarginY;
            bbox[2] += 2 * diffMarginX;
            bbox[3] += 2 * diffMarginY;
            return bbox;
          }
          updateRotation(rotation) {
            this.#currentRotation = rotation;
            return {
              path: {
                transform: this.rotationTransform
              }
            };
          }
          get viewBox() {
            return this.#bbox.map(Outline.svgRound).join(" ");
          }
          get defaultProperties() {
            const [x, y] = this.#bbox;
            return {
              root: {
                viewBox: this.viewBox
              },
              path: {
                "transform-origin": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`
              }
            };
          }
          get rotationTransform() {
            const [, , width, height] = this.#bbox;
            let a = 0,
              b = 0,
              c = 0,
              d = 0,
              e = 0,
              f = 0;
            switch (this.#currentRotation) {
              case 90:
                b = height / width;
                c = -width / height;
                e = width;
                break;
              case 180:
                a = -1;
                d = -1;
                e = width;
                f = height;
                break;
              case 270:
                b = -height / width;
                c = width / height;
                f = height;
                break;
              default:
                return "";
            }
            return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;
          }
          getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {
            const [marginX, marginY] = this.#getMarginComponents();
            const [x, y, width, height] = this.#bbox;
            if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
              const tx = newX + newWidth / 2 - (x + width / 2);
              const ty = newY + newHeight / 2 - (y + height / 2);
              return {
                path: {
                  "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
                  transform: `${this.rotationTransform} translate(${tx} ${ty})`
                }
              };
            }
            const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
            const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
            const s2x = width / newWidth;
            const s2y = height / newHeight;
            return {
              path: {
                "transform-origin": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,
                transform: `${this.rotationTransform} scale(${s2x} ${s2y}) ` + `translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) ` + `translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`
              }
            };
          }
          getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {
            const [marginX, marginY] = this.#getMarginComponents();
            const bbox = this.#bbox;
            const [x, y, width, height] = bbox;
            bbox[0] = newX;
            bbox[1] = newY;
            bbox[2] = newWidth;
            bbox[3] = newHeight;
            if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
              const tx = newX + newWidth / 2 - (x + width / 2);
              const ty = newY + newHeight / 2 - (y + height / 2);
              for (const {
                line,
                points
              } of this.#lines) {
                Outline._translate(line, tx, ty, line);
                Outline._translate(points, tx, ty, points);
              }
              return {
                root: {
                  viewBox: this.viewBox
                },
                path: {
                  "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
                  transform: this.rotationTransform || null,
                  d: this.toSVGPath()
                }
              };
            }
            const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
            const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
            const tx = -s1x * (x + marginX) + newX + marginX;
            const ty = -s1y * (y + marginY) + newY + marginY;
            if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {
              for (const {
                line,
                points
              } of this.#lines) {
                Outline._rescale(line, tx, ty, s1x, s1y, line);
                Outline._rescale(points, tx, ty, s1x, s1y, points);
              }
            }
            return {
              root: {
                viewBox: this.viewBox
              },
              path: {
                "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
                transform: this.rotationTransform || null,
                d: this.toSVGPath()
              }
            };
          }
          getPathTranslatedSVGProperties([newX, newY], parentDimensions) {
            const [newParentWidth, newParentHeight] = parentDimensions;
            const bbox = this.#bbox;
            const tx = newX - bbox[0];
            const ty = newY - bbox[1];
            if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) {
              for (const {
                line,
                points
              } of this.#lines) {
                Outline._translate(line, tx, ty, line);
                Outline._translate(points, tx, ty, points);
              }
            } else {
              const sx = this.#parentWidth / newParentWidth;
              const sy = this.#parentHeight / newParentHeight;
              this.#parentWidth = newParentWidth;
              this.#parentHeight = newParentHeight;
              for (const {
                line,
                points
              } of this.#lines) {
                Outline._rescale(line, tx, ty, sx, sy, line);
                Outline._rescale(points, tx, ty, sx, sy, points);
              }
              bbox[2] *= sx;
              bbox[3] *= sy;
            }
            bbox[0] = newX;
            bbox[1] = newY;
            return {
              root: {
                viewBox: this.viewBox
              },
              path: {
                d: this.toSVGPath(),
                "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`
              }
            };
          }
          get defaultSVGProperties() {
            const bbox = this.#bbox;
            return {
              root: {
                viewBox: this.viewBox
              },
              rootClass: {
                draw: true
              },
              path: {
                d: this.toSVGPath(),
                "transform-origin": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,
                transform: this.rotationTransform || null
              },
              bbox
            };
          }
        }

        ;// ./src/display/editor/ink.js






        class InkDrawingOptions extends DrawingOptions {
          constructor(viewerParameters) {
            super();
            this._viewParameters = viewerParameters;
            super.updateProperties({
              fill: "none",
              stroke: AnnotationEditor._defaultLineColor,
              "stroke-opacity": 1,
              "stroke-width": 1,
              "stroke-linecap": "round",
              "stroke-linejoin": "round",
              "stroke-miterlimit": 10
            });
          }
          updateSVGProperty(name, value) {
            if (name === "stroke-width") {
              value ??= this["stroke-width"];
              value *= this._viewParameters.realScale;
            }
            super.updateSVGProperty(name, value);
          }
          clone() {
            const clone = new InkDrawingOptions(this._viewParameters);
            clone.updateAll(this);
            return clone;
          }
        }
        class InkEditor extends DrawingEditor {
          static _type = "ink";
          static _editorType = AnnotationEditorType.INK;
          static _defaultDrawingOptions = null;
          constructor(params) {
            super({
              ...params,
              name: "inkEditor"
            });
            this._willKeepAspectRatio = true;
            this.defaultL10nId = "pdfjs-editor-ink-editor";
          }
          static initialize(l10n, uiManager) {
            AnnotationEditor.initialize(l10n, uiManager);
            this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);
          }
          static getDefaultDrawingOptions(options) {
            const clone = this._defaultDrawingOptions.clone();
            clone.updateProperties(options);
            return clone;
          }
          static get supportMultipleDrawings() {
            return true;
          }
          static get typesMap() {
            return shadow(this, "typesMap", new Map([[AnnotationEditorParamsType.INK_THICKNESS, "stroke-width"], [AnnotationEditorParamsType.INK_COLOR, "stroke"], [AnnotationEditorParamsType.INK_OPACITY, "stroke-opacity"]]));
          }
          static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {
            return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions["stroke-width"]);
          }
          static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {
            return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
          }
          static async deserialize(data, parent, uiManager) {
            let initialData = null;
            if (data instanceof InkAnnotationElement) {
              const {
                data: {
                  inkLists,
                  rect,
                  rotation,
                  id,
                  color,
                  opacity,
                  borderStyle: {
                    rawWidth: thickness
                  },
                  popupRef,
                  richText,
                  contentsObj,
                  creationDate,
                  modificationDate
                },
                parent: {
                  page: {
                    pageNumber
                  }
                }
              } = data;
              initialData = data = {
                annotationType: AnnotationEditorType.INK,
                color: Array.from(color),
                thickness,
                opacity,
                paths: {
                  points: inkLists
                },
                boxes: null,
                pageIndex: pageNumber - 1,
                rect: rect.slice(0),
                rotation,
                annotationElementId: id,
                id,
                deleted: false,
                popupRef,
                richText,
                comment: contentsObj?.str || null,
                creationDate,
                modificationDate
              };
            }
            const editor = await super.deserialize(data, parent, uiManager);
            editor._initialData = initialData;
            if (data.comment) {
              editor.setCommentData(data);
            }
            return editor;
          }
          get toolbarButtons() {
            this._colorPicker ||= new BasicColorPicker(this);
            return [["colorPicker", this._colorPicker]];
          }
          get colorType() {
            return AnnotationEditorParamsType.INK_COLOR;
          }
          get color() {
            return this._drawingOptions.stroke;
          }
          get opacity() {
            return this._drawingOptions["stroke-opacity"];
          }
          onScaleChanging() {
            if (!this.parent) {
              return;
            }
            super.onScaleChanging();
            const {
              _drawId,
              _drawingOptions,
              parent
            } = this;
            _drawingOptions.updateSVGProperty("stroke-width");
            parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());
          }
          static onScaleChangingWhenDrawing() {
            const parent = this._currentParent;
            if (!parent) {
              return;
            }
            super.onScaleChangingWhenDrawing();
            this._defaultDrawingOptions.updateSVGProperty("stroke-width");
            parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
          }
          createDrawingOptions({
            color,
            thickness,
            opacity
          }) {
            this._drawingOptions = InkEditor.getDefaultDrawingOptions({
              stroke: Util.makeHexColor(...color),
              "stroke-width": thickness,
              "stroke-opacity": opacity
            });
          }
          serialize(isForCopying = false) {
            if (this.isEmpty()) {
              return null;
            }
            if (this.deleted) {
              return this.serializeDeleted();
            }
            const {
              lines,
              points
            } = this.serializeDraw(isForCopying);
            const {
              _drawingOptions: {
                stroke,
                "stroke-opacity": opacity,
                "stroke-width": thickness
              }
            } = this;
            const serialized = Object.assign(super.serialize(isForCopying), {
              color: AnnotationEditor._colorManager.convert(stroke),
              opacity,
              thickness,
              paths: {
                lines,
                points
              }
            });
            this.addComment(serialized);
            if (isForCopying) {
              serialized.isCopy = true;
              return serialized;
            }
            if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
              return null;
            }
            serialized.id = this.annotationElementId;
            return serialized;
          }
          #hasElementChanged(serialized) {
            const {
              color,
              thickness,
              opacity,
              pageIndex
            } = this._initialData;
            return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i) => c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;
          }
          renderAnnotationElement(annotation) {
            if (this.deleted) {
              annotation.hide();
              return null;
            }
            const {
              points,
              rect
            } = this.serializeDraw(false);
            annotation.updateEdited({
              rect,
              thickness: this._drawingOptions["stroke-width"],
              points,
              popup: this.comment
            });
            return null;
          }
        }

        ;// ./src/display/editor/drawers/contour.js

        class ContourDrawOutline extends InkDrawOutline {
          toSVGPath() {
            let path = super.toSVGPath();
            if (!path.endsWith("Z")) {
              path += "Z";
            }
            return path;
          }
        }

        ;// ./src/display/editor/drawers/signaturedraw.js




        const BASE_HEADER_LENGTH = 8;
        const POINTS_PROPERTIES_NUMBER = 3;
        class SignatureExtractor {
          static #PARAMETERS = {
            maxDim: 512,
            sigmaSFactor: 0.02,
            sigmaR: 25,
            kernelSize: 16
          };
          static #neighborIndexToId(i0, j0, i, j) {
            i -= i0;
            j -= j0;
            if (i === 0) {
              return j > 0 ? 0 : 4;
            }
            if (i === 1) {
              return j + 6;
            }
            return 2 - j;
          }
          static #neighborIdToIndex = new Int32Array([0, 1, -1, 1, -1, 0, -1, -1, 0, -1, 1, -1, 1, 0, 1, 1]);
          static #clockwiseNonZero(buf, width, i0, j0, i, j, offset) {
            const id = this.#neighborIndexToId(i0, j0, i, j);
            for (let k = 0; k < 8; k++) {
              const kk = (-k + id - offset + 16) % 8;
              const shiftI = this.#neighborIdToIndex[2 * kk];
              const shiftJ = this.#neighborIdToIndex[2 * kk + 1];
              if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {
                return kk;
              }
            }
            return -1;
          }
          static #counterClockwiseNonZero(buf, width, i0, j0, i, j, offset) {
            const id = this.#neighborIndexToId(i0, j0, i, j);
            for (let k = 0; k < 8; k++) {
              const kk = (k + id + offset + 16) % 8;
              const shiftI = this.#neighborIdToIndex[2 * kk];
              const shiftJ = this.#neighborIdToIndex[2 * kk + 1];
              if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {
                return kk;
              }
            }
            return -1;
          }
          static #findContours(buf, width, height, threshold) {
            const N = buf.length;
            const types = new Int32Array(N);
            for (let i = 0; i < N; i++) {
              types[i] = buf[i] <= threshold ? 1 : 0;
            }
            for (let i = 1; i < height - 1; i++) {
              types[i * width] = types[i * width + width - 1] = 0;
            }
            for (let i = 0; i < width; i++) {
              types[i] = types[width * height - 1 - i] = 0;
            }
            let nbd = 1;
            let lnbd;
            const contours = [];
            for (let i = 1; i < height - 1; i++) {
              lnbd = 1;
              for (let j = 1; j < width - 1; j++) {
                const ij = i * width + j;
                const pix = types[ij];
                if (pix === 0) {
                  continue;
                }
                let i2 = i;
                let j2 = j;
                if (pix === 1 && types[ij - 1] === 0) {
                  nbd += 1;
                  j2 -= 1;
                } else if (pix >= 1 && types[ij + 1] === 0) {
                  nbd += 1;
                  j2 += 1;
                  if (pix > 1) {
                    lnbd = pix;
                  }
                } else {
                  if (pix !== 1) {
                    lnbd = Math.abs(pix);
                  }
                  continue;
                }
                const points = [j, i];
                const isHole = j2 === j + 1;
                const contour = {
                  isHole,
                  points,
                  id: nbd,
                  parent: 0
                };
                contours.push(contour);
                let contour0;
                for (const c of contours) {
                  if (c.id === lnbd) {
                    contour0 = c;
                    break;
                  }
                }
                if (!contour0) {
                  contour.parent = isHole ? lnbd : 0;
                } else if (contour0.isHole) {
                  contour.parent = isHole ? contour0.parent : lnbd;
                } else {
                  contour.parent = isHole ? lnbd : contour0.parent;
                }
                const k = this.#clockwiseNonZero(types, width, i, j, i2, j2, 0);
                if (k === -1) {
                  types[ij] = -nbd;
                  if (types[ij] !== 1) {
                    lnbd = Math.abs(types[ij]);
                  }
                  continue;
                }
                let shiftI = this.#neighborIdToIndex[2 * k];
                let shiftJ = this.#neighborIdToIndex[2 * k + 1];
                const i1 = i + shiftI;
                const j1 = j + shiftJ;
                i2 = i1;
                j2 = j1;
                let i3 = i;
                let j3 = j;
                while (true) {
                  const kk = this.#counterClockwiseNonZero(types, width, i3, j3, i2, j2, 1);
                  shiftI = this.#neighborIdToIndex[2 * kk];
                  shiftJ = this.#neighborIdToIndex[2 * kk + 1];
                  const i4 = i3 + shiftI;
                  const j4 = j3 + shiftJ;
                  points.push(j4, i4);
                  const ij3 = i3 * width + j3;
                  if (types[ij3 + 1] === 0) {
                    types[ij3] = -nbd;
                  } else if (types[ij3] === 1) {
                    types[ij3] = nbd;
                  }
                  if (i4 === i && j4 === j && i3 === i1 && j3 === j1) {
                    if (types[ij] !== 1) {
                      lnbd = Math.abs(types[ij]);
                    }
                    break;
                  } else {
                    i2 = i3;
                    j2 = j3;
                    i3 = i4;
                    j3 = j4;
                  }
                }
              }
            }
            return contours;
          }
          static #douglasPeuckerHelper(points, start, end, output) {
            if (end - start <= 4) {
              for (let i = start; i < end - 2; i += 2) {
                output.push(points[i], points[i + 1]);
              }
              return;
            }
            const ax = points[start];
            const ay = points[start + 1];
            const abx = points[end - 4] - ax;
            const aby = points[end - 3] - ay;
            const dist = Math.hypot(abx, aby);
            const nabx = abx / dist;
            const naby = aby / dist;
            const aa = nabx * ay - naby * ax;
            const m = aby / abx;
            const invS = 1 / dist;
            const phi = Math.atan(m);
            const cosPhi = Math.cos(phi);
            const sinPhi = Math.sin(phi);
            const tmax = invS * (Math.abs(cosPhi) + Math.abs(sinPhi));
            const poly = invS * (1 - tmax + tmax ** 2);
            const partialPhi = Math.max(Math.atan(Math.abs(sinPhi + cosPhi) * poly), Math.atan(Math.abs(sinPhi - cosPhi) * poly));
            let dmax = 0;
            let index = start;
            for (let i = start + 2; i < end - 2; i += 2) {
              const d = Math.abs(aa - nabx * points[i + 1] + naby * points[i]);
              if (d > dmax) {
                index = i;
                dmax = d;
              }
            }
            if (dmax > (dist * partialPhi) ** 2) {
              this.#douglasPeuckerHelper(points, start, index + 2, output);
              this.#douglasPeuckerHelper(points, index, end, output);
            } else {
              output.push(ax, ay);
            }
          }
          static #douglasPeucker(points) {
            const output = [];
            const len = points.length;
            this.#douglasPeuckerHelper(points, 0, len, output);
            output.push(points[len - 2], points[len - 1]);
            return output.length <= 4 ? null : output;
          }
          static #bilateralFilter(buf, width, height, sigmaS, sigmaR, kernelSize) {
            const kernel = new Float32Array(kernelSize ** 2);
            const sigmaS2 = -2 * sigmaS ** 2;
            const halfSize = kernelSize >> 1;
            for (let i = 0; i < kernelSize; i++) {
              const x = (i - halfSize) ** 2;
              for (let j = 0; j < kernelSize; j++) {
                kernel[i * kernelSize + j] = Math.exp((x + (j - halfSize) ** 2) / sigmaS2);
              }
            }
            const rangeValues = new Float32Array(256);
            const sigmaR2 = -2 * sigmaR ** 2;
            for (let i = 0; i < 256; i++) {
              rangeValues[i] = Math.exp(i ** 2 / sigmaR2);
            }
            const N = buf.length;
            const out = new Uint8Array(N);
            const histogram = new Uint32Array(256);
            for (let i = 0; i < height; i++) {
              for (let j = 0; j < width; j++) {
                const ij = i * width + j;
                const center = buf[ij];
                let sum = 0;
                let norm = 0;
                for (let k = 0; k < kernelSize; k++) {
                  const y = i + k - halfSize;
                  if (y < 0 || y >= height) {
                    continue;
                  }
                  for (let l = 0; l < kernelSize; l++) {
                    const x = j + l - halfSize;
                    if (x < 0 || x >= width) {
                      continue;
                    }
                    const neighbour = buf[y * width + x];
                    const w = kernel[k * kernelSize + l] * rangeValues[Math.abs(neighbour - center)];
                    sum += neighbour * w;
                    norm += w;
                  }
                }
                const pix = out[ij] = Math.round(sum / norm);
                histogram[pix]++;
              }
            }
            return [out, histogram];
          }
          static #getHistogram(buf) {
            const histogram = new Uint32Array(256);
            for (const g of buf) {
              histogram[g]++;
            }
            return histogram;
          }
          static #toUint8(buf) {
            const N = buf.length;
            const out = new Uint8ClampedArray(N >> 2);
            let max = -Infinity;
            let min = Infinity;
            for (let i = 0, ii = out.length; i < ii; i++) {
              const pix = out[i] = buf[i << 2];
              max = Math.max(max, pix);
              min = Math.min(min, pix);
            }
            const ratio = 255 / (max - min);
            for (let i = 0, ii = out.length; i < ii; i++) {
              out[i] = (out[i] - min) * ratio;
            }
            return out;
          }
          static #guessThreshold(histogram) {
            let i;
            let M = -Infinity;
            let L = -Infinity;
            const min = histogram.findIndex(v => v !== 0);
            let pos = min;
            let spos = min;
            for (i = min; i < 256; i++) {
              const v = histogram[i];
              if (v > M) {
                if (i - pos > L) {
                  L = i - pos;
                  spos = i - 1;
                }
                M = v;
                pos = i;
              }
            }
            for (i = spos - 1; i >= 0; i--) {
              if (histogram[i] > histogram[i + 1]) {
                break;
              }
            }
            return i;
          }
          static #getGrayPixels(bitmap) {
            const originalBitmap = bitmap;
            const {
              width,
              height
            } = bitmap;
            const {
              maxDim
            } = this.#PARAMETERS;
            let newWidth = width;
            let newHeight = height;
            if (width > maxDim || height > maxDim) {
              let prevWidth = width;
              let prevHeight = height;
              let steps = Math.log2(Math.max(width, height) / maxDim);
              const isteps = Math.floor(steps);
              steps = steps === isteps ? isteps - 1 : isteps;
              for (let i = 0; i < steps; i++) {
                newWidth = Math.ceil(prevWidth / 2);
                newHeight = Math.ceil(prevHeight / 2);
                const offscreen = new OffscreenCanvas(newWidth, newHeight);
                const ctx = offscreen.getContext("2d");
                ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
                prevWidth = newWidth;
                prevHeight = newHeight;
                if (bitmap !== originalBitmap) {
                  bitmap.close();
                }
                bitmap = offscreen.transferToImageBitmap();
              }
              const ratio = Math.min(maxDim / newWidth, maxDim / newHeight);
              newWidth = Math.round(newWidth * ratio);
              newHeight = Math.round(newHeight * ratio);
            }
            const offscreen = new OffscreenCanvas(newWidth, newHeight);
            const ctx = offscreen.getContext("2d", {
              willReadFrequently: true
            });
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, newWidth, newHeight);
            ctx.filter = "grayscale(1)";
            ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newWidth, newHeight);
            const grayImage = ctx.getImageData(0, 0, newWidth, newHeight).data;
            const uint8Buf = this.#toUint8(grayImage);
            return [uint8Buf, newWidth, newHeight];
          }
          static extractContoursFromText(text, {
            fontFamily,
            fontStyle,
            fontWeight
          }, pageWidth, pageHeight, rotation, innerMargin) {
            let canvas = new OffscreenCanvas(1, 1);
            let ctx = canvas.getContext("2d", {
              alpha: false
            });
            const fontSize = 200;
            const font = ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
            const {
              actualBoundingBoxLeft,
              actualBoundingBoxRight,
              actualBoundingBoxAscent,
              actualBoundingBoxDescent,
              fontBoundingBoxAscent,
              fontBoundingBoxDescent,
              width
            } = ctx.measureText(text);
            const SCALE = 1.5;
            const canvasWidth = Math.ceil(Math.max(Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) || 0, width) * SCALE);
            const canvasHeight = Math.ceil(Math.max(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent) || fontSize, Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || fontSize) * SCALE);
            canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
            ctx = canvas.getContext("2d", {
              alpha: true,
              willReadFrequently: true
            });
            ctx.font = font;
            ctx.filter = "grayscale(1)";
            ctx.fillStyle = "white";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            ctx.fillStyle = "black";
            ctx.fillText(text, canvasWidth * (SCALE - 1) / 2, canvasHeight * (3 - SCALE) / 2);
            const uint8Buf = this.#toUint8(ctx.getImageData(0, 0, canvasWidth, canvasHeight).data);
            const histogram = this.#getHistogram(uint8Buf);
            const threshold = this.#guessThreshold(histogram);
            const contourList = this.#findContours(uint8Buf, canvasWidth, canvasHeight, threshold);
            return this.processDrawnLines({
              lines: {
                curves: contourList,
                width: canvasWidth,
                height: canvasHeight
              },
              pageWidth,
              pageHeight,
              rotation,
              innerMargin,
              mustSmooth: true,
              areContours: true
            });
          }
          static process(bitmap, pageWidth, pageHeight, rotation, innerMargin) {
            const [uint8Buf, width, height] = this.#getGrayPixels(bitmap);
            const [buffer, histogram] = this.#bilateralFilter(uint8Buf, width, height, Math.hypot(width, height) * this.#PARAMETERS.sigmaSFactor, this.#PARAMETERS.sigmaR, this.#PARAMETERS.kernelSize);
            const threshold = this.#guessThreshold(histogram);
            const contourList = this.#findContours(buffer, width, height, threshold);
            return this.processDrawnLines({
              lines: {
                curves: contourList,
                width,
                height
              },
              pageWidth,
              pageHeight,
              rotation,
              innerMargin,
              mustSmooth: true,
              areContours: true
            });
          }
          static processDrawnLines({
            lines,
            pageWidth,
            pageHeight,
            rotation,
            innerMargin,
            mustSmooth,
            areContours
          }) {
            if (rotation % 180 !== 0) {
              [pageWidth, pageHeight] = [pageHeight, pageWidth];
            }
            const {
              curves,
              width,
              height
            } = lines;
            const thickness = lines.thickness ?? 0;
            const linesAndPoints = [];
            const ratio = Math.min(pageWidth / width, pageHeight / height);
            const xScale = ratio / pageWidth;
            const yScale = ratio / pageHeight;
            const newCurves = [];
            for (const {
              points
            } of curves) {
              const reducedPoints = mustSmooth ? this.#douglasPeucker(points) : points;
              if (!reducedPoints) {
                continue;
              }
              newCurves.push(reducedPoints);
              const len = reducedPoints.length;
              const newPoints = new Float32Array(len);
              const line = new Float32Array(3 * (len === 2 ? 2 : len - 2));
              linesAndPoints.push({
                line,
                points: newPoints
              });
              if (len === 2) {
                newPoints[0] = reducedPoints[0] * xScale;
                newPoints[1] = reducedPoints[1] * yScale;
                line.set([NaN, NaN, NaN, NaN, newPoints[0], newPoints[1]], 0);
                continue;
              }
              let [x1, y1, x2, y2] = reducedPoints;
              x1 *= xScale;
              y1 *= yScale;
              x2 *= xScale;
              y2 *= yScale;
              newPoints.set([x1, y1, x2, y2], 0);
              line.set([NaN, NaN, NaN, NaN, x1, y1], 0);
              for (let i = 4; i < len; i += 2) {
                const x = newPoints[i] = reducedPoints[i] * xScale;
                const y = newPoints[i + 1] = reducedPoints[i + 1] * yScale;
                line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);
                [x1, y1, x2, y2] = [x2, y2, x, y];
              }
            }
            if (linesAndPoints.length === 0) {
              return null;
            }
            const outline = areContours ? new ContourDrawOutline() : new InkDrawOutline();
            outline.build(linesAndPoints, pageWidth, pageHeight, 1, rotation, areContours ? 0 : thickness, innerMargin);
            return {
              outline,
              newCurves,
              areContours,
              thickness,
              width,
              height
            };
          }
          static async compressSignature({
            outlines,
            areContours,
            thickness,
            width,
            height
          }) {
            let minDiff = Infinity;
            let maxDiff = -Infinity;
            let outlinesLength = 0;
            for (const points of outlines) {
              outlinesLength += points.length;
              for (let i = 2, ii = points.length; i < ii; i++) {
                const dx = points[i] - points[i - 2];
                minDiff = Math.min(minDiff, dx);
                maxDiff = Math.max(maxDiff, dx);
              }
            }
            let bufferType;
            if (minDiff >= -128 && maxDiff <= 127) {
              bufferType = Int8Array;
            } else if (minDiff >= -32768 && maxDiff <= 32767) {
              bufferType = Int16Array;
            } else {
              bufferType = Int32Array;
            }
            const len = outlines.length;
            const headerLength = BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * len;
            const header = new Uint32Array(headerLength);
            let offset = 0;
            header[offset++] = headerLength * Uint32Array.BYTES_PER_ELEMENT + (outlinesLength - 2 * len) * bufferType.BYTES_PER_ELEMENT;
            header[offset++] = 0;
            header[offset++] = width;
            header[offset++] = height;
            header[offset++] = areContours ? 0 : 1;
            header[offset++] = Math.max(0, Math.floor(thickness ?? 0));
            header[offset++] = len;
            header[offset++] = bufferType.BYTES_PER_ELEMENT;
            for (const points of outlines) {
              header[offset++] = points.length - 2;
              header[offset++] = points[0];
              header[offset++] = points[1];
            }
            const cs = new CompressionStream("deflate-raw");
            const writer = cs.writable.getWriter();
            await writer.ready;
            writer.write(header);
            const BufferCtor = bufferType.prototype.constructor;
            for (const points of outlines) {
              const diffs = new BufferCtor(points.length - 2);
              for (let i = 2, ii = points.length; i < ii; i++) {
                diffs[i - 2] = points[i] - points[i - 2];
              }
              writer.write(diffs);
            }
            writer.close();
            const buf = await new Response(cs.readable).arrayBuffer();
            const bytes = new Uint8Array(buf);
            return toBase64Util(bytes);
          }
          static async decompressSignature(signatureData) {
            try {
              const bytes = fromBase64Util(signatureData);
              const {
                readable,
                writable
              } = new DecompressionStream("deflate-raw");
              const writer = writable.getWriter();
              await writer.ready;
              writer.write(bytes).then(async () => {
                await writer.ready;
                await writer.close();
              }).catch(() => { });
              let data = null;
              let offset = 0;
              for await (const chunk of readable) {
                data ||= new Uint8Array(new Uint32Array(chunk.buffer, 0, 4)[0]);
                data.set(chunk, offset);
                offset += chunk.length;
              }
              const header = new Uint32Array(data.buffer, 0, data.length >> 2);
              const version = header[1];
              if (version !== 0) {
                throw new Error(`Invalid version: ${version}`);
              }
              const width = header[2];
              const height = header[3];
              const areContours = header[4] === 0;
              const thickness = header[5];
              const numberOfDrawings = header[6];
              const bufferType = header[7];
              const outlines = [];
              const diffsOffset = (BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * numberOfDrawings) * Uint32Array.BYTES_PER_ELEMENT;
              let diffs;
              switch (bufferType) {
                case Int8Array.BYTES_PER_ELEMENT:
                  diffs = new Int8Array(data.buffer, diffsOffset);
                  break;
                case Int16Array.BYTES_PER_ELEMENT:
                  diffs = new Int16Array(data.buffer, diffsOffset);
                  break;
                case Int32Array.BYTES_PER_ELEMENT:
                  diffs = new Int32Array(data.buffer, diffsOffset);
                  break;
              }
              offset = 0;
              for (let i = 0; i < numberOfDrawings; i++) {
                const len = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH];
                const points = new Float32Array(len + 2);
                outlines.push(points);
                for (let j = 0; j < POINTS_PROPERTIES_NUMBER - 1; j++) {
                  points[j] = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH + j + 1];
                }
                for (let j = 0; j < len; j++) {
                  points[j + 2] = points[j] + diffs[offset++];
                }
              }
              return {
                areContours,
                thickness,
                outlines,
                width,
                height
              };
            } catch (e) {
              warn(`decompressSignature: ${e}`);
              return null;
            }
          }
        }

        ;// ./src/display/editor/signature.js







        class SignatureOptions extends DrawingOptions {
          constructor() {
            super();
            super.updateProperties({
              fill: AnnotationEditor._defaultLineColor,
              "stroke-width": 0
            });
          }
          clone() {
            const clone = new SignatureOptions();
            clone.updateAll(this);
            return clone;
          }
        }
        class DrawnSignatureOptions extends InkDrawingOptions {
          constructor(viewerParameters) {
            super(viewerParameters);
            super.updateProperties({
              stroke: AnnotationEditor._defaultLineColor,
              "stroke-width": 1
            });
          }
          clone() {
            const clone = new DrawnSignatureOptions(this._viewParameters);
            clone.updateAll(this);
            return clone;
          }
        }
        class SignatureEditor extends DrawingEditor {
          #isExtracted = false;
          #description = null;
          #signatureData = null;
          #signatureUUID = null;
          static _type = "signature";
          static _editorType = AnnotationEditorType.SIGNATURE;
          static _defaultDrawingOptions = null;
          constructor(params) {
            super({
              ...params,
              mustBeCommitted: true,
              name: "signatureEditor"
            });
            this._willKeepAspectRatio = true;
            this.#signatureData = params.signatureData || null;
            this.#description = null;
            this.defaultL10nId = "pdfjs-editor-signature-editor1";
          }
          static initialize(l10n, uiManager) {
            AnnotationEditor.initialize(l10n, uiManager);
            this._defaultDrawingOptions = new SignatureOptions();
            this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(uiManager.viewParameters);
          }
          static getDefaultDrawingOptions(options) {
            const clone = this._defaultDrawingOptions.clone();
            clone.updateProperties(options);
            return clone;
          }
          static get supportMultipleDrawings() {
            return false;
          }
          static get typesMap() {
            return shadow(this, "typesMap", new Map());
          }
          static get isDrawer() {
            return false;
          }
          get telemetryFinalData() {
            return {
              type: "signature",
              hasDescription: !!this.#description
            };
          }
          static computeTelemetryFinalData(data) {
            const hasDescriptionStats = data.get("hasDescription");
            return {
              hasAltText: hasDescriptionStats.get(true) ?? 0,
              hasNoAltText: hasDescriptionStats.get(false) ?? 0
            };
          }
          get isResizable() {
            return true;
          }
          onScaleChanging() {
            if (this._drawId === null) {
              return;
            }
            super.onScaleChanging();
          }
          render() {
            if (this.div) {
              return this.div;
            }
            let baseX, baseY;
            const {
              _isCopy
            } = this;
            if (_isCopy) {
              this._isCopy = false;
              baseX = this.x;
              baseY = this.y;
            }
            super.render();
            if (this._drawId === null) {
              if (this.#signatureData) {
                const {
                  lines,
                  mustSmooth,
                  areContours,
                  description,
                  uuid,
                  heightInPage
                } = this.#signatureData;
                const {
                  rawDims: {
                    pageWidth,
                    pageHeight
                  },
                  rotation
                } = this.parent.viewport;
                const outline = SignatureExtractor.processDrawnLines({
                  lines,
                  pageWidth,
                  pageHeight,
                  rotation,
                  innerMargin: SignatureEditor._INNER_MARGIN,
                  mustSmooth,
                  areContours
                });
                this.addSignature(outline, heightInPage, description, uuid);
              } else {
                this.div.setAttribute("data-l10n-args", JSON.stringify({
                  description: ""
                }));
                this.div.hidden = true;
                this._uiManager.getSignature(this);
              }
            } else {
              this.div.setAttribute("data-l10n-args", JSON.stringify({
                description: this.#description || ""
              }));
            }
            if (_isCopy) {
              this._isCopy = true;
              this._moveAfterPaste(baseX, baseY);
            }
            return this.div;
          }
          setUuid(uuid) {
            this.#signatureUUID = uuid;
            this.addEditToolbar();
          }
          getUuid() {
            return this.#signatureUUID;
          }
          get description() {
            return this.#description;
          }
          set description(description) {
            this.#description = description;
            if (!this.div) {
              return;
            }
            this.div.setAttribute("data-l10n-args", JSON.stringify({
              description
            }));
            super.addEditToolbar().then(toolbar => {
              toolbar?.updateEditSignatureButton(description);
            });
          }
          getSignaturePreview() {
            const {
              newCurves,
              areContours,
              thickness,
              width,
              height
            } = this.#signatureData;
            const maxDim = Math.max(width, height);
            const outlineData = SignatureExtractor.processDrawnLines({
              lines: {
                curves: newCurves.map(points => ({
                  points
                })),
                thickness,
                width,
                height
              },
              pageWidth: maxDim,
              pageHeight: maxDim,
              rotation: 0,
              innerMargin: 0,
              mustSmooth: false,
              areContours
            });
            return {
              areContours,
              outline: outlineData.outline
            };
          }
          get toolbarButtons() {
            if (this._uiManager.signatureManager) {
              return [["editSignature", this._uiManager.signatureManager]];
            }
            return super.toolbarButtons;
          }
          addSignature(data, heightInPage, description, uuid) {
            const {
              x: savedX,
              y: savedY
            } = this;
            const {
              outline
            } = this.#signatureData = data;
            this.#isExtracted = outline instanceof ContourDrawOutline;
            this.description = description;
            let drawingOptions;
            if (this.#isExtracted) {
              drawingOptions = SignatureEditor.getDefaultDrawingOptions();
            } else {
              drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();
              drawingOptions.updateProperties({
                "stroke-width": outline.thickness
              });
            }
            this._addOutlines({
              drawOutlines: outline,
              drawingOptions
            });
            const [, pageHeight] = this.pageDimensions;
            let newHeight = heightInPage / pageHeight;
            newHeight = newHeight >= 1 ? 0.5 : newHeight;
            this.width *= newHeight / this.height;
            if (this.width >= 1) {
              newHeight *= 0.9 / this.width;
              this.width = 0.9;
            }
            this.height = newHeight;
            this.setDims();
            this.x = savedX;
            this.y = savedY;
            this.center();
            this._onResized();
            this.onScaleChanging();
            this.rotate();
            this._uiManager.addToAnnotationStorage(this);
            this.setUuid(uuid);
            this._reportTelemetry({
              action: "pdfjs.signature.inserted",
              data: {
                hasBeenSaved: !!uuid,
                hasDescription: !!description
              }
            });
            this.div.hidden = false;
          }
          getFromImage(bitmap) {
            const {
              rawDims: {
                pageWidth,
                pageHeight
              },
              rotation
            } = this.parent.viewport;
            return SignatureExtractor.process(bitmap, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);
          }
          getFromText(text, fontInfo) {
            const {
              rawDims: {
                pageWidth,
                pageHeight
              },
              rotation
            } = this.parent.viewport;
            return SignatureExtractor.extractContoursFromText(text, fontInfo, pageWidth, pageHeight, rotation, SignatureEditor._INNER_MARGIN);
          }
          getDrawnSignature(curves) {
            const {
              rawDims: {
                pageWidth,
                pageHeight
              },
              rotation
            } = this.parent.viewport;
            return SignatureExtractor.processDrawnLines({
              lines: curves,
              pageWidth,
              pageHeight,
              rotation,
              innerMargin: SignatureEditor._INNER_MARGIN,
              mustSmooth: false,
              areContours: false
            });
          }
          createDrawingOptions({
            areContours,
            thickness
          }) {
            if (areContours) {
              this._drawingOptions = SignatureEditor.getDefaultDrawingOptions();
            } else {
              this._drawingOptions = SignatureEditor._defaultDrawnSignatureOptions.clone();
              this._drawingOptions.updateProperties({
                "stroke-width": thickness
              });
            }
          }
          serialize(isForCopying = false) {
            if (this.isEmpty()) {
              return null;
            }
            const {
              lines,
              points
            } = this.serializeDraw(isForCopying);
            const {
              _drawingOptions: {
                "stroke-width": thickness
              }
            } = this;
            const serialized = Object.assign(super.serialize(isForCopying), {
              isSignature: true,
              areContours: this.#isExtracted,
              color: [0, 0, 0],
              thickness: this.#isExtracted ? 0 : thickness
            });
            this.addComment(serialized);
            if (isForCopying) {
              serialized.paths = {
                lines,
                points
              };
              serialized.uuid = this.#signatureUUID;
              serialized.isCopy = true;
            } else {
              serialized.lines = lines;
            }
            if (this.#description) {
              serialized.accessibilityData = {
                type: "Figure",
                alt: this.#description
              };
            }
            return serialized;
          }
          static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {
            if (data.areContours) {
              return ContourDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
            }
            return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
          }
          static async deserialize(data, parent, uiManager) {
            const editor = await super.deserialize(data, parent, uiManager);
            editor.#isExtracted = data.areContours;
            editor.description = data.accessibilityData?.alt || "";
            editor.#signatureUUID = data.uuid;
            return editor;
          }
        }

        ;// ./src/display/editor/stamp.js




        class StampEditor extends AnnotationEditor {
          #bitmap = null;
          #bitmapId = null;
          #bitmapPromise = null;
          #bitmapUrl = null;
          #bitmapFile = null;
          #bitmapFileName = "";
          #canvas = null;
          #missingCanvas = false;
          #resizeTimeoutId = null;
          #isSvg = false;
          #hasBeenAddedInUndoStack = false;
          static _type = "stamp";
          static _editorType = AnnotationEditorType.STAMP;
          constructor(params) {
            super({
              ...params,
              name: "stampEditor"
            });
            this.#bitmapUrl = params.bitmapUrl;
            this.#bitmapFile = params.bitmapFile;
            this.defaultL10nId = "pdfjs-editor-stamp-editor";
          }
          static initialize(l10n, uiManager) {
            AnnotationEditor.initialize(l10n, uiManager);
          }
          static isHandlingMimeForPasting(mime) {
            return SupportedImageMimeTypes.includes(mime);
          }
          static paste(item, parent) {
            parent.pasteEditor({
              mode: AnnotationEditorType.STAMP
            }, {
              bitmapFile: item.getAsFile()
            });
          }
          altTextFinish() {
            if (this._uiManager.useNewAltTextFlow) {
              this.div.hidden = false;
            }
            super.altTextFinish();
          }
          get telemetryFinalData() {
            return {
              type: "stamp",
              hasAltText: !!this.altTextData?.altText
            };
          }
          static computeTelemetryFinalData(data) {
            const hasAltTextStats = data.get("hasAltText");
            return {
              hasAltText: hasAltTextStats.get(true) ?? 0,
              hasNoAltText: hasAltTextStats.get(false) ?? 0
            };
          }
          #getBitmapFetched(data, fromId = false) {
            if (!data) {
              this.remove();
              return;
            }
            this.#bitmap = data.bitmap;
            if (!fromId) {
              this.#bitmapId = data.id;
              this.#isSvg = data.isSvg;
            }
            if (data.file) {
              this.#bitmapFileName = data.file.name;
            }
            this.#createCanvas();
          }
          #getBitmapDone() {
            this.#bitmapPromise = null;
            this._uiManager.enableWaiting(false);
            if (!this.#canvas) {
              return;
            }
            if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {
              this.addEditToolbar().then(() => {
                this._editToolbar.hide();
                this._uiManager.editAltText(this, true);
              });
              return;
            }
            if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {
              this._reportTelemetry({
                action: "pdfjs.image.image_added",
                data: {
                  alt_text_modal: false,
                  alt_text_type: "empty"
                }
              });
              try {
                this.mlGuessAltText();
              } catch { }
            }
            this.div.focus();
          }
          async mlGuessAltText(imageData = null, updateAltTextData = true) {
            if (this.hasAltTextData()) {
              return null;
            }
            const {
              mlManager
            } = this._uiManager;
            if (!mlManager) {
              throw new Error("No ML.");
            }
            if (!(await mlManager.isEnabledFor("altText"))) {
              throw new Error("ML isn't enabled for alt text.");
            }
            const {
              data,
              width,
              height
            } = imageData || this.copyCanvas(null, null, true).imageData;
            const response = await mlManager.guess({
              name: "altText",
              request: {
                data,
                width,
                height,
                channels: data.length / (width * height)
              }
            });
            if (!response) {
              throw new Error("No response from the AI service.");
            }
            if (response.error) {
              throw new Error("Error from the AI service.");
            }
            if (response.cancel) {
              return null;
            }
            if (!response.output) {
              throw new Error("No valid response from the AI service.");
            }
            const altText = response.output;
            await this.setGuessedAltText(altText);
            if (updateAltTextData && !this.hasAltTextData()) {
              this.altTextData = {
                alt: altText,
                decorative: false
              };
            }
            return altText;
          }
          #getBitmap() {
            if (this.#bitmapId) {
              this._uiManager.enableWaiting(true);
              this._uiManager.imageManager.getFromId(this.#bitmapId).then(data => this.#getBitmapFetched(data, true)).finally(() => this.#getBitmapDone());
              return;
            }
            if (this.#bitmapUrl) {
              const url = this.#bitmapUrl;
              this.#bitmapUrl = null;
              this._uiManager.enableWaiting(true);
              this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());
              return;
            }
            if (this.#bitmapFile) {
              const file = this.#bitmapFile;
              this.#bitmapFile = null;
              this._uiManager.enableWaiting(true);
              this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());
              return;
            }
            const input = document.createElement("input");
            input.type = "file";
            input.accept = SupportedImageMimeTypes.join(",");
            const signal = this._uiManager._signal;
            this.#bitmapPromise = new Promise(resolve => {
              input.addEventListener("change", async () => {
                if (!input.files || input.files.length === 0) {
                  this.remove();
                } else {
                  this._uiManager.enableWaiting(true);
                  const data = await this._uiManager.imageManager.getFromFile(input.files[0]);
                  this._reportTelemetry({
                    action: "pdfjs.image.image_selected",
                    data: {
                      alt_text_modal: this._uiManager.useNewAltTextFlow
                    }
                  });
                  this.#getBitmapFetched(data);
                }
                resolve();
              }, {
                signal
              });
              input.addEventListener("cancel", () => {
                this.remove();
                resolve();
              }, {
                signal
              });
            }).finally(() => this.#getBitmapDone());
            input.click();
          }
          remove() {
            if (this.#bitmapId) {
              this.#bitmap = null;
              this._uiManager.imageManager.deleteId(this.#bitmapId);
              this.#canvas?.remove();
              this.#canvas = null;
              if (this.#resizeTimeoutId) {
                clearTimeout(this.#resizeTimeoutId);
                this.#resizeTimeoutId = null;
              }
            }
            super.remove();
          }
          rebuild() {
            if (!this.parent) {
              if (this.#bitmapId) {
                this.#getBitmap();
              }
              return;
            }
            super.rebuild();
            if (this.div === null) {
              return;
            }
            if (this.#bitmapId && this.#canvas === null) {
              this.#getBitmap();
            }
            if (!this.isAttachedToDOM) {
              this.parent.add(this);
            }
          }
          onceAdded(focus) {
            this._isDraggable = true;
            if (focus) {
              this.div.focus();
            }
          }
          isEmpty() {
            return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId || this.#missingCanvas);
          }
          get toolbarButtons() {
            return [["altText", this.createAltText()]];
          }
          get isResizable() {
            return true;
          }
          render() {
            if (this.div) {
              return this.div;
            }
            let baseX, baseY;
            if (this._isCopy) {
              baseX = this.x;
              baseY = this.y;
            }
            super.render();
            this.div.hidden = true;
            this.createAltText();
            if (!this.#missingCanvas) {
              if (this.#bitmap) {
                this.#createCanvas();
              } else {
                this.#getBitmap();
              }
            }
            if (this._isCopy) {
              this._moveAfterPaste(baseX, baseY);
            }
            this._uiManager.addShouldRescale(this);
            return this.div;
          }
          setCanvas(annotationElementId, canvas) {
            const {
              id: bitmapId,
              bitmap
            } = this._uiManager.imageManager.getFromCanvas(annotationElementId, canvas);
            canvas.remove();
            if (bitmapId && this._uiManager.imageManager.isValidId(bitmapId)) {
              this.#bitmapId = bitmapId;
              if (bitmap) {
                this.#bitmap = bitmap;
              }
              this.#missingCanvas = false;
              this.#createCanvas();
            }
          }
          _onResized() {
            this.onScaleChanging();
          }
          onScaleChanging() {
            if (!this.parent) {
              return;
            }
            if (this.#resizeTimeoutId !== null) {
              clearTimeout(this.#resizeTimeoutId);
            }
            const TIME_TO_WAIT = 200;
            this.#resizeTimeoutId = setTimeout(() => {
              this.#resizeTimeoutId = null;
              this.#drawBitmap();
            }, TIME_TO_WAIT);
          }
          #createCanvas() {
            const {
              div
            } = this;
            let {
              width,
              height
            } = this.#bitmap;
            const [pageWidth, pageHeight] = this.pageDimensions;
            const MAX_RATIO = 0.75;
            if (this.width) {
              width = this.width * pageWidth;
              height = this.height * pageHeight;
            } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {
              const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);
              width *= factor;
              height *= factor;
            }
            this._uiManager.enableWaiting(false);
            const canvas = this.#canvas = document.createElement("canvas");
            canvas.setAttribute("role", "img");
            this.addContainer(canvas);
            this.width = width / pageWidth;
            this.height = height / pageHeight;
            this.setDims();
            if (this._initialOptions?.isCentered) {
              this.center();
            } else {
              this.fixAndSetPosition();
            }
            this._initialOptions = null;
            if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {
              div.hidden = false;
            }
            this.#drawBitmap();
            if (!this.#hasBeenAddedInUndoStack) {
              this.parent.addUndoableEditor(this);
              this.#hasBeenAddedInUndoStack = true;
            }
            this._reportTelemetry({
              action: "inserted_image"
            });
            if (this.#bitmapFileName) {
              this.div.setAttribute("aria-description", this.#bitmapFileName);
            }
            if (!this.annotationElementId) {
              this._uiManager.a11yAlert("pdfjs-editor-stamp-added-alert");
            }
          }
          copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {
            if (!maxDataDimension) {
              maxDataDimension = 224;
            }
            const {
              width: bitmapWidth,
              height: bitmapHeight
            } = this.#bitmap;
            const outputScale = new OutputScale();
            let bitmap = this.#bitmap;
            let width = bitmapWidth,
              height = bitmapHeight;
            let canvas = null;
            if (maxPreviewDimension) {
              if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {
                const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);
                width = Math.floor(bitmapWidth * ratio);
                height = Math.floor(bitmapHeight * ratio);
              }
              canvas = document.createElement("canvas");
              const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);
              const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);
              if (!this.#isSvg) {
                bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);
              }
              const ctx = canvas.getContext("2d");
              ctx.filter = this._uiManager.hcmFilter;
              let white = "white",
                black = "#cfcfd8";
              if (this._uiManager.hcmFilter !== "none") {
                black = "black";
              } else if (ColorScheme.isDarkMode) {
                white = "#8f8f9d";
                black = "#42414d";
              }
              const boxDim = 15;
              const boxDimWidth = boxDim * outputScale.sx;
              const boxDimHeight = boxDim * outputScale.sy;
              const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);
              const patternCtx = pattern.getContext("2d");
              patternCtx.fillStyle = white;
              patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);
              patternCtx.fillStyle = black;
              patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);
              patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);
              ctx.fillStyle = ctx.createPattern(pattern, "repeat");
              ctx.fillRect(0, 0, scaledWidth, scaledHeight);
              ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
            }
            let imageData = null;
            if (createImageData) {
              let dataWidth, dataHeight;
              if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {
                dataWidth = bitmap.width;
                dataHeight = bitmap.height;
              } else {
                bitmap = this.#bitmap;
                if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {
                  const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);
                  dataWidth = Math.floor(bitmapWidth * ratio);
                  dataHeight = Math.floor(bitmapHeight * ratio);
                  if (!this.#isSvg) {
                    bitmap = this.#scaleBitmap(dataWidth, dataHeight);
                  }
                }
              }
              const offscreen = new OffscreenCanvas(dataWidth, dataHeight);
              const offscreenCtx = offscreen.getContext("2d", {
                willReadFrequently: true
              });
              offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);
              imageData = {
                width: dataWidth,
                height: dataHeight,
                data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data
              };
            }
            return {
              canvas,
              width,
              height,
              imageData
            };
          }
          #scaleBitmap(width, height) {
            const {
              width: bitmapWidth,
              height: bitmapHeight
            } = this.#bitmap;
            let newWidth = bitmapWidth;
            let newHeight = bitmapHeight;
            let bitmap = this.#bitmap;
            while (newWidth > 2 * width || newHeight > 2 * height) {
              const prevWidth = newWidth;
              const prevHeight = newHeight;
              if (newWidth > 2 * width) {
                newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);
              }
              if (newHeight > 2 * height) {
                newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);
              }
              const offscreen = new OffscreenCanvas(newWidth, newHeight);
              const ctx = offscreen.getContext("2d");
              ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
              bitmap = offscreen.transferToImageBitmap();
            }
            return bitmap;
          }
          #drawBitmap() {
            const [parentWidth, parentHeight] = this.parentDimensions;
            const {
              width,
              height
            } = this;
            const outputScale = new OutputScale();
            const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);
            const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);
            const canvas = this.#canvas;
            if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {
              return;
            }
            canvas.width = scaledWidth;
            canvas.height = scaledHeight;
            const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);
            const ctx = canvas.getContext("2d");
            ctx.filter = this._uiManager.hcmFilter;
            ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
          }
          #serializeBitmap(toUrl) {
            if (toUrl) {
              if (this.#isSvg) {
                const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);
                if (url) {
                  return url;
                }
              }
              const canvas = document.createElement("canvas");
              ({
                width: canvas.width,
                height: canvas.height
              } = this.#bitmap);
              const ctx = canvas.getContext("2d");
              ctx.drawImage(this.#bitmap, 0, 0);
              return canvas.toDataURL();
            }
            if (this.#isSvg) {
              const [pageWidth, pageHeight] = this.pageDimensions;
              const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);
              const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);
              const offscreen = new OffscreenCanvas(width, height);
              const ctx = offscreen.getContext("2d");
              ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);
              return offscreen.transferToImageBitmap();
            }
            return structuredClone(this.#bitmap);
          }
          static async deserialize(data, parent, uiManager) {
            let initialData = null;
            let missingCanvas = false;
            if (data instanceof StampAnnotationElement) {
              const {
                data: {
                  rect,
                  rotation,
                  id,
                  structParent,
                  popupRef,
                  richText,
                  contentsObj,
                  creationDate,
                  modificationDate
                },
                container,
                parent: {
                  page: {
                    pageNumber
                  }
                },
                canvas
              } = data;
              let bitmapId, bitmap;
              if (canvas) {
                delete data.canvas;
                ({
                  id: bitmapId,
                  bitmap
                } = uiManager.imageManager.getFromCanvas(container.id, canvas));
                canvas.remove();
              } else {
                missingCanvas = true;
                data._hasNoCanvas = true;
              }
              const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get("aria-label") || "";
              initialData = data = {
                annotationType: AnnotationEditorType.STAMP,
                bitmapId,
                bitmap,
                pageIndex: pageNumber - 1,
                rect: rect.slice(0),
                rotation,
                annotationElementId: id,
                id,
                deleted: false,
                accessibilityData: {
                  decorative: false,
                  altText
                },
                isSvg: false,
                structParent,
                popupRef,
                richText,
                comment: contentsObj?.str || null,
                creationDate,
                modificationDate
              };
            }
            const editor = await super.deserialize(data, parent, uiManager);
            const {
              rect,
              bitmap,
              bitmapUrl,
              bitmapId,
              isSvg,
              accessibilityData
            } = data;
            if (missingCanvas) {
              uiManager.addMissingCanvas(data.id, editor);
              editor.#missingCanvas = true;
            } else if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
              editor.#bitmapId = bitmapId;
              if (bitmap) {
                editor.#bitmap = bitmap;
              }
            } else {
              editor.#bitmapUrl = bitmapUrl;
            }
            editor.#isSvg = isSvg;
            const [parentWidth, parentHeight] = editor.pageDimensions;
            editor.width = (rect[2] - rect[0]) / parentWidth;
            editor.height = (rect[3] - rect[1]) / parentHeight;
            if (accessibilityData) {
              editor.altTextData = accessibilityData;
            }
            editor._initialData = initialData;
            if (data.comment) {
              editor.setCommentData(data);
            }
            editor.#hasBeenAddedInUndoStack = !!initialData;
            return editor;
          }
          serialize(isForCopying = false, context = null) {
            if (this.isEmpty()) {
              return null;
            }
            if (this.deleted) {
              return this.serializeDeleted();
            }
            const serialized = Object.assign(super.serialize(isForCopying), {
              bitmapId: this.#bitmapId,
              isSvg: this.#isSvg
            });
            this.addComment(serialized);
            if (isForCopying) {
              serialized.bitmapUrl = this.#serializeBitmap(true);
              serialized.accessibilityData = this.serializeAltText(true);
              serialized.isCopy = true;
              return serialized;
            }
            const {
              decorative,
              altText
            } = this.serializeAltText(false);
            if (!decorative && altText) {
              serialized.accessibilityData = {
                type: "Figure",
                alt: altText
              };
            }
            if (this.annotationElementId) {
              const changes = this.#hasElementChanged(serialized);
              if (changes.isSame) {
                return null;
              }
              if (changes.isSameAltText) {
                delete serialized.accessibilityData;
              } else {
                serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;
              }
              serialized.id = this.annotationElementId;
              delete serialized.bitmapId;
              return serialized;
            }
            if (context === null) {
              return serialized;
            }
            context.stamps ||= new Map();
            const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;
            if (!context.stamps.has(this.#bitmapId)) {
              context.stamps.set(this.#bitmapId, {
                area,
                serialized
              });
              serialized.bitmap = this.#serializeBitmap(false);
            } else if (this.#isSvg) {
              const prevData = context.stamps.get(this.#bitmapId);
              if (area > prevData.area) {
                prevData.area = area;
                prevData.serialized.bitmap.close();
                prevData.serialized.bitmap = this.#serializeBitmap(false);
              }
            }
            return serialized;
          }
          #hasElementChanged(serialized) {
            const {
              pageIndex,
              accessibilityData: {
                altText
              }
            } = this._initialData;
            const isSamePageIndex = serialized.pageIndex === pageIndex;
            const isSameAltText = (serialized.accessibilityData?.alt || "") === altText;
            return {
              isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,
              isSameAltText
            };
          }
          renderAnnotationElement(annotation) {
            if (this.deleted) {
              annotation.hide();
              return null;
            }
            annotation.updateEdited({
              rect: this.getPDFRect(),
              popup: this.comment
            });
            return null;
          }
        }

        ;// ./src/display/editor/annotation_editor_layer.js








        class AnnotationEditorLayer {
          #accessibilityManager;
          #allowClick = false;
          #annotationLayer = null;
          #clickAC = null;
          #editorFocusTimeoutId = null;
          #editors = new Map();
          #hadPointerDown = false;
          #isDisabling = false;
          #isEnabling = false;
          #drawingAC = null;
          #focusedElement = null;
          #textLayer = null;
          #textSelectionAC = null;
          #textLayerDblClickAC = null;
          #lastPointerDownTimestamp = -1;
          #uiManager;
          static _initialized = false;
          static #editorTypes = new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor, SignatureEditor].map(type => [type._editorType, type]));
          constructor({
            uiManager,
            pageIndex,
            div,
            structTreeLayer,
            accessibilityManager,
            annotationLayer,
            drawLayer,
            textLayer,
            viewport,
            l10n
          }) {
            const editorTypes = [...AnnotationEditorLayer.#editorTypes.values()];
            if (!AnnotationEditorLayer._initialized) {
              AnnotationEditorLayer._initialized = true;
              for (const editorType of editorTypes) {
                editorType.initialize(l10n, uiManager);
              }
            }
            uiManager.registerEditorTypes(editorTypes);
            this.#uiManager = uiManager;
            this.pageIndex = pageIndex;
            this.div = div;
            this.#accessibilityManager = accessibilityManager;
            this.#annotationLayer = annotationLayer;
            this.viewport = viewport;
            this.#textLayer = textLayer;
            this.drawLayer = drawLayer;
            this._structTree = structTreeLayer;
            this.#uiManager.addLayer(this);
          }
          get isEmpty() {
            return this.#editors.size === 0;
          }
          get isInvisible() {
            return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;
          }
          updateToolbar(options) {
            this.#uiManager.updateToolbar(options);
          }
          updateMode(mode = this.#uiManager.getMode()) {
            this.#cleanup();
            switch (mode) {
              case AnnotationEditorType.NONE:
                this.div.classList.toggle("nonEditing", true);
                this.disableTextSelection();
                this.togglePointerEvents(false);
                this.toggleAnnotationLayerPointerEvents(true);
                this.disableClick();
                return;
              case AnnotationEditorType.INK:
                this.disableTextSelection();
                this.togglePointerEvents(true);
                this.enableClick();
                break;
              case AnnotationEditorType.HIGHLIGHT:
                this.enableTextSelection();
                this.togglePointerEvents(false);
                this.disableClick();
                break;
              default:
                this.disableTextSelection();
                this.togglePointerEvents(true);
                this.enableClick();
            }
            this.toggleAnnotationLayerPointerEvents(false);
            const {
              classList
            } = this.div;
            classList.toggle("nonEditing", false);
            if (mode === AnnotationEditorType.POPUP) {
              classList.toggle("commentEditing", true);
            } else {
              classList.toggle("commentEditing", false);
              for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {
                classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);
              }
            }
            this.div.hidden = false;
          }
          hasTextLayer(textLayer) {
            return textLayer === this.#textLayer?.div;
          }
          setEditingState(isEditing) {
            this.#uiManager.setEditingState(isEditing);
          }
          addCommands(params) {
            this.#uiManager.addCommands(params);
          }
          cleanUndoStack(type) {
            this.#uiManager.cleanUndoStack(type);
          }
          toggleDrawing(enabled = false) {
            this.div.classList.toggle("drawing", !enabled);
          }
          togglePointerEvents(enabled = false) {
            this.div.classList.toggle("disabled", !enabled);
          }
          toggleAnnotationLayerPointerEvents(enabled = false) {
            this.#annotationLayer?.togglePointerEvents(enabled);
          }
          get #allEditorsIterator() {
            return this.#editors.size !== 0 ? this.#editors.values() : this.#uiManager.getEditors(this.pageIndex);
          }
          async enable() {
            this.#isEnabling = true;
            this.div.tabIndex = 0;
            this.togglePointerEvents(true);
            this.div.classList.toggle("nonEditing", false);
            this.#textLayerDblClickAC?.abort();
            this.#textLayerDblClickAC = null;
            const annotationElementIds = new Set();
            for (const editor of this.#allEditorsIterator) {
              editor.enableEditing();
              editor.show(true);
              if (editor.annotationElementId) {
                this.#uiManager.removeChangedExistingAnnotation(editor);
                annotationElementIds.add(editor.annotationElementId);
              }
            }
            const annotationLayer = this.#annotationLayer;
            if (annotationLayer) {
              for (const editable of annotationLayer.getEditableAnnotations()) {
                editable.hide();
                if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {
                  continue;
                }
                if (annotationElementIds.has(editable.data.id)) {
                  continue;
                }
                const editor = await this.deserialize(editable);
                if (!editor) {
                  continue;
                }
                this.addOrRebuild(editor);
                editor.enableEditing();
              }
            }
            this.#isEnabling = false;
            this.#uiManager._eventBus.dispatch("editorsrendered", {
              source: this,
              pageNumber: this.pageIndex + 1
            });
          }
          disable() {
            this.#isDisabling = true;
            this.div.tabIndex = -1;
            this.togglePointerEvents(false);
            this.div.classList.toggle("nonEditing", true);
            if (this.#textLayer && !this.#textLayerDblClickAC) {
              this.#textLayerDblClickAC = new AbortController();
              const signal = this.#uiManager.combinedSignal(this.#textLayerDblClickAC);
              this.#textLayer.div.addEventListener("pointerdown", e => {
                const DBL_CLICK_THRESHOLD = 500;
                const {
                  clientX,
                  clientY,
                  timeStamp
                } = e;
                const lastPointerDownTimestamp = this.#lastPointerDownTimestamp;
                if (timeStamp - lastPointerDownTimestamp > DBL_CLICK_THRESHOLD) {
                  this.#lastPointerDownTimestamp = timeStamp;
                  return;
                }
                this.#lastPointerDownTimestamp = -1;
                const {
                  classList
                } = this.div;
                classList.toggle("getElements", true);
                const elements = document.elementsFromPoint(clientX, clientY);
                classList.toggle("getElements", false);
                if (!this.div.contains(elements[0])) {
                  return;
                }
                let id;
                const regex = new RegExp(`^${AnnotationEditorPrefix}[0-9]+$`);
                for (const element of elements) {
                  if (regex.test(element.id)) {
                    id = element.id;
                    break;
                  }
                }
                if (!id) {
                  return;
                }
                const editor = this.#editors.get(id);
                if (editor?.annotationElementId === null) {
                  e.stopPropagation();
                  e.preventDefault();
                  editor.dblclick(e);
                }
              }, {
                signal,
                capture: true
              });
            }
            const annotationLayer = this.#annotationLayer;
            const needFakeAnnotation = [];
            if (annotationLayer) {
              const changedAnnotations = new Map();
              const resetAnnotations = new Map();
              for (const editor of this.#allEditorsIterator) {
                editor.disableEditing();
                if (!editor.annotationElementId) {
                  needFakeAnnotation.push(editor);
                  continue;
                }
                if (editor.serialize() !== null) {
                  changedAnnotations.set(editor.annotationElementId, editor);
                  continue;
                } else {
                  resetAnnotations.set(editor.annotationElementId, editor);
                }
                this.getEditableAnnotation(editor.annotationElementId)?.show();
                editor.remove();
              }
              const editables = annotationLayer.getEditableAnnotations();
              for (const editable of editables) {
                const {
                  id
                } = editable.data;
                if (this.#uiManager.isDeletedAnnotationElement(id)) {
                  editable.updateEdited({
                    deleted: true
                  });
                  continue;
                }
                let editor = resetAnnotations.get(id);
                if (editor) {
                  editor.resetAnnotationElement(editable);
                  editor.show(false);
                  editable.show();
                  continue;
                }
                editor = changedAnnotations.get(id);
                if (editor) {
                  this.#uiManager.addChangedExistingAnnotation(editor);
                  if (editor.renderAnnotationElement(editable)) {
                    editor.show(false);
                  }
                }
                editable.show();
              }
            }
            this.#cleanup();
            if (this.isEmpty) {
              this.div.hidden = true;
            }
            const {
              classList
            } = this.div;
            for (const editorType of AnnotationEditorLayer.#editorTypes.values()) {
              classList.remove(`${editorType._type}Editing`);
            }
            this.disableTextSelection();
            this.toggleAnnotationLayerPointerEvents(true);
            annotationLayer?.updateFakeAnnotations(needFakeAnnotation);
            this.#isDisabling = false;
          }
          getEditableAnnotation(id) {
            return this.#annotationLayer?.getEditableAnnotation(id) || null;
          }
          setActiveEditor(editor) {
            const currentActive = this.#uiManager.getActive();
            if (currentActive === editor) {
              return;
            }
            this.#uiManager.setActiveEditor(editor);
          }
          enableTextSelection() {
            this.div.tabIndex = -1;
            if (this.#textLayer?.div && !this.#textSelectionAC) {
              this.#textSelectionAC = new AbortController();
              const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);
              this.#textLayer.div.addEventListener("pointerdown", this.#textLayerPointerDown.bind(this), {
                signal
              });
              this.#textLayer.div.classList.add("highlighting");
            }
          }
          disableTextSelection() {
            this.div.tabIndex = 0;
            if (this.#textLayer?.div && this.#textSelectionAC) {
              this.#textSelectionAC.abort();
              this.#textSelectionAC = null;
              this.#textLayer.div.classList.remove("highlighting");
            }
          }
          #textLayerPointerDown(event) {
            this.#uiManager.unselectAll();
            const {
              target
            } = event;
            if (target === this.#textLayer.div || (target.getAttribute("role") === "img" || target.classList.contains("endOfContent")) && this.#textLayer.div.contains(target)) {
              const {
                isMac
              } = util_FeatureTest.platform;
              if (event.button !== 0 || event.ctrlKey && isMac) {
                return;
              }
              this.#uiManager.showAllEditors("highlight", true, true);
              this.#textLayer.div.classList.add("free");
              this.toggleDrawing();
              HighlightEditor.startHighlighting(this, this.#uiManager.direction === "ltr", {
                target: this.#textLayer.div,
                x: event.x,
                y: event.y
              });
              this.#textLayer.div.addEventListener("pointerup", () => {
                this.#textLayer.div.classList.remove("free");
                this.toggleDrawing(true);
              }, {
                once: true,
                signal: this.#uiManager._signal
              });
              event.preventDefault();
            }
          }
          enableClick() {
            if (this.#clickAC) {
              return;
            }
            this.#clickAC = new AbortController();
            const signal = this.#uiManager.combinedSignal(this.#clickAC);
            this.div.addEventListener("pointerdown", this.pointerdown.bind(this), {
              signal
            });
            const pointerup = this.pointerup.bind(this);
            this.div.addEventListener("pointerup", pointerup, {
              signal
            });
            this.div.addEventListener("pointercancel", pointerup, {
              signal
            });
          }
          disableClick() {
            this.#clickAC?.abort();
            this.#clickAC = null;
          }
          attach(editor) {
            this.#editors.set(editor.id, editor);
            const {
              annotationElementId
            } = editor;
            if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {
              this.#uiManager.removeDeletedAnnotationElement(editor);
            }
          }
          detach(editor) {
            this.#editors.delete(editor.id);
            this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
            if (!this.#isDisabling && editor.annotationElementId) {
              this.#uiManager.addDeletedAnnotationElement(editor);
            }
          }
          remove(editor) {
            this.detach(editor);
            this.#uiManager.removeEditor(editor);
            editor.div.remove();
            editor.isAttachedToDOM = false;
          }
          changeParent(editor) {
            if (editor.parent === this) {
              return;
            }
            if (editor.parent && editor.annotationElementId) {
              this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);
              AnnotationEditor.deleteAnnotationElement(editor);
              editor.annotationElementId = null;
            }
            this.attach(editor);
            editor.parent?.detach(editor);
            editor.setParent(this);
            if (editor.div && editor.isAttachedToDOM) {
              editor.div.remove();
              this.div.append(editor.div);
            }
          }
          add(editor) {
            if (editor.parent === this && editor.isAttachedToDOM) {
              return;
            }
            this.changeParent(editor);
            this.#uiManager.addEditor(editor);
            this.attach(editor);
            if (!editor.isAttachedToDOM) {
              const div = editor.render();
              this.div.append(div);
              editor.isAttachedToDOM = true;
            }
            editor.fixAndSetPosition();
            editor.onceAdded(!this.#isEnabling);
            this.#uiManager.addToAnnotationStorage(editor);
            editor._reportTelemetry(editor.telemetryInitialData);
          }
          moveEditorInDOM(editor) {
            if (!editor.isAttachedToDOM) {
              return;
            }
            const {
              activeElement
            } = document;
            if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {
              editor._focusEventsAllowed = false;
              this.#editorFocusTimeoutId = setTimeout(() => {
                this.#editorFocusTimeoutId = null;
                if (!editor.div.contains(document.activeElement)) {
                  editor.div.addEventListener("focusin", () => {
                    editor._focusEventsAllowed = true;
                  }, {
                    once: true,
                    signal: this.#uiManager._signal
                  });
                  activeElement.focus();
                } else {
                  editor._focusEventsAllowed = true;
                }
              }, 0);
            }
            editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
          }
          addOrRebuild(editor) {
            if (editor.needsToBeRebuilt()) {
              editor.parent ||= this;
              editor.rebuild();
              editor.show();
            } else {
              this.add(editor);
            }
          }
          addUndoableEditor(editor) {
            const cmd = () => editor._uiManager.rebuild(editor);
            const undo = () => {
              editor.remove();
            };
            this.addCommands({
              cmd,
              undo,
              mustExec: false
            });
          }
          getEditorByUID(uid) {
            for (const editor of this.#editors.values()) {
              if (editor.uid === uid) {
                return editor;
              }
            }
            return null;
          }
          getNextId() {
            return this.#uiManager.getId();
          }
          get #currentEditorType() {
            return AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());
          }
          combinedSignal(ac) {
            return this.#uiManager.combinedSignal(ac);
          }
          #createNewEditor(params) {
            const editorType = this.#currentEditorType;
            return editorType ? new editorType.prototype.constructor(params) : null;
          }
          canCreateNewEmptyEditor() {
            return this.#currentEditorType?.canCreateNewEmptyEditor();
          }
          async pasteEditor(options, params) {
            this.updateToolbar(options);
            await this.#uiManager.updateMode(options.mode);
            const {
              offsetX,
              offsetY
            } = this.#getCenterPoint();
            const id = this.getNextId();
            const editor = this.#createNewEditor({
              parent: this,
              id,
              x: offsetX,
              y: offsetY,
              uiManager: this.#uiManager,
              isCentered: true,
              ...params
            });
            if (editor) {
              this.add(editor);
            }
          }
          async deserialize(data) {
            return (await AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager)) || null;
          }
          createAndAddNewEditor(event, isCentered, data = {}) {
            const id = this.getNextId();
            const editor = this.#createNewEditor({
              parent: this,
              id,
              x: event.offsetX,
              y: event.offsetY,
              uiManager: this.#uiManager,
              isCentered,
              ...data
            });
            if (editor) {
              this.add(editor);
            }
            return editor;
          }
          get boundingClientRect() {
            return this.div.getBoundingClientRect();
          }
          #getCenterPoint() {
            const {
              x,
              y,
              width,
              height
            } = this.boundingClientRect;
            const tlX = Math.max(0, x);
            const tlY = Math.max(0, y);
            const brX = Math.min(window.innerWidth, x + width);
            const brY = Math.min(window.innerHeight, y + height);
            const centerX = (tlX + brX) / 2 - x;
            const centerY = (tlY + brY) / 2 - y;
            const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];
            return {
              offsetX,
              offsetY
            };
          }
          addNewEditor(data = {}) {
            this.createAndAddNewEditor(this.#getCenterPoint(), true, data);
          }
          setSelected(editor) {
            this.#uiManager.setSelected(editor);
          }
          toggleSelected(editor) {
            this.#uiManager.toggleSelected(editor);
          }
          unselect(editor) {
            this.#uiManager.unselect(editor);
          }
          pointerup(event) {
            const {
              isMac
            } = util_FeatureTest.platform;
            if (event.button !== 0 || event.ctrlKey && isMac) {
              return;
            }
            if (event.target !== this.div) {
              return;
            }
            if (!this.#hadPointerDown) {
              return;
            }
            this.#hadPointerDown = false;
            if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) {
              return;
            }
            if (!this.#allowClick) {
              this.#allowClick = true;
              return;
            }
            const currentMode = this.#uiManager.getMode();
            if (currentMode === AnnotationEditorType.STAMP || currentMode === AnnotationEditorType.SIGNATURE) {
              this.#uiManager.unselectAll();
              return;
            }
            this.createAndAddNewEditor(event, false);
          }
          pointerdown(event) {
            if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {
              this.enableTextSelection();
            }
            if (this.#hadPointerDown) {
              this.#hadPointerDown = false;
              return;
            }
            const {
              isMac
            } = util_FeatureTest.platform;
            if (event.button !== 0 || event.ctrlKey && isMac) {
              return;
            }
            if (event.target !== this.div) {
              return;
            }
            this.#hadPointerDown = true;
            if (this.#currentEditorType?.isDrawer) {
              this.startDrawingSession(event);
              return;
            }
            const editor = this.#uiManager.getActive();
            this.#allowClick = !editor || editor.isEmpty();
          }
          startDrawingSession(event) {
            this.div.focus({
              preventScroll: true
            });
            if (this.#drawingAC) {
              this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);
              return;
            }
            this.#uiManager.setCurrentDrawingSession(this);
            this.#drawingAC = new AbortController();
            const signal = this.#uiManager.combinedSignal(this.#drawingAC);
            this.div.addEventListener("blur", ({
              relatedTarget
            }) => {
              if (relatedTarget && !this.div.contains(relatedTarget)) {
                this.#focusedElement = null;
                this.commitOrRemove();
              }
            }, {
              signal
            });
            this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);
          }
          pause(on) {
            if (on) {
              const {
                activeElement
              } = document;
              if (this.div.contains(activeElement)) {
                this.#focusedElement = activeElement;
              }
              return;
            }
            if (this.#focusedElement) {
              setTimeout(() => {
                this.#focusedElement?.focus();
                this.#focusedElement = null;
              }, 0);
            }
          }
          endDrawingSession(isAborted = false) {
            if (!this.#drawingAC) {
              return null;
            }
            this.#uiManager.setCurrentDrawingSession(null);
            this.#drawingAC.abort();
            this.#drawingAC = null;
            this.#focusedElement = null;
            return this.#currentEditorType.endDrawing(isAborted);
          }
          findNewParent(editor, x, y) {
            const layer = this.#uiManager.findParent(x, y);
            if (layer === null || layer === this) {
              return false;
            }
            layer.changeParent(editor);
            return true;
          }
          commitOrRemove() {
            if (this.#drawingAC) {
              this.endDrawingSession();
              return true;
            }
            return false;
          }
          onScaleChanging() {
            if (!this.#drawingAC) {
              return;
            }
            this.#currentEditorType.onScaleChangingWhenDrawing(this);
          }
          destroy() {
            this.commitOrRemove();
            if (this.#uiManager.getActive()?.parent === this) {
              this.#uiManager.commitOrRemove();
              this.#uiManager.setActiveEditor(null);
            }
            if (this.#editorFocusTimeoutId) {
              clearTimeout(this.#editorFocusTimeoutId);
              this.#editorFocusTimeoutId = null;
            }
            for (const editor of this.#editors.values()) {
              this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
              editor.setParent(null);
              editor.isAttachedToDOM = false;
              editor.div.remove();
            }
            this.div = null;
            this.#editors.clear();
            this.#uiManager.removeLayer(this);
          }
          #cleanup() {
            for (const editor of this.#editors.values()) {
              if (editor.isEmpty()) {
                editor.remove();
              }
            }
          }
          render({
            viewport
          }) {
            this.viewport = viewport;
            setLayerDimensions(this.div, viewport);
            for (const editor of this.#uiManager.getEditors(this.pageIndex)) {
              this.add(editor);
              editor.rebuild();
            }
            this.updateMode();
          }
          update({
            viewport
          }) {
            this.#uiManager.commitOrRemove();
            this.#cleanup();
            const oldRotation = this.viewport.rotation;
            const rotation = viewport.rotation;
            this.viewport = viewport;
            setLayerDimensions(this.div, {
              rotation
            });
            if (oldRotation !== rotation) {
              for (const editor of this.#editors.values()) {
                editor.rotate(rotation);
              }
            }
          }
          get pageDimensions() {
            const {
              pageWidth,
              pageHeight
            } = this.viewport.rawDims;
            return [pageWidth, pageHeight];
          }
          get scale() {
            return this.#uiManager.viewParameters.realScale;
          }
        }

        ;// ./src/display/draw_layer.js


        class DrawLayer {
          #parent = null;
          #mapping = new Map();
          #toUpdate = new Map();
          static #id = 0;
          constructor({
            pageIndex
          }) {
            this.pageIndex = pageIndex;
          }
          setParent(parent) {
            if (!this.#parent) {
              this.#parent = parent;
              return;
            }
            if (this.#parent !== parent) {
              if (this.#mapping.size > 0) {
                for (const root of this.#mapping.values()) {
                  root.remove();
                  parent.append(root);
                }
              }
              this.#parent = parent;
            }
          }
          static get _svgFactory() {
            return shadow(this, "_svgFactory", new DOMSVGFactory());
          }
          static #setBox(element, [x, y, width, height]) {
            const {
              style
            } = element;
            style.top = `${100 * y}%`;
            style.left = `${100 * x}%`;
            style.width = `${100 * width}%`;
            style.height = `${100 * height}%`;
          }
          #createSVG() {
            const svg = DrawLayer._svgFactory.create(1, 1, true);
            this.#parent.append(svg);
            svg.setAttribute("aria-hidden", true);
            return svg;
          }
          #createClipPath(defs, pathId) {
            const clipPath = DrawLayer._svgFactory.createElement("clipPath");
            defs.append(clipPath);
            const clipPathId = `clip_${pathId}`;
            clipPath.setAttribute("id", clipPathId);
            clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
            const clipPathUse = DrawLayer._svgFactory.createElement("use");
            clipPath.append(clipPathUse);
            clipPathUse.setAttribute("href", `#${pathId}`);
            clipPathUse.classList.add("clip");
            return clipPathId;
          }
          #updateProperties(element, properties) {
            for (const [key, value] of Object.entries(properties)) {
              if (value === null) {
                element.removeAttribute(key);
              } else {
                element.setAttribute(key, value);
              }
            }
          }
          draw(properties, isPathUpdatable = false, hasClip = false) {
            const id = DrawLayer.#id++;
            const root = this.#createSVG();
            const defs = DrawLayer._svgFactory.createElement("defs");
            root.append(defs);
            const path = DrawLayer._svgFactory.createElement("path");
            defs.append(path);
            const pathId = `path_p${this.pageIndex}_${id}`;
            path.setAttribute("id", pathId);
            path.setAttribute("vector-effect", "non-scaling-stroke");
            if (isPathUpdatable) {
              this.#toUpdate.set(id, path);
            }
            const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;
            const use = DrawLayer._svgFactory.createElement("use");
            root.append(use);
            use.setAttribute("href", `#${pathId}`);
            this.updateProperties(root, properties);
            this.#mapping.set(id, root);
            return {
              id,
              clipPathId: `url(#${clipPathId})`
            };
          }
          drawOutline(properties, mustRemoveSelfIntersections) {
            const id = DrawLayer.#id++;
            const root = this.#createSVG();
            const defs = DrawLayer._svgFactory.createElement("defs");
            root.append(defs);
            const path = DrawLayer._svgFactory.createElement("path");
            defs.append(path);
            const pathId = `path_p${this.pageIndex}_${id}`;
            path.setAttribute("id", pathId);
            path.setAttribute("vector-effect", "non-scaling-stroke");
            let maskId;
            if (mustRemoveSelfIntersections) {
              const mask = DrawLayer._svgFactory.createElement("mask");
              defs.append(mask);
              maskId = `mask_p${this.pageIndex}_${id}`;
              mask.setAttribute("id", maskId);
              mask.setAttribute("maskUnits", "objectBoundingBox");
              const rect = DrawLayer._svgFactory.createElement("rect");
              mask.append(rect);
              rect.setAttribute("width", "1");
              rect.setAttribute("height", "1");
              rect.setAttribute("fill", "white");
              const use = DrawLayer._svgFactory.createElement("use");
              mask.append(use);
              use.setAttribute("href", `#${pathId}`);
              use.setAttribute("stroke", "none");
              use.setAttribute("fill", "black");
              use.setAttribute("fill-rule", "nonzero");
              use.classList.add("mask");
            }
            const use1 = DrawLayer._svgFactory.createElement("use");
            root.append(use1);
            use1.setAttribute("href", `#${pathId}`);
            if (maskId) {
              use1.setAttribute("mask", `url(#${maskId})`);
            }
            const use2 = use1.cloneNode();
            root.append(use2);
            use1.classList.add("mainOutline");
            use2.classList.add("secondaryOutline");
            this.updateProperties(root, properties);
            this.#mapping.set(id, root);
            return id;
          }
          finalizeDraw(id, properties) {
            this.#toUpdate.delete(id);
            this.updateProperties(id, properties);
          }
          updateProperties(elementOrId, properties) {
            if (!properties) {
              return;
            }
            const {
              root,
              bbox,
              rootClass,
              path
            } = properties;
            const element = typeof elementOrId === "number" ? this.#mapping.get(elementOrId) : elementOrId;
            if (!element) {
              return;
            }
            if (root) {
              this.#updateProperties(element, root);
            }
            if (bbox) {
              DrawLayer.#setBox(element, bbox);
            }
            if (rootClass) {
              const {
                classList
              } = element;
              for (const [className, value] of Object.entries(rootClass)) {
                classList.toggle(className, value);
              }
            }
            if (path) {
              const defs = element.firstChild;
              const pathElement = defs.firstChild;
              this.#updateProperties(pathElement, path);
            }
          }
          updateParent(id, layer) {
            if (layer === this) {
              return;
            }
            const root = this.#mapping.get(id);
            if (!root) {
              return;
            }
            layer.#parent.append(root);
            this.#mapping.delete(id);
            layer.#mapping.set(id, root);
          }
          remove(id) {
            this.#toUpdate.delete(id);
            if (this.#parent === null) {
              return;
            }
            this.#mapping.get(id).remove();
            this.#mapping.delete(id);
          }
          destroy() {
            this.#parent = null;
            for (const root of this.#mapping.values()) {
              root.remove();
            }
            this.#mapping.clear();
            this.#toUpdate.clear();
          }
        }

        ;// ./src/pdf.js
















        {
          globalThis._pdfjsTestingUtils = {
            HighlightOutliner: HighlightOutliner
          };
        }
        globalThis.pdfjsLib = {
          AbortException: AbortException,
          AnnotationEditorLayer: AnnotationEditorLayer,
          AnnotationEditorParamsType: AnnotationEditorParamsType,
          AnnotationEditorType: AnnotationEditorType,
          AnnotationEditorUIManager: AnnotationEditorUIManager,
          AnnotationLayer: AnnotationLayer,
          AnnotationMode: AnnotationMode,
          AnnotationType: AnnotationType,
          applyOpacity: applyOpacity,
          build: build,
          ColorPicker: ColorPicker,
          createValidAbsoluteUrl: createValidAbsoluteUrl,
          CSSConstants: CSSConstants,
          DOMSVGFactory: DOMSVGFactory,
          DrawLayer: DrawLayer,
          FeatureTest: util_FeatureTest,
          fetchData: fetchData,
          findContrastColor: findContrastColor,
          getDocument: getDocument,
          getFilenameFromUrl: getFilenameFromUrl,
          getPdfFilenameFromUrl: getPdfFilenameFromUrl,
          getRGB: getRGB,
          getUuid: getUuid,
          getXfaPageViewport: getXfaPageViewport,
          GlobalWorkerOptions: GlobalWorkerOptions,
          ImageKind: util_ImageKind,
          InvalidPDFException: InvalidPDFException,
          isDataScheme: isDataScheme,
          isPdfFile: isPdfFile,
          isValidExplicitDest: isValidExplicitDest,
          MathClamp: MathClamp,
          noContextMenu: noContextMenu,
          normalizeUnicode: normalizeUnicode,
          OPS: OPS,
          OutputScale: OutputScale,
          PasswordResponses: PasswordResponses,
          PDFDataRangeTransport: PDFDataRangeTransport,
          PDFDateString: PDFDateString,
          PDFWorker: PDFWorker,
          PermissionFlag: PermissionFlag,
          PixelsPerInch: PixelsPerInch,
          RenderingCancelledException: RenderingCancelledException,
          renderRichText: renderRichText,
          ResponseException: ResponseException,
          setLayerDimensions: setLayerDimensions,
          shadow: shadow,
          SignatureExtractor: SignatureExtractor,
          stopEvent: stopEvent,
          SupportedImageMimeTypes: SupportedImageMimeTypes,
          TextLayer: TextLayer,
          TouchManager: TouchManager,
          updateUrlHash: updateUrlHash,
          Util: Util,
          VerbosityLevel: VerbosityLevel,
          version: version,
          XfaLayer: XfaLayer
        };



        //# sourceMappingURL=pdf.mjs.map

        /***/
}),

/***/ "../../packages/eko-core/dist lazy recursive":
/*!******************************************************************!*\
  !*** ../../packages/eko-core/dist/ lazy strict namespace object ***!
  \******************************************************************/
/***/ ((module) => {

        function webpackEmptyAsyncContext(req) {
          // Here Promise.resolve().then() is used instead of new Promise() to prevent
          // uncaught exception popping up in devtools
          return Promise.resolve().then(() => {
            var e = new Error("Cannot find module '" + req + "'");
            e.code = 'MODULE_NOT_FOUND';
            throw e;
          });
        }
        webpackEmptyAsyncContext.keys = () => ([]);
        webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext;
        webpackEmptyAsyncContext.id = "../../packages/eko-core/dist lazy recursive";
        module.exports = webpackEmptyAsyncContext;

        /***/
}),

/***/ "../../packages/eko-core/dist/index.esm.js":
/*!*************************************************!*\
  !*** ../../packages/eko-core/dist/index.esm.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Agent: () => (/* binding */ Agent),
/* harmony export */   AgentChain: () => (/* binding */ AgentChain),
/* harmony export */   AgentContext: () => (/* binding */ AgentContext),
/* harmony export */   BaseBrowserAgent: () => (/* binding */ BaseBrowserAgent),
/* harmony export */   BaseBrowserLabelsAgent: () => (/* binding */ BaseBrowserLabelsAgent),
/* harmony export */   BaseBrowserScreenAgent: () => (/* binding */ BaseBrowserScreenAgent),
/* harmony export */   Chain: () => (/* binding */ Chain),
/* harmony export */   ChatAgent: () => (/* binding */ ChatAgent),
/* harmony export */   ChatContext: () => (/* binding */ ChatContext),
/* harmony export */   Context: () => (/* binding */ TaskContext),
/* harmony export */   Eko: () => (/* binding */ Eko),
/* harmony export */   EkoMemory: () => (/* binding */ EkoMemory),
/* harmony export */   ForeachTaskTool: () => (/* binding */ ForeachTaskTool),
/* harmony export */   HumanInteractTool: () => (/* binding */ HumanInteractTool),
/* harmony export */   Log: () => (/* binding */ Log),
/* harmony export */   Planner: () => (/* binding */ Planner),
/* harmony export */   RetryLanguageModel: () => (/* binding */ RetryLanguageModel),
/* harmony export */   SimpleHttpMcpClient: () => (/* binding */ SimpleHttpMcpClient),
/* harmony export */   SimpleSseMcpClient: () => (/* binding */ SimpleSseMcpClient),
/* harmony export */   TaskContext: () => (/* binding */ TaskContext),
/* harmony export */   TaskNodeStatusTool: () => (/* binding */ TaskNodeStatusTool),
/* harmony export */   VariableStorageTool: () => (/* binding */ VariableStorageTool),
/* harmony export */   WatchTriggerTool: () => (/* binding */ WatchTriggerTool),
/* harmony export */   buildAgentTree: () => (/* binding */ buildAgentTree),
/* harmony export */   buildSimpleAgentWorkflow: () => (/* binding */ buildSimpleAgentWorkflow),
/* harmony export */   call_timeout: () => (/* binding */ call_timeout),
/* harmony export */   compressImageData: () => (/* binding */ compressImageData),
/* harmony export */   config: () => (/* binding */ config$1),
/* harmony export */   convertToolSchema: () => (/* binding */ convertToolSchema),
/* harmony export */   "default": () => (/* binding */ Eko),
/* harmony export */   extract_page_content: () => (/* binding */ extract_page_content),
/* harmony export */   global: () => (/* binding */ global),
/* harmony export */   mergeTools: () => (/* binding */ mergeTools),
/* harmony export */   parseWorkflow: () => (/* binding */ parseWorkflow),
/* harmony export */   resetWorkflowXml: () => (/* binding */ resetWorkflowXml),
/* harmony export */   sub: () => (/* binding */ sub),
/* harmony export */   toFile: () => (/* binding */ toFile),
/* harmony export */   toImage: () => (/* binding */ toImage),
/* harmony export */   uuidv4: () => (/* binding */ uuidv4)
          /* harmony export */
});
        const config$1 = {
          name: "Eko",
          mode: "normal",
          platform: "mac",
          maxReactNum: 500,
          maxOutputTokens: 16000,
          maxRetryNum: 3,
          agentParallel: false,
          compressThreshold: 80,
          compressTokensThreshold: 80000,
          largeTextLength: 8000,
          fileTextMaxLength: 20000,
          maxDialogueImgFileNum: 1,
          toolResultMultimodal: true,
          parallelToolCalls: true,
          markImageMode: "draw",
          expertModeTodoLoopNum: 10,
          memoryConfig: {
            maxMessageNum: 15,
            maxInputTokens: 64000,
            enableCompression: true,
            compressionThreshold: 10,
            compressionMaxLength: 6000,
          },
        };

        var LogLevel;
        (function (LogLevel) {
          LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
          LogLevel[LogLevel["INFO"] = 1] = "INFO";
          LogLevel[LogLevel["WARN"] = 2] = "WARN";
          LogLevel[LogLevel["ERROR"] = 3] = "ERROR";
          LogLevel[LogLevel["FATAL"] = 4] = "FATAL";
          LogLevel[LogLevel["OFF"] = 5] = "OFF";
        })(LogLevel || (LogLevel = {}));
        class ConsoleTransport {
          log(level, message) {
            const methods = {
              [LogLevel.DEBUG]: console.debug,
              [LogLevel.INFO]: console.info,
              [LogLevel.WARN]: console.warn,
              [LogLevel.ERROR]: console.error,
              [LogLevel.FATAL]: console.error,
              [LogLevel.OFF]: () => { }
            };
            const method = methods[level] || console.log;
            method(message);
          }
        }
        class Logger {
          constructor(options = {}) {
            this.level = options.level ?? LogLevel.INFO;
            this.prefix = options.prefix ?? '';
            this.dateFormat = options.dateFormat ?? true;
            this.transports = options.transport ?? [new ConsoleTransport()];
          }
          setLevel(level) {
            this.level = level;
            return this;
          }
          setPrefix(prefix) {
            this.prefix = prefix;
            return this;
          }
          addTransport(transport) {
            this.transports.push(transport);
            return this;
          }
          formatMessage(level, message) {
            const levelNames = {
              [LogLevel.DEBUG]: 'DEBUG',
              [LogLevel.INFO]: 'INFO',
              [LogLevel.WARN]: 'WARN',
              [LogLevel.ERROR]: 'ERROR',
              [LogLevel.FATAL]: 'FATAL',
              [LogLevel.OFF]: 'OFF'
            };
            let formattedMessage = '';
            if (this.dateFormat) {
              formattedMessage += `[${new Date().toLocaleString()}] `;
            }
            formattedMessage += `[${levelNames[level] || 'UNKNOWN'}] `;
            if (this.prefix) {
              formattedMessage += `[${this.prefix}] `;
            }
            formattedMessage += message;
            return formattedMessage;
          }
          log(level, message, ...args) {
            if (level < this.level) {
              return;
            }
            let finalMessage;
            if (message instanceof Error) {
              finalMessage = `${message.message}\n${message.stack}`;
            }
            else {
              finalMessage = message;
            }
            if (args.length > 0) {
              finalMessage += ' ' + args.map(arg => {
                if (arg == null || arg == undefined) {
                  return arg + '';
                }
                else if (arg instanceof Error || (arg.stack && arg.message)) {
                  return `${arg.message}\n${arg.stack}`;
                }
                else if (typeof arg === 'object') {
                  return JSON.stringify(arg);
                }
                return String(arg);
              }).join(' ');
            }
            const formattedMessage = this.formatMessage(level, finalMessage);
            this.transports.forEach(transport => {
              transport.log(level, formattedMessage);
            });
          }
          isEnableDebug() {
            return this.level <= LogLevel.DEBUG;
          }
          debug(message, ...args) {
            this.log(LogLevel.DEBUG, message, ...args);
          }
          isEnableInfo() {
            return this.level <= LogLevel.INFO;
          }
          info(message, ...args) {
            this.log(LogLevel.INFO, message, ...args);
          }
          warn(message, ...args) {
            this.log(LogLevel.WARN, message, ...args);
          }
          error(message, ...args) {
            this.log(LogLevel.ERROR, message, ...args);
          }
          fatal(message, ...args) {
            this.log(LogLevel.FATAL, message, ...args);
          }
          createChild(name, options = {}) {
            const childPrefix = this.prefix ? `${this.prefix}.${name}` : name;
            return new Logger({
              level: options.level || this.level,
              prefix: childPrefix,
              dateFormat: options.dateFormat !== undefined ? options.dateFormat : this.dateFormat,
              transport: options.transport || this.transports
            });
          }
        }
        const Log = new Logger();

        function sleep(time) {
          return new Promise((resolve) => setTimeout(() => resolve(), time));
        }
        function uuidv4() {
          return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
            const r = (Math.random() * 16) | 0;
            const v = c === "x" ? r : (r & 0x3) | 0x8;
            return v.toString(16);
          });
        }
        function call_timeout(fun, timeout, error_callback) {
          return new Promise(async (resolve, reject) => {
            let timer = setTimeout(() => {
              reject(new Error("Timeout"));
              error_callback && error_callback("Timeout");
            }, timeout);
            try {
              const result = await fun();
              clearTimeout(timer);
              resolve(result);
            }
            catch (e) {
              clearTimeout(timer);
              reject(e);
              error_callback && error_callback(e + "");
            }
          });
        }
        function convertToolSchema(tool) {
          if ("function" in tool) {
            return {
              type: "function",
              name: tool.function.name,
              description: tool.function.description,
              inputSchema: tool.function.parameters,
            };
          }
          else if ("input_schema" in tool) {
            return {
              type: "function",
              name: tool.name,
              description: tool.description,
              inputSchema: tool.input_schema,
            };
          }
          else if ("inputSchema" in tool) {
            return {
              type: "function",
              name: tool.name,
              description: tool.description,
              inputSchema: tool.inputSchema,
            };
          }
          else {
            return {
              type: "function",
              name: tool.name,
              description: tool.description,
              inputSchema: tool.parameters,
            };
          }
        }
        function toImage(mediaData) {
          return toFile(mediaData);
        }
        function toFile(mediaData, type = "base64|url") {
          if (mediaData.startsWith("http://") || mediaData.startsWith("https://")) {
            return new URL(mediaData);
          }
          else if (mediaData.startsWith("//") &&
            mediaData.indexOf(".") > 0 &&
            mediaData.length < 1000) {
            return new URL("https:" + mediaData);
          }
          if (mediaData.startsWith("data:")) {
            mediaData = mediaData.substring(mediaData.indexOf(",") + 1);
          }
          if (type === "binary|url") {
            // @ts-ignore
            if (typeof Buffer != "undefined") {
              // @ts-ignore
              const buffer = Buffer.from(mediaData, "base64");
              return new Uint8Array(buffer);
            }
            else {
              const binaryString = atob(mediaData);
              const fileData = new Uint8Array(binaryString.length);
              for (let i = 0; i < binaryString.length; i++) {
                fileData[i] = binaryString.charCodeAt(i);
              }
              return fileData;
            }
          }
          else {
            return mediaData;
          }
        }
        function getMimeType(data) {
          let mediaType = "image/png";
          if (data.startsWith("data:")) {
            mediaType = data.split(";")[0].split(":")[1];
          }
          else if (data.indexOf(".") > -1) {
            if (data.indexOf(".png") > -1) {
              mediaType = "image/png";
            }
            else if (data.indexOf(".jpg") > -1 || data.indexOf(".jpeg") > -1) {
              mediaType = "image/jpeg";
            }
            else if (data.indexOf(".pdf") > -1) {
              mediaType = "application/pdf";
            }
            else if (data.indexOf(".docx") > -1) {
              mediaType =
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
            }
            else if (data.indexOf(".xlsx") > -1) {
              mediaType =
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
            }
            else if (data.indexOf(".pptx") > -1) {
              mediaType =
                "application/vnd.openxmlformats-officedocument.presentationml.presentation";
            }
            else if (data.indexOf(".txt") > -1) {
              mediaType = "text/plain";
            }
            else if (data.indexOf(".md") > -1) {
              mediaType = "text/markdown";
            }
            else if (data.indexOf(".json") > -1) {
              mediaType = "application/json";
            }
            else if (data.indexOf(".xml") > -1) {
              mediaType = "application/xml";
            }
            else if (data.indexOf(".csv") > -1) {
              mediaType = "text/csv";
            }
          }
          return mediaType;
        }
        async function compressImageData(imageBase64, imageType, compress, quality) {
          const base64Data = imageBase64;
          const binaryString = typeof atob !== "undefined"
            ? atob(base64Data)
            : // @ts-ignore
            Buffer.from(base64Data, "base64").toString("binary");
          const bytes = new Uint8Array(binaryString.length);
          for (let i = 0; i < binaryString.length; i++) {
            bytes[i] = binaryString.charCodeAt(i);
          }
          if (!quality) {
            if (bytes.length >= 1024 * 1024 * 3) {
              quality = 0.6;
            }
            else if (bytes.length >= 1024 * 1024 * 1.5) {
              quality = 0.8;
            }
            else {
              quality = 1;
            }
          }
          const targetByScale = (bitmapWidth, bitmapHeight) => ({
            width: compress.scale
              ? bitmapWidth * compress.scale
              : compress.resizeWidth,
            height: compress.scale
              ? bitmapHeight * compress.scale
              : compress.resizeHeight,
          });
          const hasOffscreen = typeof OffscreenCanvas !== "undefined";
          const hasCreateImageBitmap = typeof createImageBitmap !== "undefined";
          const hasDOM = typeof document !== "undefined" && typeof Image !== "undefined";
          const isNode = typeof window === "undefined" &&
            // @ts-ignore
            typeof process !== "undefined" &&
            // @ts-ignore
            !!process.versions &&
            // @ts-ignore
            !!process.versions.node;
          const loadImageAny = async () => {
            if (hasCreateImageBitmap) {
              const blob = new Blob([bytes], { type: imageType });
              const bitmap = await createImageBitmap(blob);
              return { img: bitmap, width: bitmap.width, height: bitmap.height };
            }
            if (hasDOM) {
              const img = await new Promise((resolve, reject) => {
                const image = new Image();
                image.onload = () => resolve(image);
                image.onerror = (e) => reject(e);
                image.src = `data:${imageType};base64,${imageBase64}`;
              });
              return { img, width: img.width, height: img.height };
            }
            if (isNode) {
              const canvasMod = await loadPackage("canvas");
              const { loadImage } = canvasMod;
              const dataUrl = `data:${imageType};base64,${imageBase64}`;
              const img = await loadImage(dataUrl);
              return { img, width: img.width, height: img.height };
            }
            throw new Error("No image environment available");
          };
          const createCanvasAny = async (width, height) => {
            if (hasOffscreen) {
              const canvas = new OffscreenCanvas(width, height);
              return {
                ctx: canvas.getContext("2d"),
                exportBase64: async (mime, q) => {
                  const blob = await canvas.convertToBlob({ type: mime, quality: q });
                  return await new Promise((res, rej) => {
                    const reader = new FileReader();
                    reader.onloadend = () => {
                      const url = reader.result;
                      res(url.substring(url.indexOf("base64,") + 7));
                    };
                    reader.onerror = () => rej(new Error("Failed to convert blob to base64"));
                    reader.readAsDataURL(blob);
                  });
                },
              };
            }
            if (hasDOM) {
              const canvas = document.createElement("canvas");
              canvas.width = width;
              canvas.height = height;
              return {
                ctx: canvas.getContext("2d"),
                exportBase64: async (mime, q) => {
                  const dataUrl = canvas.toDataURL(mime, q);
                  return dataUrl.substring(dataUrl.indexOf("base64,") + 7);
                },
              };
            }
            if (isNode) {
              const canvasMod = await loadPackage("canvas");
              const { createCanvas } = canvasMod;
              const canvas = createCanvas(width, height);
              return {
                ctx: canvas.getContext("2d"),
                exportBase64: async (mime, q) => {
                  const buffer = canvas.toBuffer(mime, { quality: q });
                  return ((
                    // @ts-ignore
                    typeof Buffer !== "undefined" ? Buffer.from(buffer) : buffer).toString("base64"));
                },
              };
            }
            throw new Error("No canvas environment available");
          };
          const loaded = await loadImageAny();
          const { width, height } = targetByScale(loaded.width, loaded.height);
          if (loaded.width == width && loaded.height == height && quality == 1) {
            return {
              imageBase64: imageBase64,
              imageType: imageType,
            };
          }
          const { ctx, exportBase64 } = await createCanvasAny(width, height);
          if (!ctx) {
            return {
              imageBase64: imageBase64,
              imageType: imageType,
            };
          }
          ctx.drawImage(loaded.img, 0, 0, width, height);
          const outBase64 = await exportBase64("image/jpeg", quality);
          return {
            imageBase64: outBase64,
            imageType: "image/jpeg",
          };
        }
        function mergeTools(tools1, tools2) {
          let tools = [];
          let toolMap2 = tools2.reduce((map, tool) => {
            map[tool.name] = tool;
            return map;
          }, {});
          let names = [];
          for (let i = 0; i < tools1.length; i++) {
            let tool1 = tools1[i];
            let tool2 = toolMap2[tool1.name];
            if (tool2) {
              tools.push(tool2);
              delete toolMap2[tool1.name];
            }
            else {
              tools.push(tool1);
            }
          }
          for (let i = 0; i < tools2.length; i++) {
            let tool2 = tools2[i];
            if (toolMap2[tool2.name] && names.indexOf(tool2.name) === -1) {
              tools.push(tool2);
              names.push(tool2.name);
            }
          }
          return tools;
        }
        function mergeAgents(agents1, agents2) {
          let agents = [];
          let agentMap2 = agents2.reduce((map, agent) => {
            map[agent.Name] = agent;
            return map;
          }, {});
          for (let i = 0; i < agents1.length; i++) {
            let agent1 = agents1[i];
            let agent2 = agentMap2[agent1.Name];
            if (agent2) {
              agents.push(agent2);
              delete agentMap2[agent1.Name];
            }
            else {
              agents.push(agent1);
            }
          }
          for (let i = 0; i < agents2.length; i++) {
            let agent2 = agents2[i];
            if (agentMap2[agent2.Name]) {
              agents.push(agent2);
            }
          }
          return agents;
        }
        function sub(str, maxLength, appendPoint = true) {
          if (!str) {
            return "";
          }
          if (str.length > maxLength) {
            // return str.substring(0, maxLength) + (appendPoint ? "..." : "");
            return (Array.from(str).slice(0, maxLength).join("") + (appendPoint ? "..." : ""));
          }
          return str;
        }
        function fixJson(code) {
          if (!code) {
            return {};
          }
          try {
            return JSON.parse(code);
          }
          catch (e) { }
          try {
            return JSON.parse(code + '"}');
          }
          catch (e) { }
          const stack = [];
          for (let i = 0; i < code.length; i++) {
            let s = code[i];
            if (s === "{") {
              stack.push("}");
            }
            else if (s === "}") {
              stack.pop();
            }
            else if (s === "[") {
              stack.push("]");
            }
            else if (s === "]") {
              stack.pop();
            }
            else if (s === '"') {
              if (stack[stack.length - 1] === '"') {
                stack.pop();
              }
              else {
                stack.push('"');
              }
            }
          }
          const missingParts = [];
          while (stack.length > 0) {
            missingParts.push(stack.pop());
          }
          let json = code + missingParts.join("");
          try {
            return JSON.parse(json);
          }
          catch (e) {
            return {};
          }
        }
        function fixXmlTag(code) {
          code = code.trim();
          if (code.endsWith("<")) {
            code = code.substring(0, code.length - 1);
          }
          if (code.indexOf("&") > -1) {
            code = code.replace(/&(?![a-zA-Z0-9#]+;)/g, "&amp;");
          }
          function fixDoubleChar(code) {
            const stack = [];
            for (let i = 0; i < code.length; i++) {
              let s = code[i];
              if (s === "<") {
                stack.push(">");
              }
              else if (s === ">") {
                stack.pop();
              }
              else if (s === '"') {
                if (stack[stack.length - 1] === '"') {
                  stack.pop();
                }
                else {
                  stack.push('"');
                }
              }
            }
            const missingParts = [];
            while (stack.length > 0) {
              missingParts.push(stack.pop());
            }
            return code + missingParts.join("");
          }
          let eIdx = code.lastIndexOf(" ");
          let endStr = eIdx > -1 ? code.substring(eIdx + 1) : "";
          if (code.endsWith("=")) {
            code += '""';
          }
          else if (endStr == "name" ||
            endStr == "id" ||
            endStr == "depen" ||
            endStr == "depends" ||
            endStr == "dependsOn" ||
            endStr == "input" ||
            endStr == "output" ||
            endStr == "items" ||
            endStr == "event" ||
            endStr == "loop") {
            let idx1 = code.lastIndexOf(">");
            let idx2 = code.lastIndexOf("<");
            if (idx1 < idx2 && code.lastIndexOf(" ") > idx2) {
              code += '=""';
            }
          }
          code = fixDoubleChar(code);
          const stack = [];
          function isSelfClosing(tag) {
            return tag.endsWith("/>");
          }
          for (let i = 0; i < code.length; i++) {
            let s = code[i];
            if (s === "<") {
              const isEndTag = code[i + 1] === "/";
              let endIndex = code.indexOf(">", i);
              let tagContent = code.slice(i, endIndex + 1);
              if (isSelfClosing(tagContent));
              else if (isEndTag) {
                stack.pop();
              }
              else {
                stack.push(tagContent);
              }
              if (endIndex == -1) {
                break;
              }
              i = endIndex;
            }
          }
          const missingParts = [];
          while (stack.length > 0) {
            const top = stack.pop();
            if (top.startsWith("<")) {
              let arr = top.match(/<(\w+)/);
              if (arr) {
                const tagName = arr[1];
                missingParts.push(`</${tagName}>`);
              }
            }
            else {
              missingParts.push(top);
            }
          }
          let completedCode = code + missingParts.join("");
          return completedCode;
        }
        async function loadPackage(packageName) {
          // @ts-ignore
          if (typeof require !== "undefined") {
            try {
              return await __webpack_require__("../../packages/eko-core/dist lazy recursive")(packageName);
            }
            catch {
              // @ts-ignore
              return require(packageName);
            }
          }
          return await __webpack_require__("../../packages/eko-core/dist lazy recursive")(packageName);
        }

        // src/errors/ai-sdk-error.ts
        var marker$1 = "vercel.ai.error";
        var symbol$1 = Symbol.for(marker$1);
        var _a$1;
        var _AISDKError$1 = class _AISDKError extends Error {
          /**
           * Creates an AI SDK Error.
           *
           * @param {Object} params - The parameters for creating the error.
           * @param {string} params.name - The name of the error.
           * @param {string} params.message - The error message.
           * @param {unknown} [params.cause] - The underlying cause of the error.
           */
          constructor({
            name: name14,
            message,
            cause
          }) {
            super(message);
            this[_a$1] = true;
            this.name = name14;
            this.cause = cause;
          }
          /**
           * Checks if the given error is an AI SDK Error.
           * @param {unknown} error - The error to check.
           * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
           */
          static isInstance(error) {
            return _AISDKError.hasMarker(error, marker$1);
          }
          static hasMarker(error, marker15) {
            const markerSymbol = Symbol.for(marker15);
            return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
          }
        };
        _a$1 = symbol$1;
        var AISDKError$1 = _AISDKError$1;

        // src/errors/api-call-error.ts
        var name$1 = "AI_APICallError";
        var marker2$1 = `vercel.ai.error.${name$1}`;
        var symbol2$1 = Symbol.for(marker2$1);
        var _a2$1;
        var APICallError$1 = class APICallError extends AISDKError$1 {
          constructor({
            message,
            url,
            requestBodyValues,
            statusCode,
            responseHeaders,
            responseBody,
            cause,
            isRetryable = statusCode != null && (statusCode === 408 || // request timeout
              statusCode === 409 || // conflict
              statusCode === 429 || // too many requests
              statusCode >= 500),
            // server error
            data
          }) {
            super({ name: name$1, message, cause });
            this[_a2$1] = true;
            this.url = url;
            this.requestBodyValues = requestBodyValues;
            this.statusCode = statusCode;
            this.responseHeaders = responseHeaders;
            this.responseBody = responseBody;
            this.isRetryable = isRetryable;
            this.data = data;
          }
          static isInstance(error) {
            return AISDKError$1.hasMarker(error, marker2$1);
          }
        };
        _a2$1 = symbol2$1;

        // src/errors/empty-response-body-error.ts
        var name2$1 = "AI_EmptyResponseBodyError";
        var marker3$1 = `vercel.ai.error.${name2$1}`;
        var symbol3$1 = Symbol.for(marker3$1);
        var _a3$1;
        var EmptyResponseBodyError$1 = class EmptyResponseBodyError extends AISDKError$1 {
          // used in isInstance
          constructor({ message = "Empty response body" } = {}) {
            super({ name: name2$1, message });
            this[_a3$1] = true;
          }
          static isInstance(error) {
            return AISDKError$1.hasMarker(error, marker3$1);
          }
        };
        _a3$1 = symbol3$1;

        // src/errors/get-error-message.ts
        function getErrorMessage$1(error) {
          if (error == null) {
            return "unknown error";
          }
          if (typeof error === "string") {
            return error;
          }
          if (error instanceof Error) {
            return error.message;
          }
          return JSON.stringify(error);
        }

        // src/errors/invalid-argument-error.ts
        var name3$1 = "AI_InvalidArgumentError";
        var marker4$1 = `vercel.ai.error.${name3$1}`;
        var symbol4$1 = Symbol.for(marker4$1);
        var _a4$1;
        var InvalidArgumentError$1 = class InvalidArgumentError extends AISDKError$1 {
          constructor({
            message,
            cause,
            argument
          }) {
            super({ name: name3$1, message, cause });
            this[_a4$1] = true;
            this.argument = argument;
          }
          static isInstance(error) {
            return AISDKError$1.hasMarker(error, marker4$1);
          }
        };
        _a4$1 = symbol4$1;

        // src/errors/invalid-prompt-error.ts
        var name4$1 = "AI_InvalidPromptError";
        var marker5$1 = `vercel.ai.error.${name4$1}`;
        var symbol5$1 = Symbol.for(marker5$1);
        var _a5$1;
        var InvalidPromptError$1 = class InvalidPromptError extends AISDKError$1 {
          constructor({
            prompt,
            message,
            cause
          }) {
            super({ name: name4$1, message: `Invalid prompt: ${message}`, cause });
            this[_a5$1] = true;
            this.prompt = prompt;
          }
          static isInstance(error) {
            return AISDKError$1.hasMarker(error, marker5$1);
          }
        };
        _a5$1 = symbol5$1;

        // src/errors/invalid-response-data-error.ts
        var name5$1 = "AI_InvalidResponseDataError";
        var marker6$1 = `vercel.ai.error.${name5$1}`;
        var symbol6$1 = Symbol.for(marker6$1);
        var _a6$1;
        var InvalidResponseDataError$1 = class InvalidResponseDataError extends AISDKError$1 {
          constructor({
            data,
            message = `Invalid response data: ${JSON.stringify(data)}.`
          }) {
            super({ name: name5$1, message });
            this[_a6$1] = true;
            this.data = data;
          }
          static isInstance(error) {
            return AISDKError$1.hasMarker(error, marker6$1);
          }
        };
        _a6$1 = symbol6$1;

        // src/errors/json-parse-error.ts
        var name6$1 = "AI_JSONParseError";
        var marker7$1 = `vercel.ai.error.${name6$1}`;
        var symbol7$1 = Symbol.for(marker7$1);
        var _a7$1;
        var JSONParseError$1 = class JSONParseError extends AISDKError$1 {
          constructor({ text, cause }) {
            super({
              name: name6$1,
              message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage$1(cause)}`,
              cause
            });
            this[_a7$1] = true;
            this.text = text;
          }
          static isInstance(error) {
            return AISDKError$1.hasMarker(error, marker7$1);
          }
        };
        _a7$1 = symbol7$1;

        // src/errors/load-api-key-error.ts
        var name7$1 = "AI_LoadAPIKeyError";
        var marker8$1 = `vercel.ai.error.${name7$1}`;
        var symbol8$1 = Symbol.for(marker8$1);
        var _a8$1;
        var LoadAPIKeyError$1 = class LoadAPIKeyError extends AISDKError$1 {
          // used in isInstance
          constructor({ message }) {
            super({ name: name7$1, message });
            this[_a8$1] = true;
          }
          static isInstance(error) {
            return AISDKError$1.hasMarker(error, marker8$1);
          }
        };
        _a8$1 = symbol8$1;

        // src/errors/load-setting-error.ts
        var name8 = "AI_LoadSettingError";
        var marker9 = `vercel.ai.error.${name8}`;
        var symbol9 = Symbol.for(marker9);
        var _a9;
        var LoadSettingError = class extends AISDKError$1 {
          // used in isInstance
          constructor({ message }) {
            super({ name: name8, message });
            this[_a9] = true;
          }
          static isInstance(error) {
            return AISDKError$1.hasMarker(error, marker9);
          }
        };
        _a9 = symbol9;

        // src/errors/no-such-model-error.ts
        var name10 = "AI_NoSuchModelError";
        var marker11 = `vercel.ai.error.${name10}`;
        var symbol11 = Symbol.for(marker11);
        var _a11;
        var NoSuchModelError = class extends AISDKError$1 {
          constructor({
            errorName = name10,
            modelId,
            modelType,
            message = `No such ${modelType}: ${modelId}`
          }) {
            super({ name: errorName, message });
            this[_a11] = true;
            this.modelId = modelId;
            this.modelType = modelType;
          }
          static isInstance(error) {
            return AISDKError$1.hasMarker(error, marker11);
          }
        };
        _a11 = symbol11;

        // src/errors/too-many-embedding-values-for-call-error.ts
        var name11 = "AI_TooManyEmbeddingValuesForCallError";
        var marker12 = `vercel.ai.error.${name11}`;
        var symbol12 = Symbol.for(marker12);
        var _a12;
        var TooManyEmbeddingValuesForCallError = class extends AISDKError$1 {
          constructor(options) {
            super({
              name: name11,
              message: `Too many values for a single embedding call. The ${options.provider} model "${options.modelId}" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`
            });
            this[_a12] = true;
            this.provider = options.provider;
            this.modelId = options.modelId;
            this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;
            this.values = options.values;
          }
          static isInstance(error) {
            return AISDKError$1.hasMarker(error, marker12);
          }
        };
        _a12 = symbol12;

        // src/errors/type-validation-error.ts
        var name12$1 = "AI_TypeValidationError";
        var marker13$1 = `vercel.ai.error.${name12$1}`;
        var symbol13$1 = Symbol.for(marker13$1);
        var _a13$1;
        var _TypeValidationError$1 = class _TypeValidationError extends AISDKError$1 {
          constructor({ value, cause }) {
            super({
              name: name12$1,
              message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage$1(cause)}`,
              cause
            });
            this[_a13$1] = true;
            this.value = value;
          }
          static isInstance(error) {
            return AISDKError$1.hasMarker(error, marker13$1);
          }
          /**
           * Wraps an error into a TypeValidationError.
           * If the cause is already a TypeValidationError with the same value, it returns the cause.
           * Otherwise, it creates a new TypeValidationError.
           *
           * @param {Object} params - The parameters for wrapping the error.
           * @param {unknown} params.value - The value that failed validation.
           * @param {unknown} params.cause - The original error or cause of the validation failure.
           * @returns {TypeValidationError} A TypeValidationError instance.
           */
          static wrap({
            value,
            cause
          }) {
            return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });
          }
        };
        _a13$1 = symbol13$1;
        var TypeValidationError$1 = _TypeValidationError$1;

        // src/errors/unsupported-functionality-error.ts
        var name13$1 = "AI_UnsupportedFunctionalityError";
        var marker14$1 = `vercel.ai.error.${name13$1}`;
        var symbol14$1 = Symbol.for(marker14$1);
        var _a14$1;
        var UnsupportedFunctionalityError$1 = class UnsupportedFunctionalityError extends AISDKError$1 {
          constructor({
            functionality,
            message = `'${functionality}' functionality not supported.`
          }) {
            super({ name: name13$1, message });
            this[_a14$1] = true;
            this.functionality = functionality;
          }
          static isInstance(error) {
            return AISDKError$1.hasMarker(error, marker14$1);
          }
        };
        _a14$1 = symbol14$1;

        let ParseError$1 = class ParseError extends Error {
          constructor(message, options) {
            super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
          }
        };
        function noop$1(_arg) {
        }
        function createParser$1(callbacks) {
          if (typeof callbacks == "function")
            throw new TypeError(
              "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
            );
          const { onEvent = noop$1, onError = noop$1, onRetry = noop$1, onComment } = callbacks;
          let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
          function feed(newChunk) {
            const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines$1(`${incompleteLine}${chunk}`);
            for (const line of complete)
              parseLine(line);
            incompleteLine = incomplete, isFirstChunk = false;
          }
          function parseLine(line) {
            if (line === "") {
              dispatchEvent();
              return;
            }
            if (line.startsWith(":")) {
              onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
              return;
            }
            const fieldSeparatorIndex = line.indexOf(":");
            if (fieldSeparatorIndex !== -1) {
              const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
              processField(field, value, line);
              return;
            }
            processField(line, "", line);
          }
          function processField(field, value, line) {
            switch (field) {
              case "event":
                eventType = value;
                break;
              case "data":
                data = `${data}${value}
`;
                break;
              case "id":
                id = value.includes("\0") ? void 0 : value;
                break;
              case "retry":
                /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
                  new ParseError$1(`Invalid \`retry\` value: "${value}"`, {
                    type: "invalid-retry",
                    value,
                    line
                  })
                );
                break;
              default:
                onError(
                  new ParseError$1(
                    `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
                    { type: "unknown-field", field, value, line }
                  )
                );
                break;
            }
          }
          function dispatchEvent() {
            data.length > 0 && onEvent({
              id,
              event: eventType || void 0,
              // If the data buffer's last character is a U+000A LINE FEED (LF) character,
              // then remove the last character from the data buffer.
              data: data.endsWith(`
`) ? data.slice(0, -1) : data
            }), id = void 0, data = "", eventType = "";
          }
          function reset(options = {}) {
            incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
          }
          return { feed, reset };
        }
        function splitLines$1(chunk) {
          const lines = [];
          let incompleteLine = "", searchIndex = 0;
          for (; searchIndex < chunk.length;) {
            const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
            let lineEnd = -1;
            if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
              incompleteLine = chunk.slice(searchIndex);
              break;
            } else {
              const line = chunk.slice(searchIndex, lineEnd);
              lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
            }
          }
          return [lines, incompleteLine];
        }

        let EventSourceParserStream$1 = class EventSourceParserStream extends TransformStream {
          constructor({ onError, onRetry, onComment } = {}) {
            let parser;
            super({
              start(controller) {
                parser = createParser$1({
                  onEvent: (event) => {
                    controller.enqueue(event);
                  },
                  onError(error) {
                    onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
                  },
                  onRetry,
                  onComment
                });
              },
              transform(chunk) {
                parser.feed(chunk);
              }
            });
          }
        };

        /** A special constant with type `never` */
        function $constructor(name, initializer, params) {
          function init(inst, def) {
            var _a;
            Object.defineProperty(inst, "_zod", {
              value: inst._zod ?? {},
              enumerable: false,
            });
            (_a = inst._zod).traits ?? (_a.traits = new Set());
            inst._zod.traits.add(name);
            initializer(inst, def);
            // support prototype modifications
            for (const k in _.prototype) {
              if (!(k in inst))
                Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });
            }
            inst._zod.constr = _;
            inst._zod.def = def;
          }
          // doesn't work if Parent has a constructor with arguments
          const Parent = params?.Parent ?? Object;
          class Definition extends Parent {
          }
          Object.defineProperty(Definition, "name", { value: name });
          function _(def) {
            var _a;
            const inst = params?.Parent ? new Definition() : this;
            init(inst, def);
            (_a = inst._zod).deferred ?? (_a.deferred = []);
            for (const fn of inst._zod.deferred) {
              fn();
            }
            return inst;
          }
          Object.defineProperty(_, "init", { value: init });
          Object.defineProperty(_, Symbol.hasInstance, {
            value: (inst) => {
              if (params?.Parent && inst instanceof params.Parent)
                return true;
              return inst?._zod?.traits?.has(name);
            },
          });
          Object.defineProperty(_, "name", { value: name });
          return _;
        }
        class $ZodAsyncError extends Error {
          constructor() {
            super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
          }
        }
        class $ZodEncodeError extends Error {
          constructor(name) {
            super(`Encountered unidirectional transform during encode: ${name}`);
            this.name = "ZodEncodeError";
          }
        }
        const globalConfig = {};
        function config(newConfig) {
          return globalConfig;
        }

        // functions
        function getEnumValues(entries) {
          const numericValues = Object.values(entries).filter((v) => typeof v === "number");
          const values = Object.entries(entries)
            .filter(([k, _]) => numericValues.indexOf(+k) === -1)
            .map(([_, v]) => v);
          return values;
        }
        function jsonStringifyReplacer(_, value) {
          if (typeof value === "bigint")
            return value.toString();
          return value;
        }
        function cached(getter) {
          return {
            get value() {
              {
                const value = getter();
                Object.defineProperty(this, "value", { value });
                return value;
              }
            },
          };
        }
        function nullish(input) {
          return input === null || input === undefined;
        }
        function cleanRegex(source) {
          const start = source.startsWith("^") ? 1 : 0;
          const end = source.endsWith("$") ? source.length - 1 : source.length;
          return source.slice(start, end);
        }
        function floatSafeRemainder(val, step) {
          const valDecCount = (val.toString().split(".")[1] || "").length;
          const stepString = step.toString();
          let stepDecCount = (stepString.split(".")[1] || "").length;
          if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
            const match = stepString.match(/\d?e-(\d?)/);
            if (match?.[1]) {
              stepDecCount = Number.parseInt(match[1]);
            }
          }
          const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
          const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
          const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
          return (valInt % stepInt) / 10 ** decCount;
        }
        const EVALUATING = Symbol("evaluating");
        function defineLazy(object, key, getter) {
          let value = undefined;
          Object.defineProperty(object, key, {
            get() {
              if (value === EVALUATING) {
                // Circular reference detected, return undefined to break the cycle
                return undefined;
              }
              if (value === undefined) {
                value = EVALUATING;
                value = getter();
              }
              return value;
            },
            set(v) {
              Object.defineProperty(object, key, {
                value: v,
                // configurable: true,
              });
              // object[key] = v;
            },
            configurable: true,
          });
        }
        function assignProp(target, prop, value) {
          Object.defineProperty(target, prop, {
            value,
            writable: true,
            enumerable: true,
            configurable: true,
          });
        }
        function mergeDefs(...defs) {
          const mergedDescriptors = {};
          for (const def of defs) {
            const descriptors = Object.getOwnPropertyDescriptors(def);
            Object.assign(mergedDescriptors, descriptors);
          }
          return Object.defineProperties({}, mergedDescriptors);
        }
        function esc(str) {
          return JSON.stringify(str);
        }
        const captureStackTrace = ("captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => { });
        function isObject(data) {
          return typeof data === "object" && data !== null && !Array.isArray(data);
        }
        const allowsEval = cached(() => {
          // @ts-ignore
          if (typeof navigator !== "undefined" && navigator?.userAgent?.includes("Cloudflare")) {
            return false;
          }
          try {
            const F = Function;
            new F("");
            return true;
          }
          catch (_) {
            return false;
          }
        });
        function isPlainObject(o) {
          if (isObject(o) === false)
            return false;
          // modified constructor
          const ctor = o.constructor;
          if (ctor === undefined)
            return true;
          // modified prototype
          const prot = ctor.prototype;
          if (isObject(prot) === false)
            return false;
          // ctor doesn't have static `isPrototypeOf`
          if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
            return false;
          }
          return true;
        }
        function shallowClone(o) {
          if (isPlainObject(o))
            return { ...o };
          if (Array.isArray(o))
            return [...o];
          return o;
        }
        const propertyKeyTypes = new Set(["string", "number", "symbol"]);
        function escapeRegex(str) {
          return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        }
        // zod-specific utils
        function clone(inst, def, params) {
          const cl = new inst._zod.constr(def ?? inst._zod.def);
          if (!def || params?.parent)
            cl._zod.parent = inst;
          return cl;
        }
        function normalizeParams(_params) {
          const params = _params;
          if (!params)
            return {};
          if (typeof params === "string")
            return { error: () => params };
          if (params?.message !== undefined) {
            if (params?.error !== undefined)
              throw new Error("Cannot specify both `message` and `error` params");
            params.error = params.message;
          }
          delete params.message;
          if (typeof params.error === "string")
            return { ...params, error: () => params.error };
          return params;
        }
        function optionalKeys(shape) {
          return Object.keys(shape).filter((k) => {
            return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
          });
        }
        const NUMBER_FORMAT_RANGES = {
          safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
          int32: [-2147483648, 2147483647],
          uint32: [0, 4294967295],
          float32: [-34028234663852886e22, 3.4028234663852886e38],
          float64: [-Number.MAX_VALUE, Number.MAX_VALUE],
        };
        function pick(schema, mask) {
          const currDef = schema._zod.def;
          const def = mergeDefs(schema._zod.def, {
            get shape() {
              const newShape = {};
              for (const key in mask) {
                if (!(key in currDef.shape)) {
                  throw new Error(`Unrecognized key: "${key}"`);
                }
                if (!mask[key])
                  continue;
                newShape[key] = currDef.shape[key];
              }
              assignProp(this, "shape", newShape); // self-caching
              return newShape;
            },
            checks: [],
          });
          return clone(schema, def);
        }
        function omit(schema, mask) {
          const currDef = schema._zod.def;
          const def = mergeDefs(schema._zod.def, {
            get shape() {
              const newShape = { ...schema._zod.def.shape };
              for (const key in mask) {
                if (!(key in currDef.shape)) {
                  throw new Error(`Unrecognized key: "${key}"`);
                }
                if (!mask[key])
                  continue;
                delete newShape[key];
              }
              assignProp(this, "shape", newShape); // self-caching
              return newShape;
            },
            checks: [],
          });
          return clone(schema, def);
        }
        function extend(schema, shape) {
          if (!isPlainObject(shape)) {
            throw new Error("Invalid input to extend: expected a plain object");
          }
          const checks = schema._zod.def.checks;
          const hasChecks = checks && checks.length > 0;
          if (hasChecks) {
            throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
          }
          const def = mergeDefs(schema._zod.def, {
            get shape() {
              const _shape = { ...schema._zod.def.shape, ...shape };
              assignProp(this, "shape", _shape); // self-caching
              return _shape;
            },
            checks: [],
          });
          return clone(schema, def);
        }
        function safeExtend(schema, shape) {
          if (!isPlainObject(shape)) {
            throw new Error("Invalid input to safeExtend: expected a plain object");
          }
          const def = {
            ...schema._zod.def,
            get shape() {
              const _shape = { ...schema._zod.def.shape, ...shape };
              assignProp(this, "shape", _shape); // self-caching
              return _shape;
            },
            checks: schema._zod.def.checks,
          };
          return clone(schema, def);
        }
        function merge(a, b) {
          const def = mergeDefs(a._zod.def, {
            get shape() {
              const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
              assignProp(this, "shape", _shape); // self-caching
              return _shape;
            },
            get catchall() {
              return b._zod.def.catchall;
            },
            checks: [], // delete existing checks
          });
          return clone(a, def);
        }
        function partial(Class, schema, mask) {
          const def = mergeDefs(schema._zod.def, {
            get shape() {
              const oldShape = schema._zod.def.shape;
              const shape = { ...oldShape };
              if (mask) {
                for (const key in mask) {
                  if (!(key in oldShape)) {
                    throw new Error(`Unrecognized key: "${key}"`);
                  }
                  if (!mask[key])
                    continue;
                  // if (oldShape[key]!._zod.optin === "optional") continue;
                  shape[key] = Class
                    ? new Class({
                      type: "optional",
                      innerType: oldShape[key],
                    })
                    : oldShape[key];
                }
              }
              else {
                for (const key in oldShape) {
                  // if (oldShape[key]!._zod.optin === "optional") continue;
                  shape[key] = Class
                    ? new Class({
                      type: "optional",
                      innerType: oldShape[key],
                    })
                    : oldShape[key];
                }
              }
              assignProp(this, "shape", shape); // self-caching
              return shape;
            },
            checks: [],
          });
          return clone(schema, def);
        }
        function required(Class, schema, mask) {
          const def = mergeDefs(schema._zod.def, {
            get shape() {
              const oldShape = schema._zod.def.shape;
              const shape = { ...oldShape };
              if (mask) {
                for (const key in mask) {
                  if (!(key in shape)) {
                    throw new Error(`Unrecognized key: "${key}"`);
                  }
                  if (!mask[key])
                    continue;
                  // overwrite with non-optional
                  shape[key] = new Class({
                    type: "nonoptional",
                    innerType: oldShape[key],
                  });
                }
              }
              else {
                for (const key in oldShape) {
                  // overwrite with non-optional
                  shape[key] = new Class({
                    type: "nonoptional",
                    innerType: oldShape[key],
                  });
                }
              }
              assignProp(this, "shape", shape); // self-caching
              return shape;
            },
            checks: [],
          });
          return clone(schema, def);
        }
        // invalid_type | too_big | too_small | invalid_format | not_multiple_of | unrecognized_keys | invalid_union | invalid_key | invalid_element | invalid_value | custom
        function aborted(x, startIndex = 0) {
          if (x.aborted === true)
            return true;
          for (let i = startIndex; i < x.issues.length; i++) {
            if (x.issues[i]?.continue !== true) {
              return true;
            }
          }
          return false;
        }
        function prefixIssues(path, issues) {
          return issues.map((iss) => {
            var _a;
            (_a = iss).path ?? (_a.path = []);
            iss.path.unshift(path);
            return iss;
          });
        }
        function unwrapMessage(message) {
          return typeof message === "string" ? message : message?.message;
        }
        function finalizeIssue(iss, ctx, config) {
          const full = { ...iss, path: iss.path ?? [] };
          // for backwards compatibility
          if (!iss.message) {
            const message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ??
              unwrapMessage(ctx?.error?.(iss)) ??
              unwrapMessage(config.customError?.(iss)) ??
              unwrapMessage(config.localeError?.(iss)) ??
              "Invalid input";
            full.message = message;
          }
          // delete (full as any).def;
          delete full.inst;
          delete full.continue;
          if (!ctx?.reportInput) {
            delete full.input;
          }
          return full;
        }
        function getLengthableOrigin(input) {
          if (Array.isArray(input))
            return "array";
          if (typeof input === "string")
            return "string";
          return "unknown";
        }
        function issue(...args) {
          const [iss, input, inst] = args;
          if (typeof iss === "string") {
            return {
              message: iss,
              code: "custom",
              input,
              inst,
            };
          }
          return { ...iss };
        }

        const initializer$1 = (inst, def) => {
          inst.name = "$ZodError";
          Object.defineProperty(inst, "_zod", {
            value: inst._zod,
            enumerable: false,
          });
          Object.defineProperty(inst, "issues", {
            value: def,
            enumerable: false,
          });
          inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
          Object.defineProperty(inst, "toString", {
            value: () => inst.message,
            enumerable: false,
          });
        };
        const $ZodError = $constructor("$ZodError", initializer$1);
        const $ZodRealError = $constructor("$ZodError", initializer$1, { Parent: Error });
        function flattenError(error, mapper = (issue) => issue.message) {
          const fieldErrors = {};
          const formErrors = [];
          for (const sub of error.issues) {
            if (sub.path.length > 0) {
              fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
              fieldErrors[sub.path[0]].push(mapper(sub));
            }
            else {
              formErrors.push(mapper(sub));
            }
          }
          return { formErrors, fieldErrors };
        }
        function formatError(error, mapper = (issue) => issue.message) {
          const fieldErrors = { _errors: [] };
          const processError = (error) => {
            for (const issue of error.issues) {
              if (issue.code === "invalid_union" && issue.errors.length) {
                issue.errors.map((issues) => processError({ issues }));
              }
              else if (issue.code === "invalid_key") {
                processError({ issues: issue.issues });
              }
              else if (issue.code === "invalid_element") {
                processError({ issues: issue.issues });
              }
              else if (issue.path.length === 0) {
                fieldErrors._errors.push(mapper(issue));
              }
              else {
                let curr = fieldErrors;
                let i = 0;
                while (i < issue.path.length) {
                  const el = issue.path[i];
                  const terminal = i === issue.path.length - 1;
                  if (!terminal) {
                    curr[el] = curr[el] || { _errors: [] };
                  }
                  else {
                    curr[el] = curr[el] || { _errors: [] };
                    curr[el]._errors.push(mapper(issue));
                  }
                  curr = curr[el];
                  i++;
                }
              }
            }
          };
          processError(error);
          return fieldErrors;
        }

        const _parse$2 = (_Err) => (schema, value, _ctx, _params) => {
          const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
          const result = schema._zod.run({ value, issues: [] }, ctx);
          if (result instanceof Promise) {
            throw new $ZodAsyncError();
          }
          if (result.issues.length) {
            const e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
            captureStackTrace(e, _params?.callee);
            throw e;
          }
          return result.value;
        };
        const _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
          const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
          let result = schema._zod.run({ value, issues: [] }, ctx);
          if (result instanceof Promise)
            result = await result;
          if (result.issues.length) {
            const e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
            captureStackTrace(e, params?.callee);
            throw e;
          }
          return result.value;
        };
        const _safeParse = (_Err) => (schema, value, _ctx) => {
          const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
          const result = schema._zod.run({ value, issues: [] }, ctx);
          if (result instanceof Promise) {
            throw new $ZodAsyncError();
          }
          return result.issues.length
            ? {
              success: false,
              error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config()))),
            }
            : { success: true, data: result.value };
        };
        const safeParse$1 = /* @__PURE__*/ _safeParse($ZodRealError);
        const _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
          const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
          let result = schema._zod.run({ value, issues: [] }, ctx);
          if (result instanceof Promise)
            result = await result;
          return result.issues.length
            ? {
              success: false,
              error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config()))),
            }
            : { success: true, data: result.value };
        };
        const safeParseAsync$1 = /* @__PURE__*/ _safeParseAsync($ZodRealError);
        const _encode = (_Err) => (schema, value, _ctx) => {
          const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
          return _parse$2(_Err)(schema, value, ctx);
        };
        const _decode = (_Err) => (schema, value, _ctx) => {
          return _parse$2(_Err)(schema, value, _ctx);
        };
        const _encodeAsync = (_Err) => async (schema, value, _ctx) => {
          const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
          return _parseAsync(_Err)(schema, value, ctx);
        };
        const _decodeAsync = (_Err) => async (schema, value, _ctx) => {
          return _parseAsync(_Err)(schema, value, _ctx);
        };
        const _safeEncode = (_Err) => (schema, value, _ctx) => {
          const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
          return _safeParse(_Err)(schema, value, ctx);
        };
        const _safeDecode = (_Err) => (schema, value, _ctx) => {
          return _safeParse(_Err)(schema, value, _ctx);
        };
        const _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
          const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
          return _safeParseAsync(_Err)(schema, value, ctx);
        };
        const _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
          return _safeParseAsync(_Err)(schema, value, _ctx);
        };

        const cuid = /^[cC][^\s-]{8,}$/;
        const cuid2 = /^[0-9a-z]+$/;
        const ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
        const xid = /^[0-9a-vA-V]{20}$/;
        const ksuid = /^[A-Za-z0-9]{27}$/;
        const nanoid = /^[a-zA-Z0-9_-]{21}$/;
        /** ISO 8601-1 duration regex. Does not support the 8601-2 extensions like negative durations or fractional/negative components. */
        const duration$1 = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
        /** A regex for any UUID-like identifier: 8-4-4-4-12 hex pattern */
        const guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
        /** Returns a regex for validating an RFC 9562/4122 UUID.
         *
         * @param version Optionally specify a version 1-8. If no version is specified, all versions are supported. */
        const uuid = (version) => {
          if (!version)
            return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
          return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
        };
        /** Practical email validation */
        const email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
        // from https://thekevinscott.com/emojis-in-javascript/#writing-a-regular-expression
        const _emoji$1 = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
        function emoji() {
          return new RegExp(_emoji$1, "u");
        }
        const ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
        const ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
        const cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
        const cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
        // https://stackoverflow.com/questions/7860392/determine-if-string-is-in-base64-using-javascript
        const base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
        const base64url = /^[A-Za-z0-9_-]*$/;
        // based on https://stackoverflow.com/questions/106179/regular-expression-to-match-dns-hostname-or-ip-address
        // export const hostname: RegExp = /^([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+$/;
        const hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
        // https://blog.stevenlevithan.com/archives/validate-phone-number#r4-3 (regex sans spaces)
        const e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
        // const dateSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
        const dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
        const date$1 = /*@__PURE__*/ new RegExp(`^${dateSource}$`);
        function timeSource(args) {
          const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
          const regex = typeof args.precision === "number"
            ? args.precision === -1
              ? `${hhmm}`
              : args.precision === 0
                ? `${hhmm}:[0-5]\\d`
                : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}`
            : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
          return regex;
        }
        function time$1(args) {
          return new RegExp(`^${timeSource(args)}$`);
        }
        // Adapted from https://stackoverflow.com/a/3143231
        function datetime$1(args) {
          const time = timeSource({ precision: args.precision });
          const opts = ["Z"];
          if (args.local)
            opts.push("");
          // if (args.offset) opts.push(`([+-]\\d{2}:\\d{2})`);
          if (args.offset)
            opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
          const timeRegex = `${time}(?:${opts.join("|")})`;
          return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
        }
        const string$1 = (params) => {
          const regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : `[\\s\\S]*`;
          return new RegExp(`^${regex}$`);
        };
        const integer = /^-?\d+$/;
        const number$2 = /^-?\d+(?:\.\d+)?/;
        const boolean$1 = /^(?:true|false)$/i;
        // regex for string with no uppercase letters
        const lowercase = /^[^A-Z]*$/;
        // regex for string with no lowercase letters
        const uppercase = /^[^a-z]*$/;

        // import { $ZodType } from "./schemas.js";
        const $ZodCheck = /*@__PURE__*/ $constructor("$ZodCheck", (inst, def) => {
          var _a;
          inst._zod ?? (inst._zod = {});
          inst._zod.def = def;
          (_a = inst._zod).onattach ?? (_a.onattach = []);
        });
        const numericOriginMap = {
          number: "number",
          bigint: "bigint",
          object: "date",
        };
        const $ZodCheckLessThan = /*@__PURE__*/ $constructor("$ZodCheckLessThan", (inst, def) => {
          $ZodCheck.init(inst, def);
          const origin = numericOriginMap[typeof def.value];
          inst._zod.onattach.push((inst) => {
            const bag = inst._zod.bag;
            const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
            if (def.value < curr) {
              if (def.inclusive)
                bag.maximum = def.value;
              else
                bag.exclusiveMaximum = def.value;
            }
          });
          inst._zod.check = (payload) => {
            if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
              return;
            }
            payload.issues.push({
              origin,
              code: "too_big",
              maximum: def.value,
              input: payload.value,
              inclusive: def.inclusive,
              inst,
              continue: !def.abort,
            });
          };
        });
        const $ZodCheckGreaterThan = /*@__PURE__*/ $constructor("$ZodCheckGreaterThan", (inst, def) => {
          $ZodCheck.init(inst, def);
          const origin = numericOriginMap[typeof def.value];
          inst._zod.onattach.push((inst) => {
            const bag = inst._zod.bag;
            const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
            if (def.value > curr) {
              if (def.inclusive)
                bag.minimum = def.value;
              else
                bag.exclusiveMinimum = def.value;
            }
          });
          inst._zod.check = (payload) => {
            if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
              return;
            }
            payload.issues.push({
              origin,
              code: "too_small",
              minimum: def.value,
              input: payload.value,
              inclusive: def.inclusive,
              inst,
              continue: !def.abort,
            });
          };
        });
        const $ZodCheckMultipleOf =
/*@__PURE__*/ $constructor("$ZodCheckMultipleOf", (inst, def) => {
          $ZodCheck.init(inst, def);
          inst._zod.onattach.push((inst) => {
            var _a;
            (_a = inst._zod.bag).multipleOf ?? (_a.multipleOf = def.value);
          });
          inst._zod.check = (payload) => {
            if (typeof payload.value !== typeof def.value)
              throw new Error("Cannot mix number and bigint in multiple_of check.");
            const isMultiple = typeof payload.value === "bigint"
              ? payload.value % def.value === BigInt(0)
              : floatSafeRemainder(payload.value, def.value) === 0;
            if (isMultiple)
              return;
            payload.issues.push({
              origin: typeof payload.value,
              code: "not_multiple_of",
              divisor: def.value,
              input: payload.value,
              inst,
              continue: !def.abort,
            });
          };
        });
        const $ZodCheckNumberFormat = /*@__PURE__*/ $constructor("$ZodCheckNumberFormat", (inst, def) => {
          $ZodCheck.init(inst, def); // no format checks
          def.format = def.format || "float64";
          const isInt = def.format?.includes("int");
          const origin = isInt ? "int" : "number";
          const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
          inst._zod.onattach.push((inst) => {
            const bag = inst._zod.bag;
            bag.format = def.format;
            bag.minimum = minimum;
            bag.maximum = maximum;
            if (isInt)
              bag.pattern = integer;
          });
          inst._zod.check = (payload) => {
            const input = payload.value;
            if (isInt) {
              if (!Number.isInteger(input)) {
                // invalid_format issue
                // payload.issues.push({
                //   expected: def.format,
                //   format: def.format,
                //   code: "invalid_format",
                //   input,
                //   inst,
                // });
                // invalid_type issue
                payload.issues.push({
                  expected: origin,
                  format: def.format,
                  code: "invalid_type",
                  continue: false,
                  input,
                  inst,
                });
                return;
                // not_multiple_of issue
                // payload.issues.push({
                //   code: "not_multiple_of",
                //   origin: "number",
                //   input,
                //   inst,
                //   divisor: 1,
                // });
              }
              if (!Number.isSafeInteger(input)) {
                if (input > 0) {
                  // too_big
                  payload.issues.push({
                    input,
                    code: "too_big",
                    maximum: Number.MAX_SAFE_INTEGER,
                    note: "Integers must be within the safe integer range.",
                    inst,
                    origin,
                    continue: !def.abort,
                  });
                }
                else {
                  // too_small
                  payload.issues.push({
                    input,
                    code: "too_small",
                    minimum: Number.MIN_SAFE_INTEGER,
                    note: "Integers must be within the safe integer range.",
                    inst,
                    origin,
                    continue: !def.abort,
                  });
                }
                return;
              }
            }
            if (input < minimum) {
              payload.issues.push({
                origin: "number",
                input,
                code: "too_small",
                minimum,
                inclusive: true,
                inst,
                continue: !def.abort,
              });
            }
            if (input > maximum) {
              payload.issues.push({
                origin: "number",
                input,
                code: "too_big",
                maximum,
                inst,
              });
            }
          };
        });
        const $ZodCheckMaxLength = /*@__PURE__*/ $constructor("$ZodCheckMaxLength", (inst, def) => {
          var _a;
          $ZodCheck.init(inst, def);
          (_a = inst._zod.def).when ?? (_a.when = (payload) => {
            const val = payload.value;
            return !nullish(val) && val.length !== undefined;
          });
          inst._zod.onattach.push((inst) => {
            const curr = (inst._zod.bag.maximum ?? Number.POSITIVE_INFINITY);
            if (def.maximum < curr)
              inst._zod.bag.maximum = def.maximum;
          });
          inst._zod.check = (payload) => {
            const input = payload.value;
            const length = input.length;
            if (length <= def.maximum)
              return;
            const origin = getLengthableOrigin(input);
            payload.issues.push({
              origin,
              code: "too_big",
              maximum: def.maximum,
              inclusive: true,
              input,
              inst,
              continue: !def.abort,
            });
          };
        });
        const $ZodCheckMinLength = /*@__PURE__*/ $constructor("$ZodCheckMinLength", (inst, def) => {
          var _a;
          $ZodCheck.init(inst, def);
          (_a = inst._zod.def).when ?? (_a.when = (payload) => {
            const val = payload.value;
            return !nullish(val) && val.length !== undefined;
          });
          inst._zod.onattach.push((inst) => {
            const curr = (inst._zod.bag.minimum ?? Number.NEGATIVE_INFINITY);
            if (def.minimum > curr)
              inst._zod.bag.minimum = def.minimum;
          });
          inst._zod.check = (payload) => {
            const input = payload.value;
            const length = input.length;
            if (length >= def.minimum)
              return;
            const origin = getLengthableOrigin(input);
            payload.issues.push({
              origin,
              code: "too_small",
              minimum: def.minimum,
              inclusive: true,
              input,
              inst,
              continue: !def.abort,
            });
          };
        });
        const $ZodCheckLengthEquals = /*@__PURE__*/ $constructor("$ZodCheckLengthEquals", (inst, def) => {
          var _a;
          $ZodCheck.init(inst, def);
          (_a = inst._zod.def).when ?? (_a.when = (payload) => {
            const val = payload.value;
            return !nullish(val) && val.length !== undefined;
          });
          inst._zod.onattach.push((inst) => {
            const bag = inst._zod.bag;
            bag.minimum = def.length;
            bag.maximum = def.length;
            bag.length = def.length;
          });
          inst._zod.check = (payload) => {
            const input = payload.value;
            const length = input.length;
            if (length === def.length)
              return;
            const origin = getLengthableOrigin(input);
            const tooBig = length > def.length;
            payload.issues.push({
              origin,
              ...(tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length }),
              inclusive: true,
              exact: true,
              input: payload.value,
              inst,
              continue: !def.abort,
            });
          };
        });
        const $ZodCheckStringFormat = /*@__PURE__*/ $constructor("$ZodCheckStringFormat", (inst, def) => {
          var _a, _b;
          $ZodCheck.init(inst, def);
          inst._zod.onattach.push((inst) => {
            const bag = inst._zod.bag;
            bag.format = def.format;
            if (def.pattern) {
              bag.patterns ?? (bag.patterns = new Set());
              bag.patterns.add(def.pattern);
            }
          });
          if (def.pattern)
            (_a = inst._zod).check ?? (_a.check = (payload) => {
              def.pattern.lastIndex = 0;
              if (def.pattern.test(payload.value))
                return;
              payload.issues.push({
                origin: "string",
                code: "invalid_format",
                format: def.format,
                input: payload.value,
                ...(def.pattern ? { pattern: def.pattern.toString() } : {}),
                inst,
                continue: !def.abort,
              });
            });
          else
            (_b = inst._zod).check ?? (_b.check = () => { });
        });
        const $ZodCheckRegex = /*@__PURE__*/ $constructor("$ZodCheckRegex", (inst, def) => {
          $ZodCheckStringFormat.init(inst, def);
          inst._zod.check = (payload) => {
            def.pattern.lastIndex = 0;
            if (def.pattern.test(payload.value))
              return;
            payload.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "regex",
              input: payload.value,
              pattern: def.pattern.toString(),
              inst,
              continue: !def.abort,
            });
          };
        });
        const $ZodCheckLowerCase = /*@__PURE__*/ $constructor("$ZodCheckLowerCase", (inst, def) => {
          def.pattern ?? (def.pattern = lowercase);
          $ZodCheckStringFormat.init(inst, def);
        });
        const $ZodCheckUpperCase = /*@__PURE__*/ $constructor("$ZodCheckUpperCase", (inst, def) => {
          def.pattern ?? (def.pattern = uppercase);
          $ZodCheckStringFormat.init(inst, def);
        });
        const $ZodCheckIncludes = /*@__PURE__*/ $constructor("$ZodCheckIncludes", (inst, def) => {
          $ZodCheck.init(inst, def);
          const escapedRegex = escapeRegex(def.includes);
          const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
          def.pattern = pattern;
          inst._zod.onattach.push((inst) => {
            const bag = inst._zod.bag;
            bag.patterns ?? (bag.patterns = new Set());
            bag.patterns.add(pattern);
          });
          inst._zod.check = (payload) => {
            if (payload.value.includes(def.includes, def.position))
              return;
            payload.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "includes",
              includes: def.includes,
              input: payload.value,
              inst,
              continue: !def.abort,
            });
          };
        });
        const $ZodCheckStartsWith = /*@__PURE__*/ $constructor("$ZodCheckStartsWith", (inst, def) => {
          $ZodCheck.init(inst, def);
          const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
          def.pattern ?? (def.pattern = pattern);
          inst._zod.onattach.push((inst) => {
            const bag = inst._zod.bag;
            bag.patterns ?? (bag.patterns = new Set());
            bag.patterns.add(pattern);
          });
          inst._zod.check = (payload) => {
            if (payload.value.startsWith(def.prefix))
              return;
            payload.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "starts_with",
              prefix: def.prefix,
              input: payload.value,
              inst,
              continue: !def.abort,
            });
          };
        });
        const $ZodCheckEndsWith = /*@__PURE__*/ $constructor("$ZodCheckEndsWith", (inst, def) => {
          $ZodCheck.init(inst, def);
          const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
          def.pattern ?? (def.pattern = pattern);
          inst._zod.onattach.push((inst) => {
            const bag = inst._zod.bag;
            bag.patterns ?? (bag.patterns = new Set());
            bag.patterns.add(pattern);
          });
          inst._zod.check = (payload) => {
            if (payload.value.endsWith(def.suffix))
              return;
            payload.issues.push({
              origin: "string",
              code: "invalid_format",
              format: "ends_with",
              suffix: def.suffix,
              input: payload.value,
              inst,
              continue: !def.abort,
            });
          };
        });
        const $ZodCheckOverwrite = /*@__PURE__*/ $constructor("$ZodCheckOverwrite", (inst, def) => {
          $ZodCheck.init(inst, def);
          inst._zod.check = (payload) => {
            payload.value = def.tx(payload.value);
          };
        });

        class Doc {
          constructor(args = []) {
            this.content = [];
            this.indent = 0;
            if (this)
              this.args = args;
          }
          indented(fn) {
            this.indent += 1;
            fn(this);
            this.indent -= 1;
          }
          write(arg) {
            if (typeof arg === "function") {
              arg(this, { execution: "sync" });
              arg(this, { execution: "async" });
              return;
            }
            const content = arg;
            const lines = content.split("\n").filter((x) => x);
            const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
            const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
            for (const line of dedented) {
              this.content.push(line);
            }
          }
          compile() {
            const F = Function;
            const args = this?.args;
            const content = this?.content ?? [``];
            const lines = [...content.map((x) => `  ${x}`)];
            // console.log(lines.join("\n"));
            return new F(...args, lines.join("\n"));
          }
        }

        const version = {
          major: 4,
          minor: 1,
          patch: 12,
        };

        const $ZodType = /*@__PURE__*/ $constructor("$ZodType", (inst, def) => {
          var _a;
          inst ?? (inst = {});
          inst._zod.def = def; // set _def property
          inst._zod.bag = inst._zod.bag || {}; // initialize _bag object
          inst._zod.version = version;
          const checks = [...(inst._zod.def.checks ?? [])];
          // if inst is itself a checks.$ZodCheck, run it as a check
          if (inst._zod.traits.has("$ZodCheck")) {
            checks.unshift(inst);
          }
          for (const ch of checks) {
            for (const fn of ch._zod.onattach) {
              fn(inst);
            }
          }
          if (checks.length === 0) {
            // deferred initializer
            // inst._zod.parse is not yet defined
            (_a = inst._zod).deferred ?? (_a.deferred = []);
            inst._zod.deferred?.push(() => {
              inst._zod.run = inst._zod.parse;
            });
          }
          else {
            const runChecks = (payload, checks, ctx) => {
              let isAborted = aborted(payload);
              let asyncResult;
              for (const ch of checks) {
                if (ch._zod.def.when) {
                  const shouldRun = ch._zod.def.when(payload);
                  if (!shouldRun)
                    continue;
                }
                else if (isAborted) {
                  continue;
                }
                const currLen = payload.issues.length;
                const _ = ch._zod.check(payload);
                if (_ instanceof Promise && ctx?.async === false) {
                  throw new $ZodAsyncError();
                }
                if (asyncResult || _ instanceof Promise) {
                  asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
                    await _;
                    const nextLen = payload.issues.length;
                    if (nextLen === currLen)
                      return;
                    if (!isAborted)
                      isAborted = aborted(payload, currLen);
                  });
                }
                else {
                  const nextLen = payload.issues.length;
                  if (nextLen === currLen)
                    continue;
                  if (!isAborted)
                    isAborted = aborted(payload, currLen);
                }
              }
              if (asyncResult) {
                return asyncResult.then(() => {
                  return payload;
                });
              }
              return payload;
            };
            // const handleChecksResult = (
            //   checkResult: ParsePayload,
            //   originalResult: ParsePayload,
            //   ctx: ParseContextInternal
            // ): util.MaybeAsync<ParsePayload> => {
            //   // if the checks mutated the value && there are no issues, re-parse the result
            //   if (checkResult.value !== originalResult.value && !checkResult.issues.length)
            //     return inst._zod.parse(checkResult, ctx);
            //   return originalResult;
            // };
            const handleCanaryResult = (canary, payload, ctx) => {
              // abort if the canary is aborted
              if (aborted(canary)) {
                canary.aborted = true;
                return canary;
              }
              // run checks first, then
              const checkResult = runChecks(payload, checks, ctx);
              if (checkResult instanceof Promise) {
                if (ctx.async === false)
                  throw new $ZodAsyncError();
                return checkResult.then((checkResult) => inst._zod.parse(checkResult, ctx));
              }
              return inst._zod.parse(checkResult, ctx);
            };
            inst._zod.run = (payload, ctx) => {
              if (ctx.skipChecks) {
                return inst._zod.parse(payload, ctx);
              }
              if (ctx.direction === "backward") {
                // run canary
                // initial pass (no checks)
                const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
                if (canary instanceof Promise) {
                  return canary.then((canary) => {
                    return handleCanaryResult(canary, payload, ctx);
                  });
                }
                return handleCanaryResult(canary, payload, ctx);
              }
              // forward
              const result = inst._zod.parse(payload, ctx);
              if (result instanceof Promise) {
                if (ctx.async === false)
                  throw new $ZodAsyncError();
                return result.then((result) => runChecks(result, checks, ctx));
              }
              return runChecks(result, checks, ctx);
            };
          }
          inst["~standard"] = {
            validate: (value) => {
              try {
                const r = safeParse$1(inst, value);
                return r.success ? { value: r.data } : { issues: r.error?.issues };
              }
              catch (_) {
                return safeParseAsync$1(inst, value).then((r) => (r.success ? { value: r.data } : { issues: r.error?.issues }));
              }
            },
            vendor: "zod",
            version: 1,
          };
        });
        const $ZodString = /*@__PURE__*/ $constructor("$ZodString", (inst, def) => {
          $ZodType.init(inst, def);
          inst._zod.pattern = [...(inst?._zod.bag?.patterns ?? [])].pop() ?? string$1(inst._zod.bag);
          inst._zod.parse = (payload, _) => {
            if (def.coerce)
              try {
                payload.value = String(payload.value);
              }
              catch (_) { }
            if (typeof payload.value === "string")
              return payload;
            payload.issues.push({
              expected: "string",
              code: "invalid_type",
              input: payload.value,
              inst,
            });
            return payload;
          };
        });
        const $ZodStringFormat = /*@__PURE__*/ $constructor("$ZodStringFormat", (inst, def) => {
          // check initialization must come first
          $ZodCheckStringFormat.init(inst, def);
          $ZodString.init(inst, def);
        });
        const $ZodGUID = /*@__PURE__*/ $constructor("$ZodGUID", (inst, def) => {
          def.pattern ?? (def.pattern = guid);
          $ZodStringFormat.init(inst, def);
        });
        const $ZodUUID = /*@__PURE__*/ $constructor("$ZodUUID", (inst, def) => {
          if (def.version) {
            const versionMap = {
              v1: 1,
              v2: 2,
              v3: 3,
              v4: 4,
              v5: 5,
              v6: 6,
              v7: 7,
              v8: 8,
            };
            const v = versionMap[def.version];
            if (v === undefined)
              throw new Error(`Invalid UUID version: "${def.version}"`);
            def.pattern ?? (def.pattern = uuid(v));
          }
          else
            def.pattern ?? (def.pattern = uuid());
          $ZodStringFormat.init(inst, def);
        });
        const $ZodEmail = /*@__PURE__*/ $constructor("$ZodEmail", (inst, def) => {
          def.pattern ?? (def.pattern = email);
          $ZodStringFormat.init(inst, def);
        });
        const $ZodURL = /*@__PURE__*/ $constructor("$ZodURL", (inst, def) => {
          $ZodStringFormat.init(inst, def);
          inst._zod.check = (payload) => {
            try {
              // Trim whitespace from input
              const trimmed = payload.value.trim();
              // @ts-ignore
              const url = new URL(trimmed);
              if (def.hostname) {
                def.hostname.lastIndex = 0;
                if (!def.hostname.test(url.hostname)) {
                  payload.issues.push({
                    code: "invalid_format",
                    format: "url",
                    note: "Invalid hostname",
                    pattern: hostname.source,
                    input: payload.value,
                    inst,
                    continue: !def.abort,
                  });
                }
              }
              if (def.protocol) {
                def.protocol.lastIndex = 0;
                if (!def.protocol.test(url.protocol.endsWith(":") ? url.protocol.slice(0, -1) : url.protocol)) {
                  payload.issues.push({
                    code: "invalid_format",
                    format: "url",
                    note: "Invalid protocol",
                    pattern: def.protocol.source,
                    input: payload.value,
                    inst,
                    continue: !def.abort,
                  });
                }
              }
              // Set the output value based on normalize flag
              if (def.normalize) {
                // Use normalized URL
                payload.value = url.href;
              }
              else {
                // Preserve the original input (trimmed)
                payload.value = trimmed;
              }
              return;
            }
            catch (_) {
              payload.issues.push({
                code: "invalid_format",
                format: "url",
                input: payload.value,
                inst,
                continue: !def.abort,
              });
            }
          };
        });
        const $ZodEmoji = /*@__PURE__*/ $constructor("$ZodEmoji", (inst, def) => {
          def.pattern ?? (def.pattern = emoji());
          $ZodStringFormat.init(inst, def);
        });
        const $ZodNanoID = /*@__PURE__*/ $constructor("$ZodNanoID", (inst, def) => {
          def.pattern ?? (def.pattern = nanoid);
          $ZodStringFormat.init(inst, def);
        });
        const $ZodCUID = /*@__PURE__*/ $constructor("$ZodCUID", (inst, def) => {
          def.pattern ?? (def.pattern = cuid);
          $ZodStringFormat.init(inst, def);
        });
        const $ZodCUID2 = /*@__PURE__*/ $constructor("$ZodCUID2", (inst, def) => {
          def.pattern ?? (def.pattern = cuid2);
          $ZodStringFormat.init(inst, def);
        });
        const $ZodULID = /*@__PURE__*/ $constructor("$ZodULID", (inst, def) => {
          def.pattern ?? (def.pattern = ulid);
          $ZodStringFormat.init(inst, def);
        });
        const $ZodXID = /*@__PURE__*/ $constructor("$ZodXID", (inst, def) => {
          def.pattern ?? (def.pattern = xid);
          $ZodStringFormat.init(inst, def);
        });
        const $ZodKSUID = /*@__PURE__*/ $constructor("$ZodKSUID", (inst, def) => {
          def.pattern ?? (def.pattern = ksuid);
          $ZodStringFormat.init(inst, def);
        });
        const $ZodISODateTime = /*@__PURE__*/ $constructor("$ZodISODateTime", (inst, def) => {
          def.pattern ?? (def.pattern = datetime$1(def));
          $ZodStringFormat.init(inst, def);
        });
        const $ZodISODate = /*@__PURE__*/ $constructor("$ZodISODate", (inst, def) => {
          def.pattern ?? (def.pattern = date$1);
          $ZodStringFormat.init(inst, def);
        });
        const $ZodISOTime = /*@__PURE__*/ $constructor("$ZodISOTime", (inst, def) => {
          def.pattern ?? (def.pattern = time$1(def));
          $ZodStringFormat.init(inst, def);
        });
        const $ZodISODuration = /*@__PURE__*/ $constructor("$ZodISODuration", (inst, def) => {
          def.pattern ?? (def.pattern = duration$1);
          $ZodStringFormat.init(inst, def);
        });
        const $ZodIPv4 = /*@__PURE__*/ $constructor("$ZodIPv4", (inst, def) => {
          def.pattern ?? (def.pattern = ipv4);
          $ZodStringFormat.init(inst, def);
          inst._zod.onattach.push((inst) => {
            const bag = inst._zod.bag;
            bag.format = `ipv4`;
          });
        });
        const $ZodIPv6 = /*@__PURE__*/ $constructor("$ZodIPv6", (inst, def) => {
          def.pattern ?? (def.pattern = ipv6);
          $ZodStringFormat.init(inst, def);
          inst._zod.onattach.push((inst) => {
            const bag = inst._zod.bag;
            bag.format = `ipv6`;
          });
          inst._zod.check = (payload) => {
            try {
              // @ts-ignore
              new URL(`http://[${payload.value}]`);
              // return;
            }
            catch {
              payload.issues.push({
                code: "invalid_format",
                format: "ipv6",
                input: payload.value,
                inst,
                continue: !def.abort,
              });
            }
          };
        });
        const $ZodCIDRv4 = /*@__PURE__*/ $constructor("$ZodCIDRv4", (inst, def) => {
          def.pattern ?? (def.pattern = cidrv4);
          $ZodStringFormat.init(inst, def);
        });
        const $ZodCIDRv6 = /*@__PURE__*/ $constructor("$ZodCIDRv6", (inst, def) => {
          def.pattern ?? (def.pattern = cidrv6); // not used for validation
          $ZodStringFormat.init(inst, def);
          inst._zod.check = (payload) => {
            const parts = payload.value.split("/");
            try {
              if (parts.length !== 2)
                throw new Error();
              const [address, prefix] = parts;
              if (!prefix)
                throw new Error();
              const prefixNum = Number(prefix);
              if (`${prefixNum}` !== prefix)
                throw new Error();
              if (prefixNum < 0 || prefixNum > 128)
                throw new Error();
              // @ts-ignore
              new URL(`http://[${address}]`);
            }
            catch {
              payload.issues.push({
                code: "invalid_format",
                format: "cidrv6",
                input: payload.value,
                inst,
                continue: !def.abort,
              });
            }
          };
        });
        //////////////////////////////   ZodBase64   //////////////////////////////
        function isValidBase64(data) {
          if (data === "")
            return true;
          if (data.length % 4 !== 0)
            return false;
          try {
            // @ts-ignore
            atob(data);
            return true;
          }
          catch {
            return false;
          }
        }
        const $ZodBase64 = /*@__PURE__*/ $constructor("$ZodBase64", (inst, def) => {
          def.pattern ?? (def.pattern = base64);
          $ZodStringFormat.init(inst, def);
          inst._zod.onattach.push((inst) => {
            inst._zod.bag.contentEncoding = "base64";
          });
          inst._zod.check = (payload) => {
            if (isValidBase64(payload.value))
              return;
            payload.issues.push({
              code: "invalid_format",
              format: "base64",
              input: payload.value,
              inst,
              continue: !def.abort,
            });
          };
        });
        //////////////////////////////   ZodBase64   //////////////////////////////
        function isValidBase64URL(data) {
          if (!base64url.test(data))
            return false;
          const base64 = data.replace(/[-_]/g, (c) => (c === "-" ? "+" : "/"));
          const padded = base64.padEnd(Math.ceil(base64.length / 4) * 4, "=");
          return isValidBase64(padded);
        }
        const $ZodBase64URL = /*@__PURE__*/ $constructor("$ZodBase64URL", (inst, def) => {
          def.pattern ?? (def.pattern = base64url);
          $ZodStringFormat.init(inst, def);
          inst._zod.onattach.push((inst) => {
            inst._zod.bag.contentEncoding = "base64url";
          });
          inst._zod.check = (payload) => {
            if (isValidBase64URL(payload.value))
              return;
            payload.issues.push({
              code: "invalid_format",
              format: "base64url",
              input: payload.value,
              inst,
              continue: !def.abort,
            });
          };
        });
        const $ZodE164 = /*@__PURE__*/ $constructor("$ZodE164", (inst, def) => {
          def.pattern ?? (def.pattern = e164);
          $ZodStringFormat.init(inst, def);
        });
        //////////////////////////////   ZodJWT   //////////////////////////////
        function isValidJWT(token, algorithm = null) {
          try {
            const tokensParts = token.split(".");
            if (tokensParts.length !== 3)
              return false;
            const [header] = tokensParts;
            if (!header)
              return false;
            // @ts-ignore
            const parsedHeader = JSON.parse(atob(header));
            if ("typ" in parsedHeader && parsedHeader?.typ !== "JWT")
              return false;
            if (!parsedHeader.alg)
              return false;
            if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
              return false;
            return true;
          }
          catch {
            return false;
          }
        }
        const $ZodJWT = /*@__PURE__*/ $constructor("$ZodJWT", (inst, def) => {
          $ZodStringFormat.init(inst, def);
          inst._zod.check = (payload) => {
            if (isValidJWT(payload.value, def.alg))
              return;
            payload.issues.push({
              code: "invalid_format",
              format: "jwt",
              input: payload.value,
              inst,
              continue: !def.abort,
            });
          };
        });
        const $ZodNumber = /*@__PURE__*/ $constructor("$ZodNumber", (inst, def) => {
          $ZodType.init(inst, def);
          inst._zod.pattern = inst._zod.bag.pattern ?? number$2;
          inst._zod.parse = (payload, _ctx) => {
            if (def.coerce)
              try {
                payload.value = Number(payload.value);
              }
              catch (_) { }
            const input = payload.value;
            if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
              return payload;
            }
            const received = typeof input === "number"
              ? Number.isNaN(input)
                ? "NaN"
                : !Number.isFinite(input)
                  ? "Infinity"
                  : undefined
              : undefined;
            payload.issues.push({
              expected: "number",
              code: "invalid_type",
              input,
              inst,
              ...(received ? { received } : {}),
            });
            return payload;
          };
        });
        const $ZodNumberFormat = /*@__PURE__*/ $constructor("$ZodNumber", (inst, def) => {
          $ZodCheckNumberFormat.init(inst, def);
          $ZodNumber.init(inst, def); // no format checksp
        });
        const $ZodBoolean = /*@__PURE__*/ $constructor("$ZodBoolean", (inst, def) => {
          $ZodType.init(inst, def);
          inst._zod.pattern = boolean$1;
          inst._zod.parse = (payload, _ctx) => {
            if (def.coerce)
              try {
                payload.value = Boolean(payload.value);
              }
              catch (_) { }
            const input = payload.value;
            if (typeof input === "boolean")
              return payload;
            payload.issues.push({
              expected: "boolean",
              code: "invalid_type",
              input,
              inst,
            });
            return payload;
          };
        });
        const $ZodAny = /*@__PURE__*/ $constructor("$ZodAny", (inst, def) => {
          $ZodType.init(inst, def);
          inst._zod.parse = (payload) => payload;
        });
        const $ZodUnknown = /*@__PURE__*/ $constructor("$ZodUnknown", (inst, def) => {
          $ZodType.init(inst, def);
          inst._zod.parse = (payload) => payload;
        });
        const $ZodNever = /*@__PURE__*/ $constructor("$ZodNever", (inst, def) => {
          $ZodType.init(inst, def);
          inst._zod.parse = (payload, _ctx) => {
            payload.issues.push({
              expected: "never",
              code: "invalid_type",
              input: payload.value,
              inst,
            });
            return payload;
          };
        });
        function handleArrayResult(result, final, index) {
          if (result.issues.length) {
            final.issues.push(...prefixIssues(index, result.issues));
          }
          final.value[index] = result.value;
        }
        const $ZodArray = /*@__PURE__*/ $constructor("$ZodArray", (inst, def) => {
          $ZodType.init(inst, def);
          inst._zod.parse = (payload, ctx) => {
            const input = payload.value;
            if (!Array.isArray(input)) {
              payload.issues.push({
                expected: "array",
                code: "invalid_type",
                input,
                inst,
              });
              return payload;
            }
            payload.value = Array(input.length);
            const proms = [];
            for (let i = 0; i < input.length; i++) {
              const item = input[i];
              const result = def.element._zod.run({
                value: item,
                issues: [],
              }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result) => handleArrayResult(result, payload, i)));
              }
              else {
                handleArrayResult(result, payload, i);
              }
            }
            if (proms.length) {
              return Promise.all(proms).then(() => payload);
            }
            return payload; //handleArrayResultsAsync(parseResults, final);
          };
        });
        function handlePropertyResult(result, final, key, input) {
          if (result.issues.length) {
            final.issues.push(...prefixIssues(key, result.issues));
          }
          if (result.value === undefined) {
            if (key in input) {
              final.value[key] = undefined;
            }
          }
          else {
            final.value[key] = result.value;
          }
        }
        function normalizeDef(def) {
          const keys = Object.keys(def.shape);
          for (const k of keys) {
            if (!def.shape?.[k]?._zod?.traits?.has("$ZodType")) {
              throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
            }
          }
          const okeys = optionalKeys(def.shape);
          return {
            ...def,
            keys,
            keySet: new Set(keys),
            numKeys: keys.length,
            optionalKeys: new Set(okeys),
          };
        }
        function handleCatchall(proms, input, payload, ctx, def, inst) {
          const unrecognized = [];
          // iterate over input keys
          const keySet = def.keySet;
          const _catchall = def.catchall._zod;
          const t = _catchall.def.type;
          for (const key of Object.keys(input)) {
            if (keySet.has(key))
              continue;
            if (t === "never") {
              unrecognized.push(key);
              continue;
            }
            const r = _catchall.run({ value: input[key], issues: [] }, ctx);
            if (r instanceof Promise) {
              proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));
            }
            else {
              handlePropertyResult(r, payload, key, input);
            }
          }
          if (unrecognized.length) {
            payload.issues.push({
              code: "unrecognized_keys",
              keys: unrecognized,
              input,
              inst,
            });
          }
          if (!proms.length)
            return payload;
          return Promise.all(proms).then(() => {
            return payload;
          });
        }
        const $ZodObject = /*@__PURE__*/ $constructor("$ZodObject", (inst, def) => {
          // requires cast because technically $ZodObject doesn't extend
          $ZodType.init(inst, def);
          // const sh = def.shape;
          const desc = Object.getOwnPropertyDescriptor(def, "shape");
          if (!desc?.get) {
            const sh = def.shape;
            Object.defineProperty(def, "shape", {
              get: () => {
                const newSh = { ...sh };
                Object.defineProperty(def, "shape", {
                  value: newSh,
                });
                return newSh;
              },
            });
          }
          const _normalized = cached(() => normalizeDef(def));
          defineLazy(inst._zod, "propValues", () => {
            const shape = def.shape;
            const propValues = {};
            for (const key in shape) {
              const field = shape[key]._zod;
              if (field.values) {
                propValues[key] ?? (propValues[key] = new Set());
                for (const v of field.values)
                  propValues[key].add(v);
              }
            }
            return propValues;
          });
          const isObject$1 = isObject;
          const catchall = def.catchall;
          let value;
          inst._zod.parse = (payload, ctx) => {
            value ?? (value = _normalized.value);
            const input = payload.value;
            if (!isObject$1(input)) {
              payload.issues.push({
                expected: "object",
                code: "invalid_type",
                input,
                inst,
              });
              return payload;
            }
            payload.value = {};
            const proms = [];
            const shape = value.shape;
            for (const key of value.keys) {
              const el = shape[key];
              const r = el._zod.run({ value: input[key], issues: [] }, ctx);
              if (r instanceof Promise) {
                proms.push(r.then((r) => handlePropertyResult(r, payload, key, input)));
              }
              else {
                handlePropertyResult(r, payload, key, input);
              }
            }
            if (!catchall) {
              return proms.length ? Promise.all(proms).then(() => payload) : payload;
            }
            return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
          };
        });
        const $ZodObjectJIT = /*@__PURE__*/ $constructor("$ZodObjectJIT", (inst, def) => {
          // requires cast because technically $ZodObject doesn't extend
          $ZodObject.init(inst, def);
          const superParse = inst._zod.parse;
          const _normalized = cached(() => normalizeDef(def));
          const generateFastpass = (shape) => {
            const doc = new Doc(["shape", "payload", "ctx"]);
            const normalized = _normalized.value;
            const parseStr = (key) => {
              const k = esc(key);
              return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
            };
            doc.write(`const input = payload.value;`);
            const ids = Object.create(null);
            let counter = 0;
            for (const key of normalized.keys) {
              ids[key] = `key_${counter++}`;
            }
            // A: preserve key order {
            doc.write(`const newResult = {};`);
            for (const key of normalized.keys) {
              const id = ids[key];
              const k = esc(key);
              doc.write(`const ${id} = ${parseStr(key)};`);
              doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
            }
            doc.write(`payload.value = newResult;`);
            doc.write(`return payload;`);
            const fn = doc.compile();
            return (payload, ctx) => fn(shape, payload, ctx);
          };
          let fastpass;
          const isObject$1 = isObject;
          const jit = !globalConfig.jitless;
          const allowsEval$1 = allowsEval;
          const fastEnabled = jit && allowsEval$1.value; // && !def.catchall;
          const catchall = def.catchall;
          let value;
          inst._zod.parse = (payload, ctx) => {
            value ?? (value = _normalized.value);
            const input = payload.value;
            if (!isObject$1(input)) {
              payload.issues.push({
                expected: "object",
                code: "invalid_type",
                input,
                inst,
              });
              return payload;
            }
            if (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {
              // always synchronous
              if (!fastpass)
                fastpass = generateFastpass(def.shape);
              payload = fastpass(payload, ctx);
              if (!catchall)
                return payload;
              return handleCatchall([], input, payload, ctx, value, inst);
            }
            return superParse(payload, ctx);
          };
        });
        function handleUnionResults(results, final, inst, ctx) {
          for (const result of results) {
            if (result.issues.length === 0) {
              final.value = result.value;
              return final;
            }
          }
          const nonaborted = results.filter((r) => !aborted(r));
          if (nonaborted.length === 1) {
            final.value = nonaborted[0].value;
            return nonaborted[0];
          }
          final.issues.push({
            code: "invalid_union",
            input: final.value,
            inst,
            errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config()))),
          });
          return final;
        }
        const $ZodUnion = /*@__PURE__*/ $constructor("$ZodUnion", (inst, def) => {
          $ZodType.init(inst, def);
          defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : undefined);
          defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : undefined);
          defineLazy(inst._zod, "values", () => {
            if (def.options.every((o) => o._zod.values)) {
              return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
            }
            return undefined;
          });
          defineLazy(inst._zod, "pattern", () => {
            if (def.options.every((o) => o._zod.pattern)) {
              const patterns = def.options.map((o) => o._zod.pattern);
              return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
            }
            return undefined;
          });
          const single = def.options.length === 1;
          const first = def.options[0]._zod.run;
          inst._zod.parse = (payload, ctx) => {
            if (single) {
              return first(payload, ctx);
            }
            let async = false;
            const results = [];
            for (const option of def.options) {
              const result = option._zod.run({
                value: payload.value,
                issues: [],
              }, ctx);
              if (result instanceof Promise) {
                results.push(result);
                async = true;
              }
              else {
                if (result.issues.length === 0)
                  return result;
                results.push(result);
              }
            }
            if (!async)
              return handleUnionResults(results, payload, inst, ctx);
            return Promise.all(results).then((results) => {
              return handleUnionResults(results, payload, inst, ctx);
            });
          };
        });
        const $ZodDiscriminatedUnion =
          /*@__PURE__*/
          $constructor("$ZodDiscriminatedUnion", (inst, def) => {
            $ZodUnion.init(inst, def);
            const _super = inst._zod.parse;
            defineLazy(inst._zod, "propValues", () => {
              const propValues = {};
              for (const option of def.options) {
                const pv = option._zod.propValues;
                if (!pv || Object.keys(pv).length === 0)
                  throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
                for (const [k, v] of Object.entries(pv)) {
                  if (!propValues[k])
                    propValues[k] = new Set();
                  for (const val of v) {
                    propValues[k].add(val);
                  }
                }
              }
              return propValues;
            });
            const disc = cached(() => {
              const opts = def.options;
              const map = new Map();
              for (const o of opts) {
                const values = o._zod.propValues?.[def.discriminator];
                if (!values || values.size === 0)
                  throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
                for (const v of values) {
                  if (map.has(v)) {
                    throw new Error(`Duplicate discriminator value "${String(v)}"`);
                  }
                  map.set(v, o);
                }
              }
              return map;
            });
            inst._zod.parse = (payload, ctx) => {
              const input = payload.value;
              if (!isObject(input)) {
                payload.issues.push({
                  code: "invalid_type",
                  expected: "object",
                  input,
                  inst,
                });
                return payload;
              }
              const opt = disc.value.get(input?.[def.discriminator]);
              if (opt) {
                return opt._zod.run(payload, ctx);
              }
              if (def.unionFallback) {
                return _super(payload, ctx);
              }
              // no matching discriminator
              payload.issues.push({
                code: "invalid_union",
                errors: [],
                note: "No matching discriminator",
                discriminator: def.discriminator,
                input,
                path: [def.discriminator],
                inst,
              });
              return payload;
            };
          });
        const $ZodIntersection = /*@__PURE__*/ $constructor("$ZodIntersection", (inst, def) => {
          $ZodType.init(inst, def);
          inst._zod.parse = (payload, ctx) => {
            const input = payload.value;
            const left = def.left._zod.run({ value: input, issues: [] }, ctx);
            const right = def.right._zod.run({ value: input, issues: [] }, ctx);
            const async = left instanceof Promise || right instanceof Promise;
            if (async) {
              return Promise.all([left, right]).then(([left, right]) => {
                return handleIntersectionResults(payload, left, right);
              });
            }
            return handleIntersectionResults(payload, left, right);
          };
        });
        function mergeValues(a, b) {
          // const aType = parse.t(a);
          // const bType = parse.t(b);
          if (a === b) {
            return { valid: true, data: a };
          }
          if (a instanceof Date && b instanceof Date && +a === +b) {
            return { valid: true, data: a };
          }
          if (isPlainObject(a) && isPlainObject(b)) {
            const bKeys = Object.keys(b);
            const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
            const newObj = { ...a, ...b };
            for (const key of sharedKeys) {
              const sharedValue = mergeValues(a[key], b[key]);
              if (!sharedValue.valid) {
                return {
                  valid: false,
                  mergeErrorPath: [key, ...sharedValue.mergeErrorPath],
                };
              }
              newObj[key] = sharedValue.data;
            }
            return { valid: true, data: newObj };
          }
          if (Array.isArray(a) && Array.isArray(b)) {
            if (a.length !== b.length) {
              return { valid: false, mergeErrorPath: [] };
            }
            const newArray = [];
            for (let index = 0; index < a.length; index++) {
              const itemA = a[index];
              const itemB = b[index];
              const sharedValue = mergeValues(itemA, itemB);
              if (!sharedValue.valid) {
                return {
                  valid: false,
                  mergeErrorPath: [index, ...sharedValue.mergeErrorPath],
                };
              }
              newArray.push(sharedValue.data);
            }
            return { valid: true, data: newArray };
          }
          return { valid: false, mergeErrorPath: [] };
        }
        function handleIntersectionResults(result, left, right) {
          if (left.issues.length) {
            result.issues.push(...left.issues);
          }
          if (right.issues.length) {
            result.issues.push(...right.issues);
          }
          if (aborted(result))
            return result;
          const merged = mergeValues(left.value, right.value);
          if (!merged.valid) {
            throw new Error(`Unmergable intersection. Error path: ` + `${JSON.stringify(merged.mergeErrorPath)}`);
          }
          result.value = merged.data;
          return result;
        }
        const $ZodTuple = /*@__PURE__*/ $constructor("$ZodTuple", (inst, def) => {
          $ZodType.init(inst, def);
          const items = def.items;
          const optStart = items.length - [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
          inst._zod.parse = (payload, ctx) => {
            const input = payload.value;
            if (!Array.isArray(input)) {
              payload.issues.push({
                input,
                inst,
                expected: "tuple",
                code: "invalid_type",
              });
              return payload;
            }
            payload.value = [];
            const proms = [];
            if (!def.rest) {
              const tooBig = input.length > items.length;
              const tooSmall = input.length < optStart - 1;
              if (tooBig || tooSmall) {
                payload.issues.push({
                  ...(tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length }),
                  input,
                  inst,
                  origin: "array",
                });
                return payload;
              }
            }
            let i = -1;
            for (const item of items) {
              i++;
              if (i >= input.length)
                if (i >= optStart)
                  continue;
              const result = item._zod.run({
                value: input[i],
                issues: [],
              }, ctx);
              if (result instanceof Promise) {
                proms.push(result.then((result) => handleTupleResult(result, payload, i)));
              }
              else {
                handleTupleResult(result, payload, i);
              }
            }
            if (def.rest) {
              const rest = input.slice(items.length);
              for (const el of rest) {
                i++;
                const result = def.rest._zod.run({
                  value: el,
                  issues: [],
                }, ctx);
                if (result instanceof Promise) {
                  proms.push(result.then((result) => handleTupleResult(result, payload, i)));
                }
                else {
                  handleTupleResult(result, payload, i);
                }
              }
            }
            if (proms.length)
              return Promise.all(proms).then(() => payload);
            return payload;
          };
        });
        function handleTupleResult(result, final, index) {
          if (result.issues.length) {
            final.issues.push(...prefixIssues(index, result.issues));
          }
          final.value[index] = result.value;
        }
        const $ZodRecord = /*@__PURE__*/ $constructor("$ZodRecord", (inst, def) => {
          $ZodType.init(inst, def);
          inst._zod.parse = (payload, ctx) => {
            const input = payload.value;
            if (!isPlainObject(input)) {
              payload.issues.push({
                expected: "record",
                code: "invalid_type",
                input,
                inst,
              });
              return payload;
            }
            const proms = [];
            if (def.keyType._zod.values) {
              const values = def.keyType._zod.values;
              payload.value = {};
              for (const key of values) {
                if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
                  const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
                  if (result instanceof Promise) {
                    proms.push(result.then((result) => {
                      if (result.issues.length) {
                        payload.issues.push(...prefixIssues(key, result.issues));
                      }
                      payload.value[key] = result.value;
                    }));
                  }
                  else {
                    if (result.issues.length) {
                      payload.issues.push(...prefixIssues(key, result.issues));
                    }
                    payload.value[key] = result.value;
                  }
                }
              }
              let unrecognized;
              for (const key in input) {
                if (!values.has(key)) {
                  unrecognized = unrecognized ?? [];
                  unrecognized.push(key);
                }
              }
              if (unrecognized && unrecognized.length > 0) {
                payload.issues.push({
                  code: "unrecognized_keys",
                  input,
                  inst,
                  keys: unrecognized,
                });
              }
            }
            else {
              payload.value = {};
              for (const key of Reflect.ownKeys(input)) {
                if (key === "__proto__")
                  continue;
                const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
                if (keyResult instanceof Promise) {
                  throw new Error("Async schemas not supported in object keys currently");
                }
                if (keyResult.issues.length) {
                  payload.issues.push({
                    code: "invalid_key",
                    origin: "record",
                    issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                    input: key,
                    path: [key],
                    inst,
                  });
                  payload.value[keyResult.value] = keyResult.value;
                  continue;
                }
                const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
                if (result instanceof Promise) {
                  proms.push(result.then((result) => {
                    if (result.issues.length) {
                      payload.issues.push(...prefixIssues(key, result.issues));
                    }
                    payload.value[keyResult.value] = result.value;
                  }));
                }
                else {
                  if (result.issues.length) {
                    payload.issues.push(...prefixIssues(key, result.issues));
                  }
                  payload.value[keyResult.value] = result.value;
                }
              }
            }
            if (proms.length) {
              return Promise.all(proms).then(() => payload);
            }
            return payload;
          };
        });
        const $ZodEnum = /*@__PURE__*/ $constructor("$ZodEnum", (inst, def) => {
          $ZodType.init(inst, def);
          const values = getEnumValues(def.entries);
          const valuesSet = new Set(values);
          inst._zod.values = valuesSet;
          inst._zod.pattern = new RegExp(`^(${values
            .filter((k) => propertyKeyTypes.has(typeof k))
            .map((o) => (typeof o === "string" ? escapeRegex(o) : o.toString()))
            .join("|")})$`);
          inst._zod.parse = (payload, _ctx) => {
            const input = payload.value;
            if (valuesSet.has(input)) {
              return payload;
            }
            payload.issues.push({
              code: "invalid_value",
              values,
              input,
              inst,
            });
            return payload;
          };
        });
        const $ZodLiteral = /*@__PURE__*/ $constructor("$ZodLiteral", (inst, def) => {
          $ZodType.init(inst, def);
          if (def.values.length === 0) {
            throw new Error("Cannot create literal schema with no valid values");
          }
          inst._zod.values = new Set(def.values);
          inst._zod.pattern = new RegExp(`^(${def.values
            .map((o) => (typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)))
            .join("|")})$`);
          inst._zod.parse = (payload, _ctx) => {
            const input = payload.value;
            if (inst._zod.values.has(input)) {
              return payload;
            }
            payload.issues.push({
              code: "invalid_value",
              values: def.values,
              input,
              inst,
            });
            return payload;
          };
        });
        const $ZodTransform = /*@__PURE__*/ $constructor("$ZodTransform", (inst, def) => {
          $ZodType.init(inst, def);
          inst._zod.parse = (payload, ctx) => {
            if (ctx.direction === "backward") {
              throw new $ZodEncodeError(inst.constructor.name);
            }
            const _out = def.transform(payload.value, payload);
            if (ctx.async) {
              const output = _out instanceof Promise ? _out : Promise.resolve(_out);
              return output.then((output) => {
                payload.value = output;
                return payload;
              });
            }
            if (_out instanceof Promise) {
              throw new $ZodAsyncError();
            }
            payload.value = _out;
            return payload;
          };
        });
        function handleOptionalResult(result, input) {
          if (result.issues.length && input === undefined) {
            return { issues: [], value: undefined };
          }
          return result;
        }
        const $ZodOptional = /*@__PURE__*/ $constructor("$ZodOptional", (inst, def) => {
          $ZodType.init(inst, def);
          inst._zod.optin = "optional";
          inst._zod.optout = "optional";
          defineLazy(inst._zod, "values", () => {
            return def.innerType._zod.values ? new Set([...def.innerType._zod.values, undefined]) : undefined;
          });
          defineLazy(inst._zod, "pattern", () => {
            const pattern = def.innerType._zod.pattern;
            return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : undefined;
          });
          inst._zod.parse = (payload, ctx) => {
            if (def.innerType._zod.optin === "optional") {
              const result = def.innerType._zod.run(payload, ctx);
              if (result instanceof Promise)
                return result.then((r) => handleOptionalResult(r, payload.value));
              return handleOptionalResult(result, payload.value);
            }
            if (payload.value === undefined) {
              return payload;
            }
            return def.innerType._zod.run(payload, ctx);
          };
        });
        const $ZodNullable = /*@__PURE__*/ $constructor("$ZodNullable", (inst, def) => {
          $ZodType.init(inst, def);
          defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
          defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
          defineLazy(inst._zod, "pattern", () => {
            const pattern = def.innerType._zod.pattern;
            return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : undefined;
          });
          defineLazy(inst._zod, "values", () => {
            return def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : undefined;
          });
          inst._zod.parse = (payload, ctx) => {
            // Forward direction (decode): allow null to pass through
            if (payload.value === null)
              return payload;
            return def.innerType._zod.run(payload, ctx);
          };
        });
        const $ZodDefault = /*@__PURE__*/ $constructor("$ZodDefault", (inst, def) => {
          $ZodType.init(inst, def);
          // inst._zod.qin = "true";
          inst._zod.optin = "optional";
          defineLazy(inst._zod, "values", () => def.innerType._zod.values);
          inst._zod.parse = (payload, ctx) => {
            if (ctx.direction === "backward") {
              return def.innerType._zod.run(payload, ctx);
            }
            // Forward direction (decode): apply defaults for undefined input
            if (payload.value === undefined) {
              payload.value = def.defaultValue;
              /**
               * $ZodDefault returns the default value immediately in forward direction.
               * It doesn't pass the default value into the validator ("prefault"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a "prefault" for the pipe.   */
              return payload;
            }
            // Forward direction: continue with default handling
            const result = def.innerType._zod.run(payload, ctx);
            if (result instanceof Promise) {
              return result.then((result) => handleDefaultResult(result, def));
            }
            return handleDefaultResult(result, def);
          };
        });
        function handleDefaultResult(payload, def) {
          if (payload.value === undefined) {
            payload.value = def.defaultValue;
          }
          return payload;
        }
        const $ZodPrefault = /*@__PURE__*/ $constructor("$ZodPrefault", (inst, def) => {
          $ZodType.init(inst, def);
          inst._zod.optin = "optional";
          defineLazy(inst._zod, "values", () => def.innerType._zod.values);
          inst._zod.parse = (payload, ctx) => {
            if (ctx.direction === "backward") {
              return def.innerType._zod.run(payload, ctx);
            }
            // Forward direction (decode): apply prefault for undefined input
            if (payload.value === undefined) {
              payload.value = def.defaultValue;
            }
            return def.innerType._zod.run(payload, ctx);
          };
        });
        const $ZodNonOptional = /*@__PURE__*/ $constructor("$ZodNonOptional", (inst, def) => {
          $ZodType.init(inst, def);
          defineLazy(inst._zod, "values", () => {
            const v = def.innerType._zod.values;
            return v ? new Set([...v].filter((x) => x !== undefined)) : undefined;
          });
          inst._zod.parse = (payload, ctx) => {
            const result = def.innerType._zod.run(payload, ctx);
            if (result instanceof Promise) {
              return result.then((result) => handleNonOptionalResult(result, inst));
            }
            return handleNonOptionalResult(result, inst);
          };
        });
        function handleNonOptionalResult(payload, inst) {
          if (!payload.issues.length && payload.value === undefined) {
            payload.issues.push({
              code: "invalid_type",
              expected: "nonoptional",
              input: payload.value,
              inst,
            });
          }
          return payload;
        }
        const $ZodCatch = /*@__PURE__*/ $constructor("$ZodCatch", (inst, def) => {
          $ZodType.init(inst, def);
          defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
          defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
          defineLazy(inst._zod, "values", () => def.innerType._zod.values);
          inst._zod.parse = (payload, ctx) => {
            if (ctx.direction === "backward") {
              return def.innerType._zod.run(payload, ctx);
            }
            // Forward direction (decode): apply catch logic
            const result = def.innerType._zod.run(payload, ctx);
            if (result instanceof Promise) {
              return result.then((result) => {
                payload.value = result.value;
                if (result.issues.length) {
                  payload.value = def.catchValue({
                    ...payload,
                    error: {
                      issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                    },
                    input: payload.value,
                  });
                  payload.issues = [];
                }
                return payload;
              });
            }
            payload.value = result.value;
            if (result.issues.length) {
              payload.value = def.catchValue({
                ...payload,
                error: {
                  issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())),
                },
                input: payload.value,
              });
              payload.issues = [];
            }
            return payload;
          };
        });
        const $ZodPipe = /*@__PURE__*/ $constructor("$ZodPipe", (inst, def) => {
          $ZodType.init(inst, def);
          defineLazy(inst._zod, "values", () => def.in._zod.values);
          defineLazy(inst._zod, "optin", () => def.in._zod.optin);
          defineLazy(inst._zod, "optout", () => def.out._zod.optout);
          defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
          inst._zod.parse = (payload, ctx) => {
            if (ctx.direction === "backward") {
              const right = def.out._zod.run(payload, ctx);
              if (right instanceof Promise) {
                return right.then((right) => handlePipeResult(right, def.in, ctx));
              }
              return handlePipeResult(right, def.in, ctx);
            }
            const left = def.in._zod.run(payload, ctx);
            if (left instanceof Promise) {
              return left.then((left) => handlePipeResult(left, def.out, ctx));
            }
            return handlePipeResult(left, def.out, ctx);
          };
        });
        function handlePipeResult(left, next, ctx) {
          if (left.issues.length) {
            // prevent further checks
            left.aborted = true;
            return left;
          }
          return next._zod.run({ value: left.value, issues: left.issues }, ctx);
        }
        const $ZodReadonly = /*@__PURE__*/ $constructor("$ZodReadonly", (inst, def) => {
          $ZodType.init(inst, def);
          defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
          defineLazy(inst._zod, "values", () => def.innerType._zod.values);
          defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
          defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
          inst._zod.parse = (payload, ctx) => {
            if (ctx.direction === "backward") {
              return def.innerType._zod.run(payload, ctx);
            }
            const result = def.innerType._zod.run(payload, ctx);
            if (result instanceof Promise) {
              return result.then(handleReadonlyResult);
            }
            return handleReadonlyResult(result);
          };
        });
        function handleReadonlyResult(payload) {
          payload.value = Object.freeze(payload.value);
          return payload;
        }
        const $ZodLazy = /*@__PURE__*/ $constructor("$ZodLazy", (inst, def) => {
          $ZodType.init(inst, def);
          // let _innerType!: any;
          // util.defineLazy(def, "getter", () => {
          //   if (!_innerType) {
          //     _innerType = def.getter();
          //   }
          //   return () => _innerType;
          // });
          defineLazy(inst._zod, "innerType", () => def.getter());
          defineLazy(inst._zod, "pattern", () => inst._zod.innerType._zod.pattern);
          defineLazy(inst._zod, "propValues", () => inst._zod.innerType._zod.propValues);
          defineLazy(inst._zod, "optin", () => inst._zod.innerType._zod.optin ?? undefined);
          defineLazy(inst._zod, "optout", () => inst._zod.innerType._zod.optout ?? undefined);
          inst._zod.parse = (payload, ctx) => {
            const inner = inst._zod.innerType;
            return inner._zod.run(payload, ctx);
          };
        });
        const $ZodCustom = /*@__PURE__*/ $constructor("$ZodCustom", (inst, def) => {
          $ZodCheck.init(inst, def);
          $ZodType.init(inst, def);
          inst._zod.parse = (payload, _) => {
            return payload;
          };
          inst._zod.check = (payload) => {
            const input = payload.value;
            const r = def.fn(input);
            if (r instanceof Promise) {
              return r.then((r) => handleRefineResult(r, payload, input, inst));
            }
            handleRefineResult(r, payload, input, inst);
            return;
          };
        });
        function handleRefineResult(result, payload, input, inst) {
          if (!result) {
            const _iss = {
              code: "custom",
              input,
              inst, // incorporates params.error into issue reporting
              path: [...(inst._zod.def.path ?? [])], // incorporates params.error into issue reporting
              continue: !inst._zod.def.abort,
              // params: inst._zod.def.params,
            };
            if (inst._zod.def.params)
              _iss.params = inst._zod.def.params;
            payload.issues.push(issue(_iss));
          }
        }

        class $ZodRegistry {
          constructor() {
            this._map = new WeakMap();
            this._idmap = new Map();
          }
          add(schema, ..._meta) {
            const meta = _meta[0];
            this._map.set(schema, meta);
            if (meta && typeof meta === "object" && "id" in meta) {
              if (this._idmap.has(meta.id)) {
                throw new Error(`ID ${meta.id} already exists in the registry`);
              }
              this._idmap.set(meta.id, schema);
            }
            return this;
          }
          clear() {
            this._map = new WeakMap();
            this._idmap = new Map();
            return this;
          }
          remove(schema) {
            const meta = this._map.get(schema);
            if (meta && typeof meta === "object" && "id" in meta) {
              this._idmap.delete(meta.id);
            }
            this._map.delete(schema);
            return this;
          }
          get(schema) {
            // return this._map.get(schema) as any;
            // inherit metadata
            const p = schema._zod.parent;
            if (p) {
              const pm = { ...(this.get(p) ?? {}) };
              delete pm.id; // do not inherit id
              const f = { ...pm, ...this._map.get(schema) };
              return Object.keys(f).length ? f : undefined;
            }
            return this._map.get(schema);
          }
          has(schema) {
            return this._map.has(schema);
          }
        }
        // registries
        function registry() {
          return new $ZodRegistry();
        }
        const globalRegistry = /*@__PURE__*/ registry();

        function _string(Class, params) {
          return new Class({
            type: "string",
            ...normalizeParams(params),
          });
        }
        function _email(Class, params) {
          return new Class({
            type: "string",
            format: "email",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _guid(Class, params) {
          return new Class({
            type: "string",
            format: "guid",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _uuid(Class, params) {
          return new Class({
            type: "string",
            format: "uuid",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _uuidv4(Class, params) {
          return new Class({
            type: "string",
            format: "uuid",
            check: "string_format",
            abort: false,
            version: "v4",
            ...normalizeParams(params),
          });
        }
        function _uuidv6(Class, params) {
          return new Class({
            type: "string",
            format: "uuid",
            check: "string_format",
            abort: false,
            version: "v6",
            ...normalizeParams(params),
          });
        }
        function _uuidv7(Class, params) {
          return new Class({
            type: "string",
            format: "uuid",
            check: "string_format",
            abort: false,
            version: "v7",
            ...normalizeParams(params),
          });
        }
        function _url(Class, params) {
          return new Class({
            type: "string",
            format: "url",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _emoji(Class, params) {
          return new Class({
            type: "string",
            format: "emoji",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _nanoid(Class, params) {
          return new Class({
            type: "string",
            format: "nanoid",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _cuid(Class, params) {
          return new Class({
            type: "string",
            format: "cuid",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _cuid2(Class, params) {
          return new Class({
            type: "string",
            format: "cuid2",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _ulid(Class, params) {
          return new Class({
            type: "string",
            format: "ulid",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _xid(Class, params) {
          return new Class({
            type: "string",
            format: "xid",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _ksuid(Class, params) {
          return new Class({
            type: "string",
            format: "ksuid",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _ipv4(Class, params) {
          return new Class({
            type: "string",
            format: "ipv4",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _ipv6(Class, params) {
          return new Class({
            type: "string",
            format: "ipv6",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _cidrv4(Class, params) {
          return new Class({
            type: "string",
            format: "cidrv4",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _cidrv6(Class, params) {
          return new Class({
            type: "string",
            format: "cidrv6",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _base64(Class, params) {
          return new Class({
            type: "string",
            format: "base64",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _base64url(Class, params) {
          return new Class({
            type: "string",
            format: "base64url",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _e164(Class, params) {
          return new Class({
            type: "string",
            format: "e164",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _jwt(Class, params) {
          return new Class({
            type: "string",
            format: "jwt",
            check: "string_format",
            abort: false,
            ...normalizeParams(params),
          });
        }
        function _isoDateTime(Class, params) {
          return new Class({
            type: "string",
            format: "datetime",
            check: "string_format",
            offset: false,
            local: false,
            precision: null,
            ...normalizeParams(params),
          });
        }
        function _isoDate(Class, params) {
          return new Class({
            type: "string",
            format: "date",
            check: "string_format",
            ...normalizeParams(params),
          });
        }
        function _isoTime(Class, params) {
          return new Class({
            type: "string",
            format: "time",
            check: "string_format",
            precision: null,
            ...normalizeParams(params),
          });
        }
        function _isoDuration(Class, params) {
          return new Class({
            type: "string",
            format: "duration",
            check: "string_format",
            ...normalizeParams(params),
          });
        }
        function _number(Class, params) {
          return new Class({
            type: "number",
            checks: [],
            ...normalizeParams(params),
          });
        }
        function _coercedNumber(Class, params) {
          return new Class({
            type: "number",
            coerce: true,
            checks: [],
            ...normalizeParams(params),
          });
        }
        function _int(Class, params) {
          return new Class({
            type: "number",
            check: "number_format",
            abort: false,
            format: "safeint",
            ...normalizeParams(params),
          });
        }
        function _boolean(Class, params) {
          return new Class({
            type: "boolean",
            ...normalizeParams(params),
          });
        }
        function _any(Class) {
          return new Class({
            type: "any",
          });
        }
        function _unknown(Class) {
          return new Class({
            type: "unknown",
          });
        }
        function _never(Class, params) {
          return new Class({
            type: "never",
            ...normalizeParams(params),
          });
        }
        function _lt(value, params) {
          return new $ZodCheckLessThan({
            check: "less_than",
            ...normalizeParams(params),
            value,
            inclusive: false,
          });
        }
        function _lte(value, params) {
          return new $ZodCheckLessThan({
            check: "less_than",
            ...normalizeParams(params),
            value,
            inclusive: true,
          });
        }
        function _gt(value, params) {
          return new $ZodCheckGreaterThan({
            check: "greater_than",
            ...normalizeParams(params),
            value,
            inclusive: false,
          });
        }
        function _gte(value, params) {
          return new $ZodCheckGreaterThan({
            check: "greater_than",
            ...normalizeParams(params),
            value,
            inclusive: true,
          });
        }
        function _multipleOf(value, params) {
          return new $ZodCheckMultipleOf({
            check: "multiple_of",
            ...normalizeParams(params),
            value,
          });
        }
        function _maxLength(maximum, params) {
          const ch = new $ZodCheckMaxLength({
            check: "max_length",
            ...normalizeParams(params),
            maximum,
          });
          return ch;
        }
        function _minLength(minimum, params) {
          return new $ZodCheckMinLength({
            check: "min_length",
            ...normalizeParams(params),
            minimum,
          });
        }
        function _length(length, params) {
          return new $ZodCheckLengthEquals({
            check: "length_equals",
            ...normalizeParams(params),
            length,
          });
        }
        function _regex(pattern, params) {
          return new $ZodCheckRegex({
            check: "string_format",
            format: "regex",
            ...normalizeParams(params),
            pattern,
          });
        }
        function _lowercase(params) {
          return new $ZodCheckLowerCase({
            check: "string_format",
            format: "lowercase",
            ...normalizeParams(params),
          });
        }
        function _uppercase(params) {
          return new $ZodCheckUpperCase({
            check: "string_format",
            format: "uppercase",
            ...normalizeParams(params),
          });
        }
        function _includes(includes, params) {
          return new $ZodCheckIncludes({
            check: "string_format",
            format: "includes",
            ...normalizeParams(params),
            includes,
          });
        }
        function _startsWith(prefix, params) {
          return new $ZodCheckStartsWith({
            check: "string_format",
            format: "starts_with",
            ...normalizeParams(params),
            prefix,
          });
        }
        function _endsWith(suffix, params) {
          return new $ZodCheckEndsWith({
            check: "string_format",
            format: "ends_with",
            ...normalizeParams(params),
            suffix,
          });
        }
        function _overwrite(tx) {
          return new $ZodCheckOverwrite({
            check: "overwrite",
            tx,
          });
        }
        // normalize
        function _normalize(form) {
          return _overwrite((input) => input.normalize(form));
        }
        // trim
        function _trim() {
          return _overwrite((input) => input.trim());
        }
        // toLowerCase
        function _toLowerCase() {
          return _overwrite((input) => input.toLowerCase());
        }
        // toUpperCase
        function _toUpperCase() {
          return _overwrite((input) => input.toUpperCase());
        }
        function _array(Class, element, params) {
          return new Class({
            type: "array",
            element,
            // get element() {
            //   return element;
            // },
            ...normalizeParams(params),
          });
        }
        // same as _custom but defaults to abort:false
        function _refine(Class, fn, _params) {
          const schema = new Class({
            type: "custom",
            check: "custom",
            fn: fn,
            ...normalizeParams(_params),
          });
          return schema;
        }
        function _superRefine(fn) {
          const ch = _check((payload) => {
            payload.addIssue = (issue$1) => {
              if (typeof issue$1 === "string") {
                payload.issues.push(issue(issue$1, payload.value, ch._zod.def));
              }
              else {
                // for Zod 3 backwards compatibility
                const _issue = issue$1;
                if (_issue.fatal)
                  _issue.continue = false;
                _issue.code ?? (_issue.code = "custom");
                _issue.input ?? (_issue.input = payload.value);
                _issue.inst ?? (_issue.inst = ch);
                _issue.continue ?? (_issue.continue = !ch._zod.def.abort); // abort is always undefined, so this is always true...
                payload.issues.push(issue(_issue));
              }
            };
            return fn(payload.value, payload);
          });
          return ch;
        }
        function _check(fn, params) {
          const ch = new $ZodCheck({
            check: "custom",
            ...normalizeParams(params),
          });
          ch._zod.check = fn;
          return ch;
        }

        class JSONSchemaGenerator {
          constructor(params) {
            this.counter = 0;
            this.metadataRegistry = params?.metadata ?? globalRegistry;
            this.target = params?.target ?? "draft-2020-12";
            this.unrepresentable = params?.unrepresentable ?? "throw";
            this.override = params?.override ?? (() => { });
            this.io = params?.io ?? "output";
            this.seen = new Map();
          }
          process(schema, _params = { path: [], schemaPath: [] }) {
            var _a;
            const def = schema._zod.def;
            const formatMap = {
              guid: "uuid",
              url: "uri",
              datetime: "date-time",
              json_string: "json-string",
              regex: "", // do not set
            };
            // check for schema in seens
            const seen = this.seen.get(schema);
            if (seen) {
              seen.count++;
              // check if cycle
              const isCycle = _params.schemaPath.includes(schema);
              if (isCycle) {
                seen.cycle = _params.path;
              }
              return seen.schema;
            }
            // initialize
            const result = { schema: {}, count: 1, cycle: undefined, path: _params.path };
            this.seen.set(schema, result);
            // custom method overrides default behavior
            const overrideSchema = schema._zod.toJSONSchema?.();
            if (overrideSchema) {
              result.schema = overrideSchema;
            }
            else {
              const params = {
                ..._params,
                schemaPath: [..._params.schemaPath, schema],
                path: _params.path,
              };
              const parent = schema._zod.parent;
              if (parent) {
                // schema was cloned from another schema
                result.ref = parent;
                this.process(parent, params);
                this.seen.get(parent).isParent = true;
              }
              else {
                const _json = result.schema;
                switch (def.type) {
                  case "string": {
                    const json = _json;
                    json.type = "string";
                    const { minimum, maximum, format, patterns, contentEncoding } = schema._zod
                      .bag;
                    if (typeof minimum === "number")
                      json.minLength = minimum;
                    if (typeof maximum === "number")
                      json.maxLength = maximum;
                    // custom pattern overrides format
                    if (format) {
                      json.format = formatMap[format] ?? format;
                      if (json.format === "")
                        delete json.format; // empty format is not valid
                    }
                    if (contentEncoding)
                      json.contentEncoding = contentEncoding;
                    if (patterns && patterns.size > 0) {
                      const regexes = [...patterns];
                      if (regexes.length === 1)
                        json.pattern = regexes[0].source;
                      else if (regexes.length > 1) {
                        result.schema.allOf = [
                          ...regexes.map((regex) => ({
                            ...(this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0"
                              ? { type: "string" }
                              : {}),
                            pattern: regex.source,
                          })),
                        ];
                      }
                    }
                    break;
                  }
                  case "number": {
                    const json = _json;
                    const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
                    if (typeof format === "string" && format.includes("int"))
                      json.type = "integer";
                    else
                      json.type = "number";
                    if (typeof exclusiveMinimum === "number") {
                      if (this.target === "draft-4" || this.target === "openapi-3.0") {
                        json.minimum = exclusiveMinimum;
                        json.exclusiveMinimum = true;
                      }
                      else {
                        json.exclusiveMinimum = exclusiveMinimum;
                      }
                    }
                    if (typeof minimum === "number") {
                      json.minimum = minimum;
                      if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                        if (exclusiveMinimum >= minimum)
                          delete json.minimum;
                        else
                          delete json.exclusiveMinimum;
                      }
                    }
                    if (typeof exclusiveMaximum === "number") {
                      if (this.target === "draft-4" || this.target === "openapi-3.0") {
                        json.maximum = exclusiveMaximum;
                        json.exclusiveMaximum = true;
                      }
                      else {
                        json.exclusiveMaximum = exclusiveMaximum;
                      }
                    }
                    if (typeof maximum === "number") {
                      json.maximum = maximum;
                      if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                        if (exclusiveMaximum <= maximum)
                          delete json.maximum;
                        else
                          delete json.exclusiveMaximum;
                      }
                    }
                    if (typeof multipleOf === "number")
                      json.multipleOf = multipleOf;
                    break;
                  }
                  case "boolean": {
                    const json = _json;
                    json.type = "boolean";
                    break;
                  }
                  case "bigint": {
                    if (this.unrepresentable === "throw") {
                      throw new Error("BigInt cannot be represented in JSON Schema");
                    }
                    break;
                  }
                  case "symbol": {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Symbols cannot be represented in JSON Schema");
                    }
                    break;
                  }
                  case "null": {
                    if (this.target === "openapi-3.0") {
                      _json.type = "string";
                      _json.nullable = true;
                      _json.enum = [null];
                    }
                    else
                      _json.type = "null";
                    break;
                  }
                  case "any": {
                    break;
                  }
                  case "unknown": {
                    break;
                  }
                  case "undefined": {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Undefined cannot be represented in JSON Schema");
                    }
                    break;
                  }
                  case "void": {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Void cannot be represented in JSON Schema");
                    }
                    break;
                  }
                  case "never": {
                    _json.not = {};
                    break;
                  }
                  case "date": {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Date cannot be represented in JSON Schema");
                    }
                    break;
                  }
                  case "array": {
                    const json = _json;
                    const { minimum, maximum } = schema._zod.bag;
                    if (typeof minimum === "number")
                      json.minItems = minimum;
                    if (typeof maximum === "number")
                      json.maxItems = maximum;
                    json.type = "array";
                    json.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
                    break;
                  }
                  case "object": {
                    const json = _json;
                    json.type = "object";
                    json.properties = {};
                    const shape = def.shape; // params.shapeCache.get(schema)!;
                    for (const key in shape) {
                      json.properties[key] = this.process(shape[key], {
                        ...params,
                        path: [...params.path, "properties", key],
                      });
                    }
                    // required keys
                    const allKeys = new Set(Object.keys(shape));
                    // const optionalKeys = new Set(def.optional);
                    const requiredKeys = new Set([...allKeys].filter((key) => {
                      const v = def.shape[key]._zod;
                      if (this.io === "input") {
                        return v.optin === undefined;
                      }
                      else {
                        return v.optout === undefined;
                      }
                    }));
                    if (requiredKeys.size > 0) {
                      json.required = Array.from(requiredKeys);
                    }
                    // catchall
                    if (def.catchall?._zod.def.type === "never") {
                      // strict
                      json.additionalProperties = false;
                    }
                    else if (!def.catchall) {
                      // regular
                      if (this.io === "output")
                        json.additionalProperties = false;
                    }
                    else if (def.catchall) {
                      json.additionalProperties = this.process(def.catchall, {
                        ...params,
                        path: [...params.path, "additionalProperties"],
                      });
                    }
                    break;
                  }
                  case "union": {
                    const json = _json;
                    const options = def.options.map((x, i) => this.process(x, {
                      ...params,
                      path: [...params.path, "anyOf", i],
                    }));
                    json.anyOf = options;
                    break;
                  }
                  case "intersection": {
                    const json = _json;
                    const a = this.process(def.left, {
                      ...params,
                      path: [...params.path, "allOf", 0],
                    });
                    const b = this.process(def.right, {
                      ...params,
                      path: [...params.path, "allOf", 1],
                    });
                    const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
                    const allOf = [
                      ...(isSimpleIntersection(a) ? a.allOf : [a]),
                      ...(isSimpleIntersection(b) ? b.allOf : [b]),
                    ];
                    json.allOf = allOf;
                    break;
                  }
                  case "tuple": {
                    const json = _json;
                    json.type = "array";
                    const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
                    const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
                    const prefixItems = def.items.map((x, i) => this.process(x, {
                      ...params,
                      path: [...params.path, prefixPath, i],
                    }));
                    const rest = def.rest
                      ? this.process(def.rest, {
                        ...params,
                        path: [...params.path, restPath, ...(this.target === "openapi-3.0" ? [def.items.length] : [])],
                      })
                      : null;
                    if (this.target === "draft-2020-12") {
                      json.prefixItems = prefixItems;
                      if (rest) {
                        json.items = rest;
                      }
                    }
                    else if (this.target === "openapi-3.0") {
                      json.items = {
                        anyOf: prefixItems,
                      };
                      if (rest) {
                        json.items.anyOf.push(rest);
                      }
                      json.minItems = prefixItems.length;
                      if (!rest) {
                        json.maxItems = prefixItems.length;
                      }
                    }
                    else {
                      json.items = prefixItems;
                      if (rest) {
                        json.additionalItems = rest;
                      }
                    }
                    // length
                    const { minimum, maximum } = schema._zod.bag;
                    if (typeof minimum === "number")
                      json.minItems = minimum;
                    if (typeof maximum === "number")
                      json.maxItems = maximum;
                    break;
                  }
                  case "record": {
                    const json = _json;
                    json.type = "object";
                    if (this.target === "draft-7" || this.target === "draft-2020-12") {
                      json.propertyNames = this.process(def.keyType, {
                        ...params,
                        path: [...params.path, "propertyNames"],
                      });
                    }
                    json.additionalProperties = this.process(def.valueType, {
                      ...params,
                      path: [...params.path, "additionalProperties"],
                    });
                    break;
                  }
                  case "map": {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Map cannot be represented in JSON Schema");
                    }
                    break;
                  }
                  case "set": {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Set cannot be represented in JSON Schema");
                    }
                    break;
                  }
                  case "enum": {
                    const json = _json;
                    const values = getEnumValues(def.entries);
                    // Number enums can have both string and number values
                    if (values.every((v) => typeof v === "number"))
                      json.type = "number";
                    if (values.every((v) => typeof v === "string"))
                      json.type = "string";
                    json.enum = values;
                    break;
                  }
                  case "literal": {
                    const json = _json;
                    const vals = [];
                    for (const val of def.values) {
                      if (val === undefined) {
                        if (this.unrepresentable === "throw") {
                          throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                        }
                      }
                      else if (typeof val === "bigint") {
                        if (this.unrepresentable === "throw") {
                          throw new Error("BigInt literals cannot be represented in JSON Schema");
                        }
                        else {
                          vals.push(Number(val));
                        }
                      }
                      else {
                        vals.push(val);
                      }
                    }
                    if (vals.length === 0);
                    else if (vals.length === 1) {
                      const val = vals[0];
                      json.type = val === null ? "null" : typeof val;
                      if (this.target === "draft-4" || this.target === "openapi-3.0") {
                        json.enum = [val];
                      }
                      else {
                        json.const = val;
                      }
                    }
                    else {
                      if (vals.every((v) => typeof v === "number"))
                        json.type = "number";
                      if (vals.every((v) => typeof v === "string"))
                        json.type = "string";
                      if (vals.every((v) => typeof v === "boolean"))
                        json.type = "string";
                      if (vals.every((v) => v === null))
                        json.type = "null";
                      json.enum = vals;
                    }
                    break;
                  }
                  case "file": {
                    const json = _json;
                    const file = {
                      type: "string",
                      format: "binary",
                      contentEncoding: "binary",
                    };
                    const { minimum, maximum, mime } = schema._zod.bag;
                    if (minimum !== undefined)
                      file.minLength = minimum;
                    if (maximum !== undefined)
                      file.maxLength = maximum;
                    if (mime) {
                      if (mime.length === 1) {
                        file.contentMediaType = mime[0];
                        Object.assign(json, file);
                      }
                      else {
                        json.anyOf = mime.map((m) => {
                          const mFile = { ...file, contentMediaType: m };
                          return mFile;
                        });
                      }
                    }
                    else {
                      Object.assign(json, file);
                    }
                    // if (this.unrepresentable === "throw") {
                    //   throw new Error("File cannot be represented in JSON Schema");
                    // }
                    break;
                  }
                  case "transform": {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Transforms cannot be represented in JSON Schema");
                    }
                    break;
                  }
                  case "nullable": {
                    const inner = this.process(def.innerType, params);
                    if (this.target === "openapi-3.0") {
                      result.ref = def.innerType;
                      _json.nullable = true;
                    }
                    else {
                      _json.anyOf = [inner, { type: "null" }];
                    }
                    break;
                  }
                  case "nonoptional": {
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    break;
                  }
                  case "success": {
                    const json = _json;
                    json.type = "boolean";
                    break;
                  }
                  case "default": {
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    _json.default = JSON.parse(JSON.stringify(def.defaultValue));
                    break;
                  }
                  case "prefault": {
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    if (this.io === "input")
                      _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
                    break;
                  }
                  case "catch": {
                    // use conditionals
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    let catchValue;
                    try {
                      catchValue = def.catchValue(undefined);
                    }
                    catch {
                      throw new Error("Dynamic catch values are not supported in JSON Schema");
                    }
                    _json.default = catchValue;
                    break;
                  }
                  case "nan": {
                    if (this.unrepresentable === "throw") {
                      throw new Error("NaN cannot be represented in JSON Schema");
                    }
                    break;
                  }
                  case "template_literal": {
                    const json = _json;
                    const pattern = schema._zod.pattern;
                    if (!pattern)
                      throw new Error("Pattern not found in template literal");
                    json.type = "string";
                    json.pattern = pattern.source;
                    break;
                  }
                  case "pipe": {
                    const innerType = this.io === "input" ? (def.in._zod.def.type === "transform" ? def.out : def.in) : def.out;
                    this.process(innerType, params);
                    result.ref = innerType;
                    break;
                  }
                  case "readonly": {
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    _json.readOnly = true;
                    break;
                  }
                  // passthrough types
                  case "promise": {
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    break;
                  }
                  case "optional": {
                    this.process(def.innerType, params);
                    result.ref = def.innerType;
                    break;
                  }
                  case "lazy": {
                    const innerType = schema._zod.innerType;
                    this.process(innerType, params);
                    result.ref = innerType;
                    break;
                  }
                  case "custom": {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Custom types cannot be represented in JSON Schema");
                    }
                    break;
                  }
                  case "function": {
                    if (this.unrepresentable === "throw") {
                      throw new Error("Function types cannot be represented in JSON Schema");
                    }
                    break;
                  }
                }
              }
            }
            // metadata
            const meta = this.metadataRegistry.get(schema);
            if (meta)
              Object.assign(result.schema, meta);
            if (this.io === "input" && isTransforming(schema)) {
              // examples/defaults only apply to output type of pipe
              delete result.schema.examples;
              delete result.schema.default;
            }
            // set prefault as default
            if (this.io === "input" && result.schema._prefault)
              (_a = result.schema).default ?? (_a.default = result.schema._prefault);
            delete result.schema._prefault;
            // pulling fresh from this.seen in case it was overwritten
            const _result = this.seen.get(schema);
            return _result.schema;
          }
          emit(schema, _params) {
            const params = {
              cycles: _params?.cycles ?? "ref",
              reused: _params?.reused ?? "inline",
              // unrepresentable: _params?.unrepresentable ?? "throw",
              // uri: _params?.uri ?? ((id) => `${id}`),
              external: _params?.external ?? undefined,
            };
            // iterate over seen map;
            const root = this.seen.get(schema);
            if (!root)
              throw new Error("Unprocessed schema. This is a bug in Zod.");
            // initialize result with root schema fields
            // Object.assign(result, seen.cached);
            // returns a ref to the schema
            // defId will be empty if the ref points to an external schema (or #)
            const makeURI = (entry) => {
              // comparing the seen objects because sometimes
              // multiple schemas map to the same seen object.
              // e.g. lazy
              // external is configured
              const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
              if (params.external) {
                const externalId = params.external.registry.get(entry[0])?.id; // ?? "__shared";// `__schema${this.counter++}`;
                // check if schema is in the external registry
                const uriGenerator = params.external.uri ?? ((id) => id);
                if (externalId) {
                  return { ref: uriGenerator(externalId) };
                }
                // otherwise, add to __shared
                const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
                entry[1].defId = id; // set defId so it will be reused if needed
                return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
              }
              if (entry[1] === root) {
                return { ref: "#" };
              }
              // self-contained schema
              const uriPrefix = `#`;
              const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
              const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
              return { defId, ref: defUriPrefix + defId };
            };
            // stored cached version in `def` property
            // remove all properties, set $ref
            const extractToDef = (entry) => {
              // if the schema is already a reference, do not extract it
              if (entry[1].schema.$ref) {
                return;
              }
              const seen = entry[1];
              const { ref, defId } = makeURI(entry);
              seen.def = { ...seen.schema };
              // defId won't be set if the schema is a reference to an external schema
              if (defId)
                seen.defId = defId;
              // wipe away all properties except $ref
              const schema = seen.schema;
              for (const key in schema) {
                delete schema[key];
              }
              schema.$ref = ref;
            };
            // throw on cycles
            // break cycles
            if (params.cycles === "throw") {
              for (const entry of this.seen.entries()) {
                const seen = entry[1];
                if (seen.cycle) {
                  throw new Error("Cycle detected: " +
                    `#/${seen.cycle?.join("/")}/<root>` +
                    '\n\nSet the `cycles` parameter to `"ref"` to resolve cyclical schemas with defs.');
                }
              }
            }
            // extract schemas into $defs
            for (const entry of this.seen.entries()) {
              const seen = entry[1];
              // convert root schema to # $ref
              if (schema === entry[0]) {
                extractToDef(entry); // this has special handling for the root schema
                continue;
              }
              // extract schemas that are in the external registry
              if (params.external) {
                const ext = params.external.registry.get(entry[0])?.id;
                if (schema !== entry[0] && ext) {
                  extractToDef(entry);
                  continue;
                }
              }
              // extract schemas with `id` meta
              const id = this.metadataRegistry.get(entry[0])?.id;
              if (id) {
                extractToDef(entry);
                continue;
              }
              // break cycles
              if (seen.cycle) {
                // any
                extractToDef(entry);
                continue;
              }
              // extract reused schemas
              if (seen.count > 1) {
                if (params.reused === "ref") {
                  extractToDef(entry);
                  // biome-ignore lint:
                  continue;
                }
              }
            }
            // flatten _refs
            const flattenRef = (zodSchema, params) => {
              const seen = this.seen.get(zodSchema);
              const schema = seen.def ?? seen.schema;
              const _cached = { ...schema };
              // already seen
              if (seen.ref === null) {
                return;
              }
              // flatten ref if defined
              const ref = seen.ref;
              seen.ref = null; // prevent recursion
              if (ref) {
                flattenRef(ref, params);
                // merge referenced schema into current
                const refSchema = this.seen.get(ref).schema;
                if (refSchema.$ref &&
                  (params.target === "draft-7" || params.target === "draft-4" || params.target === "openapi-3.0")) {
                  schema.allOf = schema.allOf ?? [];
                  schema.allOf.push(refSchema);
                }
                else {
                  Object.assign(schema, refSchema);
                  Object.assign(schema, _cached); // prevent overwriting any fields in the original schema
                }
              }
              // execute overrides
              if (!seen.isParent)
                this.override({
                  zodSchema: zodSchema,
                  jsonSchema: schema,
                  path: seen.path ?? [],
                });
            };
            for (const entry of [...this.seen.entries()].reverse()) {
              flattenRef(entry[0], { target: this.target });
            }
            const result = {};
            if (this.target === "draft-2020-12") {
              result.$schema = "https://json-schema.org/draft/2020-12/schema";
            }
            else if (this.target === "draft-7") {
              result.$schema = "http://json-schema.org/draft-07/schema#";
            }
            else if (this.target === "draft-4") {
              result.$schema = "http://json-schema.org/draft-04/schema#";
            }
            else if (this.target === "openapi-3.0");
            else {
              // @ts-ignore
              console.warn(`Invalid target: ${this.target}`);
            }
            if (params.external?.uri) {
              const id = params.external.registry.get(schema)?.id;
              if (!id)
                throw new Error("Schema is missing an `id` property");
              result.$id = params.external.uri(id);
            }
            Object.assign(result, root.def);
            // build defs object
            const defs = params.external?.defs ?? {};
            for (const entry of this.seen.entries()) {
              const seen = entry[1];
              if (seen.def && seen.defId) {
                defs[seen.defId] = seen.def;
              }
            }
            // set definitions in result
            if (params.external);
            else {
              if (Object.keys(defs).length > 0) {
                if (this.target === "draft-2020-12") {
                  result.$defs = defs;
                }
                else {
                  result.definitions = defs;
                }
              }
            }
            try {
              // this "finalizes" this schema and ensures all cycles are removed
              // each call to .emit() is functionally independent
              // though the seen map is shared
              return JSON.parse(JSON.stringify(result));
            }
            catch (_err) {
              throw new Error("Error converting schema to JSON.");
            }
          }
        }
        function toJSONSchema(input, _params) {
          if (input instanceof $ZodRegistry) {
            const gen = new JSONSchemaGenerator(_params);
            const defs = {};
            for (const entry of input._idmap.entries()) {
              const [_, schema] = entry;
              gen.process(schema);
            }
            const schemas = {};
            const external = {
              registry: input,
              uri: _params?.uri,
              defs,
            };
            for (const entry of input._idmap.entries()) {
              const [key, schema] = entry;
              schemas[key] = gen.emit(schema, {
                ..._params,
                external,
              });
            }
            if (Object.keys(defs).length > 0) {
              const defsSegment = gen.target === "draft-2020-12" ? "$defs" : "definitions";
              schemas.__shared = {
                [defsSegment]: defs,
              };
            }
            return { schemas };
          }
          const gen = new JSONSchemaGenerator(_params);
          gen.process(input);
          return gen.emit(input, _params);
        }
        function isTransforming(_schema, _ctx) {
          const ctx = _ctx ?? { seen: new Set() };
          if (ctx.seen.has(_schema))
            return false;
          ctx.seen.add(_schema);
          const schema = _schema;
          const def = schema._zod.def;
          switch (def.type) {
            case "string":
            case "number":
            case "bigint":
            case "boolean":
            case "date":
            case "symbol":
            case "undefined":
            case "null":
            case "any":
            case "unknown":
            case "never":
            case "void":
            case "literal":
            case "enum":
            case "nan":
            case "file":
            case "template_literal":
              return false;
            case "array": {
              return isTransforming(def.element, ctx);
            }
            case "object": {
              for (const key in def.shape) {
                if (isTransforming(def.shape[key], ctx))
                  return true;
              }
              return false;
            }
            case "union": {
              for (const option of def.options) {
                if (isTransforming(option, ctx))
                  return true;
              }
              return false;
            }
            case "intersection": {
              return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
            }
            case "tuple": {
              for (const item of def.items) {
                if (isTransforming(item, ctx))
                  return true;
              }
              if (def.rest && isTransforming(def.rest, ctx))
                return true;
              return false;
            }
            case "record": {
              return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
            }
            case "map": {
              return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
            }
            case "set": {
              return isTransforming(def.valueType, ctx);
            }
            // inner types
            case "promise":
            case "optional":
            case "nonoptional":
            case "nullable":
            case "readonly":
              return isTransforming(def.innerType, ctx);
            case "lazy":
              return isTransforming(def.getter(), ctx);
            case "default": {
              return isTransforming(def.innerType, ctx);
            }
            case "prefault": {
              return isTransforming(def.innerType, ctx);
            }
            case "custom": {
              return false;
            }
            case "transform": {
              return true;
            }
            case "pipe": {
              return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
            }
            case "success": {
              return false;
            }
            case "catch": {
              return false;
            }
            case "function": {
              return false;
            }
          }
          throw new Error(`Unknown schema type: ${def.type}`);
        }

        const ZodISODateTime = /*@__PURE__*/ $constructor("ZodISODateTime", (inst, def) => {
          $ZodISODateTime.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        function datetime(params) {
          return _isoDateTime(ZodISODateTime, params);
        }
        const ZodISODate = /*@__PURE__*/ $constructor("ZodISODate", (inst, def) => {
          $ZodISODate.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        function date(params) {
          return _isoDate(ZodISODate, params);
        }
        const ZodISOTime = /*@__PURE__*/ $constructor("ZodISOTime", (inst, def) => {
          $ZodISOTime.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        function time(params) {
          return _isoTime(ZodISOTime, params);
        }
        const ZodISODuration = /*@__PURE__*/ $constructor("ZodISODuration", (inst, def) => {
          $ZodISODuration.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        function duration(params) {
          return _isoDuration(ZodISODuration, params);
        }

        const initializer = (inst, issues) => {
          $ZodError.init(inst, issues);
          inst.name = "ZodError";
          Object.defineProperties(inst, {
            format: {
              value: (mapper) => formatError(inst, mapper),
              // enumerable: false,
            },
            flatten: {
              value: (mapper) => flattenError(inst, mapper),
              // enumerable: false,
            },
            addIssue: {
              value: (issue) => {
                inst.issues.push(issue);
                inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
              },
              // enumerable: false,
            },
            addIssues: {
              value: (issues) => {
                inst.issues.push(...issues);
                inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
              },
              // enumerable: false,
            },
            isEmpty: {
              get() {
                return inst.issues.length === 0;
              },
              // enumerable: false,
            },
          });
          // Object.defineProperty(inst, "isEmpty", {
          //   get() {
          //     return inst.issues.length === 0;
          //   },
          // });
        };
        const ZodRealError = $constructor("ZodError", initializer, {
          Parent: Error,
        });
        // /** @deprecated Use `z.core.$ZodErrorMapCtx` instead. */
        // export type ErrorMapCtx = core.$ZodErrorMapCtx;

        const parse = /* @__PURE__ */ _parse$2(ZodRealError);
        const parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);
        const safeParse = /* @__PURE__ */ _safeParse(ZodRealError);
        const safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);
        // Codec functions
        const encode = /* @__PURE__ */ _encode(ZodRealError);
        const decode = /* @__PURE__ */ _decode(ZodRealError);
        const encodeAsync = /* @__PURE__ */ _encodeAsync(ZodRealError);
        const decodeAsync = /* @__PURE__ */ _decodeAsync(ZodRealError);
        const safeEncode = /* @__PURE__ */ _safeEncode(ZodRealError);
        const safeDecode = /* @__PURE__ */ _safeDecode(ZodRealError);
        const safeEncodeAsync = /* @__PURE__ */ _safeEncodeAsync(ZodRealError);
        const safeDecodeAsync = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

        const ZodType = /*@__PURE__*/ $constructor("ZodType", (inst, def) => {
          $ZodType.init(inst, def);
          inst.def = def;
          inst.type = def.type;
          Object.defineProperty(inst, "_def", { value: def });
          // base methods
          inst.check = (...checks) => {
            return inst.clone(mergeDefs(def, {
              checks: [
                ...(def.checks ?? []),
                ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch),
              ],
            }));
          };
          inst.clone = (def, params) => clone(inst, def, params);
          inst.brand = () => inst;
          inst.register = ((reg, meta) => {
            reg.add(inst, meta);
            return inst;
          });
          // parsing
          inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });
          inst.safeParse = (data, params) => safeParse(inst, data, params);
          inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
          inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
          inst.spa = inst.safeParseAsync;
          // encoding/decoding
          inst.encode = (data, params) => encode(inst, data, params);
          inst.decode = (data, params) => decode(inst, data, params);
          inst.encodeAsync = async (data, params) => encodeAsync(inst, data, params);
          inst.decodeAsync = async (data, params) => decodeAsync(inst, data, params);
          inst.safeEncode = (data, params) => safeEncode(inst, data, params);
          inst.safeDecode = (data, params) => safeDecode(inst, data, params);
          inst.safeEncodeAsync = async (data, params) => safeEncodeAsync(inst, data, params);
          inst.safeDecodeAsync = async (data, params) => safeDecodeAsync(inst, data, params);
          // refinements
          inst.refine = (check, params) => inst.check(refine(check, params));
          inst.superRefine = (refinement) => inst.check(superRefine(refinement));
          inst.overwrite = (fn) => inst.check(_overwrite(fn));
          // wrappers
          inst.optional = () => optional(inst);
          inst.nullable = () => nullable(inst);
          inst.nullish = () => optional(nullable(inst));
          inst.nonoptional = (params) => nonoptional(inst, params);
          inst.array = () => array(inst);
          inst.or = (arg) => union([inst, arg]);
          inst.and = (arg) => intersection(inst, arg);
          inst.transform = (tx) => pipe(inst, transform(tx));
          inst.default = (def) => _default(inst, def);
          inst.prefault = (def) => prefault(inst, def);
          // inst.coalesce = (def, params) => coalesce(inst, def, params);
          inst.catch = (params) => _catch(inst, params);
          inst.pipe = (target) => pipe(inst, target);
          inst.readonly = () => readonly(inst);
          // meta
          inst.describe = (description) => {
            const cl = inst.clone();
            globalRegistry.add(cl, { description });
            return cl;
          };
          Object.defineProperty(inst, "description", {
            get() {
              return globalRegistry.get(inst)?.description;
            },
            configurable: true,
          });
          inst.meta = (...args) => {
            if (args.length === 0) {
              return globalRegistry.get(inst);
            }
            const cl = inst.clone();
            globalRegistry.add(cl, args[0]);
            return cl;
          };
          // helpers
          inst.isOptional = () => inst.safeParse(undefined).success;
          inst.isNullable = () => inst.safeParse(null).success;
          return inst;
        });
        /** @internal */
        const _ZodString = /*@__PURE__*/ $constructor("_ZodString", (inst, def) => {
          $ZodString.init(inst, def);
          ZodType.init(inst, def);
          const bag = inst._zod.bag;
          inst.format = bag.format ?? null;
          inst.minLength = bag.minimum ?? null;
          inst.maxLength = bag.maximum ?? null;
          // validations
          inst.regex = (...args) => inst.check(_regex(...args));
          inst.includes = (...args) => inst.check(_includes(...args));
          inst.startsWith = (...args) => inst.check(_startsWith(...args));
          inst.endsWith = (...args) => inst.check(_endsWith(...args));
          inst.min = (...args) => inst.check(_minLength(...args));
          inst.max = (...args) => inst.check(_maxLength(...args));
          inst.length = (...args) => inst.check(_length(...args));
          inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
          inst.lowercase = (params) => inst.check(_lowercase(params));
          inst.uppercase = (params) => inst.check(_uppercase(params));
          // transforms
          inst.trim = () => inst.check(_trim());
          inst.normalize = (...args) => inst.check(_normalize(...args));
          inst.toLowerCase = () => inst.check(_toLowerCase());
          inst.toUpperCase = () => inst.check(_toUpperCase());
        });
        const ZodString = /*@__PURE__*/ $constructor("ZodString", (inst, def) => {
          $ZodString.init(inst, def);
          _ZodString.init(inst, def);
          inst.email = (params) => inst.check(_email(ZodEmail, params));
          inst.url = (params) => inst.check(_url(ZodURL, params));
          inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
          inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
          inst.guid = (params) => inst.check(_guid(ZodGUID, params));
          inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
          inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
          inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
          inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
          inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
          inst.guid = (params) => inst.check(_guid(ZodGUID, params));
          inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
          inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
          inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
          inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
          inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
          inst.xid = (params) => inst.check(_xid(ZodXID, params));
          inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
          inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
          inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
          inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
          inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
          inst.e164 = (params) => inst.check(_e164(ZodE164, params));
          // iso
          inst.datetime = (params) => inst.check(datetime(params));
          inst.date = (params) => inst.check(date(params));
          inst.time = (params) => inst.check(time(params));
          inst.duration = (params) => inst.check(duration(params));
        });
        function string(params) {
          return _string(ZodString, params);
        }
        const ZodStringFormat = /*@__PURE__*/ $constructor("ZodStringFormat", (inst, def) => {
          $ZodStringFormat.init(inst, def);
          _ZodString.init(inst, def);
        });
        const ZodEmail = /*@__PURE__*/ $constructor("ZodEmail", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodEmail.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodGUID = /*@__PURE__*/ $constructor("ZodGUID", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodGUID.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodUUID = /*@__PURE__*/ $constructor("ZodUUID", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodUUID.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodURL = /*@__PURE__*/ $constructor("ZodURL", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodURL.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodEmoji = /*@__PURE__*/ $constructor("ZodEmoji", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodEmoji.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodNanoID = /*@__PURE__*/ $constructor("ZodNanoID", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodNanoID.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodCUID = /*@__PURE__*/ $constructor("ZodCUID", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodCUID.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodCUID2 = /*@__PURE__*/ $constructor("ZodCUID2", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodCUID2.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodULID = /*@__PURE__*/ $constructor("ZodULID", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodULID.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodXID = /*@__PURE__*/ $constructor("ZodXID", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodXID.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodKSUID = /*@__PURE__*/ $constructor("ZodKSUID", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodKSUID.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodIPv4 = /*@__PURE__*/ $constructor("ZodIPv4", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodIPv4.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodIPv6 = /*@__PURE__*/ $constructor("ZodIPv6", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodIPv6.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodCIDRv4 = /*@__PURE__*/ $constructor("ZodCIDRv4", (inst, def) => {
          $ZodCIDRv4.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodCIDRv6 = /*@__PURE__*/ $constructor("ZodCIDRv6", (inst, def) => {
          $ZodCIDRv6.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodBase64 = /*@__PURE__*/ $constructor("ZodBase64", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodBase64.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodBase64URL = /*@__PURE__*/ $constructor("ZodBase64URL", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodBase64URL.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodE164 = /*@__PURE__*/ $constructor("ZodE164", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodE164.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodJWT = /*@__PURE__*/ $constructor("ZodJWT", (inst, def) => {
          // ZodStringFormat.init(inst, def);
          $ZodJWT.init(inst, def);
          ZodStringFormat.init(inst, def);
        });
        const ZodNumber = /*@__PURE__*/ $constructor("ZodNumber", (inst, def) => {
          $ZodNumber.init(inst, def);
          ZodType.init(inst, def);
          inst.gt = (value, params) => inst.check(_gt(value, params));
          inst.gte = (value, params) => inst.check(_gte(value, params));
          inst.min = (value, params) => inst.check(_gte(value, params));
          inst.lt = (value, params) => inst.check(_lt(value, params));
          inst.lte = (value, params) => inst.check(_lte(value, params));
          inst.max = (value, params) => inst.check(_lte(value, params));
          inst.int = (params) => inst.check(int(params));
          inst.safe = (params) => inst.check(int(params));
          inst.positive = (params) => inst.check(_gt(0, params));
          inst.nonnegative = (params) => inst.check(_gte(0, params));
          inst.negative = (params) => inst.check(_lt(0, params));
          inst.nonpositive = (params) => inst.check(_lte(0, params));
          inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
          inst.step = (value, params) => inst.check(_multipleOf(value, params));
          // inst.finite = (params) => inst.check(core.finite(params));
          inst.finite = () => inst;
          const bag = inst._zod.bag;
          inst.minValue =
            Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
          inst.maxValue =
            Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
          inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
          inst.isFinite = true;
          inst.format = bag.format ?? null;
        });
        function number$1(params) {
          return _number(ZodNumber, params);
        }
        const ZodNumberFormat = /*@__PURE__*/ $constructor("ZodNumberFormat", (inst, def) => {
          $ZodNumberFormat.init(inst, def);
          ZodNumber.init(inst, def);
        });
        function int(params) {
          return _int(ZodNumberFormat, params);
        }
        const ZodBoolean = /*@__PURE__*/ $constructor("ZodBoolean", (inst, def) => {
          $ZodBoolean.init(inst, def);
          ZodType.init(inst, def);
        });
        function boolean(params) {
          return _boolean(ZodBoolean, params);
        }
        const ZodAny = /*@__PURE__*/ $constructor("ZodAny", (inst, def) => {
          $ZodAny.init(inst, def);
          ZodType.init(inst, def);
        });
        function any() {
          return _any(ZodAny);
        }
        const ZodUnknown = /*@__PURE__*/ $constructor("ZodUnknown", (inst, def) => {
          $ZodUnknown.init(inst, def);
          ZodType.init(inst, def);
        });
        function unknown() {
          return _unknown(ZodUnknown);
        }
        const ZodNever = /*@__PURE__*/ $constructor("ZodNever", (inst, def) => {
          $ZodNever.init(inst, def);
          ZodType.init(inst, def);
        });
        function never(params) {
          return _never(ZodNever, params);
        }
        const ZodArray = /*@__PURE__*/ $constructor("ZodArray", (inst, def) => {
          $ZodArray.init(inst, def);
          ZodType.init(inst, def);
          inst.element = def.element;
          inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
          inst.nonempty = (params) => inst.check(_minLength(1, params));
          inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
          inst.length = (len, params) => inst.check(_length(len, params));
          inst.unwrap = () => inst.element;
        });
        function array(element, params) {
          return _array(ZodArray, element, params);
        }
        const ZodObject = /*@__PURE__*/ $constructor("ZodObject", (inst, def) => {
          $ZodObjectJIT.init(inst, def);
          ZodType.init(inst, def);
          defineLazy(inst, "shape", () => {
            return def.shape;
          });
          inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
          inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall: catchall });
          inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
          inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
          inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
          inst.strip = () => inst.clone({ ...inst._zod.def, catchall: undefined });
          inst.extend = (incoming) => {
            return extend(inst, incoming);
          };
          inst.safeExtend = (incoming) => {
            return safeExtend(inst, incoming);
          };
          inst.merge = (other) => merge(inst, other);
          inst.pick = (mask) => pick(inst, mask);
          inst.omit = (mask) => omit(inst, mask);
          inst.partial = (...args) => partial(ZodOptional, inst, args[0]);
          inst.required = (...args) => required(ZodNonOptional, inst, args[0]);
        });
        function object(shape, params) {
          const def = {
            type: "object",
            shape: shape ?? {},
            ...normalizeParams(params),
          };
          return new ZodObject(def);
        }
        // looseObject
        function looseObject(shape, params) {
          return new ZodObject({
            type: "object",
            shape,
            catchall: unknown(),
            ...normalizeParams(params),
          });
        }
        const ZodUnion = /*@__PURE__*/ $constructor("ZodUnion", (inst, def) => {
          $ZodUnion.init(inst, def);
          ZodType.init(inst, def);
          inst.options = def.options;
        });
        function union(options, params) {
          return new ZodUnion({
            type: "union",
            options: options,
            ...normalizeParams(params),
          });
        }
        const ZodDiscriminatedUnion = /*@__PURE__*/ $constructor("ZodDiscriminatedUnion", (inst, def) => {
          ZodUnion.init(inst, def);
          $ZodDiscriminatedUnion.init(inst, def);
        });
        function discriminatedUnion(discriminator, options, params) {
          // const [options, params] = args;
          return new ZodDiscriminatedUnion({
            type: "union",
            options,
            discriminator,
            ...normalizeParams(params),
          });
        }
        const ZodIntersection = /*@__PURE__*/ $constructor("ZodIntersection", (inst, def) => {
          $ZodIntersection.init(inst, def);
          ZodType.init(inst, def);
        });
        function intersection(left, right) {
          return new ZodIntersection({
            type: "intersection",
            left: left,
            right: right,
          });
        }
        const ZodTuple = /*@__PURE__*/ $constructor("ZodTuple", (inst, def) => {
          $ZodTuple.init(inst, def);
          ZodType.init(inst, def);
          inst.rest = (rest) => inst.clone({
            ...inst._zod.def,
            rest: rest,
          });
        });
        function tuple(items, _paramsOrRest, _params) {
          const hasRest = _paramsOrRest instanceof $ZodType;
          const params = hasRest ? _params : _paramsOrRest;
          const rest = hasRest ? _paramsOrRest : null;
          return new ZodTuple({
            type: "tuple",
            items: items,
            rest,
            ...normalizeParams(params),
          });
        }
        const ZodRecord = /*@__PURE__*/ $constructor("ZodRecord", (inst, def) => {
          $ZodRecord.init(inst, def);
          ZodType.init(inst, def);
          inst.keyType = def.keyType;
          inst.valueType = def.valueType;
        });
        function record(keyType, valueType, params) {
          return new ZodRecord({
            type: "record",
            keyType,
            valueType: valueType,
            ...normalizeParams(params),
          });
        }
        const ZodEnum = /*@__PURE__*/ $constructor("ZodEnum", (inst, def) => {
          $ZodEnum.init(inst, def);
          ZodType.init(inst, def);
          inst.enum = def.entries;
          inst.options = Object.values(def.entries);
          const keys = new Set(Object.keys(def.entries));
          inst.extract = (values, params) => {
            const newEntries = {};
            for (const value of values) {
              if (keys.has(value)) {
                newEntries[value] = def.entries[value];
              }
              else
                throw new Error(`Key ${value} not found in enum`);
            }
            return new ZodEnum({
              ...def,
              checks: [],
              ...normalizeParams(params),
              entries: newEntries,
            });
          };
          inst.exclude = (values, params) => {
            const newEntries = { ...def.entries };
            for (const value of values) {
              if (keys.has(value)) {
                delete newEntries[value];
              }
              else
                throw new Error(`Key ${value} not found in enum`);
            }
            return new ZodEnum({
              ...def,
              checks: [],
              ...normalizeParams(params),
              entries: newEntries,
            });
          };
        });
        function _enum(values, params) {
          const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
          return new ZodEnum({
            type: "enum",
            entries,
            ...normalizeParams(params),
          });
        }
        const ZodLiteral = /*@__PURE__*/ $constructor("ZodLiteral", (inst, def) => {
          $ZodLiteral.init(inst, def);
          ZodType.init(inst, def);
          inst.values = new Set(def.values);
          Object.defineProperty(inst, "value", {
            get() {
              if (def.values.length > 1) {
                throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
              }
              return def.values[0];
            },
          });
        });
        function literal(value, params) {
          return new ZodLiteral({
            type: "literal",
            values: Array.isArray(value) ? value : [value],
            ...normalizeParams(params),
          });
        }
        const ZodTransform = /*@__PURE__*/ $constructor("ZodTransform", (inst, def) => {
          $ZodTransform.init(inst, def);
          ZodType.init(inst, def);
          inst._zod.parse = (payload, _ctx) => {
            if (_ctx.direction === "backward") {
              throw new $ZodEncodeError(inst.constructor.name);
            }
            payload.addIssue = (issue$1) => {
              if (typeof issue$1 === "string") {
                payload.issues.push(issue(issue$1, payload.value, def));
              }
              else {
                // for Zod 3 backwards compatibility
                const _issue = issue$1;
                if (_issue.fatal)
                  _issue.continue = false;
                _issue.code ?? (_issue.code = "custom");
                _issue.input ?? (_issue.input = payload.value);
                _issue.inst ?? (_issue.inst = inst);
                // _issue.continue ??= true;
                payload.issues.push(issue(_issue));
              }
            };
            const output = def.transform(payload.value, payload);
            if (output instanceof Promise) {
              return output.then((output) => {
                payload.value = output;
                return payload;
              });
            }
            payload.value = output;
            return payload;
          };
        });
        function transform(fn) {
          return new ZodTransform({
            type: "transform",
            transform: fn,
          });
        }
        const ZodOptional = /*@__PURE__*/ $constructor("ZodOptional", (inst, def) => {
          $ZodOptional.init(inst, def);
          ZodType.init(inst, def);
          inst.unwrap = () => inst._zod.def.innerType;
        });
        function optional(innerType) {
          return new ZodOptional({
            type: "optional",
            innerType: innerType,
          });
        }
        const ZodNullable = /*@__PURE__*/ $constructor("ZodNullable", (inst, def) => {
          $ZodNullable.init(inst, def);
          ZodType.init(inst, def);
          inst.unwrap = () => inst._zod.def.innerType;
        });
        function nullable(innerType) {
          return new ZodNullable({
            type: "nullable",
            innerType: innerType,
          });
        }
        const ZodDefault = /*@__PURE__*/ $constructor("ZodDefault", (inst, def) => {
          $ZodDefault.init(inst, def);
          ZodType.init(inst, def);
          inst.unwrap = () => inst._zod.def.innerType;
          inst.removeDefault = inst.unwrap;
        });
        function _default(innerType, defaultValue) {
          return new ZodDefault({
            type: "default",
            innerType: innerType,
            get defaultValue() {
              return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
            },
          });
        }
        const ZodPrefault = /*@__PURE__*/ $constructor("ZodPrefault", (inst, def) => {
          $ZodPrefault.init(inst, def);
          ZodType.init(inst, def);
          inst.unwrap = () => inst._zod.def.innerType;
        });
        function prefault(innerType, defaultValue) {
          return new ZodPrefault({
            type: "prefault",
            innerType: innerType,
            get defaultValue() {
              return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
            },
          });
        }
        const ZodNonOptional = /*@__PURE__*/ $constructor("ZodNonOptional", (inst, def) => {
          $ZodNonOptional.init(inst, def);
          ZodType.init(inst, def);
          inst.unwrap = () => inst._zod.def.innerType;
        });
        function nonoptional(innerType, params) {
          return new ZodNonOptional({
            type: "nonoptional",
            innerType: innerType,
            ...normalizeParams(params),
          });
        }
        const ZodCatch = /*@__PURE__*/ $constructor("ZodCatch", (inst, def) => {
          $ZodCatch.init(inst, def);
          ZodType.init(inst, def);
          inst.unwrap = () => inst._zod.def.innerType;
          inst.removeCatch = inst.unwrap;
        });
        function _catch(innerType, catchValue) {
          return new ZodCatch({
            type: "catch",
            innerType: innerType,
            catchValue: (typeof catchValue === "function" ? catchValue : () => catchValue),
          });
        }
        const ZodPipe = /*@__PURE__*/ $constructor("ZodPipe", (inst, def) => {
          $ZodPipe.init(inst, def);
          ZodType.init(inst, def);
          inst.in = def.in;
          inst.out = def.out;
        });
        function pipe(in_, out) {
          return new ZodPipe({
            type: "pipe",
            in: in_,
            out: out,
            // ...util.normalizeParams(params),
          });
        }
        const ZodReadonly = /*@__PURE__*/ $constructor("ZodReadonly", (inst, def) => {
          $ZodReadonly.init(inst, def);
          ZodType.init(inst, def);
          inst.unwrap = () => inst._zod.def.innerType;
        });
        function readonly(innerType) {
          return new ZodReadonly({
            type: "readonly",
            innerType: innerType,
          });
        }
        const ZodLazy = /*@__PURE__*/ $constructor("ZodLazy", (inst, def) => {
          $ZodLazy.init(inst, def);
          ZodType.init(inst, def);
          inst.unwrap = () => inst._zod.def.getter();
        });
        function lazy(getter) {
          return new ZodLazy({
            type: "lazy",
            getter: getter,
          });
        }
        const ZodCustom = /*@__PURE__*/ $constructor("ZodCustom", (inst, def) => {
          $ZodCustom.init(inst, def);
          ZodType.init(inst, def);
        });
        function refine(fn, _params = {}) {
          return _refine(ZodCustom, fn, _params);
        }
        // superRefine
        function superRefine(fn) {
          return _superRefine(fn);
        }

        function number(params) {
          return _coercedNumber(ZodNumber, params);
        }

        var util;
        (function (util) {
          util.assertEqual = (_) => { };
          function assertIs(_arg) { }
          util.assertIs = assertIs;
          function assertNever(_x) {
            throw new Error();
          }
          util.assertNever = assertNever;
          util.arrayToEnum = (items) => {
            const obj = {};
            for (const item of items) {
              obj[item] = item;
            }
            return obj;
          };
          util.getValidEnumValues = (obj) => {
            const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
            const filtered = {};
            for (const k of validKeys) {
              filtered[k] = obj[k];
            }
            return util.objectValues(filtered);
          };
          util.objectValues = (obj) => {
            return util.objectKeys(obj).map(function (e) {
              return obj[e];
            });
          };
          util.objectKeys = typeof Object.keys === "function" // eslint-disable-line ban/ban
            ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban
            : (object) => {
              const keys = [];
              for (const key in object) {
                if (Object.prototype.hasOwnProperty.call(object, key)) {
                  keys.push(key);
                }
              }
              return keys;
            };
          util.find = (arr, checker) => {
            for (const item of arr) {
              if (checker(item))
                return item;
            }
            return undefined;
          };
          util.isInteger = typeof Number.isInteger === "function"
            ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban
            : (val) => typeof val === "number" && Number.isFinite(val) && Math.floor(val) === val;
          function joinValues(array, separator = " | ") {
            return array.map((val) => (typeof val === "string" ? `'${val}'` : val)).join(separator);
          }
          util.joinValues = joinValues;
          util.jsonStringifyReplacer = (_, value) => {
            if (typeof value === "bigint") {
              return value.toString();
            }
            return value;
          };
        })(util || (util = {}));
        var objectUtil;
        (function (objectUtil) {
          objectUtil.mergeShapes = (first, second) => {
            return {
              ...first,
              ...second, // second overwrites first
            };
          };
        })(objectUtil || (objectUtil = {}));
        util.arrayToEnum([
          "string",
          "nan",
          "number",
          "integer",
          "float",
          "boolean",
          "date",
          "bigint",
          "symbol",
          "function",
          "undefined",
          "null",
          "array",
          "object",
          "unknown",
          "promise",
          "void",
          "never",
          "map",
          "set",
        ]);

        util.arrayToEnum([
          "invalid_type",
          "invalid_literal",
          "custom",
          "invalid_union",
          "invalid_union_discriminator",
          "invalid_enum_value",
          "unrecognized_keys",
          "invalid_arguments",
          "invalid_return_type",
          "invalid_date",
          "invalid_string",
          "too_small",
          "too_big",
          "invalid_intersection_types",
          "not_multiple_of",
          "not_finite",
        ]);
        class ZodError extends Error {
          get errors() {
            return this.issues;
          }
          constructor(issues) {
            super();
            this.issues = [];
            this.addIssue = (sub) => {
              this.issues = [...this.issues, sub];
            };
            this.addIssues = (subs = []) => {
              this.issues = [...this.issues, ...subs];
            };
            const actualProto = new.target.prototype;
            if (Object.setPrototypeOf) {
              // eslint-disable-next-line ban/ban
              Object.setPrototypeOf(this, actualProto);
            }
            else {
              this.__proto__ = actualProto;
            }
            this.name = "ZodError";
            this.issues = issues;
          }
          format(_mapper) {
            const mapper = _mapper ||
              function (issue) {
                return issue.message;
              };
            const fieldErrors = { _errors: [] };
            const processError = (error) => {
              for (const issue of error.issues) {
                if (issue.code === "invalid_union") {
                  issue.unionErrors.map(processError);
                }
                else if (issue.code === "invalid_return_type") {
                  processError(issue.returnTypeError);
                }
                else if (issue.code === "invalid_arguments") {
                  processError(issue.argumentsError);
                }
                else if (issue.path.length === 0) {
                  fieldErrors._errors.push(mapper(issue));
                }
                else {
                  let curr = fieldErrors;
                  let i = 0;
                  while (i < issue.path.length) {
                    const el = issue.path[i];
                    const terminal = i === issue.path.length - 1;
                    if (!terminal) {
                      curr[el] = curr[el] || { _errors: [] };
                      // if (typeof el === "string") {
                      //   curr[el] = curr[el] || { _errors: [] };
                      // } else if (typeof el === "number") {
                      //   const errorArray: any = [];
                      //   errorArray._errors = [];
                      //   curr[el] = curr[el] || errorArray;
                      // }
                    }
                    else {
                      curr[el] = curr[el] || { _errors: [] };
                      curr[el]._errors.push(mapper(issue));
                    }
                    curr = curr[el];
                    i++;
                  }
                }
              }
            };
            processError(this);
            return fieldErrors;
          }
          static assert(value) {
            if (!(value instanceof ZodError)) {
              throw new Error(`Not a ZodError: ${value}`);
            }
          }
          toString() {
            return this.message;
          }
          get message() {
            return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
          }
          get isEmpty() {
            return this.issues.length === 0;
          }
          flatten(mapper = (issue) => issue.message) {
            const fieldErrors = Object.create(null);
            const formErrors = [];
            for (const sub of this.issues) {
              if (sub.path.length > 0) {
                const firstEl = sub.path[0];
                fieldErrors[firstEl] = fieldErrors[firstEl] || [];
                fieldErrors[firstEl].push(mapper(sub));
              }
              else {
                formErrors.push(mapper(sub));
              }
            }
            return { formErrors, fieldErrors };
          }
          get formErrors() {
            return this.flatten();
          }
        }
        ZodError.create = (issues) => {
          const error = new ZodError(issues);
          return error;
        };

        var errorUtil;
        (function (errorUtil) {
          errorUtil.errToObj = (message) => typeof message === "string" ? { message } : message || {};
          // biome-ignore lint:
          errorUtil.toString = (message) => typeof message === "string" ? message : message?.message;
        })(errorUtil || (errorUtil = {}));

        var ZodFirstPartyTypeKind;
        (function (ZodFirstPartyTypeKind) {
          ZodFirstPartyTypeKind["ZodString"] = "ZodString";
          ZodFirstPartyTypeKind["ZodNumber"] = "ZodNumber";
          ZodFirstPartyTypeKind["ZodNaN"] = "ZodNaN";
          ZodFirstPartyTypeKind["ZodBigInt"] = "ZodBigInt";
          ZodFirstPartyTypeKind["ZodBoolean"] = "ZodBoolean";
          ZodFirstPartyTypeKind["ZodDate"] = "ZodDate";
          ZodFirstPartyTypeKind["ZodSymbol"] = "ZodSymbol";
          ZodFirstPartyTypeKind["ZodUndefined"] = "ZodUndefined";
          ZodFirstPartyTypeKind["ZodNull"] = "ZodNull";
          ZodFirstPartyTypeKind["ZodAny"] = "ZodAny";
          ZodFirstPartyTypeKind["ZodUnknown"] = "ZodUnknown";
          ZodFirstPartyTypeKind["ZodNever"] = "ZodNever";
          ZodFirstPartyTypeKind["ZodVoid"] = "ZodVoid";
          ZodFirstPartyTypeKind["ZodArray"] = "ZodArray";
          ZodFirstPartyTypeKind["ZodObject"] = "ZodObject";
          ZodFirstPartyTypeKind["ZodUnion"] = "ZodUnion";
          ZodFirstPartyTypeKind["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
          ZodFirstPartyTypeKind["ZodIntersection"] = "ZodIntersection";
          ZodFirstPartyTypeKind["ZodTuple"] = "ZodTuple";
          ZodFirstPartyTypeKind["ZodRecord"] = "ZodRecord";
          ZodFirstPartyTypeKind["ZodMap"] = "ZodMap";
          ZodFirstPartyTypeKind["ZodSet"] = "ZodSet";
          ZodFirstPartyTypeKind["ZodFunction"] = "ZodFunction";
          ZodFirstPartyTypeKind["ZodLazy"] = "ZodLazy";
          ZodFirstPartyTypeKind["ZodLiteral"] = "ZodLiteral";
          ZodFirstPartyTypeKind["ZodEnum"] = "ZodEnum";
          ZodFirstPartyTypeKind["ZodEffects"] = "ZodEffects";
          ZodFirstPartyTypeKind["ZodNativeEnum"] = "ZodNativeEnum";
          ZodFirstPartyTypeKind["ZodOptional"] = "ZodOptional";
          ZodFirstPartyTypeKind["ZodNullable"] = "ZodNullable";
          ZodFirstPartyTypeKind["ZodDefault"] = "ZodDefault";
          ZodFirstPartyTypeKind["ZodCatch"] = "ZodCatch";
          ZodFirstPartyTypeKind["ZodPromise"] = "ZodPromise";
          ZodFirstPartyTypeKind["ZodBranded"] = "ZodBranded";
          ZodFirstPartyTypeKind["ZodPipeline"] = "ZodPipeline";
          ZodFirstPartyTypeKind["ZodReadonly"] = "ZodReadonly";
        })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

        // src/combine-headers.ts
        function combineHeaders$1(...headers) {
          return headers.reduce(
            (combinedHeaders, currentHeaders) => ({
              ...combinedHeaders,
              ...currentHeaders != null ? currentHeaders : {}
            }),
            {}
          );
        }

        // src/extract-response-headers.ts
        function extractResponseHeaders$1(response) {
          return Object.fromEntries([...response.headers]);
        }
        var createIdGenerator$1 = ({
          prefix,
          size = 16,
          alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
          separator = "-"
        } = {}) => {
          const generator = () => {
            const alphabetLength = alphabet.length;
            const chars = new Array(size);
            for (let i = 0; i < size; i++) {
              chars[i] = alphabet[Math.random() * alphabetLength | 0];
            }
            return chars.join("");
          };
          if (prefix == null) {
            return generator;
          }
          if (alphabet.includes(separator)) {
            throw new InvalidArgumentError$1({
              argument: "separator",
              message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
            });
          }
          return () => `${prefix}${separator}${generator()}`;
        };
        var generateId$1 = createIdGenerator$1();

        // src/is-abort-error.ts
        function isAbortError$1(error) {
          return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
            error.name === "TimeoutError");
        }

        // src/handle-fetch-error.ts
        var FETCH_FAILED_ERROR_MESSAGES$1 = ["fetch failed", "failed to fetch"];
        function handleFetchError$1({
          error,
          url,
          requestBodyValues
        }) {
          if (isAbortError$1(error)) {
            return error;
          }
          if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES$1.includes(error.message.toLowerCase())) {
            const cause = error.cause;
            if (cause != null) {
              return new APICallError$1({
                message: `Cannot connect to API: ${cause.message}`,
                cause,
                url,
                requestBodyValues,
                isRetryable: true
                // retry when network error
              });
            }
          }
          return error;
        }

        // src/get-runtime-environment-user-agent.ts
        function getRuntimeEnvironmentUserAgent(globalThisAny = globalThis) {
          var _a, _b, _c;
          if (globalThisAny.window) {
            return `runtime/browser`;
          }
          if ((_a = globalThisAny.navigator) == null ? void 0 : _a.userAgent) {
            return `runtime/${globalThisAny.navigator.userAgent.toLowerCase()}`;
          }
          if ((_c = (_b = globalThisAny.process) == null ? void 0 : _b.versions) == null ? void 0 : _c.node) {
            return `runtime/node.js/${globalThisAny.process.version.substring(0)}`;
          }
          if (globalThisAny.EdgeRuntime) {
            return `runtime/vercel-edge`;
          }
          return "runtime/unknown";
        }

        // src/remove-undefined-entries.ts
        function removeUndefinedEntries$1(record) {
          return Object.fromEntries(
            Object.entries(record).filter(([_key, value]) => value != null)
          );
        }

        // src/with-user-agent-suffix.ts
        function withUserAgentSuffix(headers, ...userAgentSuffixParts) {
          const cleanedHeaders = removeUndefinedEntries$1(
            headers != null ? headers : {}
          );
          const normalizedHeaders = new Headers(cleanedHeaders);
          const currentUserAgentHeader = normalizedHeaders.get("user-agent") || "";
          normalizedHeaders.set(
            "user-agent",
            [currentUserAgentHeader, ...userAgentSuffixParts].filter(Boolean).join(" ")
          );
          return Object.fromEntries(normalizedHeaders);
        }

        // src/version.ts
        var VERSION$5 = "3.0.12";
        function loadApiKey$1({
          apiKey,
          environmentVariableName,
          apiKeyParameterName = "apiKey",
          description
        }) {
          if (typeof apiKey === "string") {
            return apiKey;
          }
          if (apiKey != null) {
            throw new LoadAPIKeyError$1({
              message: `${description} API key must be a string.`
            });
          }
          if (typeof process === "undefined") {
            throw new LoadAPIKeyError$1({
              message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
            });
          }
          apiKey = process.env[environmentVariableName];
          if (apiKey == null) {
            throw new LoadAPIKeyError$1({
              message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
            });
          }
          if (typeof apiKey !== "string") {
            throw new LoadAPIKeyError$1({
              message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
            });
          }
          return apiKey;
        }

        // src/load-optional-setting.ts
        function loadOptionalSetting({
          settingValue,
          environmentVariableName
        }) {
          if (typeof settingValue === "string") {
            return settingValue;
          }
          if (settingValue != null || typeof process === "undefined") {
            return void 0;
          }
          settingValue = process.env[environmentVariableName];
          if (settingValue == null || typeof settingValue !== "string") {
            return void 0;
          }
          return settingValue;
        }
        function loadSetting({
          settingValue,
          environmentVariableName,
          settingName,
          description
        }) {
          if (typeof settingValue === "string") {
            return settingValue;
          }
          if (settingValue != null) {
            throw new LoadSettingError({
              message: `${description} setting must be a string.`
            });
          }
          if (typeof process === "undefined") {
            throw new LoadSettingError({
              message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`
            });
          }
          settingValue = process.env[environmentVariableName];
          if (settingValue == null) {
            throw new LoadSettingError({
              message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`
            });
          }
          if (typeof settingValue !== "string") {
            throw new LoadSettingError({
              message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
            });
          }
          return settingValue;
        }

        // src/media-type-to-extension.ts
        function mediaTypeToExtension(mediaType) {
          var _a;
          const [_type, subtype = ""] = mediaType.toLowerCase().split("/");
          return (_a = {
            mpeg: "mp3",
            "x-wav": "wav",
            opus: "ogg",
            mp4: "m4a",
            "x-m4a": "m4a"
          }[subtype]) != null ? _a : subtype;
        }

        // src/secure-json-parse.ts
        var suspectProtoRx$1 = /"__proto__"\s*:/;
        var suspectConstructorRx$1 = /"constructor"\s*:/;
        function _parse$1(text) {
          const obj = JSON.parse(text);
          if (obj === null || typeof obj !== "object") {
            return obj;
          }
          if (suspectProtoRx$1.test(text) === false && suspectConstructorRx$1.test(text) === false) {
            return obj;
          }
          return filter$1(obj);
        }
        function filter$1(obj) {
          let next = [obj];
          while (next.length) {
            const nodes = next;
            next = [];
            for (const node of nodes) {
              if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
                throw new SyntaxError("Object contains forbidden prototype property");
              }
              if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
                throw new SyntaxError("Object contains forbidden prototype property");
              }
              for (const key in node) {
                const value = node[key];
                if (value && typeof value === "object") {
                  next.push(value);
                }
              }
            }
          }
          return obj;
        }
        function secureJsonParse$1(text) {
          const { stackTraceLimit } = Error;
          Error.stackTraceLimit = 0;
          try {
            return _parse$1(text);
          } finally {
            Error.stackTraceLimit = stackTraceLimit;
          }
        }
        var validatorSymbol$1 = Symbol.for("vercel.ai.validator");
        function validator$1(validate) {
          return { [validatorSymbol$1]: true, validate };
        }
        function isValidator$1(value) {
          return typeof value === "object" && value !== null && validatorSymbol$1 in value && value[validatorSymbol$1] === true && "validate" in value;
        }
        function lazyValidator(createValidator) {
          let validator2;
          return () => {
            if (validator2 == null) {
              validator2 = createValidator();
            }
            return validator2;
          };
        }
        function asValidator$1(value) {
          return isValidator$1(value) ? value : typeof value === "function" ? value() : standardSchemaValidator$1(value);
        }
        function standardSchemaValidator$1(standardSchema) {
          return validator$1(async (value) => {
            const result = await standardSchema["~standard"].validate(value);
            return result.issues == null ? { success: true, value: result.value } : {
              success: false,
              error: new TypeValidationError$1({
                value,
                cause: result.issues
              })
            };
          });
        }

        // src/validate-types.ts
        async function validateTypes$1({
          value,
          schema
        }) {
          const result = await safeValidateTypes$1({ value, schema });
          if (!result.success) {
            throw TypeValidationError$1.wrap({ value, cause: result.error });
          }
          return result.value;
        }
        async function safeValidateTypes$1({
          value,
          schema
        }) {
          const validator2 = asValidator$1(schema);
          try {
            if (validator2.validate == null) {
              return { success: true, value, rawValue: value };
            }
            const result = await validator2.validate(value);
            if (result.success) {
              return { success: true, value: result.value, rawValue: value };
            }
            return {
              success: false,
              error: TypeValidationError$1.wrap({ value, cause: result.error }),
              rawValue: value
            };
          } catch (error) {
            return {
              success: false,
              error: TypeValidationError$1.wrap({ value, cause: error }),
              rawValue: value
            };
          }
        }

        // src/parse-json.ts
        async function parseJSON$1({
          text,
          schema
        }) {
          try {
            const value = secureJsonParse$1(text);
            if (schema == null) {
              return value;
            }
            return validateTypes$1({ value, schema });
          } catch (error) {
            if (JSONParseError$1.isInstance(error) || TypeValidationError$1.isInstance(error)) {
              throw error;
            }
            throw new JSONParseError$1({ text, cause: error });
          }
        }
        async function safeParseJSON$1({
          text,
          schema
        }) {
          try {
            const value = secureJsonParse$1(text);
            if (schema == null) {
              return { success: true, value, rawValue: value };
            }
            return await safeValidateTypes$1({ value, schema });
          } catch (error) {
            return {
              success: false,
              error: JSONParseError$1.isInstance(error) ? error : new JSONParseError$1({ text, cause: error }),
              rawValue: void 0
            };
          }
        }
        function isParsableJson$1(input) {
          try {
            secureJsonParse$1(input);
            return true;
          } catch (e) {
            return false;
          }
        }
        function parseJsonEventStream$1({
          stream,
          schema
        }) {
          return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream$1()).pipeThrough(
            new TransformStream({
              async transform({ data }, controller) {
                if (data === "[DONE]") {
                  return;
                }
                controller.enqueue(await safeParseJSON$1({ text: data, schema }));
              }
            })
          );
        }
        async function parseProviderOptions({
          provider,
          providerOptions,
          schema
        }) {
          if ((providerOptions == null ? void 0 : providerOptions[provider]) == null) {
            return void 0;
          }
          const parsedProviderOptions = await safeValidateTypes$1({
            value: providerOptions[provider],
            schema
          });
          if (!parsedProviderOptions.success) {
            throw new InvalidArgumentError$1({
              argument: "providerOptions",
              message: `invalid ${provider} provider options`,
              cause: parsedProviderOptions.error
            });
          }
          return parsedProviderOptions.value;
        }
        var getOriginalFetch2$1 = () => globalThis.fetch;
        var postJsonToApi$1 = async ({
          url,
          headers,
          body,
          failedResponseHandler,
          successfulResponseHandler,
          abortSignal,
          fetch
        }) => postToApi$1({
          url,
          headers: {
            "Content-Type": "application/json",
            ...headers
          },
          body: {
            content: JSON.stringify(body),
            values: body
          },
          failedResponseHandler,
          successfulResponseHandler,
          abortSignal,
          fetch
        });
        var postFormDataToApi = async ({
          url,
          headers,
          formData,
          failedResponseHandler,
          successfulResponseHandler,
          abortSignal,
          fetch
        }) => postToApi$1({
          url,
          headers,
          body: {
            content: formData,
            values: Object.fromEntries(formData.entries())
          },
          failedResponseHandler,
          successfulResponseHandler,
          abortSignal,
          fetch
        });
        var postToApi$1 = async ({
          url,
          headers = {},
          body,
          successfulResponseHandler,
          failedResponseHandler,
          abortSignal,
          fetch = getOriginalFetch2$1()
        }) => {
          try {
            const response = await fetch(url, {
              method: "POST",
              headers: withUserAgentSuffix(
                headers,
                `ai-sdk/provider-utils/${VERSION$5}`,
                getRuntimeEnvironmentUserAgent()
              ),
              body: body.content,
              signal: abortSignal
            });
            const responseHeaders = extractResponseHeaders$1(response);
            if (!response.ok) {
              let errorInformation;
              try {
                errorInformation = await failedResponseHandler({
                  response,
                  url,
                  requestBodyValues: body.values
                });
              } catch (error) {
                if (isAbortError$1(error) || APICallError$1.isInstance(error)) {
                  throw error;
                }
                throw new APICallError$1({
                  message: "Failed to process error response",
                  cause: error,
                  statusCode: response.status,
                  url,
                  responseHeaders,
                  requestBodyValues: body.values
                });
              }
              throw errorInformation.value;
            }
            try {
              return await successfulResponseHandler({
                response,
                url,
                requestBodyValues: body.values
              });
            } catch (error) {
              if (error instanceof Error) {
                if (isAbortError$1(error) || APICallError$1.isInstance(error)) {
                  throw error;
                }
              }
              throw new APICallError$1({
                message: "Failed to process successful response",
                cause: error,
                statusCode: response.status,
                url,
                responseHeaders,
                requestBodyValues: body.values
              });
            }
          } catch (error) {
            throw handleFetchError$1({ error, url, requestBodyValues: body.values });
          }
        };

        // src/types/tool.ts
        function tool(tool2) {
          return tool2;
        }

        // src/provider-defined-tool-factory.ts
        function createProviderDefinedToolFactory({
          id,
          name,
          inputSchema
        }) {
          return ({
            execute,
            outputSchema,
            toModelOutput,
            onInputStart,
            onInputDelta,
            onInputAvailable,
            ...args
          }) => tool({
            type: "provider-defined",
            id,
            name,
            args,
            inputSchema,
            outputSchema,
            execute,
            toModelOutput,
            onInputStart,
            onInputDelta,
            onInputAvailable
          });
        }
        function createProviderDefinedToolFactoryWithOutputSchema({
          id,
          name,
          inputSchema,
          outputSchema
        }) {
          return ({
            execute,
            toModelOutput,
            onInputStart,
            onInputDelta,
            onInputAvailable,
            ...args
          }) => tool({
            type: "provider-defined",
            id,
            name,
            args,
            inputSchema,
            outputSchema,
            execute,
            toModelOutput,
            onInputStart,
            onInputDelta,
            onInputAvailable
          });
        }

        // src/resolve.ts
        async function resolve(value) {
          if (typeof value === "function") {
            value = value();
          }
          return Promise.resolve(value);
        }
        var createJsonErrorResponseHandler$1 = ({
          errorSchema,
          errorToMessage,
          isRetryable
        }) => async ({ response, url, requestBodyValues }) => {
          const responseBody = await response.text();
          const responseHeaders = extractResponseHeaders$1(response);
          if (responseBody.trim() === "") {
            return {
              responseHeaders,
              value: new APICallError$1({
                message: response.statusText,
                url,
                requestBodyValues,
                statusCode: response.status,
                responseHeaders,
                responseBody,
                isRetryable: isRetryable == null ? void 0 : isRetryable(response)
              })
            };
          }
          try {
            const parsedError = await parseJSON$1({
              text: responseBody,
              schema: errorSchema
            });
            return {
              responseHeaders,
              value: new APICallError$1({
                message: errorToMessage(parsedError),
                url,
                requestBodyValues,
                statusCode: response.status,
                responseHeaders,
                responseBody,
                data: parsedError,
                isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
              })
            };
          } catch (parseError) {
            return {
              responseHeaders,
              value: new APICallError$1({
                message: response.statusText,
                url,
                requestBodyValues,
                statusCode: response.status,
                responseHeaders,
                responseBody,
                isRetryable: isRetryable == null ? void 0 : isRetryable(response)
              })
            };
          }
        };
        var createEventSourceResponseHandler$1 = (chunkSchema) => async ({ response }) => {
          const responseHeaders = extractResponseHeaders$1(response);
          if (response.body == null) {
            throw new EmptyResponseBodyError$1({});
          }
          return {
            responseHeaders,
            value: parseJsonEventStream$1({
              stream: response.body,
              schema: chunkSchema
            })
          };
        };
        var createJsonResponseHandler$1 = (responseSchema) => async ({ response, url, requestBodyValues }) => {
          const responseBody = await response.text();
          const parsedResult = await safeParseJSON$1({
            text: responseBody,
            schema: responseSchema
          });
          const responseHeaders = extractResponseHeaders$1(response);
          if (!parsedResult.success) {
            throw new APICallError$1({
              message: "Invalid JSON response",
              cause: parsedResult.error,
              statusCode: response.status,
              responseHeaders,
              responseBody,
              url,
              requestBodyValues
            });
          }
          return {
            responseHeaders,
            value: parsedResult.value,
            rawValue: parsedResult.rawValue
          };
        };
        var createBinaryResponseHandler = () => async ({ response, url, requestBodyValues }) => {
          const responseHeaders = extractResponseHeaders$1(response);
          if (!response.body) {
            throw new APICallError$1({
              message: "Response body is empty",
              url,
              requestBodyValues,
              statusCode: response.status,
              responseHeaders,
              responseBody: void 0
            });
          }
          try {
            const buffer = await response.arrayBuffer();
            return {
              responseHeaders,
              value: new Uint8Array(buffer)
            };
          } catch (error) {
            throw new APICallError$1({
              message: "Failed to read response as array buffer",
              url,
              requestBodyValues,
              statusCode: response.status,
              responseHeaders,
              responseBody: void 0,
              cause: error
            });
          }
        };

        // src/zod-to-json-schema/get-relative-path.ts
        var getRelativePath = (pathA, pathB) => {
          let i = 0;
          for (; i < pathA.length && i < pathB.length; i++) {
            if (pathA[i] !== pathB[i]) break;
          }
          return [(pathA.length - i).toString(), ...pathB.slice(i)].join("/");
        };

        // src/zod-to-json-schema/options.ts
        var ignoreOverride = Symbol(
          "Let zodToJsonSchema decide on which parser to use"
        );
        var defaultOptions = {
          name: void 0,
          $refStrategy: "root",
          basePath: ["#"],
          effectStrategy: "input",
          pipeStrategy: "all",
          dateStrategy: "format:date-time",
          mapStrategy: "entries",
          removeAdditionalStrategy: "passthrough",
          allowedAdditionalProperties: true,
          rejectedAdditionalProperties: false,
          definitionPath: "definitions",
          strictUnions: false,
          definitions: {},
          errorMessages: false,
          patternStrategy: "escape",
          applyRegexFlags: false,
          emailStrategy: "format:email",
          base64Strategy: "contentEncoding:base64",
          nameStrategy: "ref"
        };
        var getDefaultOptions = (options) => typeof options === "string" ? {
          ...defaultOptions,
          name: options
        } : {
          ...defaultOptions,
          ...options
        };

        // src/zod-to-json-schema/parsers/any.ts
        function parseAnyDef() {
          return {};
        }
        function parseArrayDef(def, refs) {
          var _a, _b, _c;
          const res = {
            type: "array"
          };
          if (((_a = def.type) == null ? void 0 : _a._def) && ((_c = (_b = def.type) == null ? void 0 : _b._def) == null ? void 0 : _c.typeName) !== ZodFirstPartyTypeKind.ZodAny) {
            res.items = parseDef(def.type._def, {
              ...refs,
              currentPath: [...refs.currentPath, "items"]
            });
          }
          if (def.minLength) {
            res.minItems = def.minLength.value;
          }
          if (def.maxLength) {
            res.maxItems = def.maxLength.value;
          }
          if (def.exactLength) {
            res.minItems = def.exactLength.value;
            res.maxItems = def.exactLength.value;
          }
          return res;
        }

        // src/zod-to-json-schema/parsers/bigint.ts
        function parseBigintDef(def) {
          const res = {
            type: "integer",
            format: "int64"
          };
          if (!def.checks) return res;
          for (const check of def.checks) {
            switch (check.kind) {
              case "min":
                if (check.inclusive) {
                  res.minimum = check.value;
                } else {
                  res.exclusiveMinimum = check.value;
                }
                break;
              case "max":
                if (check.inclusive) {
                  res.maximum = check.value;
                } else {
                  res.exclusiveMaximum = check.value;
                }
                break;
              case "multipleOf":
                res.multipleOf = check.value;
                break;
            }
          }
          return res;
        }

        // src/zod-to-json-schema/parsers/boolean.ts
        function parseBooleanDef() {
          return { type: "boolean" };
        }

        // src/zod-to-json-schema/parsers/branded.ts
        function parseBrandedDef(_def, refs) {
          return parseDef(_def.type._def, refs);
        }

        // src/zod-to-json-schema/parsers/catch.ts
        var parseCatchDef = (def, refs) => {
          return parseDef(def.innerType._def, refs);
        };

        // src/zod-to-json-schema/parsers/date.ts
        function parseDateDef(def, refs, overrideDateStrategy) {
          const strategy = overrideDateStrategy != null ? overrideDateStrategy : refs.dateStrategy;
          if (Array.isArray(strategy)) {
            return {
              anyOf: strategy.map((item, i) => parseDateDef(def, refs, item))
            };
          }
          switch (strategy) {
            case "string":
            case "format:date-time":
              return {
                type: "string",
                format: "date-time"
              };
            case "format:date":
              return {
                type: "string",
                format: "date"
              };
            case "integer":
              return integerDateParser(def);
          }
        }
        var integerDateParser = (def) => {
          const res = {
            type: "integer",
            format: "unix-time"
          };
          for (const check of def.checks) {
            switch (check.kind) {
              case "min":
                res.minimum = check.value;
                break;
              case "max":
                res.maximum = check.value;
                break;
            }
          }
          return res;
        };

        // src/zod-to-json-schema/parsers/default.ts
        function parseDefaultDef(_def, refs) {
          return {
            ...parseDef(_def.innerType._def, refs),
            default: _def.defaultValue()
          };
        }

        // src/zod-to-json-schema/parsers/effects.ts
        function parseEffectsDef(_def, refs) {
          return refs.effectStrategy === "input" ? parseDef(_def.schema._def, refs) : parseAnyDef();
        }

        // src/zod-to-json-schema/parsers/enum.ts
        function parseEnumDef(def) {
          return {
            type: "string",
            enum: Array.from(def.values)
          };
        }

        // src/zod-to-json-schema/parsers/intersection.ts
        var isJsonSchema7AllOfType = (type) => {
          if ("type" in type && type.type === "string") return false;
          return "allOf" in type;
        };
        function parseIntersectionDef(def, refs) {
          const allOf = [
            parseDef(def.left._def, {
              ...refs,
              currentPath: [...refs.currentPath, "allOf", "0"]
            }),
            parseDef(def.right._def, {
              ...refs,
              currentPath: [...refs.currentPath, "allOf", "1"]
            })
          ].filter((x) => !!x);
          const mergedAllOf = [];
          allOf.forEach((schema) => {
            if (isJsonSchema7AllOfType(schema)) {
              mergedAllOf.push(...schema.allOf);
            } else {
              let nestedSchema = schema;
              if ("additionalProperties" in schema && schema.additionalProperties === false) {
                const { additionalProperties, ...rest } = schema;
                nestedSchema = rest;
              }
              mergedAllOf.push(nestedSchema);
            }
          });
          return mergedAllOf.length ? { allOf: mergedAllOf } : void 0;
        }

        // src/zod-to-json-schema/parsers/literal.ts
        function parseLiteralDef(def) {
          const parsedType = typeof def.value;
          if (parsedType !== "bigint" && parsedType !== "number" && parsedType !== "boolean" && parsedType !== "string") {
            return {
              type: Array.isArray(def.value) ? "array" : "object"
            };
          }
          return {
            type: parsedType === "bigint" ? "integer" : parsedType,
            const: def.value
          };
        }

        // src/zod-to-json-schema/parsers/string.ts
        var emojiRegex = void 0;
        var zodPatterns = {
          /**
           * `c` was changed to `[cC]` to replicate /i flag
           */
          cuid: /^[cC][^\s-]{8,}$/,
          cuid2: /^[0-9a-z]+$/,
          ulid: /^[0-9A-HJKMNP-TV-Z]{26}$/,
          /**
           * `a-z` was added to replicate /i flag
           */
          email: /^(?!\.)(?!.*\.\.)([a-zA-Z0-9_'+\-\.]*)[a-zA-Z0-9_+-]@([a-zA-Z0-9][a-zA-Z0-9\-]*\.)+[a-zA-Z]{2,}$/,
          /**
           * Constructed a valid Unicode RegExp
           *
           * Lazily instantiate since this type of regex isn't supported
           * in all envs (e.g. React Native).
           *
           * See:
           * https://github.com/colinhacks/zod/issues/2433
           * Fix in Zod:
           * https://github.com/colinhacks/zod/commit/9340fd51e48576a75adc919bff65dbc4a5d4c99b
           */
          emoji: () => {
            if (emojiRegex === void 0) {
              emojiRegex = RegExp(
                "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$",
                "u"
              );
            }
            return emojiRegex;
          },
          /**
           * Unused
           */
          uuid: /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/,
          /**
           * Unused
           */
          ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/,
          ipv4Cidr: /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/,
          /**
           * Unused
           */
          ipv6: /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/,
          ipv6Cidr: /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/,
          base64: /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/,
          base64url: /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/,
          nanoid: /^[a-zA-Z0-9_-]{21}$/,
          jwt: /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
        };
        function parseStringDef(def, refs) {
          const res = {
            type: "string"
          };
          if (def.checks) {
            for (const check of def.checks) {
              switch (check.kind) {
                case "min":
                  res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
                  break;
                case "max":
                  res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
                  break;
                case "email":
                  switch (refs.emailStrategy) {
                    case "format:email":
                      addFormat(res, "email", check.message, refs);
                      break;
                    case "format:idn-email":
                      addFormat(res, "idn-email", check.message, refs);
                      break;
                    case "pattern:zod":
                      addPattern(res, zodPatterns.email, check.message, refs);
                      break;
                  }
                  break;
                case "url":
                  addFormat(res, "uri", check.message, refs);
                  break;
                case "uuid":
                  addFormat(res, "uuid", check.message, refs);
                  break;
                case "regex":
                  addPattern(res, check.regex, check.message, refs);
                  break;
                case "cuid":
                  addPattern(res, zodPatterns.cuid, check.message, refs);
                  break;
                case "cuid2":
                  addPattern(res, zodPatterns.cuid2, check.message, refs);
                  break;
                case "startsWith":
                  addPattern(
                    res,
                    RegExp(`^${escapeLiteralCheckValue(check.value, refs)}`),
                    check.message,
                    refs
                  );
                  break;
                case "endsWith":
                  addPattern(
                    res,
                    RegExp(`${escapeLiteralCheckValue(check.value, refs)}$`),
                    check.message,
                    refs
                  );
                  break;
                case "datetime":
                  addFormat(res, "date-time", check.message, refs);
                  break;
                case "date":
                  addFormat(res, "date", check.message, refs);
                  break;
                case "time":
                  addFormat(res, "time", check.message, refs);
                  break;
                case "duration":
                  addFormat(res, "duration", check.message, refs);
                  break;
                case "length":
                  res.minLength = typeof res.minLength === "number" ? Math.max(res.minLength, check.value) : check.value;
                  res.maxLength = typeof res.maxLength === "number" ? Math.min(res.maxLength, check.value) : check.value;
                  break;
                case "includes": {
                  addPattern(
                    res,
                    RegExp(escapeLiteralCheckValue(check.value, refs)),
                    check.message,
                    refs
                  );
                  break;
                }
                case "ip": {
                  if (check.version !== "v6") {
                    addFormat(res, "ipv4", check.message, refs);
                  }
                  if (check.version !== "v4") {
                    addFormat(res, "ipv6", check.message, refs);
                  }
                  break;
                }
                case "base64url":
                  addPattern(res, zodPatterns.base64url, check.message, refs);
                  break;
                case "jwt":
                  addPattern(res, zodPatterns.jwt, check.message, refs);
                  break;
                case "cidr": {
                  if (check.version !== "v6") {
                    addPattern(res, zodPatterns.ipv4Cidr, check.message, refs);
                  }
                  if (check.version !== "v4") {
                    addPattern(res, zodPatterns.ipv6Cidr, check.message, refs);
                  }
                  break;
                }
                case "emoji":
                  addPattern(res, zodPatterns.emoji(), check.message, refs);
                  break;
                case "ulid": {
                  addPattern(res, zodPatterns.ulid, check.message, refs);
                  break;
                }
                case "base64": {
                  switch (refs.base64Strategy) {
                    case "format:binary": {
                      addFormat(res, "binary", check.message, refs);
                      break;
                    }
                    case "contentEncoding:base64": {
                      res.contentEncoding = "base64";
                      break;
                    }
                    case "pattern:zod": {
                      addPattern(res, zodPatterns.base64, check.message, refs);
                      break;
                    }
                  }
                  break;
                }
                case "nanoid": {
                  addPattern(res, zodPatterns.nanoid, check.message, refs);
                }
              }
            }
          }
          return res;
        }
        function escapeLiteralCheckValue(literal, refs) {
          return refs.patternStrategy === "escape" ? escapeNonAlphaNumeric(literal) : literal;
        }
        var ALPHA_NUMERIC = new Set(
          "ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789"
        );
        function escapeNonAlphaNumeric(source) {
          let result = "";
          for (let i = 0; i < source.length; i++) {
            if (!ALPHA_NUMERIC.has(source[i])) {
              result += "\\";
            }
            result += source[i];
          }
          return result;
        }
        function addFormat(schema, value, message, refs) {
          var _a;
          if (schema.format || ((_a = schema.anyOf) == null ? void 0 : _a.some((x) => x.format))) {
            if (!schema.anyOf) {
              schema.anyOf = [];
            }
            if (schema.format) {
              schema.anyOf.push({
                format: schema.format
              });
              delete schema.format;
            }
            schema.anyOf.push({
              format: value,
              ...message && refs.errorMessages && { errorMessage: { format: message } }
            });
          } else {
            schema.format = value;
          }
        }
        function addPattern(schema, regex, message, refs) {
          var _a;
          if (schema.pattern || ((_a = schema.allOf) == null ? void 0 : _a.some((x) => x.pattern))) {
            if (!schema.allOf) {
              schema.allOf = [];
            }
            if (schema.pattern) {
              schema.allOf.push({
                pattern: schema.pattern
              });
              delete schema.pattern;
            }
            schema.allOf.push({
              pattern: stringifyRegExpWithFlags(regex, refs),
              ...message && refs.errorMessages && { errorMessage: { pattern: message } }
            });
          } else {
            schema.pattern = stringifyRegExpWithFlags(regex, refs);
          }
        }
        function stringifyRegExpWithFlags(regex, refs) {
          var _a;
          if (!refs.applyRegexFlags || !regex.flags) {
            return regex.source;
          }
          const flags = {
            i: regex.flags.includes("i"),
            // Case-insensitive
            m: regex.flags.includes("m"),
            // `^` and `$` matches adjacent to newline characters
            s: regex.flags.includes("s")
            // `.` matches newlines
          };
          const source = flags.i ? regex.source.toLowerCase() : regex.source;
          let pattern = "";
          let isEscaped = false;
          let inCharGroup = false;
          let inCharRange = false;
          for (let i = 0; i < source.length; i++) {
            if (isEscaped) {
              pattern += source[i];
              isEscaped = false;
              continue;
            }
            if (flags.i) {
              if (inCharGroup) {
                if (source[i].match(/[a-z]/)) {
                  if (inCharRange) {
                    pattern += source[i];
                    pattern += `${source[i - 2]}-${source[i]}`.toUpperCase();
                    inCharRange = false;
                  } else if (source[i + 1] === "-" && ((_a = source[i + 2]) == null ? void 0 : _a.match(/[a-z]/))) {
                    pattern += source[i];
                    inCharRange = true;
                  } else {
                    pattern += `${source[i]}${source[i].toUpperCase()}`;
                  }
                  continue;
                }
              } else if (source[i].match(/[a-z]/)) {
                pattern += `[${source[i]}${source[i].toUpperCase()}]`;
                continue;
              }
            }
            if (flags.m) {
              if (source[i] === "^") {
                pattern += `(^|(?<=[\r
]))`;
                continue;
              } else if (source[i] === "$") {
                pattern += `($|(?=[\r
]))`;
                continue;
              }
            }
            if (flags.s && source[i] === ".") {
              pattern += inCharGroup ? `${source[i]}\r
` : `[${source[i]}\r
]`;
              continue;
            }
            pattern += source[i];
            if (source[i] === "\\") {
              isEscaped = true;
            } else if (inCharGroup && source[i] === "]") {
              inCharGroup = false;
            } else if (!inCharGroup && source[i] === "[") {
              inCharGroup = true;
            }
          }
          try {
            new RegExp(pattern);
          } catch (e) {
            console.warn(
              `Could not convert regex pattern at ${refs.currentPath.join(
                "/"
              )} to a flag-independent form! Falling back to the flag-ignorant source`
            );
            return regex.source;
          }
          return pattern;
        }

        // src/zod-to-json-schema/parsers/record.ts
        function parseRecordDef(def, refs) {
          var _a, _b, _c, _d, _e, _f;
          const schema = {
            type: "object",
            additionalProperties: (_a = parseDef(def.valueType._def, {
              ...refs,
              currentPath: [...refs.currentPath, "additionalProperties"]
            })) != null ? _a : refs.allowedAdditionalProperties
          };
          if (((_b = def.keyType) == null ? void 0 : _b._def.typeName) === ZodFirstPartyTypeKind.ZodString && ((_c = def.keyType._def.checks) == null ? void 0 : _c.length)) {
            const { type, ...keyType } = parseStringDef(def.keyType._def, refs);
            return {
              ...schema,
              propertyNames: keyType
            };
          } else if (((_d = def.keyType) == null ? void 0 : _d._def.typeName) === ZodFirstPartyTypeKind.ZodEnum) {
            return {
              ...schema,
              propertyNames: {
                enum: def.keyType._def.values
              }
            };
          } else if (((_e = def.keyType) == null ? void 0 : _e._def.typeName) === ZodFirstPartyTypeKind.ZodBranded && def.keyType._def.type._def.typeName === ZodFirstPartyTypeKind.ZodString && ((_f = def.keyType._def.type._def.checks) == null ? void 0 : _f.length)) {
            const { type, ...keyType } = parseBrandedDef(
              def.keyType._def,
              refs
            );
            return {
              ...schema,
              propertyNames: keyType
            };
          }
          return schema;
        }

        // src/zod-to-json-schema/parsers/map.ts
        function parseMapDef(def, refs) {
          if (refs.mapStrategy === "record") {
            return parseRecordDef(def, refs);
          }
          const keys = parseDef(def.keyType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items", "items", "0"]
          }) || parseAnyDef();
          const values = parseDef(def.valueType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items", "items", "1"]
          }) || parseAnyDef();
          return {
            type: "array",
            maxItems: 125,
            items: {
              type: "array",
              items: [keys, values],
              minItems: 2,
              maxItems: 2
            }
          };
        }

        // src/zod-to-json-schema/parsers/native-enum.ts
        function parseNativeEnumDef(def) {
          const object = def.values;
          const actualKeys = Object.keys(def.values).filter((key) => {
            return typeof object[object[key]] !== "number";
          });
          const actualValues = actualKeys.map((key) => object[key]);
          const parsedTypes = Array.from(
            new Set(actualValues.map((values) => typeof values))
          );
          return {
            type: parsedTypes.length === 1 ? parsedTypes[0] === "string" ? "string" : "number" : ["string", "number"],
            enum: actualValues
          };
        }

        // src/zod-to-json-schema/parsers/never.ts
        function parseNeverDef() {
          return { not: parseAnyDef() };
        }

        // src/zod-to-json-schema/parsers/null.ts
        function parseNullDef() {
          return {
            type: "null"
          };
        }

        // src/zod-to-json-schema/parsers/union.ts
        var primitiveMappings = {
          ZodString: "string",
          ZodNumber: "number",
          ZodBigInt: "integer",
          ZodBoolean: "boolean",
          ZodNull: "null"
        };
        function parseUnionDef(def, refs) {
          const options = def.options instanceof Map ? Array.from(def.options.values()) : def.options;
          if (options.every(
            (x) => x._def.typeName in primitiveMappings && (!x._def.checks || !x._def.checks.length)
          )) {
            const types = options.reduce((types2, x) => {
              const type = primitiveMappings[x._def.typeName];
              return type && !types2.includes(type) ? [...types2, type] : types2;
            }, []);
            return {
              type: types.length > 1 ? types : types[0]
            };
          } else if (options.every((x) => x._def.typeName === "ZodLiteral" && !x.description)) {
            const types = options.reduce(
              (acc, x) => {
                const type = typeof x._def.value;
                switch (type) {
                  case "string":
                  case "number":
                  case "boolean":
                    return [...acc, type];
                  case "bigint":
                    return [...acc, "integer"];
                  case "object":
                    if (x._def.value === null) return [...acc, "null"];
                  case "symbol":
                  case "undefined":
                  case "function":
                  default:
                    return acc;
                }
              },
              []
            );
            if (types.length === options.length) {
              const uniqueTypes = types.filter((x, i, a) => a.indexOf(x) === i);
              return {
                type: uniqueTypes.length > 1 ? uniqueTypes : uniqueTypes[0],
                enum: options.reduce(
                  (acc, x) => {
                    return acc.includes(x._def.value) ? acc : [...acc, x._def.value];
                  },
                  []
                )
              };
            }
          } else if (options.every((x) => x._def.typeName === "ZodEnum")) {
            return {
              type: "string",
              enum: options.reduce(
                (acc, x) => [
                  ...acc,
                  ...x._def.values.filter((x2) => !acc.includes(x2))
                ],
                []
              )
            };
          }
          return asAnyOf(def, refs);
        }
        var asAnyOf = (def, refs) => {
          const anyOf = (def.options instanceof Map ? Array.from(def.options.values()) : def.options).map(
            (x, i) => parseDef(x._def, {
              ...refs,
              currentPath: [...refs.currentPath, "anyOf", `${i}`]
            })
          ).filter(
            (x) => !!x && (!refs.strictUnions || typeof x === "object" && Object.keys(x).length > 0)
          );
          return anyOf.length ? { anyOf } : void 0;
        };

        // src/zod-to-json-schema/parsers/nullable.ts
        function parseNullableDef(def, refs) {
          if (["ZodString", "ZodNumber", "ZodBigInt", "ZodBoolean", "ZodNull"].includes(
            def.innerType._def.typeName
          ) && (!def.innerType._def.checks || !def.innerType._def.checks.length)) {
            return {
              type: [
                primitiveMappings[def.innerType._def.typeName],
                "null"
              ]
            };
          }
          const base = parseDef(def.innerType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "anyOf", "0"]
          });
          return base && { anyOf: [base, { type: "null" }] };
        }

        // src/zod-to-json-schema/parsers/number.ts
        function parseNumberDef(def) {
          const res = {
            type: "number"
          };
          if (!def.checks) return res;
          for (const check of def.checks) {
            switch (check.kind) {
              case "int":
                res.type = "integer";
                break;
              case "min":
                if (check.inclusive) {
                  res.minimum = check.value;
                } else {
                  res.exclusiveMinimum = check.value;
                }
                break;
              case "max":
                if (check.inclusive) {
                  res.maximum = check.value;
                } else {
                  res.exclusiveMaximum = check.value;
                }
                break;
              case "multipleOf":
                res.multipleOf = check.value;
                break;
            }
          }
          return res;
        }

        // src/zod-to-json-schema/parsers/object.ts
        function parseObjectDef(def, refs) {
          const result = {
            type: "object",
            properties: {}
          };
          const required = [];
          const shape = def.shape();
          for (const propName in shape) {
            let propDef = shape[propName];
            if (propDef === void 0 || propDef._def === void 0) {
              continue;
            }
            const propOptional = safeIsOptional(propDef);
            const parsedDef = parseDef(propDef._def, {
              ...refs,
              currentPath: [...refs.currentPath, "properties", propName],
              propertyPath: [...refs.currentPath, "properties", propName]
            });
            if (parsedDef === void 0) {
              continue;
            }
            result.properties[propName] = parsedDef;
            if (!propOptional) {
              required.push(propName);
            }
          }
          if (required.length) {
            result.required = required;
          }
          const additionalProperties = decideAdditionalProperties(def, refs);
          if (additionalProperties !== void 0) {
            result.additionalProperties = additionalProperties;
          }
          return result;
        }
        function decideAdditionalProperties(def, refs) {
          if (def.catchall._def.typeName !== "ZodNever") {
            return parseDef(def.catchall._def, {
              ...refs,
              currentPath: [...refs.currentPath, "additionalProperties"]
            });
          }
          switch (def.unknownKeys) {
            case "passthrough":
              return refs.allowedAdditionalProperties;
            case "strict":
              return refs.rejectedAdditionalProperties;
            case "strip":
              return refs.removeAdditionalStrategy === "strict" ? refs.allowedAdditionalProperties : refs.rejectedAdditionalProperties;
          }
        }
        function safeIsOptional(schema) {
          try {
            return schema.isOptional();
          } catch (e) {
            return true;
          }
        }

        // src/zod-to-json-schema/parsers/optional.ts
        var parseOptionalDef = (def, refs) => {
          var _a;
          if (refs.currentPath.toString() === ((_a = refs.propertyPath) == null ? void 0 : _a.toString())) {
            return parseDef(def.innerType._def, refs);
          }
          const innerSchema = parseDef(def.innerType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "anyOf", "1"]
          });
          return innerSchema ? { anyOf: [{ not: parseAnyDef() }, innerSchema] } : parseAnyDef();
        };

        // src/zod-to-json-schema/parsers/pipeline.ts
        var parsePipelineDef = (def, refs) => {
          if (refs.pipeStrategy === "input") {
            return parseDef(def.in._def, refs);
          } else if (refs.pipeStrategy === "output") {
            return parseDef(def.out._def, refs);
          }
          const a = parseDef(def.in._def, {
            ...refs,
            currentPath: [...refs.currentPath, "allOf", "0"]
          });
          const b = parseDef(def.out._def, {
            ...refs,
            currentPath: [...refs.currentPath, "allOf", a ? "1" : "0"]
          });
          return {
            allOf: [a, b].filter((x) => x !== void 0)
          };
        };

        // src/zod-to-json-schema/parsers/promise.ts
        function parsePromiseDef(def, refs) {
          return parseDef(def.type._def, refs);
        }

        // src/zod-to-json-schema/parsers/set.ts
        function parseSetDef(def, refs) {
          const items = parseDef(def.valueType._def, {
            ...refs,
            currentPath: [...refs.currentPath, "items"]
          });
          const schema = {
            type: "array",
            uniqueItems: true,
            items
          };
          if (def.minSize) {
            schema.minItems = def.minSize.value;
          }
          if (def.maxSize) {
            schema.maxItems = def.maxSize.value;
          }
          return schema;
        }

        // src/zod-to-json-schema/parsers/tuple.ts
        function parseTupleDef(def, refs) {
          if (def.rest) {
            return {
              type: "array",
              minItems: def.items.length,
              items: def.items.map(
                (x, i) => parseDef(x._def, {
                  ...refs,
                  currentPath: [...refs.currentPath, "items", `${i}`]
                })
              ).reduce(
                (acc, x) => x === void 0 ? acc : [...acc, x],
                []
              ),
              additionalItems: parseDef(def.rest._def, {
                ...refs,
                currentPath: [...refs.currentPath, "additionalItems"]
              })
            };
          } else {
            return {
              type: "array",
              minItems: def.items.length,
              maxItems: def.items.length,
              items: def.items.map(
                (x, i) => parseDef(x._def, {
                  ...refs,
                  currentPath: [...refs.currentPath, "items", `${i}`]
                })
              ).reduce(
                (acc, x) => x === void 0 ? acc : [...acc, x],
                []
              )
            };
          }
        }

        // src/zod-to-json-schema/parsers/undefined.ts
        function parseUndefinedDef() {
          return {
            not: parseAnyDef()
          };
        }

        // src/zod-to-json-schema/parsers/unknown.ts
        function parseUnknownDef() {
          return parseAnyDef();
        }

        // src/zod-to-json-schema/parsers/readonly.ts
        var parseReadonlyDef = (def, refs) => {
          return parseDef(def.innerType._def, refs);
        };

        // src/zod-to-json-schema/select-parser.ts
        var selectParser = (def, typeName, refs) => {
          switch (typeName) {
            case ZodFirstPartyTypeKind.ZodString:
              return parseStringDef(def, refs);
            case ZodFirstPartyTypeKind.ZodNumber:
              return parseNumberDef(def);
            case ZodFirstPartyTypeKind.ZodObject:
              return parseObjectDef(def, refs);
            case ZodFirstPartyTypeKind.ZodBigInt:
              return parseBigintDef(def);
            case ZodFirstPartyTypeKind.ZodBoolean:
              return parseBooleanDef();
            case ZodFirstPartyTypeKind.ZodDate:
              return parseDateDef(def, refs);
            case ZodFirstPartyTypeKind.ZodUndefined:
              return parseUndefinedDef();
            case ZodFirstPartyTypeKind.ZodNull:
              return parseNullDef();
            case ZodFirstPartyTypeKind.ZodArray:
              return parseArrayDef(def, refs);
            case ZodFirstPartyTypeKind.ZodUnion:
            case ZodFirstPartyTypeKind.ZodDiscriminatedUnion:
              return parseUnionDef(def, refs);
            case ZodFirstPartyTypeKind.ZodIntersection:
              return parseIntersectionDef(def, refs);
            case ZodFirstPartyTypeKind.ZodTuple:
              return parseTupleDef(def, refs);
            case ZodFirstPartyTypeKind.ZodRecord:
              return parseRecordDef(def, refs);
            case ZodFirstPartyTypeKind.ZodLiteral:
              return parseLiteralDef(def);
            case ZodFirstPartyTypeKind.ZodEnum:
              return parseEnumDef(def);
            case ZodFirstPartyTypeKind.ZodNativeEnum:
              return parseNativeEnumDef(def);
            case ZodFirstPartyTypeKind.ZodNullable:
              return parseNullableDef(def, refs);
            case ZodFirstPartyTypeKind.ZodOptional:
              return parseOptionalDef(def, refs);
            case ZodFirstPartyTypeKind.ZodMap:
              return parseMapDef(def, refs);
            case ZodFirstPartyTypeKind.ZodSet:
              return parseSetDef(def, refs);
            case ZodFirstPartyTypeKind.ZodLazy:
              return () => def.getter()._def;
            case ZodFirstPartyTypeKind.ZodPromise:
              return parsePromiseDef(def, refs);
            case ZodFirstPartyTypeKind.ZodNaN:
            case ZodFirstPartyTypeKind.ZodNever:
              return parseNeverDef();
            case ZodFirstPartyTypeKind.ZodEffects:
              return parseEffectsDef(def, refs);
            case ZodFirstPartyTypeKind.ZodAny:
              return parseAnyDef();
            case ZodFirstPartyTypeKind.ZodUnknown:
              return parseUnknownDef();
            case ZodFirstPartyTypeKind.ZodDefault:
              return parseDefaultDef(def, refs);
            case ZodFirstPartyTypeKind.ZodBranded:
              return parseBrandedDef(def, refs);
            case ZodFirstPartyTypeKind.ZodReadonly:
              return parseReadonlyDef(def, refs);
            case ZodFirstPartyTypeKind.ZodCatch:
              return parseCatchDef(def, refs);
            case ZodFirstPartyTypeKind.ZodPipeline:
              return parsePipelineDef(def, refs);
            case ZodFirstPartyTypeKind.ZodFunction:
            case ZodFirstPartyTypeKind.ZodVoid:
            case ZodFirstPartyTypeKind.ZodSymbol:
              return void 0;
            default:
              return /* @__PURE__ */ ((_) => void 0)();
          }
        };

        // src/zod-to-json-schema/parse-def.ts
        function parseDef(def, refs, forceResolution = false) {
          var _a;
          const seenItem = refs.seen.get(def);
          if (refs.override) {
            const overrideResult = (_a = refs.override) == null ? void 0 : _a.call(
              refs,
              def,
              refs,
              seenItem,
              forceResolution
            );
            if (overrideResult !== ignoreOverride) {
              return overrideResult;
            }
          }
          if (seenItem && !forceResolution) {
            const seenSchema = get$ref(seenItem, refs);
            if (seenSchema !== void 0) {
              return seenSchema;
            }
          }
          const newItem = { def, path: refs.currentPath, jsonSchema: void 0 };
          refs.seen.set(def, newItem);
          const jsonSchemaOrGetter = selectParser(def, def.typeName, refs);
          const jsonSchema2 = typeof jsonSchemaOrGetter === "function" ? parseDef(jsonSchemaOrGetter(), refs) : jsonSchemaOrGetter;
          if (jsonSchema2) {
            addMeta(def, refs, jsonSchema2);
          }
          if (refs.postProcess) {
            const postProcessResult = refs.postProcess(jsonSchema2, def, refs);
            newItem.jsonSchema = jsonSchema2;
            return postProcessResult;
          }
          newItem.jsonSchema = jsonSchema2;
          return jsonSchema2;
        }
        var get$ref = (item, refs) => {
          switch (refs.$refStrategy) {
            case "root":
              return { $ref: item.path.join("/") };
            case "relative":
              return { $ref: getRelativePath(refs.currentPath, item.path) };
            case "none":
            case "seen": {
              if (item.path.length < refs.currentPath.length && item.path.every((value, index) => refs.currentPath[index] === value)) {
                console.warn(
                  `Recursive reference detected at ${refs.currentPath.join(
                    "/"
                  )}! Defaulting to any`
                );
                return parseAnyDef();
              }
              return refs.$refStrategy === "seen" ? parseAnyDef() : void 0;
            }
          }
        };
        var addMeta = (def, refs, jsonSchema2) => {
          if (def.description) {
            jsonSchema2.description = def.description;
          }
          return jsonSchema2;
        };

        // src/zod-to-json-schema/refs.ts
        var getRefs = (options) => {
          const _options = getDefaultOptions(options);
          const currentPath = _options.name !== void 0 ? [..._options.basePath, _options.definitionPath, _options.name] : _options.basePath;
          return {
            ..._options,
            currentPath,
            propertyPath: void 0,
            seen: new Map(
              Object.entries(_options.definitions).map(([name, def]) => [
                def._def,
                {
                  def: def._def,
                  path: [..._options.basePath, _options.definitionPath, name],
                  // Resolution of references will be forced even though seen, so it's ok that the schema is undefined here for now.
                  jsonSchema: void 0
                }
              ])
            )
          };
        };

        // src/zod-to-json-schema/zod-to-json-schema.ts
        var zodToJsonSchema = (schema, options) => {
          var _a;
          const refs = getRefs(options);
          let definitions = typeof options === "object" && options.definitions ? Object.entries(options.definitions).reduce(
            (acc, [name2, schema2]) => {
              var _a2;
              return {
                ...acc,
                [name2]: (_a2 = parseDef(
                  schema2._def,
                  {
                    ...refs,
                    currentPath: [...refs.basePath, refs.definitionPath, name2]
                  },
                  true
                )) != null ? _a2 : parseAnyDef()
              };
            },
            {}
          ) : void 0;
          const name = typeof options === "string" ? options : (options == null ? void 0 : options.nameStrategy) === "title" ? void 0 : options == null ? void 0 : options.name;
          const main = (_a = parseDef(
            schema._def,
            name === void 0 ? refs : {
              ...refs,
              currentPath: [...refs.basePath, refs.definitionPath, name]
            },
            false
          )) != null ? _a : parseAnyDef();
          const title = typeof options === "object" && options.name !== void 0 && options.nameStrategy === "title" ? options.name : void 0;
          if (title !== void 0) {
            main.title = title;
          }
          const combined = name === void 0 ? definitions ? {
            ...main,
            [refs.definitionPath]: definitions
          } : main : {
            $ref: [
              ...refs.$refStrategy === "relative" ? [] : refs.basePath,
              refs.definitionPath,
              name
            ].join("/"),
            [refs.definitionPath]: {
              ...definitions,
              [name]: main
            }
          };
          combined.$schema = "http://json-schema.org/draft-07/schema#";
          return combined;
        };

        // src/zod-to-json-schema/index.ts
        var zod_to_json_schema_default = zodToJsonSchema;

        // src/zod-schema.ts
        function zod3Schema(zodSchema2, options) {
          var _a;
          const useReferences = (_a = void 0) != null ? _a : false;
          return jsonSchema(
            // defer json schema creation to avoid unnecessary computation when only validation is needed
            () => zod_to_json_schema_default(zodSchema2, {
              $refStrategy: useReferences ? "root" : "none"
            }),
            {
              validate: async (value) => {
                const result = await zodSchema2.safeParseAsync(value);
                return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
              }
            }
          );
        }
        function zod4Schema(zodSchema2, options) {
          var _a;
          const useReferences = (_a = void 0) != null ? _a : false;
          return jsonSchema(
            // defer json schema creation to avoid unnecessary computation when only validation is needed
            () => toJSONSchema(zodSchema2, {
              target: "draft-7",
              io: "output",
              reused: useReferences ? "ref" : "inline"
            }),
            {
              validate: async (value) => {
                const result = await safeParseAsync(zodSchema2, value);
                return result.success ? { success: true, value: result.data } : { success: false, error: result.error };
              }
            }
          );
        }
        function isZod4Schema(zodSchema2) {
          return "_zod" in zodSchema2;
        }
        function zodSchema(zodSchema2, options) {
          if (isZod4Schema(zodSchema2)) {
            return zod4Schema(zodSchema2);
          } else {
            return zod3Schema(zodSchema2);
          }
        }

        // src/schema.ts
        var schemaSymbol = Symbol.for("vercel.ai.schema");
        function lazySchema(createSchema) {
          let schema;
          return () => {
            if (schema == null) {
              schema = createSchema();
            }
            return schema;
          };
        }
        function jsonSchema(jsonSchema2, {
          validate
        } = {}) {
          return {
            [schemaSymbol]: true,
            _type: void 0,
            // should never be used directly
            [validatorSymbol$1]: true,
            get jsonSchema() {
              if (typeof jsonSchema2 === "function") {
                jsonSchema2 = jsonSchema2();
              }
              return jsonSchema2;
            },
            validate
          };
        }
        function isSchema(value) {
          return typeof value === "object" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && "jsonSchema" in value && "validate" in value;
        }
        function asSchema(schema) {
          return schema == null ? jsonSchema({
            properties: {},
            additionalProperties: false
          }) : isSchema(schema) ? schema : typeof schema === "function" ? schema() : zodSchema(schema);
        }

        // src/uint8-utils.ts
        var { btoa: btoa$1, atob: atob$1 } = globalThis;
        function convertBase64ToUint8Array(base64String) {
          const base64Url = base64String.replace(/-/g, "+").replace(/_/g, "/");
          const latin1string = atob$1(base64Url);
          return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));
        }
        function convertUint8ArrayToBase64$1(array) {
          let latin1string = "";
          for (let i = 0; i < array.length; i++) {
            latin1string += String.fromCodePoint(array[i]);
          }
          return btoa$1(latin1string);
        }
        function convertToBase64(value) {
          return value instanceof Uint8Array ? convertUint8ArrayToBase64$1(value) : value;
        }

        // src/without-trailing-slash.ts
        function withoutTrailingSlash$1(url) {
          return url == null ? void 0 : url.replace(/\/$/, "");
        }

        // src/openai-provider.ts
        var openaiErrorDataSchema = object({
          error: object({
            message: string(),
            // The additional information below is handled loosely to support
            // OpenAI-compatible providers that have slightly different error
            // responses:
            type: string().nullish(),
            param: any().nullish(),
            code: union([string(), number$1()]).nullish()
          })
        });
        var openaiFailedResponseHandler = createJsonErrorResponseHandler$1({
          errorSchema: openaiErrorDataSchema,
          errorToMessage: (data) => data.error.message
        });
        function convertToOpenAIChatMessages({
          prompt,
          systemMessageMode = "system"
        }) {
          const messages = [];
          const warnings = [];
          for (const { role, content } of prompt) {
            switch (role) {
              case "system": {
                switch (systemMessageMode) {
                  case "system": {
                    messages.push({ role: "system", content });
                    break;
                  }
                  case "developer": {
                    messages.push({ role: "developer", content });
                    break;
                  }
                  case "remove": {
                    warnings.push({
                      type: "other",
                      message: "system messages are removed for this model"
                    });
                    break;
                  }
                  default: {
                    const _exhaustiveCheck = systemMessageMode;
                    throw new Error(
                      `Unsupported system message mode: ${_exhaustiveCheck}`
                    );
                  }
                }
                break;
              }
              case "user": {
                if (content.length === 1 && content[0].type === "text") {
                  messages.push({ role: "user", content: content[0].text });
                  break;
                }
                messages.push({
                  role: "user",
                  content: content.map((part, index) => {
                    var _a, _b, _c;
                    switch (part.type) {
                      case "text": {
                        return { type: "text", text: part.text };
                      }
                      case "file": {
                        if (part.mediaType.startsWith("image/")) {
                          const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                          return {
                            type: "image_url",
                            image_url: {
                              url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`,
                              // OpenAI specific extension: image detail
                              detail: (_b = (_a = part.providerOptions) == null ? void 0 : _a.openai) == null ? void 0 : _b.imageDetail
                            }
                          };
                        } else if (part.mediaType.startsWith("audio/")) {
                          if (part.data instanceof URL) {
                            throw new UnsupportedFunctionalityError$1({
                              functionality: "audio file parts with URLs"
                            });
                          }
                          switch (part.mediaType) {
                            case "audio/wav": {
                              return {
                                type: "input_audio",
                                input_audio: {
                                  data: convertToBase64(part.data),
                                  format: "wav"
                                }
                              };
                            }
                            case "audio/mp3":
                            case "audio/mpeg": {
                              return {
                                type: "input_audio",
                                input_audio: {
                                  data: convertToBase64(part.data),
                                  format: "mp3"
                                }
                              };
                            }
                            default: {
                              throw new UnsupportedFunctionalityError$1({
                                functionality: `audio content parts with media type ${part.mediaType}`
                              });
                            }
                          }
                        } else if (part.mediaType === "application/pdf") {
                          if (part.data instanceof URL) {
                            throw new UnsupportedFunctionalityError$1({
                              functionality: "PDF file parts with URLs"
                            });
                          }
                          return {
                            type: "file",
                            file: typeof part.data === "string" && part.data.startsWith("file-") ? { file_id: part.data } : {
                              filename: (_c = part.filename) != null ? _c : `part-${index}.pdf`,
                              file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                            }
                          };
                        } else {
                          throw new UnsupportedFunctionalityError$1({
                            functionality: `file part media type ${part.mediaType}`
                          });
                        }
                      }
                    }
                  })
                });
                break;
              }
              case "assistant": {
                let text = "";
                const toolCalls = [];
                for (const part of content) {
                  switch (part.type) {
                    case "text": {
                      text += part.text;
                      break;
                    }
                    case "tool-call": {
                      toolCalls.push({
                        id: part.toolCallId,
                        type: "function",
                        function: {
                          name: part.toolName,
                          arguments: JSON.stringify(part.input)
                        }
                      });
                      break;
                    }
                  }
                }
                messages.push({
                  role: "assistant",
                  content: text,
                  tool_calls: toolCalls.length > 0 ? toolCalls : void 0
                });
                break;
              }
              case "tool": {
                for (const toolResponse of content) {
                  const output = toolResponse.output;
                  let contentValue;
                  switch (output.type) {
                    case "text":
                    case "error-text":
                      contentValue = output.value;
                      break;
                    case "content":
                    case "json":
                    case "error-json":
                      contentValue = JSON.stringify(output.value);
                      break;
                  }
                  messages.push({
                    role: "tool",
                    tool_call_id: toolResponse.toolCallId,
                    content: contentValue
                  });
                }
                break;
              }
              default: {
                const _exhaustiveCheck = role;
                throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
              }
            }
          }
          return { messages, warnings };
        }

        // src/chat/get-response-metadata.ts
        function getResponseMetadata$1({
          id,
          model,
          created
        }) {
          return {
            id: id != null ? id : void 0,
            modelId: model != null ? model : void 0,
            timestamp: created != null ? new Date(created * 1e3) : void 0
          };
        }

        // src/chat/map-openai-finish-reason.ts
        function mapOpenAIFinishReason(finishReason) {
          switch (finishReason) {
            case "stop":
              return "stop";
            case "length":
              return "length";
            case "content_filter":
              return "content-filter";
            case "function_call":
            case "tool_calls":
              return "tool-calls";
            default:
              return "unknown";
          }
        }
        var openaiChatResponseSchema = lazyValidator(
          () => zodSchema(
            object({
              id: string().nullish(),
              created: number$1().nullish(),
              model: string().nullish(),
              choices: array(
                object({
                  message: object({
                    role: literal("assistant").nullish(),
                    content: string().nullish(),
                    tool_calls: array(
                      object({
                        id: string().nullish(),
                        type: literal("function"),
                        function: object({
                          name: string(),
                          arguments: string()
                        })
                      })
                    ).nullish(),
                    annotations: array(
                      object({
                        type: literal("url_citation"),
                        start_index: number$1(),
                        end_index: number$1(),
                        url: string(),
                        title: string()
                      })
                    ).nullish()
                  }),
                  index: number$1(),
                  logprobs: object({
                    content: array(
                      object({
                        token: string(),
                        logprob: number$1(),
                        top_logprobs: array(
                          object({
                            token: string(),
                            logprob: number$1()
                          })
                        )
                      })
                    ).nullish()
                  }).nullish(),
                  finish_reason: string().nullish()
                })
              ),
              usage: object({
                prompt_tokens: number$1().nullish(),
                completion_tokens: number$1().nullish(),
                total_tokens: number$1().nullish(),
                prompt_tokens_details: object({
                  cached_tokens: number$1().nullish()
                }).nullish(),
                completion_tokens_details: object({
                  reasoning_tokens: number$1().nullish(),
                  accepted_prediction_tokens: number$1().nullish(),
                  rejected_prediction_tokens: number$1().nullish()
                }).nullish()
              }).nullish()
            })
          )
        );
        var openaiChatChunkSchema = lazyValidator(
          () => zodSchema(
            union([
              object({
                id: string().nullish(),
                created: number$1().nullish(),
                model: string().nullish(),
                choices: array(
                  object({
                    delta: object({
                      role: _enum(["assistant"]).nullish(),
                      content: string().nullish(),
                      tool_calls: array(
                        object({
                          index: number$1(),
                          id: string().nullish(),
                          type: literal("function").nullish(),
                          function: object({
                            name: string().nullish(),
                            arguments: string().nullish()
                          })
                        })
                      ).nullish(),
                      annotations: array(
                        object({
                          type: literal("url_citation"),
                          start_index: number$1(),
                          end_index: number$1(),
                          url: string(),
                          title: string()
                        })
                      ).nullish()
                    }).nullish(),
                    logprobs: object({
                      content: array(
                        object({
                          token: string(),
                          logprob: number$1(),
                          top_logprobs: array(
                            object({
                              token: string(),
                              logprob: number$1()
                            })
                          )
                        })
                      ).nullish()
                    }).nullish(),
                    finish_reason: string().nullish(),
                    index: number$1()
                  })
                ),
                usage: object({
                  prompt_tokens: number$1().nullish(),
                  completion_tokens: number$1().nullish(),
                  total_tokens: number$1().nullish(),
                  prompt_tokens_details: object({
                    cached_tokens: number$1().nullish()
                  }).nullish(),
                  completion_tokens_details: object({
                    reasoning_tokens: number$1().nullish(),
                    accepted_prediction_tokens: number$1().nullish(),
                    rejected_prediction_tokens: number$1().nullish()
                  }).nullish()
                }).nullish()
              }),
              openaiErrorDataSchema
            ])
          )
        );
        var openaiChatLanguageModelOptions = lazyValidator(
          () => zodSchema(
            object({
              /**
               * Modify the likelihood of specified tokens appearing in the completion.
               *
               * Accepts a JSON object that maps tokens (specified by their token ID in
               * the GPT tokenizer) to an associated bias value from -100 to 100.
               */
              logitBias: record(number(), number$1()).optional(),
              /**
               * Return the log probabilities of the tokens.
               *
               * Setting to true will return the log probabilities of the tokens that
               * were generated.
               *
               * Setting to a number will return the log probabilities of the top n
               * tokens that were generated.
               */
              logprobs: union([boolean(), number$1()]).optional(),
              /**
               * Whether to enable parallel function calling during tool use. Default to true.
               */
              parallelToolCalls: boolean().optional(),
              /**
               * A unique identifier representing your end-user, which can help OpenAI to
               * monitor and detect abuse.
               */
              user: string().optional(),
              /**
               * Reasoning effort for reasoning models. Defaults to `medium`.
               */
              reasoningEffort: _enum(["minimal", "low", "medium", "high"]).optional(),
              /**
               * Maximum number of completion tokens to generate. Useful for reasoning models.
               */
              maxCompletionTokens: number$1().optional(),
              /**
               * Whether to enable persistence in responses API.
               */
              store: boolean().optional(),
              /**
               * Metadata to associate with the request.
               */
              metadata: record(string().max(64), string().max(512)).optional(),
              /**
               * Parameters for prediction mode.
               */
              prediction: record(string(), any()).optional(),
              /**
               * Whether to use structured outputs.
               *
               * @default true
               */
              structuredOutputs: boolean().optional(),
              /**
               * Service tier for the request.
               * - 'auto': Default service tier. The request will be processed with the service tier configured in the
               *           Project settings. Unless otherwise configured, the Project will use 'default'.
               * - 'flex': 50% cheaper processing at the cost of increased latency. Only available for o3 and o4-mini models.
               * - 'priority': Higher-speed processing with predictably low latency at premium cost. Available for Enterprise customers.
               * - 'default': The request will be processed with the standard pricing and performance for the selected model.
               *
               * @default 'auto'
               */
              serviceTier: _enum(["auto", "flex", "priority", "default"]).optional(),
              /**
               * Whether to use strict JSON schema validation.
               *
               * @default false
               */
              strictJsonSchema: boolean().optional(),
              /**
               * Controls the verbosity of the model's responses.
               * Lower values will result in more concise responses, while higher values will result in more verbose responses.
               */
              textVerbosity: _enum(["low", "medium", "high"]).optional(),
              /**
               * A cache key for prompt caching. Allows manual control over prompt caching behavior.
               * Useful for improving cache hit rates and working around automatic caching issues.
               */
              promptCacheKey: string().optional(),
              /**
               * A stable identifier used to help detect users of your application
               * that may be violating OpenAI's usage policies. The IDs should be a
               * string that uniquely identifies each user. We recommend hashing their
               * username or email address, in order to avoid sending us any identifying
               * information.
               */
              safetyIdentifier: string().optional()
            })
          )
        );
        function prepareChatTools({
          tools,
          toolChoice,
          structuredOutputs,
          strictJsonSchema
        }) {
          tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
          const toolWarnings = [];
          if (tools == null) {
            return { tools: void 0, toolChoice: void 0, toolWarnings };
          }
          const openaiTools2 = [];
          for (const tool of tools) {
            switch (tool.type) {
              case "function":
                openaiTools2.push({
                  type: "function",
                  function: {
                    name: tool.name,
                    description: tool.description,
                    parameters: tool.inputSchema,
                    strict: structuredOutputs ? strictJsonSchema : void 0
                  }
                });
                break;
              default:
                toolWarnings.push({ type: "unsupported-tool", tool });
                break;
            }
          }
          if (toolChoice == null) {
            return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
          }
          const type = toolChoice.type;
          switch (type) {
            case "auto":
            case "none":
            case "required":
              return { tools: openaiTools2, toolChoice: type, toolWarnings };
            case "tool":
              return {
                tools: openaiTools2,
                toolChoice: {
                  type: "function",
                  function: {
                    name: toolChoice.toolName
                  }
                },
                toolWarnings
              };
            default: {
              const _exhaustiveCheck = type;
              throw new UnsupportedFunctionalityError$1({
                functionality: `tool choice type: ${_exhaustiveCheck}`
              });
            }
          }
        }

        // src/chat/openai-chat-language-model.ts
        var OpenAIChatLanguageModel = class {
          constructor(modelId, config) {
            this.specificationVersion = "v2";
            this.supportedUrls = {
              "image/*": [/^https?:\/\/.*$/]
            };
            this.modelId = modelId;
            this.config = config;
          }
          get provider() {
            return this.config.provider;
          }
          async getArgs({
            prompt,
            maxOutputTokens,
            temperature,
            topP,
            topK,
            frequencyPenalty,
            presencePenalty,
            stopSequences,
            responseFormat,
            seed,
            tools,
            toolChoice,
            providerOptions
          }) {
            var _a, _b, _c, _d;
            const warnings = [];
            const openaiOptions = (_a = await parseProviderOptions({
              provider: "openai",
              providerOptions,
              schema: openaiChatLanguageModelOptions
            })) != null ? _a : {};
            const structuredOutputs = (_b = openaiOptions.structuredOutputs) != null ? _b : true;
            if (topK != null) {
              warnings.push({
                type: "unsupported-setting",
                setting: "topK"
              });
            }
            if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !structuredOutputs) {
              warnings.push({
                type: "unsupported-setting",
                setting: "responseFormat",
                details: "JSON response format schema is only supported with structuredOutputs"
              });
            }
            const { messages, warnings: messageWarnings } = convertToOpenAIChatMessages(
              {
                prompt,
                systemMessageMode: getSystemMessageMode(this.modelId)
              }
            );
            warnings.push(...messageWarnings);
            const strictJsonSchema = (_c = openaiOptions.strictJsonSchema) != null ? _c : false;
            const baseArgs = {
              // model id:
              model: this.modelId,
              // model specific settings:
              logit_bias: openaiOptions.logitBias,
              logprobs: openaiOptions.logprobs === true || typeof openaiOptions.logprobs === "number" ? true : void 0,
              top_logprobs: typeof openaiOptions.logprobs === "number" ? openaiOptions.logprobs : typeof openaiOptions.logprobs === "boolean" ? openaiOptions.logprobs ? 0 : void 0 : void 0,
              user: openaiOptions.user,
              parallel_tool_calls: openaiOptions.parallelToolCalls,
              // standardized settings:
              max_tokens: maxOutputTokens,
              temperature,
              top_p: topP,
              frequency_penalty: frequencyPenalty,
              presence_penalty: presencePenalty,
              response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? structuredOutputs && responseFormat.schema != null ? {
                type: "json_schema",
                json_schema: {
                  schema: responseFormat.schema,
                  strict: strictJsonSchema,
                  name: (_d = responseFormat.name) != null ? _d : "response",
                  description: responseFormat.description
                }
              } : { type: "json_object" } : void 0,
              stop: stopSequences,
              seed,
              verbosity: openaiOptions.textVerbosity,
              // openai specific settings:
              // TODO AI SDK 6: remove, we auto-map maxOutputTokens now
              max_completion_tokens: openaiOptions.maxCompletionTokens,
              store: openaiOptions.store,
              metadata: openaiOptions.metadata,
              prediction: openaiOptions.prediction,
              reasoning_effort: openaiOptions.reasoningEffort,
              service_tier: openaiOptions.serviceTier,
              prompt_cache_key: openaiOptions.promptCacheKey,
              safety_identifier: openaiOptions.safetyIdentifier,
              // messages:
              messages
            };
            if (isReasoningModel(this.modelId)) {
              if (baseArgs.temperature != null) {
                baseArgs.temperature = void 0;
                warnings.push({
                  type: "unsupported-setting",
                  setting: "temperature",
                  details: "temperature is not supported for reasoning models"
                });
              }
              if (baseArgs.top_p != null) {
                baseArgs.top_p = void 0;
                warnings.push({
                  type: "unsupported-setting",
                  setting: "topP",
                  details: "topP is not supported for reasoning models"
                });
              }
              if (baseArgs.frequency_penalty != null) {
                baseArgs.frequency_penalty = void 0;
                warnings.push({
                  type: "unsupported-setting",
                  setting: "frequencyPenalty",
                  details: "frequencyPenalty is not supported for reasoning models"
                });
              }
              if (baseArgs.presence_penalty != null) {
                baseArgs.presence_penalty = void 0;
                warnings.push({
                  type: "unsupported-setting",
                  setting: "presencePenalty",
                  details: "presencePenalty is not supported for reasoning models"
                });
              }
              if (baseArgs.logit_bias != null) {
                baseArgs.logit_bias = void 0;
                warnings.push({
                  type: "other",
                  message: "logitBias is not supported for reasoning models"
                });
              }
              if (baseArgs.logprobs != null) {
                baseArgs.logprobs = void 0;
                warnings.push({
                  type: "other",
                  message: "logprobs is not supported for reasoning models"
                });
              }
              if (baseArgs.top_logprobs != null) {
                baseArgs.top_logprobs = void 0;
                warnings.push({
                  type: "other",
                  message: "topLogprobs is not supported for reasoning models"
                });
              }
              if (baseArgs.max_tokens != null) {
                if (baseArgs.max_completion_tokens == null) {
                  baseArgs.max_completion_tokens = baseArgs.max_tokens;
                }
                baseArgs.max_tokens = void 0;
              }
            } else if (this.modelId.startsWith("gpt-4o-search-preview") || this.modelId.startsWith("gpt-4o-mini-search-preview")) {
              if (baseArgs.temperature != null) {
                baseArgs.temperature = void 0;
                warnings.push({
                  type: "unsupported-setting",
                  setting: "temperature",
                  details: "temperature is not supported for the search preview models and has been removed."
                });
              }
            }
            if (openaiOptions.serviceTier === "flex" && !supportsFlexProcessing(this.modelId)) {
              warnings.push({
                type: "unsupported-setting",
                setting: "serviceTier",
                details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
              });
              baseArgs.service_tier = void 0;
            }
            if (openaiOptions.serviceTier === "priority" && !supportsPriorityProcessing(this.modelId)) {
              warnings.push({
                type: "unsupported-setting",
                setting: "serviceTier",
                details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
              });
              baseArgs.service_tier = void 0;
            }
            const {
              tools: openaiTools2,
              toolChoice: openaiToolChoice,
              toolWarnings
            } = prepareChatTools({
              tools,
              toolChoice,
              structuredOutputs,
              strictJsonSchema
            });
            return {
              args: {
                ...baseArgs,
                tools: openaiTools2,
                tool_choice: openaiToolChoice
              },
              warnings: [...warnings, ...toolWarnings]
            };
          }
          async doGenerate(options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
            const { args: body, warnings } = await this.getArgs(options);
            const {
              responseHeaders,
              value: response,
              rawValue: rawResponse
            } = await postJsonToApi$1({
              url: this.config.url({
                path: "/chat/completions",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), options.headers),
              body,
              failedResponseHandler: openaiFailedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler$1(
                openaiChatResponseSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            const choice = response.choices[0];
            const content = [];
            const text = choice.message.content;
            if (text != null && text.length > 0) {
              content.push({ type: "text", text });
            }
            for (const toolCall of (_a = choice.message.tool_calls) != null ? _a : []) {
              content.push({
                type: "tool-call",
                toolCallId: (_b = toolCall.id) != null ? _b : generateId$1(),
                toolName: toolCall.function.name,
                input: toolCall.function.arguments
              });
            }
            for (const annotation of (_c = choice.message.annotations) != null ? _c : []) {
              content.push({
                type: "source",
                sourceType: "url",
                id: generateId$1(),
                url: annotation.url,
                title: annotation.title
              });
            }
            const completionTokenDetails = (_d = response.usage) == null ? void 0 : _d.completion_tokens_details;
            const promptTokenDetails = (_e = response.usage) == null ? void 0 : _e.prompt_tokens_details;
            const providerMetadata = { openai: {} };
            if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
              providerMetadata.openai.acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
            }
            if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
              providerMetadata.openai.rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
            }
            if (((_f = choice.logprobs) == null ? void 0 : _f.content) != null) {
              providerMetadata.openai.logprobs = choice.logprobs.content;
            }
            return {
              content,
              finishReason: mapOpenAIFinishReason(choice.finish_reason),
              usage: {
                inputTokens: (_h = (_g = response.usage) == null ? void 0 : _g.prompt_tokens) != null ? _h : void 0,
                outputTokens: (_j = (_i = response.usage) == null ? void 0 : _i.completion_tokens) != null ? _j : void 0,
                totalTokens: (_l = (_k = response.usage) == null ? void 0 : _k.total_tokens) != null ? _l : void 0,
                reasoningTokens: (_m = completionTokenDetails == null ? void 0 : completionTokenDetails.reasoning_tokens) != null ? _m : void 0,
                cachedInputTokens: (_n = promptTokenDetails == null ? void 0 : promptTokenDetails.cached_tokens) != null ? _n : void 0
              },
              request: { body },
              response: {
                ...getResponseMetadata$1(response),
                headers: responseHeaders,
                body: rawResponse
              },
              warnings,
              providerMetadata
            };
          }
          async doStream(options) {
            const { args, warnings } = await this.getArgs(options);
            const body = {
              ...args,
              stream: true,
              stream_options: {
                include_usage: true
              }
            };
            const { responseHeaders, value: response } = await postJsonToApi$1({
              url: this.config.url({
                path: "/chat/completions",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), options.headers),
              body,
              failedResponseHandler: openaiFailedResponseHandler,
              successfulResponseHandler: createEventSourceResponseHandler$1(
                openaiChatChunkSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            const toolCalls = [];
            let finishReason = "unknown";
            const usage = {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            };
            let isFirstChunk = true;
            let isActiveText = false;
            const providerMetadata = { openai: {} };
            return {
              stream: response.pipeThrough(
                new TransformStream({
                  start(controller) {
                    controller.enqueue({ type: "stream-start", warnings });
                  },
                  transform(chunk, controller) {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
                    if (options.includeRawChunks) {
                      controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                    }
                    if (!chunk.success) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: chunk.error });
                      return;
                    }
                    const value = chunk.value;
                    if ("error" in value) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: value.error });
                      return;
                    }
                    if (isFirstChunk) {
                      isFirstChunk = false;
                      controller.enqueue({
                        type: "response-metadata",
                        ...getResponseMetadata$1(value)
                      });
                    }
                    if (value.usage != null) {
                      usage.inputTokens = (_a = value.usage.prompt_tokens) != null ? _a : void 0;
                      usage.outputTokens = (_b = value.usage.completion_tokens) != null ? _b : void 0;
                      usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;
                      usage.reasoningTokens = (_e = (_d = value.usage.completion_tokens_details) == null ? void 0 : _d.reasoning_tokens) != null ? _e : void 0;
                      usage.cachedInputTokens = (_g = (_f = value.usage.prompt_tokens_details) == null ? void 0 : _f.cached_tokens) != null ? _g : void 0;
                      if (((_h = value.usage.completion_tokens_details) == null ? void 0 : _h.accepted_prediction_tokens) != null) {
                        providerMetadata.openai.acceptedPredictionTokens = (_i = value.usage.completion_tokens_details) == null ? void 0 : _i.accepted_prediction_tokens;
                      }
                      if (((_j = value.usage.completion_tokens_details) == null ? void 0 : _j.rejected_prediction_tokens) != null) {
                        providerMetadata.openai.rejectedPredictionTokens = (_k = value.usage.completion_tokens_details) == null ? void 0 : _k.rejected_prediction_tokens;
                      }
                    }
                    const choice = value.choices[0];
                    if ((choice == null ? void 0 : choice.finish_reason) != null) {
                      finishReason = mapOpenAIFinishReason(choice.finish_reason);
                    }
                    if (((_l = choice == null ? void 0 : choice.logprobs) == null ? void 0 : _l.content) != null) {
                      providerMetadata.openai.logprobs = choice.logprobs.content;
                    }
                    if ((choice == null ? void 0 : choice.delta) == null) {
                      return;
                    }
                    const delta = choice.delta;
                    if (delta.content != null) {
                      if (!isActiveText) {
                        controller.enqueue({ type: "text-start", id: "0" });
                        isActiveText = true;
                      }
                      controller.enqueue({
                        type: "text-delta",
                        id: "0",
                        delta: delta.content
                      });
                    }
                    if (delta.tool_calls != null) {
                      for (const toolCallDelta of delta.tool_calls) {
                        const index = toolCallDelta.index;
                        if (toolCalls[index] == null) {
                          if (toolCallDelta.type !== "function") {
                            throw new InvalidResponseDataError$1({
                              data: toolCallDelta,
                              message: `Expected 'function' type.`
                            });
                          }
                          if (toolCallDelta.id == null) {
                            throw new InvalidResponseDataError$1({
                              data: toolCallDelta,
                              message: `Expected 'id' to be a string.`
                            });
                          }
                          if (((_m = toolCallDelta.function) == null ? void 0 : _m.name) == null) {
                            throw new InvalidResponseDataError$1({
                              data: toolCallDelta,
                              message: `Expected 'function.name' to be a string.`
                            });
                          }
                          controller.enqueue({
                            type: "tool-input-start",
                            id: toolCallDelta.id,
                            toolName: toolCallDelta.function.name
                          });
                          toolCalls[index] = {
                            id: toolCallDelta.id,
                            type: "function",
                            function: {
                              name: toolCallDelta.function.name,
                              arguments: (_n = toolCallDelta.function.arguments) != null ? _n : ""
                            },
                            hasFinished: false
                          };
                          const toolCall2 = toolCalls[index];
                          if (((_o = toolCall2.function) == null ? void 0 : _o.name) != null && ((_p = toolCall2.function) == null ? void 0 : _p.arguments) != null) {
                            if (toolCall2.function.arguments.length > 0) {
                              controller.enqueue({
                                type: "tool-input-delta",
                                id: toolCall2.id,
                                delta: toolCall2.function.arguments
                              });
                            }
                            if (isParsableJson$1(toolCall2.function.arguments)) {
                              controller.enqueue({
                                type: "tool-input-end",
                                id: toolCall2.id
                              });
                              controller.enqueue({
                                type: "tool-call",
                                toolCallId: (_q = toolCall2.id) != null ? _q : generateId$1(),
                                toolName: toolCall2.function.name,
                                input: toolCall2.function.arguments
                              });
                              toolCall2.hasFinished = true;
                            }
                          }
                          continue;
                        }
                        const toolCall = toolCalls[index];
                        if (toolCall.hasFinished) {
                          continue;
                        }
                        if (((_r = toolCallDelta.function) == null ? void 0 : _r.arguments) != null) {
                          toolCall.function.arguments += (_t = (_s = toolCallDelta.function) == null ? void 0 : _s.arguments) != null ? _t : "";
                        }
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall.id,
                          delta: (_u = toolCallDelta.function.arguments) != null ? _u : ""
                        });
                        if (((_v = toolCall.function) == null ? void 0 : _v.name) != null && ((_w = toolCall.function) == null ? void 0 : _w.arguments) != null && isParsableJson$1(toolCall.function.arguments)) {
                          controller.enqueue({
                            type: "tool-input-end",
                            id: toolCall.id
                          });
                          controller.enqueue({
                            type: "tool-call",
                            toolCallId: (_x = toolCall.id) != null ? _x : generateId$1(),
                            toolName: toolCall.function.name,
                            input: toolCall.function.arguments
                          });
                          toolCall.hasFinished = true;
                        }
                      }
                    }
                    if (delta.annotations != null) {
                      for (const annotation of delta.annotations) {
                        controller.enqueue({
                          type: "source",
                          sourceType: "url",
                          id: generateId$1(),
                          url: annotation.url,
                          title: annotation.title
                        });
                      }
                    }
                  },
                  flush(controller) {
                    if (isActiveText) {
                      controller.enqueue({ type: "text-end", id: "0" });
                    }
                    controller.enqueue({
                      type: "finish",
                      finishReason,
                      usage,
                      ...providerMetadata != null ? { providerMetadata } : {}
                    });
                  }
                })
              ),
              request: { body },
              response: { headers: responseHeaders }
            };
          }
        };
        function isReasoningModel(modelId) {
          return (modelId.startsWith("o") || modelId.startsWith("gpt-5")) && !modelId.startsWith("gpt-5-chat");
        }
        function supportsFlexProcessing(modelId) {
          return modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
        }
        function supportsPriorityProcessing(modelId) {
          return modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
        }
        function getSystemMessageMode(modelId) {
          var _a, _b;
          if (!isReasoningModel(modelId)) {
            return "system";
          }
          return (_b = (_a = reasoningModels[modelId]) == null ? void 0 : _a.systemMessageMode) != null ? _b : "developer";
        }
        var reasoningModels = {
          "o1-mini": {
            systemMessageMode: "remove"
          },
          "o1-mini-2024-09-12": {
            systemMessageMode: "remove"
          },
          "o1-preview": {
            systemMessageMode: "remove"
          },
          "o1-preview-2024-09-12": {
            systemMessageMode: "remove"
          },
          o3: {
            systemMessageMode: "developer"
          },
          "o3-2025-04-16": {
            systemMessageMode: "developer"
          },
          "o3-mini": {
            systemMessageMode: "developer"
          },
          "o3-mini-2025-01-31": {
            systemMessageMode: "developer"
          },
          "o4-mini": {
            systemMessageMode: "developer"
          },
          "o4-mini-2025-04-16": {
            systemMessageMode: "developer"
          }
        };
        function convertToOpenAICompletionPrompt({
          prompt,
          user = "user",
          assistant = "assistant"
        }) {
          let text = "";
          if (prompt[0].role === "system") {
            text += `${prompt[0].content}

`;
            prompt = prompt.slice(1);
          }
          for (const { role, content } of prompt) {
            switch (role) {
              case "system": {
                throw new InvalidPromptError$1({
                  message: "Unexpected system message in prompt: ${content}",
                  prompt
                });
              }
              case "user": {
                const userMessage = content.map((part) => {
                  switch (part.type) {
                    case "text": {
                      return part.text;
                    }
                  }
                }).filter(Boolean).join("");
                text += `${user}:
${userMessage}

`;
                break;
              }
              case "assistant": {
                const assistantMessage = content.map((part) => {
                  switch (part.type) {
                    case "text": {
                      return part.text;
                    }
                    case "tool-call": {
                      throw new UnsupportedFunctionalityError$1({
                        functionality: "tool-call messages"
                      });
                    }
                  }
                }).join("");
                text += `${assistant}:
${assistantMessage}

`;
                break;
              }
              case "tool": {
                throw new UnsupportedFunctionalityError$1({
                  functionality: "tool messages"
                });
              }
              default: {
                const _exhaustiveCheck = role;
                throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
              }
            }
          }
          text += `${assistant}:
`;
          return {
            prompt: text,
            stopSequences: [`
${user}:`]
          };
        }

        // src/completion/get-response-metadata.ts
        function getResponseMetadata2$1({
          id,
          model,
          created
        }) {
          return {
            id: id != null ? id : void 0,
            modelId: model != null ? model : void 0,
            timestamp: created != null ? new Date(created * 1e3) : void 0
          };
        }

        // src/completion/map-openai-finish-reason.ts
        function mapOpenAIFinishReason2(finishReason) {
          switch (finishReason) {
            case "stop":
              return "stop";
            case "length":
              return "length";
            case "content_filter":
              return "content-filter";
            case "function_call":
            case "tool_calls":
              return "tool-calls";
            default:
              return "unknown";
          }
        }
        var openaiCompletionResponseSchema = lazyValidator(
          () => zodSchema(
            object({
              id: string().nullish(),
              created: number$1().nullish(),
              model: string().nullish(),
              choices: array(
                object({
                  text: string(),
                  finish_reason: string(),
                  logprobs: object({
                    tokens: array(string()),
                    token_logprobs: array(number$1()),
                    top_logprobs: array(record(string(), number$1())).nullish()
                  }).nullish()
                })
              ),
              usage: object({
                prompt_tokens: number$1(),
                completion_tokens: number$1(),
                total_tokens: number$1()
              }).nullish()
            })
          )
        );
        var openaiCompletionChunkSchema = lazyValidator(
          () => zodSchema(
            union([
              object({
                id: string().nullish(),
                created: number$1().nullish(),
                model: string().nullish(),
                choices: array(
                  object({
                    text: string(),
                    finish_reason: string().nullish(),
                    index: number$1(),
                    logprobs: object({
                      tokens: array(string()),
                      token_logprobs: array(number$1()),
                      top_logprobs: array(record(string(), number$1())).nullish()
                    }).nullish()
                  })
                ),
                usage: object({
                  prompt_tokens: number$1(),
                  completion_tokens: number$1(),
                  total_tokens: number$1()
                }).nullish()
              }),
              openaiErrorDataSchema
            ])
          )
        );
        var openaiCompletionProviderOptions = lazyValidator(
          () => zodSchema(
            object({
              /**
              Echo back the prompt in addition to the completion.
                 */
              echo: boolean().optional(),
              /**
              Modify the likelihood of specified tokens appearing in the completion.
              
              Accepts a JSON object that maps tokens (specified by their token ID in
              the GPT tokenizer) to an associated bias value from -100 to 100. You
              can use this tokenizer tool to convert text to token IDs. Mathematically,
              the bias is added to the logits generated by the model prior to sampling.
              The exact effect will vary per model, but values between -1 and 1 should
              decrease or increase likelihood of selection; values like -100 or 100
              should result in a ban or exclusive selection of the relevant token.
              
              As an example, you can pass {"50256": -100} to prevent the <|endoftext|>
              token from being generated.
               */
              logitBias: record(string(), number$1()).optional(),
              /**
              The suffix that comes after a completion of inserted text.
               */
              suffix: string().optional(),
              /**
              A unique identifier representing your end-user, which can help OpenAI to
              monitor and detect abuse. Learn more.
               */
              user: string().optional(),
              /**
              Return the log probabilities of the tokens. Including logprobs will increase
              the response size and can slow down response times. However, it can
              be useful to better understand how the model is behaving.
              Setting to true will return the log probabilities of the tokens that
              were generated.
              Setting to a number will return the log probabilities of the top n
              tokens that were generated.
                 */
              logprobs: union([boolean(), number$1()]).optional()
            })
          )
        );

        // src/completion/openai-completion-language-model.ts
        var OpenAICompletionLanguageModel = class {
          constructor(modelId, config) {
            this.specificationVersion = "v2";
            this.supportedUrls = {
              // No URLs are supported for completion models.
            };
            this.modelId = modelId;
            this.config = config;
          }
          get providerOptionsName() {
            return this.config.provider.split(".")[0].trim();
          }
          get provider() {
            return this.config.provider;
          }
          async getArgs({
            prompt,
            maxOutputTokens,
            temperature,
            topP,
            topK,
            frequencyPenalty,
            presencePenalty,
            stopSequences: userStopSequences,
            responseFormat,
            tools,
            toolChoice,
            seed,
            providerOptions
          }) {
            const warnings = [];
            const openaiOptions = {
              ...await parseProviderOptions({
                provider: "openai",
                providerOptions,
                schema: openaiCompletionProviderOptions
              }),
              ...await parseProviderOptions({
                provider: this.providerOptionsName,
                providerOptions,
                schema: openaiCompletionProviderOptions
              })
            };
            if (topK != null) {
              warnings.push({ type: "unsupported-setting", setting: "topK" });
            }
            if (tools == null ? void 0 : tools.length) {
              warnings.push({ type: "unsupported-setting", setting: "tools" });
            }
            if (toolChoice != null) {
              warnings.push({ type: "unsupported-setting", setting: "toolChoice" });
            }
            if (responseFormat != null && responseFormat.type !== "text") {
              warnings.push({
                type: "unsupported-setting",
                setting: "responseFormat",
                details: "JSON response format is not supported."
              });
            }
            const { prompt: completionPrompt, stopSequences } = convertToOpenAICompletionPrompt({ prompt });
            const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
            return {
              args: {
                // model id:
                model: this.modelId,
                // model specific settings:
                echo: openaiOptions.echo,
                logit_bias: openaiOptions.logitBias,
                logprobs: (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? 0 : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === false ? void 0 : openaiOptions == null ? void 0 : openaiOptions.logprobs,
                suffix: openaiOptions.suffix,
                user: openaiOptions.user,
                // standardized settings:
                max_tokens: maxOutputTokens,
                temperature,
                top_p: topP,
                frequency_penalty: frequencyPenalty,
                presence_penalty: presencePenalty,
                seed,
                // prompt:
                prompt: completionPrompt,
                // stop sequences:
                stop: stop.length > 0 ? stop : void 0
              },
              warnings
            };
          }
          async doGenerate(options) {
            var _a, _b, _c;
            const { args, warnings } = await this.getArgs(options);
            const {
              responseHeaders,
              value: response,
              rawValue: rawResponse
            } = await postJsonToApi$1({
              url: this.config.url({
                path: "/completions",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), options.headers),
              body: args,
              failedResponseHandler: openaiFailedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler$1(
                openaiCompletionResponseSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            const choice = response.choices[0];
            const providerMetadata = { openai: {} };
            if (choice.logprobs != null) {
              providerMetadata.openai.logprobs = choice.logprobs;
            }
            return {
              content: [{ type: "text", text: choice.text }],
              usage: {
                inputTokens: (_a = response.usage) == null ? void 0 : _a.prompt_tokens,
                outputTokens: (_b = response.usage) == null ? void 0 : _b.completion_tokens,
                totalTokens: (_c = response.usage) == null ? void 0 : _c.total_tokens
              },
              finishReason: mapOpenAIFinishReason2(choice.finish_reason),
              request: { body: args },
              response: {
                ...getResponseMetadata2$1(response),
                headers: responseHeaders,
                body: rawResponse
              },
              providerMetadata,
              warnings
            };
          }
          async doStream(options) {
            const { args, warnings } = await this.getArgs(options);
            const body = {
              ...args,
              stream: true,
              stream_options: {
                include_usage: true
              }
            };
            const { responseHeaders, value: response } = await postJsonToApi$1({
              url: this.config.url({
                path: "/completions",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), options.headers),
              body,
              failedResponseHandler: openaiFailedResponseHandler,
              successfulResponseHandler: createEventSourceResponseHandler$1(
                openaiCompletionChunkSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            let finishReason = "unknown";
            const providerMetadata = { openai: {} };
            const usage = {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            };
            let isFirstChunk = true;
            return {
              stream: response.pipeThrough(
                new TransformStream({
                  start(controller) {
                    controller.enqueue({ type: "stream-start", warnings });
                  },
                  transform(chunk, controller) {
                    if (options.includeRawChunks) {
                      controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                    }
                    if (!chunk.success) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: chunk.error });
                      return;
                    }
                    const value = chunk.value;
                    if ("error" in value) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: value.error });
                      return;
                    }
                    if (isFirstChunk) {
                      isFirstChunk = false;
                      controller.enqueue({
                        type: "response-metadata",
                        ...getResponseMetadata2$1(value)
                      });
                      controller.enqueue({ type: "text-start", id: "0" });
                    }
                    if (value.usage != null) {
                      usage.inputTokens = value.usage.prompt_tokens;
                      usage.outputTokens = value.usage.completion_tokens;
                      usage.totalTokens = value.usage.total_tokens;
                    }
                    const choice = value.choices[0];
                    if ((choice == null ? void 0 : choice.finish_reason) != null) {
                      finishReason = mapOpenAIFinishReason2(choice.finish_reason);
                    }
                    if ((choice == null ? void 0 : choice.logprobs) != null) {
                      providerMetadata.openai.logprobs = choice.logprobs;
                    }
                    if ((choice == null ? void 0 : choice.text) != null && choice.text.length > 0) {
                      controller.enqueue({
                        type: "text-delta",
                        id: "0",
                        delta: choice.text
                      });
                    }
                  },
                  flush(controller) {
                    if (!isFirstChunk) {
                      controller.enqueue({ type: "text-end", id: "0" });
                    }
                    controller.enqueue({
                      type: "finish",
                      finishReason,
                      providerMetadata,
                      usage
                    });
                  }
                })
              ),
              request: { body },
              response: { headers: responseHeaders }
            };
          }
        };
        var openaiEmbeddingProviderOptions = lazyValidator(
          () => zodSchema(
            object({
              /**
              The number of dimensions the resulting output embeddings should have.
              Only supported in text-embedding-3 and later models.
                 */
              dimensions: number$1().optional(),
              /**
              A unique identifier representing your end-user, which can help OpenAI to
              monitor and detect abuse. Learn more.
              */
              user: string().optional()
            })
          )
        );
        var openaiTextEmbeddingResponseSchema$1 = lazyValidator(
          () => zodSchema(
            object({
              data: array(object({ embedding: array(number$1()) })),
              usage: object({ prompt_tokens: number$1() }).nullish()
            })
          )
        );

        // src/embedding/openai-embedding-model.ts
        var OpenAIEmbeddingModel = class {
          constructor(modelId, config) {
            this.specificationVersion = "v2";
            this.maxEmbeddingsPerCall = 2048;
            this.supportsParallelCalls = true;
            this.modelId = modelId;
            this.config = config;
          }
          get provider() {
            return this.config.provider;
          }
          async doEmbed({
            values,
            headers,
            abortSignal,
            providerOptions
          }) {
            var _a;
            if (values.length > this.maxEmbeddingsPerCall) {
              throw new TooManyEmbeddingValuesForCallError({
                provider: this.provider,
                modelId: this.modelId,
                maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
                values
              });
            }
            const openaiOptions = (_a = await parseProviderOptions({
              provider: "openai",
              providerOptions,
              schema: openaiEmbeddingProviderOptions
            })) != null ? _a : {};
            const {
              responseHeaders,
              value: response,
              rawValue
            } = await postJsonToApi$1({
              url: this.config.url({
                path: "/embeddings",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), headers),
              body: {
                model: this.modelId,
                input: values,
                encoding_format: "float",
                dimensions: openaiOptions.dimensions,
                user: openaiOptions.user
              },
              failedResponseHandler: openaiFailedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler$1(
                openaiTextEmbeddingResponseSchema$1
              ),
              abortSignal,
              fetch: this.config.fetch
            });
            return {
              embeddings: response.data.map((item) => item.embedding),
              usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
              response: { headers: responseHeaders, body: rawValue }
            };
          }
        };
        var openaiImageResponseSchema = lazyValidator(
          () => zodSchema(
            object({
              data: array(
                object({
                  b64_json: string(),
                  revised_prompt: string().optional()
                })
              )
            })
          )
        );

        // src/image/openai-image-options.ts
        var modelMaxImagesPerCall$1 = {
          "dall-e-3": 1,
          "dall-e-2": 10,
          "gpt-image-1": 10,
          "gpt-image-1-mini": 10
        };
        var hasDefaultResponseFormat = /* @__PURE__ */ new Set([
          "gpt-image-1",
          "gpt-image-1-mini"
        ]);

        // src/image/openai-image-model.ts
        var OpenAIImageModel = class {
          constructor(modelId, config) {
            this.modelId = modelId;
            this.config = config;
            this.specificationVersion = "v2";
          }
          get maxImagesPerCall() {
            var _a;
            return (_a = modelMaxImagesPerCall$1[this.modelId]) != null ? _a : 1;
          }
          get provider() {
            return this.config.provider;
          }
          async doGenerate({
            prompt,
            n,
            size,
            aspectRatio,
            seed,
            providerOptions,
            headers,
            abortSignal
          }) {
            var _a, _b, _c, _d;
            const warnings = [];
            if (aspectRatio != null) {
              warnings.push({
                type: "unsupported-setting",
                setting: "aspectRatio",
                details: "This model does not support aspect ratio. Use `size` instead."
              });
            }
            if (seed != null) {
              warnings.push({ type: "unsupported-setting", setting: "seed" });
            }
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const { value: response, responseHeaders } = await postJsonToApi$1({
              url: this.config.url({
                path: "/images/generations",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), headers),
              body: {
                model: this.modelId,
                prompt,
                n,
                size,
                ...(_d = providerOptions.openai) != null ? _d : {},
                ...!hasDefaultResponseFormat.has(this.modelId) ? { response_format: "b64_json" } : {}
              },
              failedResponseHandler: openaiFailedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler$1(
                openaiImageResponseSchema
              ),
              abortSignal,
              fetch: this.config.fetch
            });
            return {
              images: response.data.map((item) => item.b64_json),
              warnings,
              response: {
                timestamp: currentDate,
                modelId: this.modelId,
                headers: responseHeaders
              },
              providerMetadata: {
                openai: {
                  images: response.data.map(
                    (item) => item.revised_prompt ? {
                      revisedPrompt: item.revised_prompt
                    } : null
                  )
                }
              }
            };
          }
        };
        var codeInterpreterInputSchema = lazySchema(
          () => zodSchema(
            object({
              code: string().nullish(),
              containerId: string()
            })
          )
        );
        var codeInterpreterOutputSchema = lazySchema(
          () => zodSchema(
            object({
              outputs: array(
                discriminatedUnion("type", [
                  object({ type: literal("logs"), logs: string() }),
                  object({ type: literal("image"), url: string() })
                ])
              ).nullish()
            })
          )
        );
        var codeInterpreterArgsSchema = lazySchema(
          () => zodSchema(
            object({
              container: union([
                string(),
                object({
                  fileIds: array(string()).optional()
                })
              ]).optional()
            })
          )
        );
        var codeInterpreterToolFactory = createProviderDefinedToolFactoryWithOutputSchema({
          id: "openai.code_interpreter",
          name: "code_interpreter",
          inputSchema: codeInterpreterInputSchema,
          outputSchema: codeInterpreterOutputSchema
        });
        var codeInterpreter = (args = {}) => {
          return codeInterpreterToolFactory(args);
        };
        var comparisonFilterSchema = object({
          key: string(),
          type: _enum(["eq", "ne", "gt", "gte", "lt", "lte"]),
          value: union([string(), number$1(), boolean()])
        });
        var compoundFilterSchema = object({
          type: _enum(["and", "or"]),
          filters: array(
            union([comparisonFilterSchema, lazy(() => compoundFilterSchema)])
          )
        });
        var fileSearchArgsSchema = lazySchema(
          () => zodSchema(
            object({
              vectorStoreIds: array(string()),
              maxNumResults: number$1().optional(),
              ranking: object({
                ranker: string().optional(),
                scoreThreshold: number$1().optional()
              }).optional(),
              filters: union([comparisonFilterSchema, compoundFilterSchema]).optional()
            })
          )
        );
        var fileSearchOutputSchema = lazySchema(
          () => zodSchema(
            object({
              queries: array(string()),
              results: array(
                object({
                  attributes: record(string(), unknown()),
                  fileId: string(),
                  filename: string(),
                  score: number$1(),
                  text: string()
                })
              ).nullable()
            })
          )
        );
        var fileSearch = createProviderDefinedToolFactoryWithOutputSchema({
          id: "openai.file_search",
          name: "file_search",
          inputSchema: object({}),
          outputSchema: fileSearchOutputSchema
        });
        var imageGenerationArgsSchema = lazySchema(
          () => zodSchema(
            object({
              background: _enum(["auto", "opaque", "transparent"]).optional(),
              inputFidelity: _enum(["low", "high"]).optional(),
              inputImageMask: object({
                fileId: string().optional(),
                imageUrl: string().optional()
              }).optional(),
              model: string().optional(),
              moderation: _enum(["auto"]).optional(),
              outputCompression: number$1().int().min(0).max(100).optional(),
              outputFormat: _enum(["png", "jpeg", "webp"]).optional(),
              partialImages: number$1().int().min(0).max(3).optional(),
              quality: _enum(["auto", "low", "medium", "high"]).optional(),
              size: _enum(["1024x1024", "1024x1536", "1536x1024", "auto"]).optional()
            }).strict()
          )
        );
        var imageGenerationInputSchema = lazySchema(() => zodSchema(object({})));
        var imageGenerationOutputSchema = lazySchema(
          () => zodSchema(object({ result: string() }))
        );
        var imageGenerationToolFactory = createProviderDefinedToolFactoryWithOutputSchema({
          id: "openai.image_generation",
          name: "image_generation",
          inputSchema: imageGenerationInputSchema,
          outputSchema: imageGenerationOutputSchema
        });
        var imageGeneration = (args = {}) => {
          return imageGenerationToolFactory(args);
        };
        var localShellInputSchema = lazySchema(
          () => zodSchema(
            object({
              action: object({
                type: literal("exec"),
                command: array(string()),
                timeoutMs: number$1().optional(),
                user: string().optional(),
                workingDirectory: string().optional(),
                env: record(string(), string()).optional()
              })
            })
          )
        );
        var localShellOutputSchema = lazySchema(
          () => zodSchema(object({ output: string() }))
        );
        var localShell = createProviderDefinedToolFactoryWithOutputSchema({
          id: "openai.local_shell",
          name: "local_shell",
          inputSchema: localShellInputSchema,
          outputSchema: localShellOutputSchema
        });
        var webSearchArgsSchema = lazySchema(
          () => zodSchema(
            object({
              filters: object({ allowedDomains: array(string()).optional() }).optional(),
              searchContextSize: _enum(["low", "medium", "high"]).optional(),
              userLocation: object({
                type: literal("approximate"),
                country: string().optional(),
                city: string().optional(),
                region: string().optional(),
                timezone: string().optional()
              }).optional()
            })
          )
        );
        var webSearchInputSchema = lazySchema(() => zodSchema(object({})));
        var webSearchOutputSchema = lazySchema(
          () => zodSchema(
            object({
              action: discriminatedUnion("type", [
                object({
                  type: literal("search"),
                  query: string().optional()
                }),
                object({
                  type: literal("openPage"),
                  url: string()
                }),
                object({
                  type: literal("find"),
                  url: string(),
                  pattern: string()
                })
              ])
            })
          )
        );
        var webSearchToolFactory = createProviderDefinedToolFactoryWithOutputSchema({
          id: "openai.web_search",
          name: "web_search",
          inputSchema: webSearchInputSchema,
          outputSchema: webSearchOutputSchema
        });
        var webSearch = (args = {}) => webSearchToolFactory(args);
        var webSearchPreviewArgsSchema = lazySchema(
          () => zodSchema(
            object({
              searchContextSize: _enum(["low", "medium", "high"]).optional(),
              userLocation: object({
                type: literal("approximate"),
                country: string().optional(),
                city: string().optional(),
                region: string().optional(),
                timezone: string().optional()
              }).optional()
            })
          )
        );
        var webSearchPreviewInputSchema = lazySchema(
          () => zodSchema(object({}))
        );
        var webSearchPreviewOutputSchema = lazySchema(
          () => zodSchema(
            object({
              action: discriminatedUnion("type", [
                object({
                  type: literal("search"),
                  query: string().optional()
                }),
                object({
                  type: literal("openPage"),
                  url: string()
                }),
                object({
                  type: literal("find"),
                  url: string(),
                  pattern: string()
                })
              ])
            })
          )
        );
        var webSearchPreview = createProviderDefinedToolFactoryWithOutputSchema({
          id: "openai.web_search_preview",
          name: "web_search_preview",
          inputSchema: webSearchPreviewInputSchema,
          outputSchema: webSearchPreviewOutputSchema
        });

        // src/openai-tools.ts
        var openaiTools = {
          /**
           * The Code Interpreter tool allows models to write and run Python code in a
           * sandboxed environment to solve complex problems in domains like data analysis,
           * coding, and math.
           *
           * @param container - The container to use for the code interpreter.
           *
           * Must have name `code_interpreter`.
           */
          codeInterpreter,
          /**
           * File search is a tool available in the Responses API. It enables models to
           * retrieve information in a knowledge base of previously uploaded files through
           * semantic and keyword search.
           *
           * Must have name `file_search`.
           *
           * @param vectorStoreIds - The vector store IDs to use for the file search.
           * @param maxNumResults - The maximum number of results to return.
           * @param ranking - The ranking options to use for the file search.
           * @param filters - The filters to use for the file search.
           */
          fileSearch,
          /**
           * The image generation tool allows you to generate images using a text prompt,
           * and optionally image inputs. It leverages the GPT Image model,
           * and automatically optimizes text inputs for improved performance.
           *
           * Must have name `image_generation`.
           *
           * @param size - Image dimensions (e.g., 1024x1024, 1024x1536)
           * @param quality - Rendering quality (e.g. low, medium, high)
           * @param format - File output format
           * @param compression - Compression level (0-100%) for JPEG and WebP formats
           * @param background - Transparent or opaque
           */
          imageGeneration,
          /**
           * Local shell is a tool that allows agents to run shell commands locally
           * on a machine you or the user provides.
           *
           * Supported models: `gpt-5-codex` and `codex-mini-latest`
           *
           * Must have name `local_shell`.
           */
          localShell,
          /**
           * Web search allows models to access up-to-date information from the internet
           * and provide answers with sourced citations.
           *
           * Must have name `web_search_preview`.
           *
           * @param searchContextSize - The search context size to use for the web search.
           * @param userLocation - The user location to use for the web search.
           *
           * @deprecated Use `webSearch` instead.
           */
          webSearchPreview,
          /**
           * Web search allows models to access up-to-date information from the internet
           * and provide answers with sourced citations.
           *
           * Must have name `web_search`.
           *
           * @param filters - The filters to use for the web search.
           * @param searchContextSize - The search context size to use for the web search.
           * @param userLocation - The user location to use for the web search.
           */
          webSearch
        };
        function isFileId(data, prefixes) {
          if (!prefixes) return false;
          return prefixes.some((prefix) => data.startsWith(prefix));
        }
        async function convertToOpenAIResponsesInput({
          prompt,
          systemMessageMode,
          fileIdPrefixes,
          store,
          hasLocalShellTool = false
        }) {
          var _a, _b, _c, _d;
          const input = [];
          const warnings = [];
          for (const { role, content } of prompt) {
            switch (role) {
              case "system": {
                switch (systemMessageMode) {
                  case "system": {
                    input.push({ role: "system", content });
                    break;
                  }
                  case "developer": {
                    input.push({ role: "developer", content });
                    break;
                  }
                  case "remove": {
                    warnings.push({
                      type: "other",
                      message: "system messages are removed for this model"
                    });
                    break;
                  }
                  default: {
                    const _exhaustiveCheck = systemMessageMode;
                    throw new Error(
                      `Unsupported system message mode: ${_exhaustiveCheck}`
                    );
                  }
                }
                break;
              }
              case "user": {
                input.push({
                  role: "user",
                  content: content.map((part, index) => {
                    var _a2, _b2, _c2;
                    switch (part.type) {
                      case "text": {
                        return { type: "input_text", text: part.text };
                      }
                      case "file": {
                        if (part.mediaType.startsWith("image/")) {
                          const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                          return {
                            type: "input_image",
                            ...part.data instanceof URL ? { image_url: part.data.toString() } : typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                              image_url: `data:${mediaType};base64,${convertToBase64(part.data)}`
                            },
                            detail: (_b2 = (_a2 = part.providerOptions) == null ? void 0 : _a2.openai) == null ? void 0 : _b2.imageDetail
                          };
                        } else if (part.mediaType === "application/pdf") {
                          if (part.data instanceof URL) {
                            return {
                              type: "input_file",
                              file_url: part.data.toString()
                            };
                          }
                          return {
                            type: "input_file",
                            ...typeof part.data === "string" && isFileId(part.data, fileIdPrefixes) ? { file_id: part.data } : {
                              filename: (_c2 = part.filename) != null ? _c2 : `part-${index}.pdf`,
                              file_data: `data:application/pdf;base64,${convertToBase64(part.data)}`
                            }
                          };
                        } else {
                          throw new UnsupportedFunctionalityError$1({
                            functionality: `file part media type ${part.mediaType}`
                          });
                        }
                      }
                    }
                  })
                });
                break;
              }
              case "assistant": {
                const reasoningMessages = {};
                const toolCallParts = {};
                for (const part of content) {
                  switch (part.type) {
                    case "text": {
                      const id = (_b = (_a = part.providerOptions) == null ? void 0 : _a.openai) == null ? void 0 : _b.itemId;
                      if (store && id != null) {
                        input.push({ type: "item_reference", id });
                        break;
                      }
                      input.push({
                        role: "assistant",
                        content: [{ type: "output_text", text: part.text }],
                        id
                      });
                      break;
                    }
                    case "tool-call": {
                      toolCallParts[part.toolCallId] = part;
                      if (part.providerExecuted) {
                        break;
                      }
                      const id = (_d = (_c = part.providerOptions) == null ? void 0 : _c.openai) == null ? void 0 : _d.itemId;
                      if (store && id != null) {
                        input.push({ type: "item_reference", id });
                        break;
                      }
                      if (hasLocalShellTool && part.toolName === "local_shell") {
                        const parsedInput = await validateTypes$1({
                          value: part.input,
                          schema: localShellInputSchema
                        });
                        input.push({
                          type: "local_shell_call",
                          call_id: part.toolCallId,
                          id,
                          action: {
                            type: "exec",
                            command: parsedInput.action.command,
                            timeout_ms: parsedInput.action.timeoutMs,
                            user: parsedInput.action.user,
                            working_directory: parsedInput.action.workingDirectory,
                            env: parsedInput.action.env
                          }
                        });
                        break;
                      }
                      input.push({
                        type: "function_call",
                        call_id: part.toolCallId,
                        name: part.toolName,
                        arguments: JSON.stringify(part.input),
                        id
                      });
                      break;
                    }
                    // assistant tool result parts are from provider-executed tools:
                    case "tool-result": {
                      if (store) {
                        input.push({ type: "item_reference", id: part.toolCallId });
                      } else {
                        warnings.push({
                          type: "other",
                          message: `Results for OpenAI tool ${part.toolName} are not sent to the API when store is false`
                        });
                      }
                      break;
                    }
                    case "reasoning": {
                      const providerOptions = await parseProviderOptions({
                        provider: "openai",
                        providerOptions: part.providerOptions,
                        schema: openaiResponsesReasoningProviderOptionsSchema
                      });
                      const reasoningId = providerOptions == null ? void 0 : providerOptions.itemId;
                      if (reasoningId != null) {
                        const reasoningMessage = reasoningMessages[reasoningId];
                        if (store) {
                          if (reasoningMessage === void 0) {
                            input.push({ type: "item_reference", id: reasoningId });
                            reasoningMessages[reasoningId] = {
                              type: "reasoning",
                              id: reasoningId,
                              summary: []
                            };
                          }
                        } else {
                          const summaryParts = [];
                          if (part.text.length > 0) {
                            summaryParts.push({
                              type: "summary_text",
                              text: part.text
                            });
                          } else if (reasoningMessage !== void 0) {
                            warnings.push({
                              type: "other",
                              message: `Cannot append empty reasoning part to existing reasoning sequence. Skipping reasoning part: ${JSON.stringify(part)}.`
                            });
                          }
                          if (reasoningMessage === void 0) {
                            reasoningMessages[reasoningId] = {
                              type: "reasoning",
                              id: reasoningId,
                              encrypted_content: providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent,
                              summary: summaryParts
                            };
                            input.push(reasoningMessages[reasoningId]);
                          } else {
                            reasoningMessage.summary.push(...summaryParts);
                            if ((providerOptions == null ? void 0 : providerOptions.reasoningEncryptedContent) != null) {
                              reasoningMessage.encrypted_content = providerOptions.reasoningEncryptedContent;
                            }
                          }
                        }
                      } else {
                        warnings.push({
                          type: "other",
                          message: `Non-OpenAI reasoning parts are not supported. Skipping reasoning part: ${JSON.stringify(part)}.`
                        });
                      }
                      break;
                    }
                  }
                }
                break;
              }
              case "tool": {
                for (const part of content) {
                  const output = part.output;
                  if (hasLocalShellTool && part.toolName === "local_shell" && output.type === "json") {
                    const parsedOutput = await validateTypes$1({
                      value: output.value,
                      schema: localShellOutputSchema
                    });
                    input.push({
                      type: "local_shell_call_output",
                      call_id: part.toolCallId,
                      output: parsedOutput.output
                    });
                    break;
                  }
                  let contentValue;
                  switch (output.type) {
                    case "text":
                    case "error-text":
                      contentValue = output.value;
                      break;
                    case "json":
                    case "error-json":
                      contentValue = JSON.stringify(output.value);
                      break;
                    case "content":
                      contentValue = output.value.map((item) => {
                        switch (item.type) {
                          case "text": {
                            return { type: "input_text", text: item.text };
                          }
                          case "media": {
                            return item.mediaType.startsWith("image/") ? {
                              type: "input_image",
                              image_url: `data:${item.mediaType};base64,${item.data}`
                            } : {
                              type: "input_file",
                              filename: "data",
                              file_data: `data:${item.mediaType};base64,${item.data}`
                            };
                          }
                        }
                      });
                      break;
                  }
                  input.push({
                    type: "function_call_output",
                    call_id: part.toolCallId,
                    output: contentValue
                  });
                }
                break;
              }
              default: {
                const _exhaustiveCheck = role;
                throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
              }
            }
          }
          return { input, warnings };
        }
        var openaiResponsesReasoningProviderOptionsSchema = object({
          itemId: string().nullish(),
          reasoningEncryptedContent: string().nullish()
        });

        // src/responses/map-openai-responses-finish-reason.ts
        function mapOpenAIResponseFinishReason({
          finishReason,
          hasFunctionCall
        }) {
          switch (finishReason) {
            case void 0:
            case null:
              return hasFunctionCall ? "tool-calls" : "stop";
            case "max_output_tokens":
              return "length";
            case "content_filter":
              return "content-filter";
            default:
              return hasFunctionCall ? "tool-calls" : "unknown";
          }
        }
        var openaiResponsesChunkSchema = lazyValidator(
          () => zodSchema(
            union([
              object({
                type: literal("response.output_text.delta"),
                item_id: string(),
                delta: string(),
                logprobs: array(
                  object({
                    token: string(),
                    logprob: number$1(),
                    top_logprobs: array(
                      object({
                        token: string(),
                        logprob: number$1()
                      })
                    )
                  })
                ).nullish()
              }),
              object({
                type: _enum(["response.completed", "response.incomplete"]),
                response: object({
                  incomplete_details: object({ reason: string() }).nullish(),
                  usage: object({
                    input_tokens: number$1(),
                    input_tokens_details: object({ cached_tokens: number$1().nullish() }).nullish(),
                    output_tokens: number$1(),
                    output_tokens_details: object({ reasoning_tokens: number$1().nullish() }).nullish()
                  }),
                  service_tier: string().nullish()
                })
              }),
              object({
                type: literal("response.created"),
                response: object({
                  id: string(),
                  created_at: number$1(),
                  model: string(),
                  service_tier: string().nullish()
                })
              }),
              object({
                type: literal("response.output_item.added"),
                output_index: number$1(),
                item: discriminatedUnion("type", [
                  object({
                    type: literal("message"),
                    id: string()
                  }),
                  object({
                    type: literal("reasoning"),
                    id: string(),
                    encrypted_content: string().nullish()
                  }),
                  object({
                    type: literal("function_call"),
                    id: string(),
                    call_id: string(),
                    name: string(),
                    arguments: string()
                  }),
                  object({
                    type: literal("web_search_call"),
                    id: string(),
                    status: string()
                  }),
                  object({
                    type: literal("computer_call"),
                    id: string(),
                    status: string()
                  }),
                  object({
                    type: literal("file_search_call"),
                    id: string()
                  }),
                  object({
                    type: literal("image_generation_call"),
                    id: string()
                  }),
                  object({
                    type: literal("code_interpreter_call"),
                    id: string(),
                    container_id: string(),
                    code: string().nullable(),
                    outputs: array(
                      discriminatedUnion("type", [
                        object({ type: literal("logs"), logs: string() }),
                        object({ type: literal("image"), url: string() })
                      ])
                    ).nullable(),
                    status: string()
                  })
                ])
              }),
              object({
                type: literal("response.output_item.done"),
                output_index: number$1(),
                item: discriminatedUnion("type", [
                  object({
                    type: literal("message"),
                    id: string()
                  }),
                  object({
                    type: literal("reasoning"),
                    id: string(),
                    encrypted_content: string().nullish()
                  }),
                  object({
                    type: literal("function_call"),
                    id: string(),
                    call_id: string(),
                    name: string(),
                    arguments: string(),
                    status: literal("completed")
                  }),
                  object({
                    type: literal("code_interpreter_call"),
                    id: string(),
                    code: string().nullable(),
                    container_id: string(),
                    outputs: array(
                      discriminatedUnion("type", [
                        object({ type: literal("logs"), logs: string() }),
                        object({ type: literal("image"), url: string() })
                      ])
                    ).nullable()
                  }),
                  object({
                    type: literal("image_generation_call"),
                    id: string(),
                    result: string()
                  }),
                  object({
                    type: literal("web_search_call"),
                    id: string(),
                    status: string(),
                    action: discriminatedUnion("type", [
                      object({
                        type: literal("search"),
                        query: string().nullish()
                      }),
                      object({
                        type: literal("open_page"),
                        url: string()
                      }),
                      object({
                        type: literal("find"),
                        url: string(),
                        pattern: string()
                      })
                    ])
                  }),
                  object({
                    type: literal("file_search_call"),
                    id: string(),
                    queries: array(string()),
                    results: array(
                      object({
                        attributes: record(string(), unknown()),
                        file_id: string(),
                        filename: string(),
                        score: number$1(),
                        text: string()
                      })
                    ).nullish()
                  }),
                  object({
                    type: literal("local_shell_call"),
                    id: string(),
                    call_id: string(),
                    action: object({
                      type: literal("exec"),
                      command: array(string()),
                      timeout_ms: number$1().optional(),
                      user: string().optional(),
                      working_directory: string().optional(),
                      env: record(string(), string()).optional()
                    })
                  }),
                  object({
                    type: literal("computer_call"),
                    id: string(),
                    status: literal("completed")
                  })
                ])
              }),
              object({
                type: literal("response.function_call_arguments.delta"),
                item_id: string(),
                output_index: number$1(),
                delta: string()
              }),
              object({
                type: literal("response.image_generation_call.partial_image"),
                item_id: string(),
                output_index: number$1(),
                partial_image_b64: string()
              }),
              object({
                type: literal("response.code_interpreter_call_code.delta"),
                item_id: string(),
                output_index: number$1(),
                delta: string()
              }),
              object({
                type: literal("response.code_interpreter_call_code.done"),
                item_id: string(),
                output_index: number$1(),
                code: string()
              }),
              object({
                type: literal("response.output_text.annotation.added"),
                annotation: discriminatedUnion("type", [
                  object({
                    type: literal("url_citation"),
                    url: string(),
                    title: string()
                  }),
                  object({
                    type: literal("file_citation"),
                    file_id: string(),
                    filename: string().nullish(),
                    index: number$1().nullish(),
                    start_index: number$1().nullish(),
                    end_index: number$1().nullish(),
                    quote: string().nullish()
                  })
                ])
              }),
              object({
                type: literal("response.reasoning_summary_part.added"),
                item_id: string(),
                summary_index: number$1()
              }),
              object({
                type: literal("response.reasoning_summary_text.delta"),
                item_id: string(),
                summary_index: number$1(),
                delta: string()
              }),
              object({
                type: literal("response.reasoning_summary_part.done"),
                item_id: string(),
                summary_index: number$1()
              }),
              object({
                type: literal("error"),
                code: string(),
                message: string(),
                param: string().nullish(),
                sequence_number: number$1()
              }),
              object({ type: string() }).loose().transform((value) => ({
                type: "unknown_chunk",
                message: value.type
              }))
              // fallback for unknown chunks
            ])
          )
        );
        var openaiResponsesResponseSchema = lazyValidator(
          () => zodSchema(
            object({
              id: string(),
              created_at: number$1(),
              error: object({
                code: string(),
                message: string()
              }).nullish(),
              model: string(),
              output: array(
                discriminatedUnion("type", [
                  object({
                    type: literal("message"),
                    role: literal("assistant"),
                    id: string(),
                    content: array(
                      object({
                        type: literal("output_text"),
                        text: string(),
                        logprobs: array(
                          object({
                            token: string(),
                            logprob: number$1(),
                            top_logprobs: array(
                              object({
                                token: string(),
                                logprob: number$1()
                              })
                            )
                          })
                        ).nullish(),
                        annotations: array(
                          discriminatedUnion("type", [
                            object({
                              type: literal("url_citation"),
                              start_index: number$1(),
                              end_index: number$1(),
                              url: string(),
                              title: string()
                            }),
                            object({
                              type: literal("file_citation"),
                              file_id: string(),
                              filename: string().nullish(),
                              index: number$1().nullish(),
                              start_index: number$1().nullish(),
                              end_index: number$1().nullish(),
                              quote: string().nullish()
                            }),
                            object({
                              type: literal("container_file_citation")
                            })
                          ])
                        )
                      })
                    )
                  }),
                  object({
                    type: literal("web_search_call"),
                    id: string(),
                    status: string(),
                    action: discriminatedUnion("type", [
                      object({
                        type: literal("search"),
                        query: string().nullish()
                      }),
                      object({
                        type: literal("open_page"),
                        url: string()
                      }),
                      object({
                        type: literal("find"),
                        url: string(),
                        pattern: string()
                      })
                    ])
                  }),
                  object({
                    type: literal("file_search_call"),
                    id: string(),
                    queries: array(string()),
                    results: array(
                      object({
                        attributes: record(string(), unknown()),
                        file_id: string(),
                        filename: string(),
                        score: number$1(),
                        text: string()
                      })
                    ).nullish()
                  }),
                  object({
                    type: literal("code_interpreter_call"),
                    id: string(),
                    code: string().nullable(),
                    container_id: string(),
                    outputs: array(
                      discriminatedUnion("type", [
                        object({ type: literal("logs"), logs: string() }),
                        object({ type: literal("image"), url: string() })
                      ])
                    ).nullable()
                  }),
                  object({
                    type: literal("image_generation_call"),
                    id: string(),
                    result: string()
                  }),
                  object({
                    type: literal("local_shell_call"),
                    id: string(),
                    call_id: string(),
                    action: object({
                      type: literal("exec"),
                      command: array(string()),
                      timeout_ms: number$1().optional(),
                      user: string().optional(),
                      working_directory: string().optional(),
                      env: record(string(), string()).optional()
                    })
                  }),
                  object({
                    type: literal("function_call"),
                    call_id: string(),
                    name: string(),
                    arguments: string(),
                    id: string()
                  }),
                  object({
                    type: literal("computer_call"),
                    id: string(),
                    status: string().optional()
                  }),
                  object({
                    type: literal("reasoning"),
                    id: string(),
                    encrypted_content: string().nullish(),
                    summary: array(
                      object({
                        type: literal("summary_text"),
                        text: string()
                      })
                    )
                  })
                ])
              ),
              service_tier: string().nullish(),
              incomplete_details: object({ reason: string() }).nullish(),
              usage: object({
                input_tokens: number$1(),
                input_tokens_details: object({ cached_tokens: number$1().nullish() }).nullish(),
                output_tokens: number$1(),
                output_tokens_details: object({ reasoning_tokens: number$1().nullish() }).nullish()
              })
            })
          )
        );
        var TOP_LOGPROBS_MAX = 20;
        var openaiResponsesProviderOptionsSchema = lazyValidator(
          () => zodSchema(
            object({
              include: array(
                _enum([
                  "reasoning.encrypted_content",
                  // handled internally by default, only needed for unknown reasoning models
                  "file_search_call.results",
                  "message.output_text.logprobs"
                ])
              ).nullish(),
              instructions: string().nullish(),
              /**
               * Return the log probabilities of the tokens.
               *
               * Setting to true will return the log probabilities of the tokens that
               * were generated.
               *
               * Setting to a number will return the log probabilities of the top n
               * tokens that were generated.
               *
               * @see https://platform.openai.com/docs/api-reference/responses/create
               * @see https://cookbook.openai.com/examples/using_logprobs
               */
              logprobs: union([boolean(), number$1().min(1).max(TOP_LOGPROBS_MAX)]).optional(),
              /**
               * The maximum number of total calls to built-in tools that can be processed in a response.
               * This maximum number applies across all built-in tool calls, not per individual tool.
               * Any further attempts to call a tool by the model will be ignored.
               */
              maxToolCalls: number$1().nullish(),
              metadata: any().nullish(),
              parallelToolCalls: boolean().nullish(),
              previousResponseId: string().nullish(),
              promptCacheKey: string().nullish(),
              reasoningEffort: string().nullish(),
              reasoningSummary: string().nullish(),
              safetyIdentifier: string().nullish(),
              serviceTier: _enum(["auto", "flex", "priority", "default"]).nullish(),
              store: boolean().nullish(),
              strictJsonSchema: boolean().nullish(),
              textVerbosity: _enum(["low", "medium", "high"]).nullish(),
              user: string().nullish()
            })
          )
        );
        async function prepareResponsesTools({
          tools,
          toolChoice,
          strictJsonSchema
        }) {
          tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
          const toolWarnings = [];
          if (tools == null) {
            return { tools: void 0, toolChoice: void 0, toolWarnings };
          }
          const openaiTools2 = [];
          for (const tool of tools) {
            switch (tool.type) {
              case "function":
                openaiTools2.push({
                  type: "function",
                  name: tool.name,
                  description: tool.description,
                  parameters: tool.inputSchema,
                  strict: strictJsonSchema
                });
                break;
              case "provider-defined": {
                switch (tool.id) {
                  case "openai.file_search": {
                    const args = await validateTypes$1({
                      value: tool.args,
                      schema: fileSearchArgsSchema
                    });
                    openaiTools2.push({
                      type: "file_search",
                      vector_store_ids: args.vectorStoreIds,
                      max_num_results: args.maxNumResults,
                      ranking_options: args.ranking ? {
                        ranker: args.ranking.ranker,
                        score_threshold: args.ranking.scoreThreshold
                      } : void 0,
                      filters: args.filters
                    });
                    break;
                  }
                  case "openai.local_shell": {
                    openaiTools2.push({
                      type: "local_shell"
                    });
                    break;
                  }
                  case "openai.web_search_preview": {
                    const args = await validateTypes$1({
                      value: tool.args,
                      schema: webSearchPreviewArgsSchema
                    });
                    openaiTools2.push({
                      type: "web_search_preview",
                      search_context_size: args.searchContextSize,
                      user_location: args.userLocation
                    });
                    break;
                  }
                  case "openai.web_search": {
                    const args = await validateTypes$1({
                      value: tool.args,
                      schema: webSearchArgsSchema
                    });
                    openaiTools2.push({
                      type: "web_search",
                      filters: args.filters != null ? { allowed_domains: args.filters.allowedDomains } : void 0,
                      search_context_size: args.searchContextSize,
                      user_location: args.userLocation
                    });
                    break;
                  }
                  case "openai.code_interpreter": {
                    const args = await validateTypes$1({
                      value: tool.args,
                      schema: codeInterpreterArgsSchema
                    });
                    openaiTools2.push({
                      type: "code_interpreter",
                      container: args.container == null ? { type: "auto", file_ids: void 0 } : typeof args.container === "string" ? args.container : { type: "auto", file_ids: args.container.fileIds }
                    });
                    break;
                  }
                  case "openai.image_generation": {
                    const args = await validateTypes$1({
                      value: tool.args,
                      schema: imageGenerationArgsSchema
                    });
                    openaiTools2.push({
                      type: "image_generation",
                      background: args.background,
                      input_fidelity: args.inputFidelity,
                      input_image_mask: args.inputImageMask ? {
                        file_id: args.inputImageMask.fileId,
                        image_url: args.inputImageMask.imageUrl
                      } : void 0,
                      model: args.model,
                      size: args.size,
                      quality: args.quality,
                      moderation: args.moderation,
                      output_format: args.outputFormat,
                      output_compression: args.outputCompression
                    });
                    break;
                  }
                }
                break;
              }
              default:
                toolWarnings.push({ type: "unsupported-tool", tool });
                break;
            }
          }
          if (toolChoice == null) {
            return { tools: openaiTools2, toolChoice: void 0, toolWarnings };
          }
          const type = toolChoice.type;
          switch (type) {
            case "auto":
            case "none":
            case "required":
              return { tools: openaiTools2, toolChoice: type, toolWarnings };
            case "tool":
              return {
                tools: openaiTools2,
                toolChoice: toolChoice.toolName === "code_interpreter" || toolChoice.toolName === "file_search" || toolChoice.toolName === "image_generation" || toolChoice.toolName === "web_search_preview" || toolChoice.toolName === "web_search" ? { type: toolChoice.toolName } : { type: "function", name: toolChoice.toolName },
                toolWarnings
              };
            default: {
              const _exhaustiveCheck = type;
              throw new UnsupportedFunctionalityError$1({
                functionality: `tool choice type: ${_exhaustiveCheck}`
              });
            }
          }
        }

        // src/responses/openai-responses-language-model.ts
        var OpenAIResponsesLanguageModel = class {
          constructor(modelId, config) {
            this.specificationVersion = "v2";
            this.supportedUrls = {
              "image/*": [/^https?:\/\/.*$/],
              "application/pdf": [/^https?:\/\/.*$/]
            };
            this.modelId = modelId;
            this.config = config;
          }
          get provider() {
            return this.config.provider;
          }
          async getArgs({
            maxOutputTokens,
            temperature,
            stopSequences,
            topP,
            topK,
            presencePenalty,
            frequencyPenalty,
            seed,
            prompt,
            providerOptions,
            tools,
            toolChoice,
            responseFormat
          }) {
            var _a, _b, _c, _d;
            const warnings = [];
            const modelConfig = getResponsesModelConfig(this.modelId);
            if (topK != null) {
              warnings.push({ type: "unsupported-setting", setting: "topK" });
            }
            if (seed != null) {
              warnings.push({ type: "unsupported-setting", setting: "seed" });
            }
            if (presencePenalty != null) {
              warnings.push({
                type: "unsupported-setting",
                setting: "presencePenalty"
              });
            }
            if (frequencyPenalty != null) {
              warnings.push({
                type: "unsupported-setting",
                setting: "frequencyPenalty"
              });
            }
            if (stopSequences != null) {
              warnings.push({ type: "unsupported-setting", setting: "stopSequences" });
            }
            const openaiOptions = await parseProviderOptions({
              provider: "openai",
              providerOptions,
              schema: openaiResponsesProviderOptionsSchema
            });
            const { input, warnings: inputWarnings } = await convertToOpenAIResponsesInput({
              prompt,
              systemMessageMode: modelConfig.systemMessageMode,
              fileIdPrefixes: this.config.fileIdPrefixes,
              store: (_a = openaiOptions == null ? void 0 : openaiOptions.store) != null ? _a : true,
              hasLocalShellTool: hasOpenAITool("openai.local_shell")
            });
            warnings.push(...inputWarnings);
            const strictJsonSchema = (_b = openaiOptions == null ? void 0 : openaiOptions.strictJsonSchema) != null ? _b : false;
            let include = openaiOptions == null ? void 0 : openaiOptions.include;
            function addInclude(key) {
              if (include == null) {
                include = [key];
              } else if (!include.includes(key)) {
                include = [...include, key];
              }
            }
            function hasOpenAITool(id) {
              return (tools == null ? void 0 : tools.find(
                (tool) => tool.type === "provider-defined" && tool.id === id
              )) != null;
            }
            const topLogprobs = typeof (openaiOptions == null ? void 0 : openaiOptions.logprobs) === "number" ? openaiOptions == null ? void 0 : openaiOptions.logprobs : (openaiOptions == null ? void 0 : openaiOptions.logprobs) === true ? TOP_LOGPROBS_MAX : void 0;
            if (topLogprobs) {
              addInclude("message.output_text.logprobs");
            }
            const webSearchToolName = (_c = tools == null ? void 0 : tools.find(
              (tool) => tool.type === "provider-defined" && (tool.id === "openai.web_search" || tool.id === "openai.web_search_preview")
            )) == null ? void 0 : _c.name;
            if (webSearchToolName) {
              addInclude("web_search_call.action.sources");
            }
            if (hasOpenAITool("openai.code_interpreter")) {
              addInclude("code_interpreter_call.outputs");
            }
            const store = openaiOptions == null ? void 0 : openaiOptions.store;
            if (store === false && modelConfig.isReasoningModel) {
              addInclude("reasoning.encrypted_content");
            }
            const baseArgs = {
              model: this.modelId,
              input,
              temperature,
              top_p: topP,
              max_output_tokens: maxOutputTokens,
              ...((responseFormat == null ? void 0 : responseFormat.type) === "json" || (openaiOptions == null ? void 0 : openaiOptions.textVerbosity)) && {
                text: {
                  ...(responseFormat == null ? void 0 : responseFormat.type) === "json" && {
                    format: responseFormat.schema != null ? {
                      type: "json_schema",
                      strict: strictJsonSchema,
                      name: (_d = responseFormat.name) != null ? _d : "response",
                      description: responseFormat.description,
                      schema: responseFormat.schema
                    } : { type: "json_object" }
                  },
                  ...(openaiOptions == null ? void 0 : openaiOptions.textVerbosity) && {
                    verbosity: openaiOptions.textVerbosity
                  }
                }
              },
              // provider options:
              max_tool_calls: openaiOptions == null ? void 0 : openaiOptions.maxToolCalls,
              metadata: openaiOptions == null ? void 0 : openaiOptions.metadata,
              parallel_tool_calls: openaiOptions == null ? void 0 : openaiOptions.parallelToolCalls,
              previous_response_id: openaiOptions == null ? void 0 : openaiOptions.previousResponseId,
              store,
              user: openaiOptions == null ? void 0 : openaiOptions.user,
              instructions: openaiOptions == null ? void 0 : openaiOptions.instructions,
              service_tier: openaiOptions == null ? void 0 : openaiOptions.serviceTier,
              include,
              prompt_cache_key: openaiOptions == null ? void 0 : openaiOptions.promptCacheKey,
              safety_identifier: openaiOptions == null ? void 0 : openaiOptions.safetyIdentifier,
              top_logprobs: topLogprobs,
              // model-specific settings:
              ...modelConfig.isReasoningModel && ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null || (openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) && {
                reasoning: {
                  ...(openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null && {
                    effort: openaiOptions.reasoningEffort
                  },
                  ...(openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null && {
                    summary: openaiOptions.reasoningSummary
                  }
                }
              },
              ...modelConfig.requiredAutoTruncation && {
                truncation: "auto"
              }
            };
            if (modelConfig.isReasoningModel) {
              if (baseArgs.temperature != null) {
                baseArgs.temperature = void 0;
                warnings.push({
                  type: "unsupported-setting",
                  setting: "temperature",
                  details: "temperature is not supported for reasoning models"
                });
              }
              if (baseArgs.top_p != null) {
                baseArgs.top_p = void 0;
                warnings.push({
                  type: "unsupported-setting",
                  setting: "topP",
                  details: "topP is not supported for reasoning models"
                });
              }
            } else {
              if ((openaiOptions == null ? void 0 : openaiOptions.reasoningEffort) != null) {
                warnings.push({
                  type: "unsupported-setting",
                  setting: "reasoningEffort",
                  details: "reasoningEffort is not supported for non-reasoning models"
                });
              }
              if ((openaiOptions == null ? void 0 : openaiOptions.reasoningSummary) != null) {
                warnings.push({
                  type: "unsupported-setting",
                  setting: "reasoningSummary",
                  details: "reasoningSummary is not supported for non-reasoning models"
                });
              }
            }
            if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "flex" && !modelConfig.supportsFlexProcessing) {
              warnings.push({
                type: "unsupported-setting",
                setting: "serviceTier",
                details: "flex processing is only available for o3, o4-mini, and gpt-5 models"
              });
              delete baseArgs.service_tier;
            }
            if ((openaiOptions == null ? void 0 : openaiOptions.serviceTier) === "priority" && !modelConfig.supportsPriorityProcessing) {
              warnings.push({
                type: "unsupported-setting",
                setting: "serviceTier",
                details: "priority processing is only available for supported models (gpt-4, gpt-5, gpt-5-mini, o3, o4-mini) and requires Enterprise access. gpt-5-nano is not supported"
              });
              delete baseArgs.service_tier;
            }
            const {
              tools: openaiTools2,
              toolChoice: openaiToolChoice,
              toolWarnings
            } = await prepareResponsesTools({
              tools,
              toolChoice,
              strictJsonSchema
            });
            return {
              webSearchToolName,
              args: {
                ...baseArgs,
                tools: openaiTools2,
                tool_choice: openaiToolChoice
              },
              warnings: [...warnings, ...toolWarnings],
              store
            };
          }
          async doGenerate(options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s;
            const {
              args: body,
              warnings,
              webSearchToolName
            } = await this.getArgs(options);
            const url = this.config.url({
              path: "/responses",
              modelId: this.modelId
            });
            const {
              responseHeaders,
              value: response,
              rawValue: rawResponse
            } = await postJsonToApi$1({
              url,
              headers: combineHeaders$1(this.config.headers(), options.headers),
              body,
              failedResponseHandler: openaiFailedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler$1(
                openaiResponsesResponseSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            if (response.error) {
              throw new APICallError$1({
                message: response.error.message,
                url,
                requestBodyValues: body,
                statusCode: 400,
                responseHeaders,
                responseBody: rawResponse,
                isRetryable: false
              });
            }
            const content = [];
            const logprobs = [];
            let hasFunctionCall = false;
            for (const part of response.output) {
              switch (part.type) {
                case "reasoning": {
                  if (part.summary.length === 0) {
                    part.summary.push({ type: "summary_text", text: "" });
                  }
                  for (const summary of part.summary) {
                    content.push({
                      type: "reasoning",
                      text: summary.text,
                      providerMetadata: {
                        openai: {
                          itemId: part.id,
                          reasoningEncryptedContent: (_a = part.encrypted_content) != null ? _a : null
                        }
                      }
                    });
                  }
                  break;
                }
                case "image_generation_call": {
                  content.push({
                    type: "tool-call",
                    toolCallId: part.id,
                    toolName: "image_generation",
                    input: "{}",
                    providerExecuted: true
                  });
                  content.push({
                    type: "tool-result",
                    toolCallId: part.id,
                    toolName: "image_generation",
                    result: {
                      result: part.result
                    },
                    providerExecuted: true
                  });
                  break;
                }
                case "local_shell_call": {
                  content.push({
                    type: "tool-call",
                    toolCallId: part.call_id,
                    toolName: "local_shell",
                    input: JSON.stringify({
                      action: part.action
                    }),
                    providerMetadata: {
                      openai: {
                        itemId: part.id
                      }
                    }
                  });
                  break;
                }
                case "message": {
                  for (const contentPart of part.content) {
                    if (((_c = (_b = options.providerOptions) == null ? void 0 : _b.openai) == null ? void 0 : _c.logprobs) && contentPart.logprobs) {
                      logprobs.push(contentPart.logprobs);
                    }
                    content.push({
                      type: "text",
                      text: contentPart.text,
                      providerMetadata: {
                        openai: {
                          itemId: part.id
                        }
                      }
                    });
                    for (const annotation of contentPart.annotations) {
                      if (annotation.type === "url_citation") {
                        content.push({
                          type: "source",
                          sourceType: "url",
                          id: (_f = (_e = (_d = this.config).generateId) == null ? void 0 : _e.call(_d)) != null ? _f : generateId$1(),
                          url: annotation.url,
                          title: annotation.title
                        });
                      } else if (annotation.type === "file_citation") {
                        content.push({
                          type: "source",
                          sourceType: "document",
                          id: (_i = (_h = (_g = this.config).generateId) == null ? void 0 : _h.call(_g)) != null ? _i : generateId$1(),
                          mediaType: "text/plain",
                          title: (_k = (_j = annotation.quote) != null ? _j : annotation.filename) != null ? _k : "Document",
                          filename: (_l = annotation.filename) != null ? _l : annotation.file_id
                        });
                      }
                    }
                  }
                  break;
                }
                case "function_call": {
                  hasFunctionCall = true;
                  content.push({
                    type: "tool-call",
                    toolCallId: part.call_id,
                    toolName: part.name,
                    input: part.arguments,
                    providerMetadata: {
                      openai: {
                        itemId: part.id
                      }
                    }
                  });
                  break;
                }
                case "web_search_call": {
                  content.push({
                    type: "tool-call",
                    toolCallId: part.id,
                    toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                    input: JSON.stringify({}),
                    providerExecuted: true
                  });
                  content.push({
                    type: "tool-result",
                    toolCallId: part.id,
                    toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                    result: mapWebSearchOutput(part.action),
                    providerExecuted: true
                  });
                  break;
                }
                case "computer_call": {
                  content.push({
                    type: "tool-call",
                    toolCallId: part.id,
                    toolName: "computer_use",
                    input: "",
                    providerExecuted: true
                  });
                  content.push({
                    type: "tool-result",
                    toolCallId: part.id,
                    toolName: "computer_use",
                    result: {
                      type: "computer_use_tool_result",
                      status: part.status || "completed"
                    },
                    providerExecuted: true
                  });
                  break;
                }
                case "file_search_call": {
                  content.push({
                    type: "tool-call",
                    toolCallId: part.id,
                    toolName: "file_search",
                    input: "{}",
                    providerExecuted: true
                  });
                  content.push({
                    type: "tool-result",
                    toolCallId: part.id,
                    toolName: "file_search",
                    result: {
                      queries: part.queries,
                      results: (_n = (_m = part.results) == null ? void 0 : _m.map((result) => ({
                        attributes: result.attributes,
                        fileId: result.file_id,
                        filename: result.filename,
                        score: result.score,
                        text: result.text
                      }))) != null ? _n : null
                    },
                    providerExecuted: true
                  });
                  break;
                }
                case "code_interpreter_call": {
                  content.push({
                    type: "tool-call",
                    toolCallId: part.id,
                    toolName: "code_interpreter",
                    input: JSON.stringify({
                      code: part.code,
                      containerId: part.container_id
                    }),
                    providerExecuted: true
                  });
                  content.push({
                    type: "tool-result",
                    toolCallId: part.id,
                    toolName: "code_interpreter",
                    result: {
                      outputs: part.outputs
                    },
                    providerExecuted: true
                  });
                  break;
                }
              }
            }
            const providerMetadata = {
              openai: { responseId: response.id }
            };
            if (logprobs.length > 0) {
              providerMetadata.openai.logprobs = logprobs;
            }
            if (typeof response.service_tier === "string") {
              providerMetadata.openai.serviceTier = response.service_tier;
            }
            return {
              content,
              finishReason: mapOpenAIResponseFinishReason({
                finishReason: (_o = response.incomplete_details) == null ? void 0 : _o.reason,
                hasFunctionCall
              }),
              usage: {
                inputTokens: response.usage.input_tokens,
                outputTokens: response.usage.output_tokens,
                totalTokens: response.usage.input_tokens + response.usage.output_tokens,
                reasoningTokens: (_q = (_p = response.usage.output_tokens_details) == null ? void 0 : _p.reasoning_tokens) != null ? _q : void 0,
                cachedInputTokens: (_s = (_r = response.usage.input_tokens_details) == null ? void 0 : _r.cached_tokens) != null ? _s : void 0
              },
              request: { body },
              response: {
                id: response.id,
                timestamp: new Date(response.created_at * 1e3),
                modelId: response.model,
                headers: responseHeaders,
                body: rawResponse
              },
              providerMetadata,
              warnings
            };
          }
          async doStream(options) {
            const {
              args: body,
              warnings,
              webSearchToolName,
              store
            } = await this.getArgs(options);
            const { responseHeaders, value: response } = await postJsonToApi$1({
              url: this.config.url({
                path: "/responses",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), options.headers),
              body: {
                ...body,
                stream: true
              },
              failedResponseHandler: openaiFailedResponseHandler,
              successfulResponseHandler: createEventSourceResponseHandler$1(
                openaiResponsesChunkSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            const self = this;
            let finishReason = "unknown";
            const usage = {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            };
            const logprobs = [];
            let responseId = null;
            const ongoingToolCalls = {};
            let hasFunctionCall = false;
            const activeReasoning = {};
            let serviceTier;
            return {
              stream: response.pipeThrough(
                new TransformStream({
                  start(controller) {
                    controller.enqueue({ type: "stream-start", warnings });
                  },
                  transform(chunk, controller) {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v;
                    if (options.includeRawChunks) {
                      controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                    }
                    if (!chunk.success) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: chunk.error });
                      return;
                    }
                    const value = chunk.value;
                    if (isResponseOutputItemAddedChunk(value)) {
                      if (value.item.type === "function_call") {
                        ongoingToolCalls[value.output_index] = {
                          toolName: value.item.name,
                          toolCallId: value.item.call_id
                        };
                        controller.enqueue({
                          type: "tool-input-start",
                          id: value.item.call_id,
                          toolName: value.item.name
                        });
                      } else if (value.item.type === "web_search_call") {
                        ongoingToolCalls[value.output_index] = {
                          toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                          toolCallId: value.item.id
                        };
                        controller.enqueue({
                          type: "tool-input-start",
                          id: value.item.id,
                          toolName: webSearchToolName != null ? webSearchToolName : "web_search",
                          providerExecuted: true
                        });
                        controller.enqueue({
                          type: "tool-input-end",
                          id: value.item.id
                        });
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: value.item.id,
                          toolName: "web_search",
                          input: JSON.stringify({}),
                          providerExecuted: true
                        });
                      } else if (value.item.type === "computer_call") {
                        ongoingToolCalls[value.output_index] = {
                          toolName: "computer_use",
                          toolCallId: value.item.id
                        };
                        controller.enqueue({
                          type: "tool-input-start",
                          id: value.item.id,
                          toolName: "computer_use",
                          providerExecuted: true
                        });
                      } else if (value.item.type === "code_interpreter_call") {
                        ongoingToolCalls[value.output_index] = {
                          toolName: "code_interpreter",
                          toolCallId: value.item.id,
                          codeInterpreter: {
                            containerId: value.item.container_id
                          }
                        };
                        controller.enqueue({
                          type: "tool-input-start",
                          id: value.item.id,
                          toolName: "code_interpreter",
                          providerExecuted: true
                        });
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: value.item.id,
                          delta: `{"containerId":"${value.item.container_id}","code":"`
                        });
                      } else if (value.item.type === "file_search_call") {
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: value.item.id,
                          toolName: "file_search",
                          input: "{}",
                          providerExecuted: true
                        });
                      } else if (value.item.type === "image_generation_call") {
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: value.item.id,
                          toolName: "image_generation",
                          input: "{}",
                          providerExecuted: true
                        });
                      } else if (value.item.type === "message") {
                        controller.enqueue({
                          type: "text-start",
                          id: value.item.id,
                          providerMetadata: {
                            openai: {
                              itemId: value.item.id
                            }
                          }
                        });
                      } else if (isResponseOutputItemAddedChunk(value) && value.item.type === "reasoning") {
                        activeReasoning[value.item.id] = {
                          encryptedContent: value.item.encrypted_content,
                          summaryParts: { 0: "active" }
                        };
                        controller.enqueue({
                          type: "reasoning-start",
                          id: `${value.item.id}:0`,
                          providerMetadata: {
                            openai: {
                              itemId: value.item.id,
                              reasoningEncryptedContent: (_a = value.item.encrypted_content) != null ? _a : null
                            }
                          }
                        });
                      }
                    } else if (isResponseOutputItemDoneChunk(value)) {
                      if (value.item.type === "function_call") {
                        ongoingToolCalls[value.output_index] = void 0;
                        hasFunctionCall = true;
                        controller.enqueue({
                          type: "tool-input-end",
                          id: value.item.call_id
                        });
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: value.item.call_id,
                          toolName: value.item.name,
                          input: value.item.arguments,
                          providerMetadata: {
                            openai: {
                              itemId: value.item.id
                            }
                          }
                        });
                      } else if (value.item.type === "web_search_call") {
                        ongoingToolCalls[value.output_index] = void 0;
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: value.item.id,
                          toolName: "web_search",
                          result: mapWebSearchOutput(value.item.action),
                          providerExecuted: true
                        });
                      } else if (value.item.type === "computer_call") {
                        ongoingToolCalls[value.output_index] = void 0;
                        controller.enqueue({
                          type: "tool-input-end",
                          id: value.item.id
                        });
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: value.item.id,
                          toolName: "computer_use",
                          input: "",
                          providerExecuted: true
                        });
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: value.item.id,
                          toolName: "computer_use",
                          result: {
                            type: "computer_use_tool_result",
                            status: value.item.status || "completed"
                          },
                          providerExecuted: true
                        });
                      } else if (value.item.type === "file_search_call") {
                        ongoingToolCalls[value.output_index] = void 0;
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: value.item.id,
                          toolName: "file_search",
                          result: {
                            queries: value.item.queries,
                            results: (_c = (_b = value.item.results) == null ? void 0 : _b.map((result) => ({
                              attributes: result.attributes,
                              fileId: result.file_id,
                              filename: result.filename,
                              score: result.score,
                              text: result.text
                            }))) != null ? _c : null
                          },
                          providerExecuted: true
                        });
                      } else if (value.item.type === "code_interpreter_call") {
                        ongoingToolCalls[value.output_index] = void 0;
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: value.item.id,
                          toolName: "code_interpreter",
                          result: {
                            outputs: value.item.outputs
                          },
                          providerExecuted: true
                        });
                      } else if (value.item.type === "image_generation_call") {
                        controller.enqueue({
                          type: "tool-result",
                          toolCallId: value.item.id,
                          toolName: "image_generation",
                          result: {
                            result: value.item.result
                          },
                          providerExecuted: true
                        });
                      } else if (value.item.type === "local_shell_call") {
                        ongoingToolCalls[value.output_index] = void 0;
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: value.item.call_id,
                          toolName: "local_shell",
                          input: JSON.stringify({
                            action: {
                              type: "exec",
                              command: value.item.action.command,
                              timeoutMs: value.item.action.timeout_ms,
                              user: value.item.action.user,
                              workingDirectory: value.item.action.working_directory,
                              env: value.item.action.env
                            }
                          }),
                          providerMetadata: {
                            openai: { itemId: value.item.id }
                          }
                        });
                      } else if (value.item.type === "message") {
                        controller.enqueue({
                          type: "text-end",
                          id: value.item.id
                        });
                      } else if (value.item.type === "reasoning") {
                        const activeReasoningPart = activeReasoning[value.item.id];
                        const summaryPartIndices = Object.entries(
                          activeReasoningPart.summaryParts
                        ).filter(
                          ([_, status]) => status === "active" || status === "can-conclude"
                        ).map(([summaryIndex]) => summaryIndex);
                        for (const summaryIndex of summaryPartIndices) {
                          controller.enqueue({
                            type: "reasoning-end",
                            id: `${value.item.id}:${summaryIndex}`,
                            providerMetadata: {
                              openai: {
                                itemId: value.item.id,
                                reasoningEncryptedContent: (_d = value.item.encrypted_content) != null ? _d : null
                              }
                            }
                          });
                        }
                        delete activeReasoning[value.item.id];
                      }
                    } else if (isResponseFunctionCallArgumentsDeltaChunk(value)) {
                      const toolCall = ongoingToolCalls[value.output_index];
                      if (toolCall != null) {
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall.toolCallId,
                          delta: value.delta
                        });
                      }
                    } else if (isResponseCodeInterpreterCallCodeDeltaChunk(value)) {
                      const toolCall = ongoingToolCalls[value.output_index];
                      if (toolCall != null) {
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall.toolCallId,
                          // The delta is code, which is embedding in a JSON string.
                          // To escape it, we use JSON.stringify and slice to remove the outer quotes.
                          delta: JSON.stringify(value.delta).slice(1, -1)
                        });
                      }
                    } else if (isResponseCodeInterpreterCallCodeDoneChunk(value)) {
                      const toolCall = ongoingToolCalls[value.output_index];
                      if (toolCall != null) {
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall.toolCallId,
                          delta: '"}'
                        });
                        controller.enqueue({
                          type: "tool-input-end",
                          id: toolCall.toolCallId
                        });
                        controller.enqueue({
                          type: "tool-call",
                          toolCallId: toolCall.toolCallId,
                          toolName: "code_interpreter",
                          input: JSON.stringify({
                            code: value.code,
                            containerId: toolCall.codeInterpreter.containerId
                          }),
                          providerExecuted: true
                        });
                      }
                    } else if (isResponseCreatedChunk(value)) {
                      responseId = value.response.id;
                      controller.enqueue({
                        type: "response-metadata",
                        id: value.response.id,
                        timestamp: new Date(value.response.created_at * 1e3),
                        modelId: value.response.model
                      });
                    } else if (isTextDeltaChunk(value)) {
                      controller.enqueue({
                        type: "text-delta",
                        id: value.item_id,
                        delta: value.delta
                      });
                      if (((_f = (_e = options.providerOptions) == null ? void 0 : _e.openai) == null ? void 0 : _f.logprobs) && value.logprobs) {
                        logprobs.push(value.logprobs);
                      }
                    } else if (value.type === "response.reasoning_summary_part.added") {
                      if (value.summary_index > 0) {
                        const activeReasoningPart = activeReasoning[value.item_id];
                        activeReasoningPart.summaryParts[value.summary_index] = "active";
                        for (const summaryIndex of Object.keys(
                          activeReasoningPart.summaryParts
                        )) {
                          if (activeReasoningPart.summaryParts[summaryIndex] === "can-conclude") {
                            controller.enqueue({
                              type: "reasoning-end",
                              id: `${value.item_id}:${summaryIndex}`,
                              providerMetadata: { openai: { itemId: value.item_id } }
                            });
                            activeReasoningPart.summaryParts[summaryIndex] = "concluded";
                          }
                        }
                        controller.enqueue({
                          type: "reasoning-start",
                          id: `${value.item_id}:${value.summary_index}`,
                          providerMetadata: {
                            openai: {
                              itemId: value.item_id,
                              reasoningEncryptedContent: (_h = (_g = activeReasoning[value.item_id]) == null ? void 0 : _g.encryptedContent) != null ? _h : null
                            }
                          }
                        });
                      }
                    } else if (value.type === "response.reasoning_summary_text.delta") {
                      controller.enqueue({
                        type: "reasoning-delta",
                        id: `${value.item_id}:${value.summary_index}`,
                        delta: value.delta,
                        providerMetadata: {
                          openai: {
                            itemId: value.item_id
                          }
                        }
                      });
                    } else if (value.type === "response.reasoning_summary_part.done") {
                      if (store) {
                        controller.enqueue({
                          type: "reasoning-end",
                          id: `${value.item_id}:${value.summary_index}`,
                          providerMetadata: {
                            openai: { itemId: value.item_id }
                          }
                        });
                        activeReasoning[value.item_id].summaryParts[value.summary_index] = "concluded";
                      } else {
                        activeReasoning[value.item_id].summaryParts[value.summary_index] = "can-conclude";
                      }
                    } else if (isResponseFinishedChunk(value)) {
                      finishReason = mapOpenAIResponseFinishReason({
                        finishReason: (_i = value.response.incomplete_details) == null ? void 0 : _i.reason,
                        hasFunctionCall
                      });
                      usage.inputTokens = value.response.usage.input_tokens;
                      usage.outputTokens = value.response.usage.output_tokens;
                      usage.totalTokens = value.response.usage.input_tokens + value.response.usage.output_tokens;
                      usage.reasoningTokens = (_k = (_j = value.response.usage.output_tokens_details) == null ? void 0 : _j.reasoning_tokens) != null ? _k : void 0;
                      usage.cachedInputTokens = (_m = (_l = value.response.usage.input_tokens_details) == null ? void 0 : _l.cached_tokens) != null ? _m : void 0;
                      if (typeof value.response.service_tier === "string") {
                        serviceTier = value.response.service_tier;
                      }
                    } else if (isResponseAnnotationAddedChunk(value)) {
                      if (value.annotation.type === "url_citation") {
                        controller.enqueue({
                          type: "source",
                          sourceType: "url",
                          id: (_p = (_o = (_n = self.config).generateId) == null ? void 0 : _o.call(_n)) != null ? _p : generateId$1(),
                          url: value.annotation.url,
                          title: value.annotation.title
                        });
                      } else if (value.annotation.type === "file_citation") {
                        controller.enqueue({
                          type: "source",
                          sourceType: "document",
                          id: (_s = (_r = (_q = self.config).generateId) == null ? void 0 : _r.call(_q)) != null ? _s : generateId$1(),
                          mediaType: "text/plain",
                          title: (_u = (_t = value.annotation.quote) != null ? _t : value.annotation.filename) != null ? _u : "Document",
                          filename: (_v = value.annotation.filename) != null ? _v : value.annotation.file_id
                        });
                      }
                    } else if (isErrorChunk(value)) {
                      controller.enqueue({ type: "error", error: value });
                    }
                  },
                  flush(controller) {
                    const providerMetadata = {
                      openai: {
                        responseId
                      }
                    };
                    if (logprobs.length > 0) {
                      providerMetadata.openai.logprobs = logprobs;
                    }
                    if (serviceTier !== void 0) {
                      providerMetadata.openai.serviceTier = serviceTier;
                    }
                    controller.enqueue({
                      type: "finish",
                      finishReason,
                      usage,
                      providerMetadata
                    });
                  }
                })
              ),
              request: { body },
              response: { headers: responseHeaders }
            };
          }
        };
        function isTextDeltaChunk(chunk) {
          return chunk.type === "response.output_text.delta";
        }
        function isResponseOutputItemDoneChunk(chunk) {
          return chunk.type === "response.output_item.done";
        }
        function isResponseFinishedChunk(chunk) {
          return chunk.type === "response.completed" || chunk.type === "response.incomplete";
        }
        function isResponseCreatedChunk(chunk) {
          return chunk.type === "response.created";
        }
        function isResponseFunctionCallArgumentsDeltaChunk(chunk) {
          return chunk.type === "response.function_call_arguments.delta";
        }
        function isResponseCodeInterpreterCallCodeDeltaChunk(chunk) {
          return chunk.type === "response.code_interpreter_call_code.delta";
        }
        function isResponseCodeInterpreterCallCodeDoneChunk(chunk) {
          return chunk.type === "response.code_interpreter_call_code.done";
        }
        function isResponseOutputItemAddedChunk(chunk) {
          return chunk.type === "response.output_item.added";
        }
        function isResponseAnnotationAddedChunk(chunk) {
          return chunk.type === "response.output_text.annotation.added";
        }
        function isErrorChunk(chunk) {
          return chunk.type === "error";
        }
        function getResponsesModelConfig(modelId) {
          const supportsFlexProcessing2 = modelId.startsWith("o3") || modelId.startsWith("o4-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-chat");
          const supportsPriorityProcessing2 = modelId.startsWith("gpt-4") || modelId.startsWith("gpt-5-mini") || modelId.startsWith("gpt-5") && !modelId.startsWith("gpt-5-nano") && !modelId.startsWith("gpt-5-chat") || modelId.startsWith("o3") || modelId.startsWith("o4-mini");
          const defaults = {
            requiredAutoTruncation: false,
            systemMessageMode: "system",
            supportsFlexProcessing: supportsFlexProcessing2,
            supportsPriorityProcessing: supportsPriorityProcessing2
          };
          if (modelId.startsWith("gpt-5-chat")) {
            return {
              ...defaults,
              isReasoningModel: false
            };
          }
          if (modelId.startsWith("o") || modelId.startsWith("gpt-5") || modelId.startsWith("codex-") || modelId.startsWith("computer-use")) {
            if (modelId.startsWith("o1-mini") || modelId.startsWith("o1-preview")) {
              return {
                ...defaults,
                isReasoningModel: true,
                systemMessageMode: "remove"
              };
            }
            return {
              ...defaults,
              isReasoningModel: true,
              systemMessageMode: "developer"
            };
          }
          return {
            ...defaults,
            isReasoningModel: false
          };
        }
        function mapWebSearchOutput(action) {
          var _a;
          switch (action.type) {
            case "search":
              return { action: { type: "search", query: (_a = action.query) != null ? _a : void 0 } };
            case "open_page":
              return { action: { type: "openPage", url: action.url } };
            case "find":
              return {
                action: { type: "find", url: action.url, pattern: action.pattern }
              };
          }
        }
        var openaiSpeechProviderOptionsSchema = lazyValidator(
          () => zodSchema(
            object({
              instructions: string().nullish(),
              speed: number$1().min(0.25).max(4).default(1).nullish()
            })
          )
        );

        // src/speech/openai-speech-model.ts
        var OpenAISpeechModel = class {
          constructor(modelId, config) {
            this.modelId = modelId;
            this.config = config;
            this.specificationVersion = "v2";
          }
          get provider() {
            return this.config.provider;
          }
          async getArgs({
            text,
            voice = "alloy",
            outputFormat = "mp3",
            speed,
            instructions,
            language,
            providerOptions
          }) {
            const warnings = [];
            const openAIOptions = await parseProviderOptions({
              provider: "openai",
              providerOptions,
              schema: openaiSpeechProviderOptionsSchema
            });
            const requestBody = {
              model: this.modelId,
              input: text,
              voice,
              response_format: "mp3",
              speed,
              instructions
            };
            if (outputFormat) {
              if (["mp3", "opus", "aac", "flac", "wav", "pcm"].includes(outputFormat)) {
                requestBody.response_format = outputFormat;
              } else {
                warnings.push({
                  type: "unsupported-setting",
                  setting: "outputFormat",
                  details: `Unsupported output format: ${outputFormat}. Using mp3 instead.`
                });
              }
            }
            if (openAIOptions) {
              const speechModelOptions = {};
              for (const key in speechModelOptions) {
                const value = speechModelOptions[key];
                if (value !== void 0) {
                  requestBody[key] = value;
                }
              }
            }
            if (language) {
              warnings.push({
                type: "unsupported-setting",
                setting: "language",
                details: `OpenAI speech models do not support language selection. Language parameter "${language}" was ignored.`
              });
            }
            return {
              requestBody,
              warnings
            };
          }
          async doGenerate(options) {
            var _a, _b, _c;
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const { requestBody, warnings } = await this.getArgs(options);
            const {
              value: audio,
              responseHeaders,
              rawValue: rawResponse
            } = await postJsonToApi$1({
              url: this.config.url({
                path: "/audio/speech",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), options.headers),
              body: requestBody,
              failedResponseHandler: openaiFailedResponseHandler,
              successfulResponseHandler: createBinaryResponseHandler(),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            return {
              audio,
              warnings,
              request: {
                body: JSON.stringify(requestBody)
              },
              response: {
                timestamp: currentDate,
                modelId: this.modelId,
                headers: responseHeaders,
                body: rawResponse
              }
            };
          }
        };
        var openaiTranscriptionResponseSchema = lazyValidator(
          () => zodSchema(
            object({
              text: string(),
              language: string().nullish(),
              duration: number$1().nullish(),
              words: array(
                object({
                  word: string(),
                  start: number$1(),
                  end: number$1()
                })
              ).nullish(),
              segments: array(
                object({
                  id: number$1(),
                  seek: number$1(),
                  start: number$1(),
                  end: number$1(),
                  text: string(),
                  tokens: array(number$1()),
                  temperature: number$1(),
                  avg_logprob: number$1(),
                  compression_ratio: number$1(),
                  no_speech_prob: number$1()
                })
              ).nullish()
            })
          )
        );
        var openAITranscriptionProviderOptions = lazyValidator(
          () => zodSchema(
            object({
              /**
               * Additional information to include in the transcription response.
               */
              include: array(string()).optional(),
              /**
               * The language of the input audio in ISO-639-1 format.
               */
              language: string().optional(),
              /**
               * An optional text to guide the model's style or continue a previous audio segment.
               */
              prompt: string().optional(),
              /**
               * The sampling temperature, between 0 and 1.
               * @default 0
               */
              temperature: number$1().min(0).max(1).default(0).optional(),
              /**
               * The timestamp granularities to populate for this transcription.
               * @default ['segment']
               */
              timestampGranularities: array(_enum(["word", "segment"])).default(["segment"]).optional()
            })
          )
        );

        // src/transcription/openai-transcription-model.ts
        var languageMap = {
          afrikaans: "af",
          arabic: "ar",
          armenian: "hy",
          azerbaijani: "az",
          belarusian: "be",
          bosnian: "bs",
          bulgarian: "bg",
          catalan: "ca",
          chinese: "zh",
          croatian: "hr",
          czech: "cs",
          danish: "da",
          dutch: "nl",
          english: "en",
          estonian: "et",
          finnish: "fi",
          french: "fr",
          galician: "gl",
          german: "de",
          greek: "el",
          hebrew: "he",
          hindi: "hi",
          hungarian: "hu",
          icelandic: "is",
          indonesian: "id",
          italian: "it",
          japanese: "ja",
          kannada: "kn",
          kazakh: "kk",
          korean: "ko",
          latvian: "lv",
          lithuanian: "lt",
          macedonian: "mk",
          malay: "ms",
          marathi: "mr",
          maori: "mi",
          nepali: "ne",
          norwegian: "no",
          persian: "fa",
          polish: "pl",
          portuguese: "pt",
          romanian: "ro",
          russian: "ru",
          serbian: "sr",
          slovak: "sk",
          slovenian: "sl",
          spanish: "es",
          swahili: "sw",
          swedish: "sv",
          tagalog: "tl",
          tamil: "ta",
          thai: "th",
          turkish: "tr",
          ukrainian: "uk",
          urdu: "ur",
          vietnamese: "vi",
          welsh: "cy"
        };
        var OpenAITranscriptionModel = class {
          constructor(modelId, config) {
            this.modelId = modelId;
            this.config = config;
            this.specificationVersion = "v2";
          }
          get provider() {
            return this.config.provider;
          }
          async getArgs({
            audio,
            mediaType,
            providerOptions
          }) {
            const warnings = [];
            const openAIOptions = await parseProviderOptions({
              provider: "openai",
              providerOptions,
              schema: openAITranscriptionProviderOptions
            });
            const formData = new FormData();
            const blob = audio instanceof Uint8Array ? new Blob([audio]) : new Blob([convertBase64ToUint8Array(audio)]);
            formData.append("model", this.modelId);
            const fileExtension = mediaTypeToExtension(mediaType);
            formData.append(
              "file",
              new File([blob], "audio", { type: mediaType }),
              `audio.${fileExtension}`
            );
            if (openAIOptions) {
              const transcriptionModelOptions = {
                include: openAIOptions.include,
                language: openAIOptions.language,
                prompt: openAIOptions.prompt,
                // https://platform.openai.com/docs/api-reference/audio/createTranscription#audio_createtranscription-response_format
                // prefer verbose_json to get segments for models that support it
                response_format: [
                  "gpt-4o-transcribe",
                  "gpt-4o-mini-transcribe"
                ].includes(this.modelId) ? "json" : "verbose_json",
                temperature: openAIOptions.temperature,
                timestamp_granularities: openAIOptions.timestampGranularities
              };
              for (const [key, value] of Object.entries(transcriptionModelOptions)) {
                if (value != null) {
                  if (Array.isArray(value)) {
                    for (const item of value) {
                      formData.append(`${key}[]`, String(item));
                    }
                  } else {
                    formData.append(key, String(value));
                  }
                }
              }
            }
            return {
              formData,
              warnings
            };
          }
          async doGenerate(options) {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const { formData, warnings } = await this.getArgs(options);
            const {
              value: response,
              responseHeaders,
              rawValue: rawResponse
            } = await postFormDataToApi({
              url: this.config.url({
                path: "/audio/transcriptions",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), options.headers),
              formData,
              failedResponseHandler: openaiFailedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler$1(
                openaiTranscriptionResponseSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            const language = response.language != null && response.language in languageMap ? languageMap[response.language] : void 0;
            return {
              text: response.text,
              segments: (_g = (_f = (_d = response.segments) == null ? void 0 : _d.map((segment) => ({
                text: segment.text,
                startSecond: segment.start,
                endSecond: segment.end
              }))) != null ? _f : (_e = response.words) == null ? void 0 : _e.map((word) => ({
                text: word.word,
                startSecond: word.start,
                endSecond: word.end
              }))) != null ? _g : [],
              language,
              durationInSeconds: (_h = response.duration) != null ? _h : void 0,
              warnings,
              response: {
                timestamp: currentDate,
                modelId: this.modelId,
                headers: responseHeaders,
                body: rawResponse
              }
            };
          }
        };

        // src/version.ts
        var VERSION$4 = "2.0.52";

        // src/openai-provider.ts
        function createOpenAI(options = {}) {
          var _a, _b;
          const baseURL = (_a = withoutTrailingSlash$1(
            loadOptionalSetting({
              settingValue: options.baseURL,
              environmentVariableName: "OPENAI_BASE_URL"
            })
          )) != null ? _a : "https://api.openai.com/v1";
          const providerName = (_b = options.name) != null ? _b : "openai";
          const getHeaders = () => withUserAgentSuffix(
            {
              Authorization: `Bearer ${loadApiKey$1({
                apiKey: options.apiKey,
                environmentVariableName: "OPENAI_API_KEY",
                description: "OpenAI"
              })}`,
              "OpenAI-Organization": options.organization,
              "OpenAI-Project": options.project,
              ...options.headers
            },
            `ai-sdk/openai/${VERSION$4}`
          );
          const createChatModel = (modelId) => new OpenAIChatLanguageModel(modelId, {
            provider: `${providerName}.chat`,
            url: ({ path }) => `${baseURL}${path}`,
            headers: getHeaders,
            fetch: options.fetch
          });
          const createCompletionModel = (modelId) => new OpenAICompletionLanguageModel(modelId, {
            provider: `${providerName}.completion`,
            url: ({ path }) => `${baseURL}${path}`,
            headers: getHeaders,
            fetch: options.fetch
          });
          const createEmbeddingModel = (modelId) => new OpenAIEmbeddingModel(modelId, {
            provider: `${providerName}.embedding`,
            url: ({ path }) => `${baseURL}${path}`,
            headers: getHeaders,
            fetch: options.fetch
          });
          const createImageModel = (modelId) => new OpenAIImageModel(modelId, {
            provider: `${providerName}.image`,
            url: ({ path }) => `${baseURL}${path}`,
            headers: getHeaders,
            fetch: options.fetch
          });
          const createTranscriptionModel = (modelId) => new OpenAITranscriptionModel(modelId, {
            provider: `${providerName}.transcription`,
            url: ({ path }) => `${baseURL}${path}`,
            headers: getHeaders,
            fetch: options.fetch
          });
          const createSpeechModel = (modelId) => new OpenAISpeechModel(modelId, {
            provider: `${providerName}.speech`,
            url: ({ path }) => `${baseURL}${path}`,
            headers: getHeaders,
            fetch: options.fetch
          });
          const createLanguageModel = (modelId) => {
            if (new.target) {
              throw new Error(
                "The OpenAI model function cannot be called with the new keyword."
              );
            }
            return createResponsesModel(modelId);
          };
          const createResponsesModel = (modelId) => {
            return new OpenAIResponsesLanguageModel(modelId, {
              provider: `${providerName}.responses`,
              url: ({ path }) => `${baseURL}${path}`,
              headers: getHeaders,
              fetch: options.fetch,
              fileIdPrefixes: ["file-"]
            });
          };
          const provider = function (modelId) {
            return createLanguageModel(modelId);
          };
          provider.languageModel = createLanguageModel;
          provider.chat = createChatModel;
          provider.completion = createCompletionModel;
          provider.responses = createResponsesModel;
          provider.embedding = createEmbeddingModel;
          provider.textEmbedding = createEmbeddingModel;
          provider.textEmbeddingModel = createEmbeddingModel;
          provider.image = createImageModel;
          provider.imageModel = createImageModel;
          provider.transcription = createTranscriptionModel;
          provider.transcriptionModel = createTranscriptionModel;
          provider.speech = createSpeechModel;
          provider.speechModel = createSpeechModel;
          provider.tools = openaiTools;
          return provider;
        }
        createOpenAI();

        // src/anthropic-provider.ts

        // src/version.ts
        var VERSION$3 = "2.0.33";
        var anthropicErrorDataSchema$1 = lazySchema(
          () => zodSchema(
            object({
              type: literal("error"),
              error: object({
                type: string(),
                message: string()
              })
            })
          )
        );
        var anthropicFailedResponseHandler = createJsonErrorResponseHandler$1({
          errorSchema: anthropicErrorDataSchema$1,
          errorToMessage: (data) => data.error.message
        });
        var anthropicMessagesResponseSchema = lazySchema(
          () => zodSchema(
            object({
              type: literal("message"),
              id: string().nullish(),
              model: string().nullish(),
              content: array(
                discriminatedUnion("type", [
                  object({
                    type: literal("text"),
                    text: string(),
                    citations: array(
                      discriminatedUnion("type", [
                        object({
                          type: literal("web_search_result_location"),
                          cited_text: string(),
                          url: string(),
                          title: string(),
                          encrypted_index: string()
                        }),
                        object({
                          type: literal("page_location"),
                          cited_text: string(),
                          document_index: number$1(),
                          document_title: string().nullable(),
                          start_page_number: number$1(),
                          end_page_number: number$1()
                        }),
                        object({
                          type: literal("char_location"),
                          cited_text: string(),
                          document_index: number$1(),
                          document_title: string().nullable(),
                          start_char_index: number$1(),
                          end_char_index: number$1()
                        })
                      ])
                    ).optional()
                  }),
                  object({
                    type: literal("thinking"),
                    thinking: string(),
                    signature: string()
                  }),
                  object({
                    type: literal("redacted_thinking"),
                    data: string()
                  }),
                  object({
                    type: literal("tool_use"),
                    id: string(),
                    name: string(),
                    input: unknown()
                  }),
                  object({
                    type: literal("server_tool_use"),
                    id: string(),
                    name: string(),
                    input: record(string(), unknown()).nullish()
                  }),
                  object({
                    type: literal("web_fetch_tool_result"),
                    tool_use_id: string(),
                    content: union([
                      object({
                        type: literal("web_fetch_result"),
                        url: string(),
                        retrieved_at: string(),
                        content: object({
                          type: literal("document"),
                          title: string().nullable(),
                          citations: object({ enabled: boolean() }).optional(),
                          source: object({
                            type: literal("text"),
                            media_type: string(),
                            data: string()
                          })
                        })
                      }),
                      object({
                        type: literal("web_fetch_tool_result_error"),
                        error_code: string()
                      })
                    ])
                  }),
                  object({
                    type: literal("web_search_tool_result"),
                    tool_use_id: string(),
                    content: union([
                      array(
                        object({
                          type: literal("web_search_result"),
                          url: string(),
                          title: string(),
                          encrypted_content: string(),
                          page_age: string().nullish()
                        })
                      ),
                      object({
                        type: literal("web_search_tool_result_error"),
                        error_code: string()
                      })
                    ])
                  }),
                  // code execution results for code_execution_20250522 tool:
                  object({
                    type: literal("code_execution_tool_result"),
                    tool_use_id: string(),
                    content: union([
                      object({
                        type: literal("code_execution_result"),
                        stdout: string(),
                        stderr: string(),
                        return_code: number$1()
                      }),
                      object({
                        type: literal("code_execution_tool_result_error"),
                        error_code: string()
                      })
                    ])
                  }),
                  // bash code execution results for code_execution_20250825 tool:
                  object({
                    type: literal("bash_code_execution_tool_result"),
                    tool_use_id: string(),
                    content: discriminatedUnion("type", [
                      object({
                        type: literal("bash_code_execution_result"),
                        content: array(
                          object({
                            type: literal("bash_code_execution_output"),
                            file_id: string()
                          })
                        ),
                        stdout: string(),
                        stderr: string(),
                        return_code: number$1()
                      }),
                      object({
                        type: literal("bash_code_execution_tool_result_error"),
                        error_code: string()
                      })
                    ])
                  }),
                  // text editor code execution results for code_execution_20250825 tool:
                  object({
                    type: literal("text_editor_code_execution_tool_result"),
                    tool_use_id: string(),
                    content: discriminatedUnion("type", [
                      object({
                        type: literal("text_editor_code_execution_tool_result_error"),
                        error_code: string()
                      }),
                      object({
                        type: literal("text_editor_code_execution_view_result"),
                        content: string(),
                        file_type: string(),
                        num_lines: number$1().nullable(),
                        start_line: number$1().nullable(),
                        total_lines: number$1().nullable()
                      }),
                      object({
                        type: literal("text_editor_code_execution_create_result"),
                        is_file_update: boolean()
                      }),
                      object({
                        type: literal(
                          "text_editor_code_execution_str_replace_result"
                        ),
                        lines: array(string()).nullable(),
                        new_lines: number$1().nullable(),
                        new_start: number$1().nullable(),
                        old_lines: number$1().nullable(),
                        old_start: number$1().nullable()
                      })
                    ])
                  })
                ])
              ),
              stop_reason: string().nullish(),
              stop_sequence: string().nullish(),
              usage: looseObject({
                input_tokens: number$1(),
                output_tokens: number$1(),
                cache_creation_input_tokens: number$1().nullish(),
                cache_read_input_tokens: number$1().nullish()
              })
            })
          )
        );
        var anthropicMessagesChunkSchema = lazySchema(
          () => zodSchema(
            discriminatedUnion("type", [
              object({
                type: literal("message_start"),
                message: object({
                  id: string().nullish(),
                  model: string().nullish(),
                  usage: looseObject({
                    input_tokens: number$1(),
                    cache_creation_input_tokens: number$1().nullish(),
                    cache_read_input_tokens: number$1().nullish()
                  })
                })
              }),
              object({
                type: literal("content_block_start"),
                index: number$1(),
                content_block: discriminatedUnion("type", [
                  object({
                    type: literal("text"),
                    text: string()
                  }),
                  object({
                    type: literal("thinking"),
                    thinking: string()
                  }),
                  object({
                    type: literal("tool_use"),
                    id: string(),
                    name: string()
                  }),
                  object({
                    type: literal("redacted_thinking"),
                    data: string()
                  }),
                  object({
                    type: literal("server_tool_use"),
                    id: string(),
                    name: string(),
                    input: record(string(), unknown()).nullish()
                  }),
                  object({
                    type: literal("web_fetch_tool_result"),
                    tool_use_id: string(),
                    content: union([
                      object({
                        type: literal("web_fetch_result"),
                        url: string(),
                        retrieved_at: string(),
                        content: object({
                          type: literal("document"),
                          title: string().nullable(),
                          citations: object({ enabled: boolean() }).optional(),
                          source: object({
                            type: literal("text"),
                            media_type: string(),
                            data: string()
                          })
                        })
                      }),
                      object({
                        type: literal("web_fetch_tool_result_error"),
                        error_code: string()
                      })
                    ])
                  }),
                  object({
                    type: literal("web_search_tool_result"),
                    tool_use_id: string(),
                    content: union([
                      array(
                        object({
                          type: literal("web_search_result"),
                          url: string(),
                          title: string(),
                          encrypted_content: string(),
                          page_age: string().nullish()
                        })
                      ),
                      object({
                        type: literal("web_search_tool_result_error"),
                        error_code: string()
                      })
                    ])
                  }),
                  // code execution results for code_execution_20250522 tool:
                  object({
                    type: literal("code_execution_tool_result"),
                    tool_use_id: string(),
                    content: union([
                      object({
                        type: literal("code_execution_result"),
                        stdout: string(),
                        stderr: string(),
                        return_code: number$1()
                      }),
                      object({
                        type: literal("code_execution_tool_result_error"),
                        error_code: string()
                      })
                    ])
                  }),
                  // bash code execution results for code_execution_20250825 tool:
                  object({
                    type: literal("bash_code_execution_tool_result"),
                    tool_use_id: string(),
                    content: discriminatedUnion("type", [
                      object({
                        type: literal("bash_code_execution_result"),
                        content: array(
                          object({
                            type: literal("bash_code_execution_output"),
                            file_id: string()
                          })
                        ),
                        stdout: string(),
                        stderr: string(),
                        return_code: number$1()
                      }),
                      object({
                        type: literal("bash_code_execution_tool_result_error"),
                        error_code: string()
                      })
                    ])
                  }),
                  // text editor code execution results for code_execution_20250825 tool:
                  object({
                    type: literal("text_editor_code_execution_tool_result"),
                    tool_use_id: string(),
                    content: discriminatedUnion("type", [
                      object({
                        type: literal("text_editor_code_execution_tool_result_error"),
                        error_code: string()
                      }),
                      object({
                        type: literal("text_editor_code_execution_view_result"),
                        content: string(),
                        file_type: string(),
                        num_lines: number$1().nullable(),
                        start_line: number$1().nullable(),
                        total_lines: number$1().nullable()
                      }),
                      object({
                        type: literal("text_editor_code_execution_create_result"),
                        is_file_update: boolean()
                      }),
                      object({
                        type: literal(
                          "text_editor_code_execution_str_replace_result"
                        ),
                        lines: array(string()).nullable(),
                        new_lines: number$1().nullable(),
                        new_start: number$1().nullable(),
                        old_lines: number$1().nullable(),
                        old_start: number$1().nullable()
                      })
                    ])
                  })
                ])
              }),
              object({
                type: literal("content_block_delta"),
                index: number$1(),
                delta: discriminatedUnion("type", [
                  object({
                    type: literal("input_json_delta"),
                    partial_json: string()
                  }),
                  object({
                    type: literal("text_delta"),
                    text: string()
                  }),
                  object({
                    type: literal("thinking_delta"),
                    thinking: string()
                  }),
                  object({
                    type: literal("signature_delta"),
                    signature: string()
                  }),
                  object({
                    type: literal("citations_delta"),
                    citation: discriminatedUnion("type", [
                      object({
                        type: literal("web_search_result_location"),
                        cited_text: string(),
                        url: string(),
                        title: string(),
                        encrypted_index: string()
                      }),
                      object({
                        type: literal("page_location"),
                        cited_text: string(),
                        document_index: number$1(),
                        document_title: string().nullable(),
                        start_page_number: number$1(),
                        end_page_number: number$1()
                      }),
                      object({
                        type: literal("char_location"),
                        cited_text: string(),
                        document_index: number$1(),
                        document_title: string().nullable(),
                        start_char_index: number$1(),
                        end_char_index: number$1()
                      })
                    ])
                  })
                ])
              }),
              object({
                type: literal("content_block_stop"),
                index: number$1()
              }),
              object({
                type: literal("error"),
                error: object({
                  type: string(),
                  message: string()
                })
              }),
              object({
                type: literal("message_delta"),
                delta: object({
                  stop_reason: string().nullish(),
                  stop_sequence: string().nullish()
                }),
                usage: looseObject({
                  output_tokens: number$1(),
                  cache_creation_input_tokens: number$1().nullish()
                })
              }),
              object({
                type: literal("message_stop")
              }),
              object({
                type: literal("ping")
              })
            ])
          )
        );
        var anthropicReasoningMetadataSchema = lazySchema(
          () => zodSchema(
            object({
              signature: string().optional(),
              redactedData: string().optional()
            })
          )
        );
        var anthropicFilePartProviderOptions = object({
          /**
           * Citation configuration for this document.
           * When enabled, this document will generate citations in the response.
           */
          citations: object({
            /**
             * Enable citations for this document
             */
            enabled: boolean()
          }).optional(),
          /**
           * Custom title for the document.
           * If not provided, the filename will be used.
           */
          title: string().optional(),
          /**
           * Context about the document that will be passed to the model
           * but not used towards cited content.
           * Useful for storing document metadata as text or stringified JSON.
           */
          context: string().optional()
        });
        var anthropicProviderOptions = object({
          sendReasoning: boolean().optional(),
          thinking: object({
            type: union([literal("enabled"), literal("disabled")]),
            budgetTokens: number$1().optional()
          }).optional(),
          /**
           * Whether to disable parallel function calling during tool use. Default is false.
           * When set to true, Claude will use at most one tool per response.
           */
          disableParallelToolUse: boolean().optional(),
          /**
           * Cache control settings for this message.
           * See https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching
           */
          cacheControl: object({
            type: literal("ephemeral"),
            ttl: union([literal("5m"), literal("1h")]).optional()
          }).optional(),
          /**
           * Agent Skills configuration. Skills enable Claude to perform specialized tasks
           * like document processing (PPTX, DOCX, PDF, XLSX) and data analysis.
           * Requires code execution tool to be enabled.
           */
          container: object({
            id: string().optional(),
            skills: array(
              object({
                type: union([literal("anthropic"), literal("custom")]),
                skillId: string(),
                version: string().optional()
              })
            ).optional()
          }).optional()
        });

        // src/get-cache-control.ts
        var MAX_CACHE_BREAKPOINTS$1 = 4;
        function getCacheControl$2(providerMetadata) {
          var _a;
          const anthropic2 = providerMetadata == null ? void 0 : providerMetadata.anthropic;
          const cacheControlValue = (_a = anthropic2 == null ? void 0 : anthropic2.cacheControl) != null ? _a : anthropic2 == null ? void 0 : anthropic2.cache_control;
          return cacheControlValue;
        }
        var CacheControlValidator$1 = class CacheControlValidator {
          constructor() {
            this.breakpointCount = 0;
            this.warnings = [];
          }
          getCacheControl(providerMetadata, context) {
            const cacheControlValue = getCacheControl$2(providerMetadata);
            if (!cacheControlValue) {
              return void 0;
            }
            if (!context.canCache) {
              this.warnings.push({
                type: "unsupported-setting",
                setting: "cacheControl",
                details: `cache_control cannot be set on ${context.type}. It will be ignored.`
              });
              return void 0;
            }
            this.breakpointCount++;
            if (this.breakpointCount > MAX_CACHE_BREAKPOINTS$1) {
              this.warnings.push({
                type: "unsupported-setting",
                setting: "cacheControl",
                details: `Maximum ${MAX_CACHE_BREAKPOINTS$1} cache breakpoints exceeded (found ${this.breakpointCount}). This breakpoint will be ignored.`
              });
              return void 0;
            }
            return cacheControlValue;
          }
          getWarnings() {
            return this.warnings;
          }
        };
        var textEditor_20250728ArgsSchema$1 = lazySchema(
          () => zodSchema(
            object({
              maxCharacters: number$1().optional()
            })
          )
        );
        var textEditor_20250728InputSchema$1 = lazySchema(
          () => zodSchema(
            object({
              command: _enum(["view", "create", "str_replace", "insert"]),
              path: string(),
              file_text: string().optional(),
              insert_line: number$1().int().optional(),
              new_str: string().optional(),
              old_str: string().optional(),
              view_range: array(number$1().int()).optional()
            })
          )
        );
        var factory$1 = createProviderDefinedToolFactory({
          id: "anthropic.text_editor_20250728",
          name: "str_replace_based_edit_tool",
          inputSchema: textEditor_20250728InputSchema$1
        });
        var textEditor_20250728$1 = (args = {}) => {
          return factory$1(args);
        };
        var webSearch_20250305ArgsSchema$1 = lazySchema(
          () => zodSchema(
            object({
              maxUses: number$1().optional(),
              allowedDomains: array(string()).optional(),
              blockedDomains: array(string()).optional(),
              userLocation: object({
                type: literal("approximate"),
                city: string().optional(),
                region: string().optional(),
                country: string().optional(),
                timezone: string().optional()
              }).optional()
            })
          )
        );
        var webSearch_20250305OutputSchema$1 = lazySchema(
          () => zodSchema(
            array(
              object({
                url: string(),
                title: string(),
                pageAge: string().nullable(),
                encryptedContent: string(),
                type: literal("web_search_result")
              })
            )
          )
        );
        var webSearch_20250305InputSchema$1 = lazySchema(
          () => zodSchema(
            object({
              query: string()
            })
          )
        );
        var factory2$1 = createProviderDefinedToolFactoryWithOutputSchema({
          id: "anthropic.web_search_20250305",
          name: "web_search",
          inputSchema: webSearch_20250305InputSchema$1,
          outputSchema: webSearch_20250305OutputSchema$1
        });
        var webSearch_20250305$1 = (args = {}) => {
          return factory2$1(args);
        };
        var webFetch_20250910ArgsSchema$1 = lazySchema(
          () => zodSchema(
            object({
              maxUses: number$1().optional(),
              allowedDomains: array(string()).optional(),
              blockedDomains: array(string()).optional(),
              citations: object({ enabled: boolean() }).optional(),
              maxContentTokens: number$1().optional()
            })
          )
        );
        var webFetch_20250910OutputSchema$1 = lazySchema(
          () => zodSchema(
            object({
              type: literal("web_fetch_result"),
              url: string(),
              content: object({
                type: literal("document"),
                title: string(),
                citations: object({ enabled: boolean() }).optional(),
                source: union([
                  object({
                    type: literal("base64"),
                    mediaType: literal("application/pdf"),
                    data: string()
                  }),
                  object({
                    type: literal("text"),
                    mediaType: literal("text/plain"),
                    data: string()
                  })
                ])
              }),
              retrievedAt: string().nullable()
            })
          )
        );
        var webFetch_20250910InputSchema$1 = lazySchema(
          () => zodSchema(
            object({
              url: string()
            })
          )
        );
        var factory3$1 = createProviderDefinedToolFactoryWithOutputSchema({
          id: "anthropic.web_fetch_20250910",
          name: "web_fetch",
          inputSchema: webFetch_20250910InputSchema$1,
          outputSchema: webFetch_20250910OutputSchema$1
        });
        var webFetch_20250910$1 = (args = {}) => {
          return factory3$1(args);
        };
        async function prepareTools$4({
          tools,
          toolChoice,
          disableParallelToolUse,
          cacheControlValidator
        }) {
          tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
          const toolWarnings = [];
          const betas = /* @__PURE__ */ new Set();
          const validator = cacheControlValidator || new CacheControlValidator$1();
          if (tools == null) {
            return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
          }
          const anthropicTools2 = [];
          for (const tool of tools) {
            switch (tool.type) {
              case "function": {
                const cacheControl = validator.getCacheControl(tool.providerOptions, {
                  type: "tool definition",
                  canCache: true
                });
                anthropicTools2.push({
                  name: tool.name,
                  description: tool.description,
                  input_schema: tool.inputSchema,
                  cache_control: cacheControl
                });
                break;
              }
              case "provider-defined": {
                switch (tool.id) {
                  case "anthropic.code_execution_20250522": {
                    betas.add("code-execution-2025-05-22");
                    anthropicTools2.push({
                      type: "code_execution_20250522",
                      name: "code_execution",
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.code_execution_20250825": {
                    betas.add("code-execution-2025-08-25");
                    anthropicTools2.push({
                      type: "code_execution_20250825",
                      name: "code_execution"
                    });
                    break;
                  }
                  case "anthropic.computer_20250124": {
                    betas.add("computer-use-2025-01-24");
                    anthropicTools2.push({
                      name: "computer",
                      type: "computer_20250124",
                      display_width_px: tool.args.displayWidthPx,
                      display_height_px: tool.args.displayHeightPx,
                      display_number: tool.args.displayNumber,
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.computer_20241022": {
                    betas.add("computer-use-2024-10-22");
                    anthropicTools2.push({
                      name: "computer",
                      type: "computer_20241022",
                      display_width_px: tool.args.displayWidthPx,
                      display_height_px: tool.args.displayHeightPx,
                      display_number: tool.args.displayNumber,
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.text_editor_20250124": {
                    betas.add("computer-use-2025-01-24");
                    anthropicTools2.push({
                      name: "str_replace_editor",
                      type: "text_editor_20250124",
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.text_editor_20241022": {
                    betas.add("computer-use-2024-10-22");
                    anthropicTools2.push({
                      name: "str_replace_editor",
                      type: "text_editor_20241022",
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.text_editor_20250429": {
                    betas.add("computer-use-2025-01-24");
                    anthropicTools2.push({
                      name: "str_replace_based_edit_tool",
                      type: "text_editor_20250429",
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.text_editor_20250728": {
                    const args = await validateTypes$1({
                      value: tool.args,
                      schema: textEditor_20250728ArgsSchema$1
                    });
                    anthropicTools2.push({
                      name: "str_replace_based_edit_tool",
                      type: "text_editor_20250728",
                      max_characters: args.maxCharacters,
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.bash_20250124": {
                    betas.add("computer-use-2025-01-24");
                    anthropicTools2.push({
                      name: "bash",
                      type: "bash_20250124",
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.bash_20241022": {
                    betas.add("computer-use-2024-10-22");
                    anthropicTools2.push({
                      name: "bash",
                      type: "bash_20241022",
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.memory_20250818": {
                    betas.add("context-management-2025-06-27");
                    anthropicTools2.push({
                      name: "memory",
                      type: "memory_20250818"
                    });
                    break;
                  }
                  case "anthropic.web_fetch_20250910": {
                    betas.add("web-fetch-2025-09-10");
                    const args = await validateTypes$1({
                      value: tool.args,
                      schema: webFetch_20250910ArgsSchema$1
                    });
                    anthropicTools2.push({
                      type: "web_fetch_20250910",
                      name: "web_fetch",
                      max_uses: args.maxUses,
                      allowed_domains: args.allowedDomains,
                      blocked_domains: args.blockedDomains,
                      citations: args.citations,
                      max_content_tokens: args.maxContentTokens,
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.web_search_20250305": {
                    const args = await validateTypes$1({
                      value: tool.args,
                      schema: webSearch_20250305ArgsSchema$1
                    });
                    anthropicTools2.push({
                      type: "web_search_20250305",
                      name: "web_search",
                      max_uses: args.maxUses,
                      allowed_domains: args.allowedDomains,
                      blocked_domains: args.blockedDomains,
                      user_location: args.userLocation,
                      cache_control: void 0
                    });
                    break;
                  }
                  default: {
                    toolWarnings.push({ type: "unsupported-tool", tool });
                    break;
                  }
                }
                break;
              }
              default: {
                toolWarnings.push({ type: "unsupported-tool", tool });
                break;
              }
            }
          }
          if (toolChoice == null) {
            return {
              tools: anthropicTools2,
              toolChoice: disableParallelToolUse ? { type: "auto", disable_parallel_tool_use: disableParallelToolUse } : void 0,
              toolWarnings,
              betas
            };
          }
          const type = toolChoice.type;
          switch (type) {
            case "auto":
              return {
                tools: anthropicTools2,
                toolChoice: {
                  type: "auto",
                  disable_parallel_tool_use: disableParallelToolUse
                },
                toolWarnings,
                betas
              };
            case "required":
              return {
                tools: anthropicTools2,
                toolChoice: {
                  type: "any",
                  disable_parallel_tool_use: disableParallelToolUse
                },
                toolWarnings,
                betas
              };
            case "none":
              return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
            case "tool":
              return {
                tools: anthropicTools2,
                toolChoice: {
                  type: "tool",
                  name: toolChoice.toolName,
                  disable_parallel_tool_use: disableParallelToolUse
                },
                toolWarnings,
                betas
              };
            default: {
              const _exhaustiveCheck = type;
              throw new UnsupportedFunctionalityError$1({
                functionality: `tool choice type: ${_exhaustiveCheck}`
              });
            }
          }
        }
        var codeExecution_20250522OutputSchema$1 = lazySchema(
          () => zodSchema(
            object({
              type: literal("code_execution_result"),
              stdout: string(),
              stderr: string(),
              return_code: number$1()
            })
          )
        );
        var codeExecution_20250522InputSchema$1 = lazySchema(
          () => zodSchema(
            object({
              code: string()
            })
          )
        );
        var factory4$1 = createProviderDefinedToolFactoryWithOutputSchema({
          id: "anthropic.code_execution_20250522",
          name: "code_execution",
          inputSchema: codeExecution_20250522InputSchema$1,
          outputSchema: codeExecution_20250522OutputSchema$1
        });
        var codeExecution_20250522$1 = (args = {}) => {
          return factory4$1(args);
        };
        var codeExecution_20250825OutputSchema$1 = lazySchema(
          () => zodSchema(
            discriminatedUnion("type", [
              object({
                type: literal("bash_code_execution_result"),
                content: array(
                  object({
                    type: literal("bash_code_execution_output"),
                    file_id: string()
                  })
                ),
                stdout: string(),
                stderr: string(),
                return_code: number$1()
              }),
              object({
                type: literal("bash_code_execution_tool_result_error"),
                error_code: string()
              }),
              object({
                type: literal("text_editor_code_execution_tool_result_error"),
                error_code: string()
              }),
              object({
                type: literal("text_editor_code_execution_view_result"),
                content: string(),
                file_type: string(),
                num_lines: number$1().nullable(),
                start_line: number$1().nullable(),
                total_lines: number$1().nullable()
              }),
              object({
                type: literal("text_editor_code_execution_create_result"),
                is_file_update: boolean()
              }),
              object({
                type: literal("text_editor_code_execution_str_replace_result"),
                lines: array(string()).nullable(),
                new_lines: number$1().nullable(),
                new_start: number$1().nullable(),
                old_lines: number$1().nullable(),
                old_start: number$1().nullable()
              })
            ])
          )
        );
        var codeExecution_20250825InputSchema$1 = lazySchema(
          () => zodSchema(
            discriminatedUnion("type", [
              object({
                type: literal("bash_code_execution"),
                command: string()
              }),
              discriminatedUnion("command", [
                object({
                  type: literal("text_editor_code_execution"),
                  command: literal("view"),
                  path: string()
                }),
                object({
                  type: literal("text_editor_code_execution"),
                  command: literal("create"),
                  path: string(),
                  file_text: string().nullish()
                }),
                object({
                  type: literal("text_editor_code_execution"),
                  command: literal("str_replace"),
                  path: string(),
                  old_str: string(),
                  new_str: string()
                })
              ])
            ])
          )
        );
        var factory5$1 = createProviderDefinedToolFactoryWithOutputSchema({
          id: "anthropic.code_execution_20250825",
          name: "code_execution",
          inputSchema: codeExecution_20250825InputSchema$1,
          outputSchema: codeExecution_20250825OutputSchema$1
        });
        var codeExecution_20250825$1 = (args = {}) => {
          return factory5$1(args);
        };

        // src/convert-to-anthropic-messages-prompt.ts
        function convertToString(data) {
          if (typeof data === "string") {
            return Buffer.from(data, "base64").toString("utf-8");
          }
          if (data instanceof Uint8Array) {
            return new TextDecoder().decode(data);
          }
          if (data instanceof URL) {
            throw new UnsupportedFunctionalityError$1({
              functionality: "URL-based text documents are not supported for citations"
            });
          }
          throw new UnsupportedFunctionalityError$1({
            functionality: `unsupported data type for text documents: ${typeof data}`
          });
        }
        async function convertToAnthropicMessagesPrompt({
          prompt,
          sendReasoning,
          warnings,
          cacheControlValidator
        }) {
          var _a, _b, _c, _d, _e;
          const betas = /* @__PURE__ */ new Set();
          const blocks = groupIntoBlocks$1(prompt);
          const validator = cacheControlValidator || new CacheControlValidator$1();
          let system = void 0;
          const messages = [];
          async function shouldEnableCitations(providerMetadata) {
            var _a2, _b2;
            const anthropicOptions = await parseProviderOptions({
              provider: "anthropic",
              providerOptions: providerMetadata,
              schema: anthropicFilePartProviderOptions
            });
            return (_b2 = (_a2 = anthropicOptions == null ? void 0 : anthropicOptions.citations) == null ? void 0 : _a2.enabled) != null ? _b2 : false;
          }
          async function getDocumentMetadata(providerMetadata) {
            const anthropicOptions = await parseProviderOptions({
              provider: "anthropic",
              providerOptions: providerMetadata,
              schema: anthropicFilePartProviderOptions
            });
            return {
              title: anthropicOptions == null ? void 0 : anthropicOptions.title,
              context: anthropicOptions == null ? void 0 : anthropicOptions.context
            };
          }
          for (let i = 0; i < blocks.length; i++) {
            const block = blocks[i];
            const isLastBlock = i === blocks.length - 1;
            const type = block.type;
            switch (type) {
              case "system": {
                if (system != null) {
                  throw new UnsupportedFunctionalityError$1({
                    functionality: "Multiple system messages that are separated by user/assistant messages"
                  });
                }
                system = block.messages.map(({ content, providerOptions }) => ({
                  type: "text",
                  text: content,
                  cache_control: validator.getCacheControl(providerOptions, {
                    type: "system message",
                    canCache: true
                  })
                }));
                break;
              }
              case "user": {
                const anthropicContent = [];
                for (const message of block.messages) {
                  const { role, content } = message;
                  switch (role) {
                    case "user": {
                      for (let j = 0; j < content.length; j++) {
                        const part = content[j];
                        const isLastPart = j === content.length - 1;
                        const cacheControl = (_a = validator.getCacheControl(part.providerOptions, {
                          type: "user message part",
                          canCache: true
                        })) != null ? _a : isLastPart ? validator.getCacheControl(message.providerOptions, {
                          type: "user message",
                          canCache: true
                        }) : void 0;
                        switch (part.type) {
                          case "text": {
                            anthropicContent.push({
                              type: "text",
                              text: part.text,
                              cache_control: cacheControl
                            });
                            break;
                          }
                          case "file": {
                            if (part.mediaType.startsWith("image/")) {
                              anthropicContent.push({
                                type: "image",
                                source: part.data instanceof URL ? {
                                  type: "url",
                                  url: part.data.toString()
                                } : {
                                  type: "base64",
                                  media_type: part.mediaType === "image/*" ? "image/jpeg" : part.mediaType,
                                  data: convertToBase64(part.data)
                                },
                                cache_control: cacheControl
                              });
                            } else if (part.mediaType === "application/pdf") {
                              betas.add("pdfs-2024-09-25");
                              const enableCitations = await shouldEnableCitations(
                                part.providerOptions
                              );
                              const metadata = await getDocumentMetadata(
                                part.providerOptions
                              );
                              anthropicContent.push({
                                type: "document",
                                source: part.data instanceof URL ? {
                                  type: "url",
                                  url: part.data.toString()
                                } : {
                                  type: "base64",
                                  media_type: "application/pdf",
                                  data: convertToBase64(part.data)
                                },
                                title: (_b = metadata.title) != null ? _b : part.filename,
                                ...metadata.context && { context: metadata.context },
                                ...enableCitations && {
                                  citations: { enabled: true }
                                },
                                cache_control: cacheControl
                              });
                            } else if (part.mediaType === "text/plain") {
                              const enableCitations = await shouldEnableCitations(
                                part.providerOptions
                              );
                              const metadata = await getDocumentMetadata(
                                part.providerOptions
                              );
                              anthropicContent.push({
                                type: "document",
                                source: part.data instanceof URL ? {
                                  type: "url",
                                  url: part.data.toString()
                                } : {
                                  type: "text",
                                  media_type: "text/plain",
                                  data: convertToString(part.data)
                                },
                                title: (_c = metadata.title) != null ? _c : part.filename,
                                ...metadata.context && { context: metadata.context },
                                ...enableCitations && {
                                  citations: { enabled: true }
                                },
                                cache_control: cacheControl
                              });
                            } else {
                              throw new UnsupportedFunctionalityError$1({
                                functionality: `media type: ${part.mediaType}`
                              });
                            }
                            break;
                          }
                        }
                      }
                      break;
                    }
                    case "tool": {
                      for (let i2 = 0; i2 < content.length; i2++) {
                        const part = content[i2];
                        const isLastPart = i2 === content.length - 1;
                        const cacheControl = (_d = validator.getCacheControl(part.providerOptions, {
                          type: "tool result part",
                          canCache: true
                        })) != null ? _d : isLastPart ? validator.getCacheControl(message.providerOptions, {
                          type: "tool result message",
                          canCache: true
                        }) : void 0;
                        const output = part.output;
                        let contentValue;
                        switch (output.type) {
                          case "content":
                            contentValue = output.value.map((contentPart) => {
                              switch (contentPart.type) {
                                case "text":
                                  return {
                                    type: "text",
                                    text: contentPart.text
                                  };
                                case "media": {
                                  if (contentPart.mediaType.startsWith("image/")) {
                                    return {
                                      type: "image",
                                      source: {
                                        type: "base64",
                                        media_type: contentPart.mediaType,
                                        data: contentPart.data
                                      }
                                    };
                                  }
                                  if (contentPart.mediaType === "application/pdf") {
                                    betas.add("pdfs-2024-09-25");
                                    return {
                                      type: "document",
                                      source: {
                                        type: "base64",
                                        media_type: contentPart.mediaType,
                                        data: contentPart.data
                                      }
                                    };
                                  }
                                  throw new UnsupportedFunctionalityError$1({
                                    functionality: `media type: ${contentPart.mediaType}`
                                  });
                                }
                              }
                            });
                            break;
                          case "text":
                          case "error-text":
                            contentValue = output.value;
                            break;
                          case "json":
                          case "error-json":
                          default:
                            contentValue = JSON.stringify(output.value);
                            break;
                        }
                        anthropicContent.push({
                          type: "tool_result",
                          tool_use_id: part.toolCallId,
                          content: contentValue,
                          is_error: output.type === "error-text" || output.type === "error-json" ? true : void 0,
                          cache_control: cacheControl
                        });
                      }
                      break;
                    }
                    default: {
                      const _exhaustiveCheck = role;
                      throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                    }
                  }
                }
                messages.push({ role: "user", content: anthropicContent });
                break;
              }
              case "assistant": {
                const anthropicContent = [];
                for (let j = 0; j < block.messages.length; j++) {
                  const message = block.messages[j];
                  const isLastMessage = j === block.messages.length - 1;
                  const { content } = message;
                  for (let k = 0; k < content.length; k++) {
                    const part = content[k];
                    const isLastContentPart = k === content.length - 1;
                    const cacheControl = (_e = validator.getCacheControl(part.providerOptions, {
                      type: "assistant message part",
                      canCache: true
                    })) != null ? _e : isLastContentPart ? validator.getCacheControl(message.providerOptions, {
                      type: "assistant message",
                      canCache: true
                    }) : void 0;
                    switch (part.type) {
                      case "text": {
                        anthropicContent.push({
                          type: "text",
                          text: (
                            // trim the last text part if it's the last message in the block
                            // because Anthropic does not allow trailing whitespace
                            // in pre-filled assistant responses
                            isLastBlock && isLastMessage && isLastContentPart ? part.text.trim() : part.text
                          ),
                          cache_control: cacheControl
                        });
                        break;
                      }
                      case "reasoning": {
                        if (sendReasoning) {
                          const reasoningMetadata = await parseProviderOptions({
                            provider: "anthropic",
                            providerOptions: part.providerOptions,
                            schema: anthropicReasoningMetadataSchema
                          });
                          if (reasoningMetadata != null) {
                            if (reasoningMetadata.signature != null) {
                              validator.getCacheControl(part.providerOptions, {
                                type: "thinking block",
                                canCache: false
                              });
                              anthropicContent.push({
                                type: "thinking",
                                thinking: part.text,
                                signature: reasoningMetadata.signature
                              });
                            } else if (reasoningMetadata.redactedData != null) {
                              validator.getCacheControl(part.providerOptions, {
                                type: "redacted thinking block",
                                canCache: false
                              });
                              anthropicContent.push({
                                type: "redacted_thinking",
                                data: reasoningMetadata.redactedData
                              });
                            } else {
                              warnings.push({
                                type: "other",
                                message: "unsupported reasoning metadata"
                              });
                            }
                          } else {
                            warnings.push({
                              type: "other",
                              message: "unsupported reasoning metadata"
                            });
                          }
                        } else {
                          warnings.push({
                            type: "other",
                            message: "sending reasoning content is disabled for this model"
                          });
                        }
                        break;
                      }
                      case "tool-call": {
                        if (part.providerExecuted) {
                          if (part.toolName === "code_execution" && part.input != null && typeof part.input === "object" && "type" in part.input && typeof part.input.type === "string" && (part.input.type === "bash_code_execution" || part.input.type === "text_editor_code_execution")) {
                            anthropicContent.push({
                              type: "server_tool_use",
                              id: part.toolCallId,
                              name: part.input.type,
                              // map back to subtool name
                              input: part.input,
                              cache_control: cacheControl
                            });
                          } else if (part.toolName === "code_execution" || // code execution 20250522
                            part.toolName === "web_fetch" || part.toolName === "web_search") {
                            anthropicContent.push({
                              type: "server_tool_use",
                              id: part.toolCallId,
                              name: part.toolName,
                              input: part.input,
                              cache_control: cacheControl
                            });
                          } else {
                            warnings.push({
                              type: "other",
                              message: `provider executed tool call for tool ${part.toolName} is not supported`
                            });
                          }
                          break;
                        }
                        anthropicContent.push({
                          type: "tool_use",
                          id: part.toolCallId,
                          name: part.toolName,
                          input: part.input,
                          cache_control: cacheControl
                        });
                        break;
                      }
                      case "tool-result": {
                        if (part.toolName === "code_execution") {
                          const output = part.output;
                          if (output.type !== "json") {
                            warnings.push({
                              type: "other",
                              message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                            });
                            break;
                          }
                          if (output.value == null || typeof output.value !== "object" || !("type" in output.value) || typeof output.value.type !== "string") {
                            warnings.push({
                              type: "other",
                              message: `provider executed tool result output value is not a valid code execution result for tool ${part.toolName}`
                            });
                            break;
                          }
                          if (output.value.type === "code_execution_result") {
                            const codeExecutionOutput = await validateTypes$1({
                              value: output.value,
                              schema: codeExecution_20250522OutputSchema$1
                            });
                            anthropicContent.push({
                              type: "code_execution_tool_result",
                              tool_use_id: part.toolCallId,
                              content: {
                                type: codeExecutionOutput.type,
                                stdout: codeExecutionOutput.stdout,
                                stderr: codeExecutionOutput.stderr,
                                return_code: codeExecutionOutput.return_code
                              },
                              cache_control: cacheControl
                            });
                          } else {
                            const codeExecutionOutput = await validateTypes$1({
                              value: output.value,
                              schema: codeExecution_20250825OutputSchema$1
                            });
                            anthropicContent.push(
                              codeExecutionOutput.type === "bash_code_execution_result" || codeExecutionOutput.type === "bash_code_execution_tool_result_error" ? {
                                type: "bash_code_execution_tool_result",
                                tool_use_id: part.toolCallId,
                                cache_control: cacheControl,
                                content: codeExecutionOutput
                              } : {
                                type: "text_editor_code_execution_tool_result",
                                tool_use_id: part.toolCallId,
                                cache_control: cacheControl,
                                content: codeExecutionOutput
                              }
                            );
                          }
                          break;
                        }
                        if (part.toolName === "web_fetch") {
                          const output = part.output;
                          if (output.type !== "json") {
                            warnings.push({
                              type: "other",
                              message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                            });
                            break;
                          }
                          const webFetchOutput = await validateTypes$1({
                            value: output.value,
                            schema: webFetch_20250910OutputSchema$1
                          });
                          anthropicContent.push({
                            type: "web_fetch_tool_result",
                            tool_use_id: part.toolCallId,
                            content: {
                              type: "web_fetch_result",
                              url: webFetchOutput.url,
                              retrieved_at: webFetchOutput.retrievedAt,
                              content: {
                                type: "document",
                                title: webFetchOutput.content.title,
                                citations: webFetchOutput.content.citations,
                                source: {
                                  type: webFetchOutput.content.source.type,
                                  media_type: webFetchOutput.content.source.mediaType,
                                  data: webFetchOutput.content.source.data
                                }
                              }
                            },
                            cache_control: cacheControl
                          });
                          break;
                        }
                        if (part.toolName === "web_search") {
                          const output = part.output;
                          if (output.type !== "json") {
                            warnings.push({
                              type: "other",
                              message: `provider executed tool result output type ${output.type} for tool ${part.toolName} is not supported`
                            });
                            break;
                          }
                          const webSearchOutput = await validateTypes$1({
                            value: output.value,
                            schema: webSearch_20250305OutputSchema$1
                          });
                          anthropicContent.push({
                            type: "web_search_tool_result",
                            tool_use_id: part.toolCallId,
                            content: webSearchOutput.map((result) => ({
                              url: result.url,
                              title: result.title,
                              page_age: result.pageAge,
                              encrypted_content: result.encryptedContent,
                              type: result.type
                            })),
                            cache_control: cacheControl
                          });
                          break;
                        }
                        warnings.push({
                          type: "other",
                          message: `provider executed tool result for tool ${part.toolName} is not supported`
                        });
                        break;
                      }
                    }
                  }
                }
                messages.push({ role: "assistant", content: anthropicContent });
                break;
              }
              default: {
                const _exhaustiveCheck = type;
                throw new Error(`content type: ${_exhaustiveCheck}`);
              }
            }
          }
          return {
            prompt: { system, messages },
            betas
          };
        }
        function groupIntoBlocks$1(prompt) {
          const blocks = [];
          let currentBlock = void 0;
          for (const message of prompt) {
            const { role } = message;
            switch (role) {
              case "system": {
                if ((currentBlock == null ? void 0 : currentBlock.type) !== "system") {
                  currentBlock = { type: "system", messages: [] };
                  blocks.push(currentBlock);
                }
                currentBlock.messages.push(message);
                break;
              }
              case "assistant": {
                if ((currentBlock == null ? void 0 : currentBlock.type) !== "assistant") {
                  currentBlock = { type: "assistant", messages: [] };
                  blocks.push(currentBlock);
                }
                currentBlock.messages.push(message);
                break;
              }
              case "user": {
                if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
                  currentBlock = { type: "user", messages: [] };
                  blocks.push(currentBlock);
                }
                currentBlock.messages.push(message);
                break;
              }
              case "tool": {
                if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
                  currentBlock = { type: "user", messages: [] };
                  blocks.push(currentBlock);
                }
                currentBlock.messages.push(message);
                break;
              }
              default: {
                const _exhaustiveCheck = role;
                throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
              }
            }
          }
          return blocks;
        }

        // src/map-anthropic-stop-reason.ts
        function mapAnthropicStopReason({
          finishReason,
          isJsonResponseFromTool
        }) {
          switch (finishReason) {
            case "pause_turn":
            case "end_turn":
            case "stop_sequence":
              return "stop";
            case "refusal":
              return "content-filter";
            case "tool_use":
              return isJsonResponseFromTool ? "stop" : "tool-calls";
            case "max_tokens":
              return "length";
            default:
              return "unknown";
          }
        }

        // src/anthropic-messages-language-model.ts
        function createCitationSource(citation, citationDocuments, generateId3) {
          var _a;
          if (citation.type !== "page_location" && citation.type !== "char_location") {
            return;
          }
          const documentInfo = citationDocuments[citation.document_index];
          if (!documentInfo) {
            return;
          }
          return {
            type: "source",
            sourceType: "document",
            id: generateId3(),
            mediaType: documentInfo.mediaType,
            title: (_a = citation.document_title) != null ? _a : documentInfo.title,
            filename: documentInfo.filename,
            providerMetadata: {
              anthropic: citation.type === "page_location" ? {
                citedText: citation.cited_text,
                startPageNumber: citation.start_page_number,
                endPageNumber: citation.end_page_number
              } : {
                citedText: citation.cited_text,
                startCharIndex: citation.start_char_index,
                endCharIndex: citation.end_char_index
              }
            }
          };
        }
        var AnthropicMessagesLanguageModel = class {
          constructor(modelId, config) {
            this.specificationVersion = "v2";
            var _a;
            this.modelId = modelId;
            this.config = config;
            this.generateId = (_a = config.generateId) != null ? _a : generateId$1;
          }
          supportsUrl(url) {
            return url.protocol === "https:";
          }
          get provider() {
            return this.config.provider;
          }
          get supportedUrls() {
            var _a, _b, _c;
            return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
          }
          async getArgs({
            prompt,
            maxOutputTokens,
            temperature,
            topP,
            topK,
            frequencyPenalty,
            presencePenalty,
            stopSequences,
            responseFormat,
            seed,
            tools,
            toolChoice,
            providerOptions
          }) {
            var _a, _b, _c, _d;
            const warnings = [];
            if (frequencyPenalty != null) {
              warnings.push({
                type: "unsupported-setting",
                setting: "frequencyPenalty"
              });
            }
            if (presencePenalty != null) {
              warnings.push({
                type: "unsupported-setting",
                setting: "presencePenalty"
              });
            }
            if (seed != null) {
              warnings.push({
                type: "unsupported-setting",
                setting: "seed"
              });
            }
            if ((responseFormat == null ? void 0 : responseFormat.type) === "json") {
              if (responseFormat.schema == null) {
                warnings.push({
                  type: "unsupported-setting",
                  setting: "responseFormat",
                  details: "JSON response format requires a schema. The response format is ignored."
                });
              } else if (tools != null) {
                warnings.push({
                  type: "unsupported-setting",
                  setting: "tools",
                  details: "JSON response format does not support tools. The provided tools are ignored."
                });
              }
            }
            const jsonResponseTool = (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null ? {
              type: "function",
              name: "json",
              description: "Respond with a JSON object.",
              inputSchema: responseFormat.schema
            } : void 0;
            const anthropicOptions = await parseProviderOptions({
              provider: "anthropic",
              providerOptions,
              schema: anthropicProviderOptions
            });
            const cacheControlValidator = new CacheControlValidator$1();
            const { prompt: messagesPrompt, betas } = await convertToAnthropicMessagesPrompt({
              prompt,
              sendReasoning: (_a = anthropicOptions == null ? void 0 : anthropicOptions.sendReasoning) != null ? _a : true,
              warnings,
              cacheControlValidator
            });
            const isThinking = ((_b = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _b.type) === "enabled";
            const thinkingBudget = (_c = anthropicOptions == null ? void 0 : anthropicOptions.thinking) == null ? void 0 : _c.budgetTokens;
            const maxOutputTokensForModel = getMaxOutputTokensForModel(this.modelId);
            const maxTokens = maxOutputTokens != null ? maxOutputTokens : maxOutputTokensForModel;
            const baseArgs = {
              // model id:
              model: this.modelId,
              // standardized settings:
              max_tokens: maxTokens,
              temperature,
              top_k: topK,
              top_p: topP,
              stop_sequences: stopSequences,
              // provider specific settings:
              ...isThinking && {
                thinking: { type: "enabled", budget_tokens: thinkingBudget }
              },
              // container with agent skills:
              ...(anthropicOptions == null ? void 0 : anthropicOptions.container) && {
                container: {
                  id: anthropicOptions.container.id,
                  skills: (_d = anthropicOptions.container.skills) == null ? void 0 : _d.map((skill) => ({
                    type: skill.type,
                    skill_id: skill.skillId,
                    version: skill.version
                  }))
                }
              },
              // prompt:
              system: messagesPrompt.system,
              messages: messagesPrompt.messages
            };
            if (isThinking) {
              if (thinkingBudget == null) {
                throw new UnsupportedFunctionalityError$1({
                  functionality: "thinking requires a budget"
                });
              }
              if (baseArgs.temperature != null) {
                baseArgs.temperature = void 0;
                warnings.push({
                  type: "unsupported-setting",
                  setting: "temperature",
                  details: "temperature is not supported when thinking is enabled"
                });
              }
              if (topK != null) {
                baseArgs.top_k = void 0;
                warnings.push({
                  type: "unsupported-setting",
                  setting: "topK",
                  details: "topK is not supported when thinking is enabled"
                });
              }
              if (topP != null) {
                baseArgs.top_p = void 0;
                warnings.push({
                  type: "unsupported-setting",
                  setting: "topP",
                  details: "topP is not supported when thinking is enabled"
                });
              }
              baseArgs.max_tokens = maxTokens + thinkingBudget;
            }
            if (baseArgs.max_tokens > maxOutputTokensForModel) {
              if (maxOutputTokens != null) {
                warnings.push({
                  type: "unsupported-setting",
                  setting: "maxOutputTokens",
                  details: `${baseArgs.max_tokens} (maxOutputTokens + thinkingBudget) is greater than ${this.modelId} ${maxOutputTokensForModel} max output tokens. The max output tokens have been limited to ${maxOutputTokensForModel}.`
                });
              }
              baseArgs.max_tokens = maxOutputTokensForModel;
            }
            if ((anthropicOptions == null ? void 0 : anthropicOptions.container) && anthropicOptions.container.skills && anthropicOptions.container.skills.length > 0) {
              betas.add("code-execution-2025-08-25");
              betas.add("skills-2025-10-02");
              betas.add("files-api-2025-04-14");
              if (!(tools == null ? void 0 : tools.some(
                (tool) => tool.type === "provider-defined" && tool.id === "anthropic.code_execution_20250825"
              ))) {
                warnings.push({
                  type: "other",
                  message: "code execution tool is required when using skills"
                });
              }
            }
            const {
              tools: anthropicTools2,
              toolChoice: anthropicToolChoice,
              toolWarnings,
              betas: toolsBetas
            } = await prepareTools$4(
              jsonResponseTool != null ? {
                tools: [jsonResponseTool],
                toolChoice: { type: "tool", toolName: jsonResponseTool.name },
                disableParallelToolUse: true,
                cacheControlValidator
              } : {
                tools: tools != null ? tools : [],
                toolChoice,
                disableParallelToolUse: anthropicOptions == null ? void 0 : anthropicOptions.disableParallelToolUse,
                cacheControlValidator
              }
            );
            const cacheWarnings = cacheControlValidator.getWarnings();
            return {
              args: {
                ...baseArgs,
                tools: anthropicTools2,
                tool_choice: anthropicToolChoice
              },
              warnings: [...warnings, ...toolWarnings, ...cacheWarnings],
              betas: /* @__PURE__ */ new Set([...betas, ...toolsBetas]),
              usesJsonResponseTool: jsonResponseTool != null
            };
          }
          async getHeaders({
            betas,
            headers
          }) {
            return combineHeaders$1(
              await resolve(this.config.headers),
              betas.size > 0 ? { "anthropic-beta": Array.from(betas).join(",") } : {},
              headers
            );
          }
          buildRequestUrl(isStreaming) {
            var _a, _b, _c;
            return (_c = (_b = (_a = this.config).buildRequestUrl) == null ? void 0 : _b.call(_a, this.config.baseURL, isStreaming)) != null ? _c : `${this.config.baseURL}/messages`;
          }
          transformRequestBody(args) {
            var _a, _b, _c;
            return (_c = (_b = (_a = this.config).transformRequestBody) == null ? void 0 : _b.call(_a, args)) != null ? _c : args;
          }
          extractCitationDocuments(prompt) {
            const isCitationPart = (part) => {
              var _a, _b;
              if (part.type !== "file") {
                return false;
              }
              if (part.mediaType !== "application/pdf" && part.mediaType !== "text/plain") {
                return false;
              }
              const anthropic2 = (_a = part.providerOptions) == null ? void 0 : _a.anthropic;
              const citationsConfig = anthropic2 == null ? void 0 : anthropic2.citations;
              return (_b = citationsConfig == null ? void 0 : citationsConfig.enabled) != null ? _b : false;
            };
            return prompt.filter((message) => message.role === "user").flatMap((message) => message.content).filter(isCitationPart).map((part) => {
              var _a;
              const filePart = part;
              return {
                title: (_a = filePart.filename) != null ? _a : "Untitled Document",
                filename: filePart.filename,
                mediaType: filePart.mediaType
              };
            });
          }
          async doGenerate(options) {
            var _a, _b, _c, _d, _e, _f;
            const { args, warnings, betas, usesJsonResponseTool } = await this.getArgs(options);
            const citationDocuments = this.extractCitationDocuments(options.prompt);
            const {
              responseHeaders,
              value: response,
              rawValue: rawResponse
            } = await postJsonToApi$1({
              url: this.buildRequestUrl(false),
              headers: await this.getHeaders({ betas, headers: options.headers }),
              body: this.transformRequestBody(args),
              failedResponseHandler: anthropicFailedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler$1(
                anthropicMessagesResponseSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            const content = [];
            for (const part of response.content) {
              switch (part.type) {
                case "text": {
                  if (!usesJsonResponseTool) {
                    content.push({ type: "text", text: part.text });
                    if (part.citations) {
                      for (const citation of part.citations) {
                        const source = createCitationSource(
                          citation,
                          citationDocuments,
                          this.generateId
                        );
                        if (source) {
                          content.push(source);
                        }
                      }
                    }
                  }
                  break;
                }
                case "thinking": {
                  content.push({
                    type: "reasoning",
                    text: part.thinking,
                    providerMetadata: {
                      anthropic: {
                        signature: part.signature
                      }
                    }
                  });
                  break;
                }
                case "redacted_thinking": {
                  content.push({
                    type: "reasoning",
                    text: "",
                    providerMetadata: {
                      anthropic: {
                        redactedData: part.data
                      }
                    }
                  });
                  break;
                }
                case "tool_use": {
                  content.push(
                    // when a json response tool is used, the tool call becomes the text:
                    usesJsonResponseTool ? {
                      type: "text",
                      text: JSON.stringify(part.input)
                    } : {
                      type: "tool-call",
                      toolCallId: part.id,
                      toolName: part.name,
                      input: JSON.stringify(part.input)
                    }
                  );
                  break;
                }
                case "server_tool_use": {
                  if (part.name === "text_editor_code_execution" || part.name === "bash_code_execution") {
                    content.push({
                      type: "tool-call",
                      toolCallId: part.id,
                      toolName: "code_execution",
                      input: JSON.stringify({ type: part.name, ...part.input }),
                      providerExecuted: true
                    });
                  } else if (part.name === "web_search" || part.name === "code_execution" || part.name === "web_fetch") {
                    content.push({
                      type: "tool-call",
                      toolCallId: part.id,
                      toolName: part.name,
                      input: JSON.stringify(part.input),
                      providerExecuted: true
                    });
                  }
                  break;
                }
                case "web_fetch_tool_result": {
                  if (part.content.type === "web_fetch_result") {
                    content.push({
                      type: "tool-result",
                      toolCallId: part.tool_use_id,
                      toolName: "web_fetch",
                      result: {
                        type: "web_fetch_result",
                        url: part.content.url,
                        retrievedAt: part.content.retrieved_at,
                        content: {
                          type: part.content.content.type,
                          title: part.content.content.title,
                          citations: part.content.content.citations,
                          source: {
                            type: part.content.content.source.type,
                            mediaType: part.content.content.source.media_type,
                            data: part.content.content.source.data
                          }
                        }
                      },
                      providerExecuted: true
                    });
                  } else if (part.content.type === "web_fetch_tool_result_error") {
                    content.push({
                      type: "tool-result",
                      toolCallId: part.tool_use_id,
                      toolName: "web_fetch",
                      isError: true,
                      result: {
                        type: "web_fetch_tool_result_error",
                        errorCode: part.content.error_code
                      },
                      providerExecuted: true
                    });
                  }
                  break;
                }
                case "web_search_tool_result": {
                  if (Array.isArray(part.content)) {
                    content.push({
                      type: "tool-result",
                      toolCallId: part.tool_use_id,
                      toolName: "web_search",
                      result: part.content.map((result) => {
                        var _a2;
                        return {
                          url: result.url,
                          title: result.title,
                          pageAge: (_a2 = result.page_age) != null ? _a2 : null,
                          encryptedContent: result.encrypted_content,
                          type: result.type
                        };
                      }),
                      providerExecuted: true
                    });
                    for (const result of part.content) {
                      content.push({
                        type: "source",
                        sourceType: "url",
                        id: this.generateId(),
                        url: result.url,
                        title: result.title,
                        providerMetadata: {
                          anthropic: {
                            pageAge: (_a = result.page_age) != null ? _a : null
                          }
                        }
                      });
                    }
                  } else {
                    content.push({
                      type: "tool-result",
                      toolCallId: part.tool_use_id,
                      toolName: "web_search",
                      isError: true,
                      result: {
                        type: "web_search_tool_result_error",
                        errorCode: part.content.error_code
                      },
                      providerExecuted: true
                    });
                  }
                  break;
                }
                // code execution 20250522:
                case "code_execution_tool_result": {
                  if (part.content.type === "code_execution_result") {
                    content.push({
                      type: "tool-result",
                      toolCallId: part.tool_use_id,
                      toolName: "code_execution",
                      result: {
                        type: part.content.type,
                        stdout: part.content.stdout,
                        stderr: part.content.stderr,
                        return_code: part.content.return_code
                      },
                      providerExecuted: true
                    });
                  } else if (part.content.type === "code_execution_tool_result_error") {
                    content.push({
                      type: "tool-result",
                      toolCallId: part.tool_use_id,
                      toolName: "code_execution",
                      isError: true,
                      result: {
                        type: "code_execution_tool_result_error",
                        errorCode: part.content.error_code
                      },
                      providerExecuted: true
                    });
                  }
                  break;
                }
                // code execution 20250825:
                case "bash_code_execution_tool_result":
                case "text_editor_code_execution_tool_result": {
                  content.push({
                    type: "tool-result",
                    toolCallId: part.tool_use_id,
                    toolName: "code_execution",
                    result: part.content,
                    providerExecuted: true
                  });
                  break;
                }
              }
            }
            return {
              content,
              finishReason: mapAnthropicStopReason({
                finishReason: response.stop_reason,
                isJsonResponseFromTool: usesJsonResponseTool
              }),
              usage: {
                inputTokens: response.usage.input_tokens,
                outputTokens: response.usage.output_tokens,
                totalTokens: response.usage.input_tokens + response.usage.output_tokens,
                cachedInputTokens: (_b = response.usage.cache_read_input_tokens) != null ? _b : void 0
              },
              request: { body: args },
              response: {
                id: (_c = response.id) != null ? _c : void 0,
                modelId: (_d = response.model) != null ? _d : void 0,
                headers: responseHeaders,
                body: rawResponse
              },
              warnings,
              providerMetadata: {
                anthropic: {
                  usage: response.usage,
                  cacheCreationInputTokens: (_e = response.usage.cache_creation_input_tokens) != null ? _e : null,
                  stopSequence: (_f = response.stop_sequence) != null ? _f : null
                }
              }
            };
          }
          async doStream(options) {
            const { args, warnings, betas, usesJsonResponseTool } = await this.getArgs(options);
            const citationDocuments = this.extractCitationDocuments(options.prompt);
            const body = { ...args, stream: true };
            const { responseHeaders, value: response } = await postJsonToApi$1({
              url: this.buildRequestUrl(true),
              headers: await this.getHeaders({ betas, headers: options.headers }),
              body: this.transformRequestBody(body),
              failedResponseHandler: anthropicFailedResponseHandler,
              successfulResponseHandler: createEventSourceResponseHandler$1(
                anthropicMessagesChunkSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            let finishReason = "unknown";
            const usage = {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            };
            const contentBlocks = {};
            let rawUsage = void 0;
            let cacheCreationInputTokens = null;
            let stopSequence = null;
            let blockType = void 0;
            const generateId3 = this.generateId;
            return {
              stream: response.pipeThrough(
                new TransformStream({
                  start(controller) {
                    controller.enqueue({ type: "stream-start", warnings });
                  },
                  transform(chunk, controller) {
                    var _a, _b, _c, _d, _e, _f, _g, _h;
                    if (options.includeRawChunks) {
                      controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                    }
                    if (!chunk.success) {
                      controller.enqueue({ type: "error", error: chunk.error });
                      return;
                    }
                    const value = chunk.value;
                    switch (value.type) {
                      case "ping": {
                        return;
                      }
                      case "content_block_start": {
                        const contentBlockType = value.content_block.type;
                        blockType = contentBlockType;
                        switch (contentBlockType) {
                          case "text": {
                            contentBlocks[value.index] = { type: "text" };
                            controller.enqueue({
                              type: "text-start",
                              id: String(value.index)
                            });
                            return;
                          }
                          case "thinking": {
                            contentBlocks[value.index] = { type: "reasoning" };
                            controller.enqueue({
                              type: "reasoning-start",
                              id: String(value.index)
                            });
                            return;
                          }
                          case "redacted_thinking": {
                            contentBlocks[value.index] = { type: "reasoning" };
                            controller.enqueue({
                              type: "reasoning-start",
                              id: String(value.index),
                              providerMetadata: {
                                anthropic: {
                                  redactedData: value.content_block.data
                                }
                              }
                            });
                            return;
                          }
                          case "tool_use": {
                            contentBlocks[value.index] = usesJsonResponseTool ? { type: "text" } : {
                              type: "tool-call",
                              toolCallId: value.content_block.id,
                              toolName: value.content_block.name,
                              input: "",
                              firstDelta: true
                            };
                            controller.enqueue(
                              usesJsonResponseTool ? { type: "text-start", id: String(value.index) } : {
                                type: "tool-input-start",
                                id: value.content_block.id,
                                toolName: value.content_block.name
                              }
                            );
                            return;
                          }
                          case "server_tool_use": {
                            if ([
                              "web_fetch",
                              "web_search",
                              // code execution 20250825:
                              "code_execution",
                              // code execution 20250825 text editor:
                              "text_editor_code_execution",
                              // code execution 20250825 bash:
                              "bash_code_execution"
                            ].includes(value.content_block.name)) {
                              contentBlocks[value.index] = {
                                type: "tool-call",
                                toolCallId: value.content_block.id,
                                toolName: value.content_block.name,
                                input: "",
                                providerExecuted: true,
                                firstDelta: true
                              };
                              const mappedToolName = value.content_block.name === "text_editor_code_execution" || value.content_block.name === "bash_code_execution" ? "code_execution" : value.content_block.name;
                              controller.enqueue({
                                type: "tool-input-start",
                                id: value.content_block.id,
                                toolName: mappedToolName,
                                providerExecuted: true
                              });
                            }
                            return;
                          }
                          case "web_fetch_tool_result": {
                            const part = value.content_block;
                            if (part.content.type === "web_fetch_result") {
                              controller.enqueue({
                                type: "tool-result",
                                toolCallId: part.tool_use_id,
                                toolName: "web_fetch",
                                result: {
                                  type: "web_fetch_result",
                                  url: part.content.url,
                                  retrievedAt: part.content.retrieved_at,
                                  content: {
                                    type: part.content.content.type,
                                    title: part.content.content.title,
                                    citations: part.content.content.citations,
                                    source: {
                                      type: part.content.content.source.type,
                                      mediaType: part.content.content.source.media_type,
                                      data: part.content.content.source.data
                                    }
                                  }
                                }
                              });
                            } else if (part.content.type === "web_fetch_tool_result_error") {
                              controller.enqueue({
                                type: "tool-result",
                                toolCallId: part.tool_use_id,
                                toolName: "web_fetch",
                                isError: true,
                                result: {
                                  type: "web_fetch_tool_result_error",
                                  errorCode: part.content.error_code
                                },
                                providerExecuted: true
                              });
                            }
                            return;
                          }
                          case "web_search_tool_result": {
                            const part = value.content_block;
                            if (Array.isArray(part.content)) {
                              controller.enqueue({
                                type: "tool-result",
                                toolCallId: part.tool_use_id,
                                toolName: "web_search",
                                result: part.content.map((result) => {
                                  var _a2;
                                  return {
                                    url: result.url,
                                    title: result.title,
                                    pageAge: (_a2 = result.page_age) != null ? _a2 : null,
                                    encryptedContent: result.encrypted_content,
                                    type: result.type
                                  };
                                }),
                                providerExecuted: true
                              });
                              for (const result of part.content) {
                                controller.enqueue({
                                  type: "source",
                                  sourceType: "url",
                                  id: generateId3(),
                                  url: result.url,
                                  title: result.title,
                                  providerMetadata: {
                                    anthropic: {
                                      pageAge: (_a = result.page_age) != null ? _a : null
                                    }
                                  }
                                });
                              }
                            } else {
                              controller.enqueue({
                                type: "tool-result",
                                toolCallId: part.tool_use_id,
                                toolName: "web_search",
                                isError: true,
                                result: {
                                  type: "web_search_tool_result_error",
                                  errorCode: part.content.error_code
                                },
                                providerExecuted: true
                              });
                            }
                            return;
                          }
                          // code execution 20250522:
                          case "code_execution_tool_result": {
                            const part = value.content_block;
                            if (part.content.type === "code_execution_result") {
                              controller.enqueue({
                                type: "tool-result",
                                toolCallId: part.tool_use_id,
                                toolName: "code_execution",
                                result: {
                                  type: part.content.type,
                                  stdout: part.content.stdout,
                                  stderr: part.content.stderr,
                                  return_code: part.content.return_code
                                },
                                providerExecuted: true
                              });
                            } else if (part.content.type === "code_execution_tool_result_error") {
                              controller.enqueue({
                                type: "tool-result",
                                toolCallId: part.tool_use_id,
                                toolName: "code_execution",
                                isError: true,
                                result: {
                                  type: "code_execution_tool_result_error",
                                  errorCode: part.content.error_code
                                },
                                providerExecuted: true
                              });
                            }
                            return;
                          }
                          // code execution 20250825:
                          case "bash_code_execution_tool_result":
                          case "text_editor_code_execution_tool_result": {
                            const part = value.content_block;
                            controller.enqueue({
                              type: "tool-result",
                              toolCallId: part.tool_use_id,
                              toolName: "code_execution",
                              result: part.content,
                              providerExecuted: true
                            });
                            return;
                          }
                          default: {
                            const _exhaustiveCheck = contentBlockType;
                            throw new Error(
                              `Unsupported content block type: ${_exhaustiveCheck}`
                            );
                          }
                        }
                      }
                      case "content_block_stop": {
                        if (contentBlocks[value.index] != null) {
                          const contentBlock = contentBlocks[value.index];
                          switch (contentBlock.type) {
                            case "text": {
                              controller.enqueue({
                                type: "text-end",
                                id: String(value.index)
                              });
                              break;
                            }
                            case "reasoning": {
                              controller.enqueue({
                                type: "reasoning-end",
                                id: String(value.index)
                              });
                              break;
                            }
                            case "tool-call":
                              if (!usesJsonResponseTool) {
                                controller.enqueue({
                                  type: "tool-input-end",
                                  id: contentBlock.toolCallId
                                });
                                const toolName = contentBlock.toolName === "text_editor_code_execution" || contentBlock.toolName === "bash_code_execution" ? "code_execution" : contentBlock.toolName;
                                controller.enqueue({
                                  type: "tool-call",
                                  toolCallId: contentBlock.toolCallId,
                                  toolName,
                                  input: contentBlock.input,
                                  providerExecuted: contentBlock.providerExecuted
                                });
                              }
                              break;
                          }
                          delete contentBlocks[value.index];
                        }
                        blockType = void 0;
                        return;
                      }
                      case "content_block_delta": {
                        const deltaType = value.delta.type;
                        switch (deltaType) {
                          case "text_delta": {
                            if (usesJsonResponseTool) {
                              return;
                            }
                            controller.enqueue({
                              type: "text-delta",
                              id: String(value.index),
                              delta: value.delta.text
                            });
                            return;
                          }
                          case "thinking_delta": {
                            controller.enqueue({
                              type: "reasoning-delta",
                              id: String(value.index),
                              delta: value.delta.thinking
                            });
                            return;
                          }
                          case "signature_delta": {
                            if (blockType === "thinking") {
                              controller.enqueue({
                                type: "reasoning-delta",
                                id: String(value.index),
                                delta: "",
                                providerMetadata: {
                                  anthropic: {
                                    signature: value.delta.signature
                                  }
                                }
                              });
                            }
                            return;
                          }
                          case "input_json_delta": {
                            const contentBlock = contentBlocks[value.index];
                            let delta = value.delta.partial_json;
                            if (delta.length === 0) {
                              return;
                            }
                            if (usesJsonResponseTool) {
                              if ((contentBlock == null ? void 0 : contentBlock.type) !== "text") {
                                return;
                              }
                              controller.enqueue({
                                type: "text-delta",
                                id: String(value.index),
                                delta
                              });
                            } else {
                              if ((contentBlock == null ? void 0 : contentBlock.type) !== "tool-call") {
                                return;
                              }
                              if (contentBlock.firstDelta && (contentBlock.toolName === "bash_code_execution" || contentBlock.toolName === "text_editor_code_execution")) {
                                delta = `{"type": "${contentBlock.toolName}",${delta.substring(1)}`;
                              }
                              controller.enqueue({
                                type: "tool-input-delta",
                                id: contentBlock.toolCallId,
                                delta
                              });
                              contentBlock.input += delta;
                              contentBlock.firstDelta = false;
                            }
                            return;
                          }
                          case "citations_delta": {
                            const citation = value.delta.citation;
                            const source = createCitationSource(
                              citation,
                              citationDocuments,
                              generateId3
                            );
                            if (source) {
                              controller.enqueue(source);
                            }
                            return;
                          }
                          default: {
                            const _exhaustiveCheck = deltaType;
                            throw new Error(
                              `Unsupported delta type: ${_exhaustiveCheck}`
                            );
                          }
                        }
                      }
                      case "message_start": {
                        usage.inputTokens = value.message.usage.input_tokens;
                        usage.cachedInputTokens = (_b = value.message.usage.cache_read_input_tokens) != null ? _b : void 0;
                        rawUsage = {
                          ...value.message.usage
                        };
                        cacheCreationInputTokens = (_c = value.message.usage.cache_creation_input_tokens) != null ? _c : null;
                        controller.enqueue({
                          type: "response-metadata",
                          id: (_d = value.message.id) != null ? _d : void 0,
                          modelId: (_e = value.message.model) != null ? _e : void 0
                        });
                        return;
                      }
                      case "message_delta": {
                        usage.outputTokens = value.usage.output_tokens;
                        usage.totalTokens = ((_f = usage.inputTokens) != null ? _f : 0) + ((_g = value.usage.output_tokens) != null ? _g : 0);
                        finishReason = mapAnthropicStopReason({
                          finishReason: value.delta.stop_reason,
                          isJsonResponseFromTool: usesJsonResponseTool
                        });
                        stopSequence = (_h = value.delta.stop_sequence) != null ? _h : null;
                        rawUsage = {
                          ...rawUsage,
                          ...value.usage
                        };
                        return;
                      }
                      case "message_stop": {
                        controller.enqueue({
                          type: "finish",
                          finishReason,
                          usage,
                          providerMetadata: {
                            anthropic: {
                              usage: rawUsage != null ? rawUsage : null,
                              cacheCreationInputTokens,
                              stopSequence
                            }
                          }
                        });
                        return;
                      }
                      case "error": {
                        controller.enqueue({ type: "error", error: value.error });
                        return;
                      }
                      default: {
                        const _exhaustiveCheck = value;
                        throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
                      }
                    }
                  }
                })
              ),
              request: { body },
              response: { headers: responseHeaders }
            };
          }
        };
        function getMaxOutputTokensForModel(modelId) {
          if (modelId.includes("claude-sonnet-4-") || modelId.includes("claude-3-7-sonnet") || modelId.includes("claude-haiku-4-5")) {
            return 64e3;
          } else if (modelId.includes("claude-opus-4-")) {
            return 32e3;
          } else if (modelId.includes("claude-3-5-haiku")) {
            return 8192;
          } else {
            return 4096;
          }
        }
        var bash_20241022InputSchema$1 = lazySchema(
          () => zodSchema(
            object({
              command: string(),
              restart: boolean().optional()
            })
          )
        );
        var bash_20241022$1 = createProviderDefinedToolFactory({
          id: "anthropic.bash_20241022",
          name: "bash",
          inputSchema: bash_20241022InputSchema$1
        });
        var bash_20250124InputSchema$1 = lazySchema(
          () => zodSchema(
            object({
              command: string(),
              restart: boolean().optional()
            })
          )
        );
        var bash_20250124$1 = createProviderDefinedToolFactory({
          id: "anthropic.bash_20250124",
          name: "bash",
          inputSchema: bash_20250124InputSchema$1
        });
        var computer_20241022InputSchema$1 = lazySchema(
          () => zodSchema(
            object({
              action: _enum([
                "key",
                "type",
                "mouse_move",
                "left_click",
                "left_click_drag",
                "right_click",
                "middle_click",
                "double_click",
                "screenshot",
                "cursor_position"
              ]),
              coordinate: array(number$1().int()).optional(),
              text: string().optional()
            })
          )
        );
        var computer_20241022$1 = createProviderDefinedToolFactory({
          id: "anthropic.computer_20241022",
          name: "computer",
          inputSchema: computer_20241022InputSchema$1
        });
        var computer_20250124InputSchema$1 = lazySchema(
          () => zodSchema(
            object({
              action: _enum([
                "key",
                "hold_key",
                "type",
                "cursor_position",
                "mouse_move",
                "left_mouse_down",
                "left_mouse_up",
                "left_click",
                "left_click_drag",
                "right_click",
                "middle_click",
                "double_click",
                "triple_click",
                "scroll",
                "wait",
                "screenshot"
              ]),
              coordinate: tuple([number$1().int(), number$1().int()]).optional(),
              duration: number$1().optional(),
              scroll_amount: number$1().optional(),
              scroll_direction: _enum(["up", "down", "left", "right"]).optional(),
              start_coordinate: tuple([number$1().int(), number$1().int()]).optional(),
              text: string().optional()
            })
          )
        );
        var computer_20250124$1 = createProviderDefinedToolFactory({
          id: "anthropic.computer_20250124",
          name: "computer",
          inputSchema: computer_20250124InputSchema$1
        });
        var memory_20250818InputSchema$1 = lazySchema(
          () => zodSchema(
            discriminatedUnion("command", [
              object({
                command: literal("view"),
                path: string(),
                view_range: tuple([number$1(), number$1()]).optional()
              }),
              object({
                command: literal("create"),
                path: string(),
                file_text: string()
              }),
              object({
                command: literal("str_replace"),
                path: string(),
                old_str: string(),
                new_str: string()
              }),
              object({
                command: literal("insert"),
                path: string(),
                insert_line: number$1(),
                insert_text: string()
              }),
              object({
                command: literal("delete"),
                path: string()
              }),
              object({
                command: literal("rename"),
                old_path: string(),
                new_path: string()
              })
            ])
          )
        );
        var memory_20250818$1 = createProviderDefinedToolFactory({
          id: "anthropic.memory_20250818",
          name: "memory",
          inputSchema: memory_20250818InputSchema$1
        });
        var textEditor_20241022InputSchema$1 = lazySchema(
          () => zodSchema(
            object({
              command: _enum(["view", "create", "str_replace", "insert", "undo_edit"]),
              path: string(),
              file_text: string().optional(),
              insert_line: number$1().int().optional(),
              new_str: string().optional(),
              old_str: string().optional(),
              view_range: array(number$1().int()).optional()
            })
          )
        );
        var textEditor_20241022$1 = createProviderDefinedToolFactory({
          id: "anthropic.text_editor_20241022",
          name: "str_replace_editor",
          inputSchema: textEditor_20241022InputSchema$1
        });
        var textEditor_20250124InputSchema$1 = lazySchema(
          () => zodSchema(
            object({
              command: _enum(["view", "create", "str_replace", "insert", "undo_edit"]),
              path: string(),
              file_text: string().optional(),
              insert_line: number$1().int().optional(),
              new_str: string().optional(),
              old_str: string().optional(),
              view_range: array(number$1().int()).optional()
            })
          )
        );
        var textEditor_20250124$1 = createProviderDefinedToolFactory({
          id: "anthropic.text_editor_20250124",
          name: "str_replace_editor",
          inputSchema: textEditor_20250124InputSchema$1
        });
        var textEditor_20250429InputSchema$1 = lazySchema(
          () => zodSchema(
            object({
              command: _enum(["view", "create", "str_replace", "insert"]),
              path: string(),
              file_text: string().optional(),
              insert_line: number$1().int().optional(),
              new_str: string().optional(),
              old_str: string().optional(),
              view_range: array(number$1().int()).optional()
            })
          )
        );
        var textEditor_20250429$1 = createProviderDefinedToolFactory({
          id: "anthropic.text_editor_20250429",
          name: "str_replace_based_edit_tool",
          inputSchema: textEditor_20250429InputSchema$1
        });

        // src/anthropic-tools.ts
        var anthropicTools$1 = {
          /**
           * The bash tool enables Claude to execute shell commands in a persistent bash session,
           * allowing system operations, script execution, and command-line automation.
           *
           * Image results are supported.
           *
           * Tool name must be `bash`.
           */
          bash_20241022: bash_20241022$1,
          /**
           * The bash tool enables Claude to execute shell commands in a persistent bash session,
           * allowing system operations, script execution, and command-line automation.
           *
           * Image results are supported.
           *
           * Tool name must be `bash`.
           */
          bash_20250124: bash_20250124$1,
          /**
           * Claude can analyze data, create visualizations, perform complex calculations,
           * run system commands, create and edit files, and process uploaded files directly within
           * the API conversation.
           *
           * The code execution tool allows Claude to run Bash commands and manipulate files,
           * including writing code, in a secure, sandboxed environment.
           *
           * Tool name must be `code_execution`.
           */
          codeExecution_20250522: codeExecution_20250522$1,
          /**
           * Claude can analyze data, create visualizations, perform complex calculations,
           * run system commands, create and edit files, and process uploaded files directly within
           * the API conversation.
           *
           * The code execution tool allows Claude to run both Python and Bash commands and manipulate files,
           * including writing code, in a secure, sandboxed environment.
           *
           * This is the latest version with enhanced Bash support and file operations.
           *
           * Tool name must be `code_execution`.
           */
          codeExecution_20250825: codeExecution_20250825$1,
          /**
           * Claude can interact with computer environments through the computer use tool, which
           * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
           *
           * Image results are supported.
           *
           * Tool name must be `computer`.
           *
           * @param displayWidthPx - The width of the display being controlled by the model in pixels.
           * @param displayHeightPx - The height of the display being controlled by the model in pixels.
           * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
           */
          computer_20241022: computer_20241022$1,
          /**
           * Claude can interact with computer environments through the computer use tool, which
           * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
           *
           * Image results are supported.
           *
           * Tool name must be `computer`.
           *
           * @param displayWidthPx - The width of the display being controlled by the model in pixels.
           * @param displayHeightPx - The height of the display being controlled by the model in pixels.
           * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
           */
          computer_20250124: computer_20250124$1,
          /**
           * The memory tool enables Claude to store and retrieve information across conversations through a memory file directory.
           * Claude can create, read, update, and delete files that persist between sessions,
           * allowing it to build knowledge over time without keeping everything in the context window.
           * The memory tool operates client-side—you control where and how the data is stored through your own infrastructure.
           *
           * Supported models: Claude Sonnet 4.5, Claude Sonnet 4, Claude Opus 4.1, Claude Opus 4.
           *
           * Tool name must be `memory`.
           */
          memory_20250818: memory_20250818$1,
          /**
           * Claude can use an Anthropic-defined text editor tool to view and modify text files,
           * helping you debug, fix, and improve your code or other text documents. This allows Claude
           * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
           *
           * Supported models: Claude Sonnet 3.5
           *
           * Tool name must be `str_replace_editor`.
           */
          textEditor_20241022: textEditor_20241022$1,
          /**
           * Claude can use an Anthropic-defined text editor tool to view and modify text files,
           * helping you debug, fix, and improve your code or other text documents. This allows Claude
           * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
           *
           * Supported models: Claude Sonnet 3.7
           *
           * Tool name must be `str_replace_editor`.
           */
          textEditor_20250124: textEditor_20250124$1,
          /**
           * Claude can use an Anthropic-defined text editor tool to view and modify text files,
           * helping you debug, fix, and improve your code or other text documents. This allows Claude
           * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
           *
           * Note: This version does not support the "undo_edit" command.
           *
           * Tool name must be `str_replace_based_edit_tool`.
           *
           * @deprecated Use textEditor_20250728 instead
           */
          textEditor_20250429: textEditor_20250429$1,
          /**
           * Claude can use an Anthropic-defined text editor tool to view and modify text files,
           * helping you debug, fix, and improve your code or other text documents. This allows Claude
           * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
           *
           * Note: This version does not support the "undo_edit" command and adds optional max_characters parameter.
           *
           * Supported models: Claude Sonnet 4, Opus 4, and Opus 4.1
           *
           * Tool name must be `str_replace_based_edit_tool`.
           *
           * @param maxCharacters - Optional maximum number of characters to view in the file
           */
          textEditor_20250728: textEditor_20250728$1,
          /**
           * Creates a web fetch tool that gives Claude direct access to real-time web content.
           *
           * Tool name must be `web_fetch`.
           *
           * @param maxUses - The max_uses parameter limits the number of web fetches performed
           * @param allowedDomains - Only fetch from these domains
           * @param blockedDomains - Never fetch from these domains
           * @param citations - Unlike web search where citations are always enabled, citations are optional for web fetch. Set "citations": {"enabled": true} to enable Claude to cite specific passages from fetched documents.
           * @param maxContentTokens - The max_content_tokens parameter limits the amount of content that will be included in the context.
           */
          webFetch_20250910: webFetch_20250910$1,
          /**
           * Creates a web search tool that gives Claude direct access to real-time web content.
           *
           * Tool name must be `web_search`.
           *
           * @param maxUses - Maximum number of web searches Claude can perform during the conversation.
           * @param allowedDomains - Optional list of domains that Claude is allowed to search.
           * @param blockedDomains - Optional list of domains that Claude should avoid when searching.
           * @param userLocation - Optional user location information to provide geographically relevant search results.
           */
          webSearch_20250305: webSearch_20250305$1
        };

        // src/anthropic-provider.ts
        function createAnthropic(options = {}) {
          var _a;
          const baseURL = (_a = withoutTrailingSlash$1(options.baseURL)) != null ? _a : "https://api.anthropic.com/v1";
          const getHeaders = () => withUserAgentSuffix(
            {
              "anthropic-version": "2023-06-01",
              "x-api-key": loadApiKey$1({
                apiKey: options.apiKey,
                environmentVariableName: "ANTHROPIC_API_KEY",
                description: "Anthropic"
              }),
              ...options.headers
            },
            `ai-sdk/anthropic/${VERSION$3}`
          );
          const createChatModel = (modelId) => {
            var _a2;
            return new AnthropicMessagesLanguageModel(modelId, {
              provider: "anthropic.messages",
              baseURL,
              headers: getHeaders,
              fetch: options.fetch,
              generateId: (_a2 = options.generateId) != null ? _a2 : generateId$1,
              supportedUrls: () => ({
                "image/*": [/^https?:\/\/.*$/]
              })
            });
          };
          const provider = function (modelId) {
            if (new.target) {
              throw new Error(
                "The Anthropic model function cannot be called with the new keyword."
              );
            }
            return createChatModel(modelId);
          };
          provider.languageModel = createChatModel;
          provider.chat = createChatModel;
          provider.messages = createChatModel;
          provider.textEmbeddingModel = (modelId) => {
            throw new NoSuchModelError({ modelId, modelType: "textEmbeddingModel" });
          };
          provider.imageModel = (modelId) => {
            throw new NoSuchModelError({ modelId, modelType: "imageModel" });
          };
          provider.tools = anthropicTools$1;
          return provider;
        }
        createAnthropic();

        // src/google-provider.ts

        // src/version.ts
        var VERSION$2 = "2.0.23";
        var googleErrorDataSchema = lazySchema(
          () => zodSchema(
            object({
              error: object({
                code: number$1().nullable(),
                message: string(),
                status: string()
              })
            })
          )
        );
        var googleFailedResponseHandler = createJsonErrorResponseHandler$1({
          errorSchema: googleErrorDataSchema,
          errorToMessage: (data) => data.error.message
        });
        var googleGenerativeAIEmbeddingProviderOptions = lazySchema(
          () => zodSchema(
            object({
              /**
               * Optional. Optional reduced dimension for the output embedding.
               * If set, excessive values in the output embedding are truncated from the end.
               */
              outputDimensionality: number$1().optional(),
              /**
               * Optional. Specifies the task type for generating embeddings.
               * Supported task types:
               * - SEMANTIC_SIMILARITY: Optimized for text similarity.
               * - CLASSIFICATION: Optimized for text classification.
               * - CLUSTERING: Optimized for clustering texts based on similarity.
               * - RETRIEVAL_DOCUMENT: Optimized for document retrieval.
               * - RETRIEVAL_QUERY: Optimized for query-based retrieval.
               * - QUESTION_ANSWERING: Optimized for answering questions.
               * - FACT_VERIFICATION: Optimized for verifying factual information.
               * - CODE_RETRIEVAL_QUERY: Optimized for retrieving code blocks based on natural language queries.
               */
              taskType: _enum([
                "SEMANTIC_SIMILARITY",
                "CLASSIFICATION",
                "CLUSTERING",
                "RETRIEVAL_DOCUMENT",
                "RETRIEVAL_QUERY",
                "QUESTION_ANSWERING",
                "FACT_VERIFICATION",
                "CODE_RETRIEVAL_QUERY"
              ]).optional()
            })
          )
        );

        // src/google-generative-ai-embedding-model.ts
        var GoogleGenerativeAIEmbeddingModel = class {
          constructor(modelId, config) {
            this.specificationVersion = "v2";
            this.maxEmbeddingsPerCall = 2048;
            this.supportsParallelCalls = true;
            this.modelId = modelId;
            this.config = config;
          }
          get provider() {
            return this.config.provider;
          }
          async doEmbed({
            values,
            headers,
            abortSignal,
            providerOptions
          }) {
            const googleOptions = await parseProviderOptions({
              provider: "google",
              providerOptions,
              schema: googleGenerativeAIEmbeddingProviderOptions
            });
            if (values.length > this.maxEmbeddingsPerCall) {
              throw new TooManyEmbeddingValuesForCallError({
                provider: this.provider,
                modelId: this.modelId,
                maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
                values
              });
            }
            const mergedHeaders = combineHeaders$1(
              await resolve(this.config.headers),
              headers
            );
            if (values.length === 1) {
              const {
                responseHeaders: responseHeaders2,
                value: response2,
                rawValue: rawValue2
              } = await postJsonToApi$1({
                url: `${this.config.baseURL}/models/${this.modelId}:embedContent`,
                headers: mergedHeaders,
                body: {
                  model: `models/${this.modelId}`,
                  content: {
                    parts: [{ text: values[0] }]
                  },
                  outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
                  taskType: googleOptions == null ? void 0 : googleOptions.taskType
                },
                failedResponseHandler: googleFailedResponseHandler,
                successfulResponseHandler: createJsonResponseHandler$1(
                  googleGenerativeAISingleEmbeddingResponseSchema
                ),
                abortSignal,
                fetch: this.config.fetch
              });
              return {
                embeddings: [response2.embedding.values],
                usage: void 0,
                response: { headers: responseHeaders2, body: rawValue2 }
              };
            }
            const {
              responseHeaders,
              value: response,
              rawValue
            } = await postJsonToApi$1({
              url: `${this.config.baseURL}/models/${this.modelId}:batchEmbedContents`,
              headers: mergedHeaders,
              body: {
                requests: values.map((value) => ({
                  model: `models/${this.modelId}`,
                  content: { role: "user", parts: [{ text: value }] },
                  outputDimensionality: googleOptions == null ? void 0 : googleOptions.outputDimensionality,
                  taskType: googleOptions == null ? void 0 : googleOptions.taskType
                }))
              },
              failedResponseHandler: googleFailedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler$1(
                googleGenerativeAITextEmbeddingResponseSchema
              ),
              abortSignal,
              fetch: this.config.fetch
            });
            return {
              embeddings: response.embeddings.map((item) => item.values),
              usage: void 0,
              response: { headers: responseHeaders, body: rawValue }
            };
          }
        };
        var googleGenerativeAITextEmbeddingResponseSchema = lazySchema(
          () => zodSchema(
            object({
              embeddings: array(object({ values: array(number$1()) }))
            })
          )
        );
        var googleGenerativeAISingleEmbeddingResponseSchema = lazySchema(
          () => zodSchema(
            object({
              embedding: object({ values: array(number$1()) })
            })
          )
        );

        // src/convert-json-schema-to-openapi-schema.ts
        function convertJSONSchemaToOpenAPISchema(jsonSchema) {
          if (jsonSchema == null || isEmptyObjectSchema(jsonSchema)) {
            return void 0;
          }
          if (typeof jsonSchema === "boolean") {
            return { type: "boolean", properties: {} };
          }
          const {
            type,
            description,
            required,
            properties,
            items,
            allOf,
            anyOf,
            oneOf,
            format,
            const: constValue,
            minLength,
            enum: enumValues
          } = jsonSchema;
          const result = {};
          if (description) result.description = description;
          if (required) result.required = required;
          if (format) result.format = format;
          if (constValue !== void 0) {
            result.enum = [constValue];
          }
          if (type) {
            if (Array.isArray(type)) {
              if (type.includes("null")) {
                result.type = type.filter((t) => t !== "null")[0];
                result.nullable = true;
              } else {
                result.type = type;
              }
            } else if (type === "null") {
              result.type = "null";
            } else {
              result.type = type;
            }
          }
          if (enumValues !== void 0) {
            result.enum = enumValues;
          }
          if (properties != null) {
            result.properties = Object.entries(properties).reduce(
              (acc, [key, value]) => {
                acc[key] = convertJSONSchemaToOpenAPISchema(value);
                return acc;
              },
              {}
            );
          }
          if (items) {
            result.items = Array.isArray(items) ? items.map(convertJSONSchemaToOpenAPISchema) : convertJSONSchemaToOpenAPISchema(items);
          }
          if (allOf) {
            result.allOf = allOf.map(convertJSONSchemaToOpenAPISchema);
          }
          if (anyOf) {
            if (anyOf.some(
              (schema) => typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null"
            )) {
              const nonNullSchemas = anyOf.filter(
                (schema) => !(typeof schema === "object" && (schema == null ? void 0 : schema.type) === "null")
              );
              if (nonNullSchemas.length === 1) {
                const converted = convertJSONSchemaToOpenAPISchema(nonNullSchemas[0]);
                if (typeof converted === "object") {
                  result.nullable = true;
                  Object.assign(result, converted);
                }
              } else {
                result.anyOf = nonNullSchemas.map(convertJSONSchemaToOpenAPISchema);
                result.nullable = true;
              }
            } else {
              result.anyOf = anyOf.map(convertJSONSchemaToOpenAPISchema);
            }
          }
          if (oneOf) {
            result.oneOf = oneOf.map(convertJSONSchemaToOpenAPISchema);
          }
          if (minLength !== void 0) {
            result.minLength = minLength;
          }
          return result;
        }
        function isEmptyObjectSchema(jsonSchema) {
          return jsonSchema != null && typeof jsonSchema === "object" && jsonSchema.type === "object" && (jsonSchema.properties == null || Object.keys(jsonSchema.properties).length === 0) && !jsonSchema.additionalProperties;
        }
        function convertToGoogleGenerativeAIMessages(prompt, options) {
          var _a;
          const systemInstructionParts = [];
          const contents = [];
          let systemMessagesAllowed = true;
          const isGemmaModel = (_a = options == null ? void 0 : options.isGemmaModel) != null ? _a : false;
          for (const { role, content } of prompt) {
            switch (role) {
              case "system": {
                if (!systemMessagesAllowed) {
                  throw new UnsupportedFunctionalityError$1({
                    functionality: "system messages are only supported at the beginning of the conversation"
                  });
                }
                systemInstructionParts.push({ text: content });
                break;
              }
              case "user": {
                systemMessagesAllowed = false;
                const parts = [];
                for (const part of content) {
                  switch (part.type) {
                    case "text": {
                      parts.push({ text: part.text });
                      break;
                    }
                    case "file": {
                      const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                      parts.push(
                        part.data instanceof URL ? {
                          fileData: {
                            mimeType: mediaType,
                            fileUri: part.data.toString()
                          }
                        } : {
                          inlineData: {
                            mimeType: mediaType,
                            data: convertToBase64(part.data)
                          }
                        }
                      );
                      break;
                    }
                  }
                }
                contents.push({ role: "user", parts });
                break;
              }
              case "assistant": {
                systemMessagesAllowed = false;
                contents.push({
                  role: "model",
                  parts: content.map((part) => {
                    var _a2, _b, _c, _d, _e, _f;
                    switch (part.type) {
                      case "text": {
                        return part.text.length === 0 ? void 0 : {
                          text: part.text,
                          thoughtSignature: (_b = (_a2 = part.providerOptions) == null ? void 0 : _a2.google) == null ? void 0 : _b.thoughtSignature
                        };
                      }
                      case "reasoning": {
                        return part.text.length === 0 ? void 0 : {
                          text: part.text,
                          thought: true,
                          thoughtSignature: (_d = (_c = part.providerOptions) == null ? void 0 : _c.google) == null ? void 0 : _d.thoughtSignature
                        };
                      }
                      case "file": {
                        if (part.mediaType !== "image/png") {
                          throw new UnsupportedFunctionalityError$1({
                            functionality: "Only PNG images are supported in assistant messages"
                          });
                        }
                        if (part.data instanceof URL) {
                          throw new UnsupportedFunctionalityError$1({
                            functionality: "File data URLs in assistant messages are not supported"
                          });
                        }
                        return {
                          inlineData: {
                            mimeType: part.mediaType,
                            data: convertToBase64(part.data)
                          }
                        };
                      }
                      case "tool-call": {
                        return {
                          functionCall: {
                            name: part.toolName,
                            args: part.input
                          },
                          thoughtSignature: (_f = (_e = part.providerOptions) == null ? void 0 : _e.google) == null ? void 0 : _f.thoughtSignature
                        };
                      }
                    }
                  }).filter((part) => part !== void 0)
                });
                break;
              }
              case "tool": {
                systemMessagesAllowed = false;
                const parts = [];
                for (const part of content) {
                  const output = part.output;
                  if (output.type === "content") {
                    for (const contentPart of output.value) {
                      switch (contentPart.type) {
                        case "text":
                          parts.push({
                            functionResponse: {
                              name: part.toolName,
                              response: {
                                name: part.toolName,
                                content: contentPart.text
                              }
                            }
                          });
                          break;
                        case "media":
                          parts.push(
                            {
                              inlineData: {
                                mimeType: contentPart.mediaType,
                                data: contentPart.data
                              }
                            },
                            {
                              text: "Tool executed successfully and returned this image as a response"
                            }
                          );
                          break;
                        default:
                          parts.push({ text: JSON.stringify(contentPart) });
                          break;
                      }
                    }
                  } else {
                    parts.push({
                      functionResponse: {
                        name: part.toolName,
                        response: {
                          name: part.toolName,
                          content: output.value
                        }
                      }
                    });
                  }
                }
                contents.push({
                  role: "user",
                  parts
                });
                break;
              }
            }
          }
          if (isGemmaModel && systemInstructionParts.length > 0 && contents.length > 0 && contents[0].role === "user") {
            const systemText = systemInstructionParts.map((part) => part.text).join("\n\n");
            contents[0].parts.unshift({ text: systemText + "\n\n" });
          }
          return {
            systemInstruction: systemInstructionParts.length > 0 && !isGemmaModel ? { parts: systemInstructionParts } : void 0,
            contents
          };
        }

        // src/get-model-path.ts
        function getModelPath(modelId) {
          return modelId.includes("/") ? modelId : `models/${modelId}`;
        }
        var googleGenerativeAIProviderOptions = lazySchema(
          () => zodSchema(
            object({
              responseModalities: array(_enum(["TEXT", "IMAGE"])).optional(),
              thinkingConfig: object({
                thinkingBudget: number$1().optional(),
                includeThoughts: boolean().optional()
              }).optional(),
              /**
               * Optional.
               * The name of the cached content used as context to serve the prediction.
               * Format: cachedContents/{cachedContent}
               */
              cachedContent: string().optional(),
              /**
               * Optional. Enable structured output. Default is true.
               *
               * This is useful when the JSON Schema contains elements that are
               * not supported by the OpenAPI schema version that
               * Google Generative AI uses. You can use this to disable
               * structured outputs if you need to.
               */
              structuredOutputs: boolean().optional(),
              /**
               * Optional. A list of unique safety settings for blocking unsafe content.
               */
              safetySettings: array(
                object({
                  category: _enum([
                    "HARM_CATEGORY_UNSPECIFIED",
                    "HARM_CATEGORY_HATE_SPEECH",
                    "HARM_CATEGORY_DANGEROUS_CONTENT",
                    "HARM_CATEGORY_HARASSMENT",
                    "HARM_CATEGORY_SEXUALLY_EXPLICIT",
                    "HARM_CATEGORY_CIVIC_INTEGRITY"
                  ]),
                  threshold: _enum([
                    "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
                    "BLOCK_LOW_AND_ABOVE",
                    "BLOCK_MEDIUM_AND_ABOVE",
                    "BLOCK_ONLY_HIGH",
                    "BLOCK_NONE",
                    "OFF"
                  ])
                })
              ).optional(),
              threshold: _enum([
                "HARM_BLOCK_THRESHOLD_UNSPECIFIED",
                "BLOCK_LOW_AND_ABOVE",
                "BLOCK_MEDIUM_AND_ABOVE",
                "BLOCK_ONLY_HIGH",
                "BLOCK_NONE",
                "OFF"
              ]).optional(),
              /**
               * Optional. Enables timestamp understanding for audio-only files.
               *
               * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/audio-understanding
               */
              audioTimestamp: boolean().optional(),
              /**
               * Optional. Defines labels used in billing reports. Available on Vertex AI only.
               *
               * https://cloud.google.com/vertex-ai/generative-ai/docs/multimodal/add-labels-to-api-calls
               */
              labels: record(string(), string()).optional(),
              /**
               * Optional. If specified, the media resolution specified will be used.
               *
               * https://ai.google.dev/api/generate-content#MediaResolution
               */
              mediaResolution: _enum([
                "MEDIA_RESOLUTION_UNSPECIFIED",
                "MEDIA_RESOLUTION_LOW",
                "MEDIA_RESOLUTION_MEDIUM",
                "MEDIA_RESOLUTION_HIGH"
              ]).optional(),
              /**
               * Optional. Configures the image generation aspect ratio for Gemini models.
               *
               * https://ai.google.dev/gemini-api/docs/image-generation#aspect_ratios
               */
              imageConfig: object({
                aspectRatio: _enum([
                  "1:1",
                  "2:3",
                  "3:2",
                  "3:4",
                  "4:3",
                  "4:5",
                  "5:4",
                  "9:16",
                  "16:9",
                  "21:9"
                ]).optional()
              }).optional()
            })
          )
        );
        function prepareTools$3({
          tools,
          toolChoice,
          modelId
        }) {
          var _a;
          tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
          const toolWarnings = [];
          const isGemini2 = modelId.includes("gemini-2");
          const supportsDynamicRetrieval = modelId.includes("gemini-1.5-flash") && !modelId.includes("-8b");
          if (tools == null) {
            return { tools: void 0, toolConfig: void 0, toolWarnings };
          }
          const hasFunctionTools = tools.some((tool) => tool.type === "function");
          const hasProviderDefinedTools = tools.some(
            (tool) => tool.type === "provider-defined"
          );
          if (hasFunctionTools && hasProviderDefinedTools) {
            toolWarnings.push({
              type: "unsupported-tool",
              tool: tools.find((tool) => tool.type === "function"),
              details: "Cannot mix function tools with provider-defined tools in the same request. Please use either function tools or provider-defined tools, but not both."
            });
          }
          if (hasProviderDefinedTools) {
            const googleTools2 = [];
            const providerDefinedTools = tools.filter(
              (tool) => tool.type === "provider-defined"
            );
            providerDefinedTools.forEach((tool) => {
              switch (tool.id) {
                case "google.google_search":
                  if (isGemini2) {
                    googleTools2.push({ googleSearch: {} });
                  } else if (supportsDynamicRetrieval) {
                    googleTools2.push({
                      googleSearchRetrieval: {
                        dynamicRetrievalConfig: {
                          mode: tool.args.mode,
                          dynamicThreshold: tool.args.dynamicThreshold
                        }
                      }
                    });
                  } else {
                    googleTools2.push({ googleSearchRetrieval: {} });
                  }
                  break;
                case "google.url_context":
                  if (isGemini2) {
                    googleTools2.push({ urlContext: {} });
                  } else {
                    toolWarnings.push({
                      type: "unsupported-tool",
                      tool,
                      details: "The URL context tool is not supported with other Gemini models than Gemini 2."
                    });
                  }
                  break;
                case "google.code_execution":
                  if (isGemini2) {
                    googleTools2.push({ codeExecution: {} });
                  } else {
                    toolWarnings.push({
                      type: "unsupported-tool",
                      tool,
                      details: "The code execution tools is not supported with other Gemini models than Gemini 2."
                    });
                  }
                  break;
                default:
                  toolWarnings.push({ type: "unsupported-tool", tool });
                  break;
              }
            });
            return {
              tools: googleTools2.length > 0 ? googleTools2 : void 0,
              toolConfig: void 0,
              toolWarnings
            };
          }
          const functionDeclarations = [];
          for (const tool of tools) {
            switch (tool.type) {
              case "function":
                functionDeclarations.push({
                  name: tool.name,
                  description: (_a = tool.description) != null ? _a : "",
                  parameters: convertJSONSchemaToOpenAPISchema(tool.inputSchema)
                });
                break;
              default:
                toolWarnings.push({ type: "unsupported-tool", tool });
                break;
            }
          }
          if (toolChoice == null) {
            return {
              tools: { functionDeclarations },
              toolConfig: void 0,
              toolWarnings
            };
          }
          const type = toolChoice.type;
          switch (type) {
            case "auto":
              return {
                tools: { functionDeclarations },
                toolConfig: { functionCallingConfig: { mode: "AUTO" } },
                toolWarnings
              };
            case "none":
              return {
                tools: { functionDeclarations },
                toolConfig: { functionCallingConfig: { mode: "NONE" } },
                toolWarnings
              };
            case "required":
              return {
                tools: { functionDeclarations },
                toolConfig: { functionCallingConfig: { mode: "ANY" } },
                toolWarnings
              };
            case "tool":
              return {
                tools: { functionDeclarations },
                toolConfig: {
                  functionCallingConfig: {
                    mode: "ANY",
                    allowedFunctionNames: [toolChoice.toolName]
                  }
                },
                toolWarnings
              };
            default: {
              const _exhaustiveCheck = type;
              throw new UnsupportedFunctionalityError$1({
                functionality: `tool choice type: ${_exhaustiveCheck}`
              });
            }
          }
        }

        // src/map-google-generative-ai-finish-reason.ts
        function mapGoogleGenerativeAIFinishReason({
          finishReason,
          hasToolCalls
        }) {
          switch (finishReason) {
            case "STOP":
              return hasToolCalls ? "tool-calls" : "stop";
            case "MAX_TOKENS":
              return "length";
            case "IMAGE_SAFETY":
            case "RECITATION":
            case "SAFETY":
            case "BLOCKLIST":
            case "PROHIBITED_CONTENT":
            case "SPII":
              return "content-filter";
            case "FINISH_REASON_UNSPECIFIED":
            case "OTHER":
              return "other";
            case "MALFORMED_FUNCTION_CALL":
              return "error";
            default:
              return "unknown";
          }
        }

        // src/google-generative-ai-language-model.ts
        var GoogleGenerativeAILanguageModel = class {
          constructor(modelId, config) {
            this.specificationVersion = "v2";
            var _a;
            this.modelId = modelId;
            this.config = config;
            this.generateId = (_a = config.generateId) != null ? _a : generateId$1;
          }
          get provider() {
            return this.config.provider;
          }
          get supportedUrls() {
            var _a, _b, _c;
            return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
          }
          async getArgs({
            prompt,
            maxOutputTokens,
            temperature,
            topP,
            topK,
            frequencyPenalty,
            presencePenalty,
            stopSequences,
            responseFormat,
            seed,
            tools,
            toolChoice,
            providerOptions
          }) {
            var _a, _b;
            const warnings = [];
            const googleOptions = await parseProviderOptions({
              provider: "google",
              providerOptions,
              schema: googleGenerativeAIProviderOptions
            });
            if (((_a = googleOptions == null ? void 0 : googleOptions.thinkingConfig) == null ? void 0 : _a.includeThoughts) === true && !this.config.provider.startsWith("google.vertex.")) {
              warnings.push({
                type: "other",
                message: `The 'includeThoughts' option is only supported with the Google Vertex provider and might not be supported or could behave unexpectedly with the current Google provider (${this.config.provider}).`
              });
            }
            const isGemmaModel = this.modelId.toLowerCase().startsWith("gemma-");
            const { contents, systemInstruction } = convertToGoogleGenerativeAIMessages(
              prompt,
              { isGemmaModel }
            );
            const {
              tools: googleTools2,
              toolConfig: googleToolConfig,
              toolWarnings
            } = prepareTools$3({
              tools,
              toolChoice,
              modelId: this.modelId
            });
            return {
              args: {
                generationConfig: {
                  // standardized settings:
                  maxOutputTokens,
                  temperature,
                  topK,
                  topP,
                  frequencyPenalty,
                  presencePenalty,
                  stopSequences,
                  seed,
                  // response format:
                  responseMimeType: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? "application/json" : void 0,
                  responseSchema: (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && // Google GenAI does not support all OpenAPI Schema features,
                    // so this is needed as an escape hatch:
                    // TODO convert into provider option
                    ((_b = googleOptions == null ? void 0 : googleOptions.structuredOutputs) != null ? _b : true) ? convertJSONSchemaToOpenAPISchema(responseFormat.schema) : void 0,
                  ...(googleOptions == null ? void 0 : googleOptions.audioTimestamp) && {
                    audioTimestamp: googleOptions.audioTimestamp
                  },
                  // provider options:
                  responseModalities: googleOptions == null ? void 0 : googleOptions.responseModalities,
                  thinkingConfig: googleOptions == null ? void 0 : googleOptions.thinkingConfig,
                  ...(googleOptions == null ? void 0 : googleOptions.imageConfig) && {
                    imageConfig: googleOptions.imageConfig
                  },
                  ...(googleOptions == null ? void 0 : googleOptions.mediaResolution) && {
                    mediaResolution: googleOptions.mediaResolution
                  }
                },
                contents,
                systemInstruction: isGemmaModel ? void 0 : systemInstruction,
                safetySettings: googleOptions == null ? void 0 : googleOptions.safetySettings,
                tools: googleTools2,
                toolConfig: googleToolConfig,
                cachedContent: googleOptions == null ? void 0 : googleOptions.cachedContent,
                labels: googleOptions == null ? void 0 : googleOptions.labels
              },
              warnings: [...warnings, ...toolWarnings]
            };
          }
          async doGenerate(options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
            const { args, warnings } = await this.getArgs(options);
            const body = JSON.stringify(args);
            const mergedHeaders = combineHeaders$1(
              await resolve(this.config.headers),
              options.headers
            );
            const {
              responseHeaders,
              value: response,
              rawValue: rawResponse
            } = await postJsonToApi$1({
              url: `${this.config.baseURL}/${getModelPath(
                this.modelId
              )}:generateContent`,
              headers: mergedHeaders,
              body: args,
              failedResponseHandler: googleFailedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler$1(responseSchema),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            const candidate = response.candidates[0];
            const content = [];
            const parts = (_b = (_a = candidate.content) == null ? void 0 : _a.parts) != null ? _b : [];
            const usageMetadata = response.usageMetadata;
            let lastCodeExecutionToolCallId;
            for (const part of parts) {
              if ("executableCode" in part && ((_c = part.executableCode) == null ? void 0 : _c.code)) {
                const toolCallId = this.config.generateId();
                lastCodeExecutionToolCallId = toolCallId;
                content.push({
                  type: "tool-call",
                  toolCallId,
                  toolName: "code_execution",
                  input: JSON.stringify(part.executableCode),
                  providerExecuted: true
                });
              } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
                content.push({
                  type: "tool-result",
                  // Assumes a result directly follows its corresponding call part.
                  toolCallId: lastCodeExecutionToolCallId,
                  toolName: "code_execution",
                  result: {
                    outcome: part.codeExecutionResult.outcome,
                    output: part.codeExecutionResult.output
                  },
                  providerExecuted: true
                });
                lastCodeExecutionToolCallId = void 0;
              } else if ("text" in part && part.text != null && part.text.length > 0) {
                content.push({
                  type: part.thought === true ? "reasoning" : "text",
                  text: part.text,
                  providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
                });
              } else if ("functionCall" in part) {
                content.push({
                  type: "tool-call",
                  toolCallId: this.config.generateId(),
                  toolName: part.functionCall.name,
                  input: JSON.stringify(part.functionCall.args),
                  providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
                });
              } else if ("inlineData" in part) {
                content.push({
                  type: "file",
                  data: part.inlineData.data,
                  mediaType: part.inlineData.mimeType
                });
              }
            }
            const sources = (_d = extractSources({
              groundingMetadata: candidate.groundingMetadata,
              generateId: this.config.generateId
            })) != null ? _d : [];
            for (const source of sources) {
              content.push(source);
            }
            return {
              content,
              finishReason: mapGoogleGenerativeAIFinishReason({
                finishReason: candidate.finishReason,
                hasToolCalls: content.some((part) => part.type === "tool-call")
              }),
              usage: {
                inputTokens: (_e = usageMetadata == null ? void 0 : usageMetadata.promptTokenCount) != null ? _e : void 0,
                outputTokens: (_f = usageMetadata == null ? void 0 : usageMetadata.candidatesTokenCount) != null ? _f : void 0,
                totalTokens: (_g = usageMetadata == null ? void 0 : usageMetadata.totalTokenCount) != null ? _g : void 0,
                reasoningTokens: (_h = usageMetadata == null ? void 0 : usageMetadata.thoughtsTokenCount) != null ? _h : void 0,
                cachedInputTokens: (_i = usageMetadata == null ? void 0 : usageMetadata.cachedContentTokenCount) != null ? _i : void 0
              },
              warnings,
              providerMetadata: {
                google: {
                  promptFeedback: (_j = response.promptFeedback) != null ? _j : null,
                  groundingMetadata: (_k = candidate.groundingMetadata) != null ? _k : null,
                  urlContextMetadata: (_l = candidate.urlContextMetadata) != null ? _l : null,
                  safetyRatings: (_m = candidate.safetyRatings) != null ? _m : null,
                  usageMetadata: usageMetadata != null ? usageMetadata : null
                }
              },
              request: { body },
              response: {
                // TODO timestamp, model id, id
                headers: responseHeaders,
                body: rawResponse
              }
            };
          }
          async doStream(options) {
            const { args, warnings } = await this.getArgs(options);
            const body = JSON.stringify(args);
            const headers = combineHeaders$1(
              await resolve(this.config.headers),
              options.headers
            );
            const { responseHeaders, value: response } = await postJsonToApi$1({
              url: `${this.config.baseURL}/${getModelPath(
                this.modelId
              )}:streamGenerateContent?alt=sse`,
              headers,
              body: args,
              failedResponseHandler: googleFailedResponseHandler,
              successfulResponseHandler: createEventSourceResponseHandler$1(chunkSchema),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            let finishReason = "unknown";
            const usage = {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            };
            let providerMetadata = void 0;
            const generateId3 = this.config.generateId;
            let hasToolCalls = false;
            let currentTextBlockId = null;
            let currentReasoningBlockId = null;
            let blockCounter = 0;
            const emittedSourceUrls = /* @__PURE__ */ new Set();
            let lastCodeExecutionToolCallId;
            return {
              stream: response.pipeThrough(
                new TransformStream({
                  start(controller) {
                    controller.enqueue({ type: "stream-start", warnings });
                  },
                  transform(chunk, controller) {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
                    if (options.includeRawChunks) {
                      controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                    }
                    if (!chunk.success) {
                      controller.enqueue({ type: "error", error: chunk.error });
                      return;
                    }
                    const value = chunk.value;
                    const usageMetadata = value.usageMetadata;
                    if (usageMetadata != null) {
                      usage.inputTokens = (_a = usageMetadata.promptTokenCount) != null ? _a : void 0;
                      usage.outputTokens = (_b = usageMetadata.candidatesTokenCount) != null ? _b : void 0;
                      usage.totalTokens = (_c = usageMetadata.totalTokenCount) != null ? _c : void 0;
                      usage.reasoningTokens = (_d = usageMetadata.thoughtsTokenCount) != null ? _d : void 0;
                      usage.cachedInputTokens = (_e = usageMetadata.cachedContentTokenCount) != null ? _e : void 0;
                    }
                    const candidate = (_f = value.candidates) == null ? void 0 : _f[0];
                    if (candidate == null) {
                      return;
                    }
                    const content = candidate.content;
                    const sources = extractSources({
                      groundingMetadata: candidate.groundingMetadata,
                      generateId: generateId3
                    });
                    if (sources != null) {
                      for (const source of sources) {
                        if (source.sourceType === "url" && !emittedSourceUrls.has(source.url)) {
                          emittedSourceUrls.add(source.url);
                          controller.enqueue(source);
                        }
                      }
                    }
                    if (content != null) {
                      const parts = (_g = content.parts) != null ? _g : [];
                      for (const part of parts) {
                        if ("executableCode" in part && ((_h = part.executableCode) == null ? void 0 : _h.code)) {
                          const toolCallId = generateId3();
                          lastCodeExecutionToolCallId = toolCallId;
                          controller.enqueue({
                            type: "tool-call",
                            toolCallId,
                            toolName: "code_execution",
                            input: JSON.stringify(part.executableCode),
                            providerExecuted: true
                          });
                          hasToolCalls = true;
                        } else if ("codeExecutionResult" in part && part.codeExecutionResult) {
                          const toolCallId = lastCodeExecutionToolCallId;
                          if (toolCallId) {
                            controller.enqueue({
                              type: "tool-result",
                              toolCallId,
                              toolName: "code_execution",
                              result: {
                                outcome: part.codeExecutionResult.outcome,
                                output: part.codeExecutionResult.output
                              },
                              providerExecuted: true
                            });
                            lastCodeExecutionToolCallId = void 0;
                          }
                        } else if ("text" in part && part.text != null && part.text.length > 0) {
                          if (part.thought === true) {
                            if (currentTextBlockId !== null) {
                              controller.enqueue({
                                type: "text-end",
                                id: currentTextBlockId
                              });
                              currentTextBlockId = null;
                            }
                            if (currentReasoningBlockId === null) {
                              currentReasoningBlockId = String(blockCounter++);
                              controller.enqueue({
                                type: "reasoning-start",
                                id: currentReasoningBlockId,
                                providerMetadata: part.thoughtSignature ? {
                                  google: {
                                    thoughtSignature: part.thoughtSignature
                                  }
                                } : void 0
                              });
                            }
                            controller.enqueue({
                              type: "reasoning-delta",
                              id: currentReasoningBlockId,
                              delta: part.text,
                              providerMetadata: part.thoughtSignature ? {
                                google: { thoughtSignature: part.thoughtSignature }
                              } : void 0
                            });
                          } else {
                            if (currentReasoningBlockId !== null) {
                              controller.enqueue({
                                type: "reasoning-end",
                                id: currentReasoningBlockId
                              });
                              currentReasoningBlockId = null;
                            }
                            if (currentTextBlockId === null) {
                              currentTextBlockId = String(blockCounter++);
                              controller.enqueue({
                                type: "text-start",
                                id: currentTextBlockId,
                                providerMetadata: part.thoughtSignature ? {
                                  google: {
                                    thoughtSignature: part.thoughtSignature
                                  }
                                } : void 0
                              });
                            }
                            controller.enqueue({
                              type: "text-delta",
                              id: currentTextBlockId,
                              delta: part.text,
                              providerMetadata: part.thoughtSignature ? {
                                google: { thoughtSignature: part.thoughtSignature }
                              } : void 0
                            });
                          }
                        }
                      }
                      const inlineDataParts = getInlineDataParts(content.parts);
                      if (inlineDataParts != null) {
                        for (const part of inlineDataParts) {
                          controller.enqueue({
                            type: "file",
                            mediaType: part.inlineData.mimeType,
                            data: part.inlineData.data
                          });
                        }
                      }
                      const toolCallDeltas = getToolCallsFromParts({
                        parts: content.parts,
                        generateId: generateId3
                      });
                      if (toolCallDeltas != null) {
                        for (const toolCall of toolCallDeltas) {
                          controller.enqueue({
                            type: "tool-input-start",
                            id: toolCall.toolCallId,
                            toolName: toolCall.toolName,
                            providerMetadata: toolCall.providerMetadata
                          });
                          controller.enqueue({
                            type: "tool-input-delta",
                            id: toolCall.toolCallId,
                            delta: toolCall.args,
                            providerMetadata: toolCall.providerMetadata
                          });
                          controller.enqueue({
                            type: "tool-input-end",
                            id: toolCall.toolCallId,
                            providerMetadata: toolCall.providerMetadata
                          });
                          controller.enqueue({
                            type: "tool-call",
                            toolCallId: toolCall.toolCallId,
                            toolName: toolCall.toolName,
                            input: toolCall.args,
                            providerMetadata: toolCall.providerMetadata
                          });
                          hasToolCalls = true;
                        }
                      }
                    }
                    if (candidate.finishReason != null) {
                      finishReason = mapGoogleGenerativeAIFinishReason({
                        finishReason: candidate.finishReason,
                        hasToolCalls
                      });
                      providerMetadata = {
                        google: {
                          promptFeedback: (_i = value.promptFeedback) != null ? _i : null,
                          groundingMetadata: (_j = candidate.groundingMetadata) != null ? _j : null,
                          urlContextMetadata: (_k = candidate.urlContextMetadata) != null ? _k : null,
                          safetyRatings: (_l = candidate.safetyRatings) != null ? _l : null
                        }
                      };
                      if (usageMetadata != null) {
                        providerMetadata.google.usageMetadata = usageMetadata;
                      }
                    }
                  },
                  flush(controller) {
                    if (currentTextBlockId !== null) {
                      controller.enqueue({
                        type: "text-end",
                        id: currentTextBlockId
                      });
                    }
                    if (currentReasoningBlockId !== null) {
                      controller.enqueue({
                        type: "reasoning-end",
                        id: currentReasoningBlockId
                      });
                    }
                    controller.enqueue({
                      type: "finish",
                      finishReason,
                      usage,
                      providerMetadata
                    });
                  }
                })
              ),
              response: { headers: responseHeaders },
              request: { body }
            };
          }
        };
        function getToolCallsFromParts({
          parts,
          generateId: generateId3
        }) {
          const functionCallParts = parts == null ? void 0 : parts.filter(
            (part) => "functionCall" in part
          );
          return functionCallParts == null || functionCallParts.length === 0 ? void 0 : functionCallParts.map((part) => ({
            type: "tool-call",
            toolCallId: generateId3(),
            toolName: part.functionCall.name,
            args: JSON.stringify(part.functionCall.args),
            providerMetadata: part.thoughtSignature ? { google: { thoughtSignature: part.thoughtSignature } } : void 0
          }));
        }
        function getInlineDataParts(parts) {
          return parts == null ? void 0 : parts.filter(
            (part) => "inlineData" in part
          );
        }
        function extractSources({
          groundingMetadata,
          generateId: generateId3
        }) {
          var _a;
          return (_a = groundingMetadata == null ? void 0 : groundingMetadata.groundingChunks) == null ? void 0 : _a.filter(
            (chunk) => chunk.web != null
          ).map((chunk) => ({
            type: "source",
            sourceType: "url",
            id: generateId3(),
            url: chunk.web.uri,
            title: chunk.web.title
          }));
        }
        var getGroundingMetadataSchema = () => object({
          webSearchQueries: array(string()).nullish(),
          retrievalQueries: array(string()).nullish(),
          searchEntryPoint: object({ renderedContent: string() }).nullish(),
          groundingChunks: array(
            object({
              web: object({ uri: string(), title: string() }).nullish(),
              retrievedContext: object({ uri: string(), title: string() }).nullish()
            })
          ).nullish(),
          groundingSupports: array(
            object({
              segment: object({
                startIndex: number$1().nullish(),
                endIndex: number$1().nullish(),
                text: string().nullish()
              }),
              segment_text: string().nullish(),
              groundingChunkIndices: array(number$1()).nullish(),
              supportChunkIndices: array(number$1()).nullish(),
              confidenceScores: array(number$1()).nullish(),
              confidenceScore: array(number$1()).nullish()
            })
          ).nullish(),
          retrievalMetadata: union([
            object({
              webDynamicRetrievalScore: number$1()
            }),
            object({})
          ]).nullish()
        });
        var getContentSchema = () => object({
          parts: array(
            union([
              // note: order matters since text can be fully empty
              object({
                functionCall: object({
                  name: string(),
                  args: unknown()
                }),
                thoughtSignature: string().nullish()
              }),
              object({
                inlineData: object({
                  mimeType: string(),
                  data: string()
                })
              }),
              object({
                executableCode: object({
                  language: string(),
                  code: string()
                }).nullish(),
                codeExecutionResult: object({
                  outcome: string(),
                  output: string()
                }).nullish(),
                text: string().nullish(),
                thought: boolean().nullish(),
                thoughtSignature: string().nullish()
              })
            ])
          ).nullish()
        });
        var getSafetyRatingSchema = () => object({
          category: string().nullish(),
          probability: string().nullish(),
          probabilityScore: number$1().nullish(),
          severity: string().nullish(),
          severityScore: number$1().nullish(),
          blocked: boolean().nullish()
        });
        var usageSchema$1 = object({
          cachedContentTokenCount: number$1().nullish(),
          thoughtsTokenCount: number$1().nullish(),
          promptTokenCount: number$1().nullish(),
          candidatesTokenCount: number$1().nullish(),
          totalTokenCount: number$1().nullish()
        });
        var getUrlContextMetadataSchema = () => object({
          urlMetadata: array(
            object({
              retrievedUrl: string(),
              urlRetrievalStatus: string()
            })
          )
        });
        var responseSchema = lazySchema(
          () => zodSchema(
            object({
              candidates: array(
                object({
                  content: getContentSchema().nullish().or(object({}).strict()),
                  finishReason: string().nullish(),
                  safetyRatings: array(getSafetyRatingSchema()).nullish(),
                  groundingMetadata: getGroundingMetadataSchema().nullish(),
                  urlContextMetadata: getUrlContextMetadataSchema().nullish()
                })
              ),
              usageMetadata: usageSchema$1.nullish(),
              promptFeedback: object({
                blockReason: string().nullish(),
                safetyRatings: array(getSafetyRatingSchema()).nullish()
              }).nullish()
            })
          )
        );
        var chunkSchema = lazySchema(
          () => zodSchema(
            object({
              candidates: array(
                object({
                  content: getContentSchema().nullish(),
                  finishReason: string().nullish(),
                  safetyRatings: array(getSafetyRatingSchema()).nullish(),
                  groundingMetadata: getGroundingMetadataSchema().nullish(),
                  urlContextMetadata: getUrlContextMetadataSchema().nullish()
                })
              ).nullish(),
              usageMetadata: usageSchema$1.nullish(),
              promptFeedback: object({
                blockReason: string().nullish(),
                safetyRatings: array(getSafetyRatingSchema()).nullish()
              }).nullish()
            })
          )
        );
        var codeExecution = createProviderDefinedToolFactoryWithOutputSchema({
          id: "google.code_execution",
          name: "code_execution",
          inputSchema: object({
            language: string().describe("The programming language of the code."),
            code: string().describe("The code to be executed.")
          }),
          outputSchema: object({
            outcome: string().describe('The outcome of the execution (e.g., "OUTCOME_OK").'),
            output: string().describe("The output from the code execution.")
          })
        });
        var googleSearch = createProviderDefinedToolFactory({
          id: "google.google_search",
          name: "google_search",
          inputSchema: lazySchema(
            () => zodSchema(
              object({
                mode: _enum(["MODE_DYNAMIC", "MODE_UNSPECIFIED"]).default("MODE_UNSPECIFIED"),
                dynamicThreshold: number$1().default(1)
              })
            )
          )
        });
        var urlContext = createProviderDefinedToolFactory({
          id: "google.url_context",
          name: "url_context",
          inputSchema: lazySchema(() => zodSchema(object({})))
        });

        // src/google-tools.ts
        var googleTools = {
          /**
           * Creates a Google search tool that gives Google direct access to real-time web content.
           * Must have name "google_search".
           */
          googleSearch,
          /**
           * Creates a URL context tool that gives Google direct access to real-time web content.
           * Must have name "url_context".
           */
          urlContext,
          /**
           * A tool that enables the model to generate and run Python code.
           * Must have name "code_execution".
           *
           * @note Ensure the selected model supports Code Execution.
           * Multi-tool usage with the code execution tool is typically compatible with Gemini >=2 models.
           *
           * @see https://ai.google.dev/gemini-api/docs/code-execution (Google AI)
           * @see https://cloud.google.com/vertex-ai/generative-ai/docs/model-reference/code-execution-api (Vertex AI)
           */
          codeExecution
        };
        var GoogleGenerativeAIImageModel = class {
          constructor(modelId, settings, config) {
            this.modelId = modelId;
            this.settings = settings;
            this.config = config;
            this.specificationVersion = "v2";
          }
          get maxImagesPerCall() {
            var _a;
            return (_a = this.settings.maxImagesPerCall) != null ? _a : 4;
          }
          get provider() {
            return this.config.provider;
          }
          async doGenerate(options) {
            var _a, _b, _c;
            const {
              prompt,
              n = 1,
              size = "1024x1024",
              aspectRatio = "1:1",
              seed,
              providerOptions,
              headers,
              abortSignal
            } = options;
            const warnings = [];
            if (size != null) {
              warnings.push({
                type: "unsupported-setting",
                setting: "size",
                details: "This model does not support the `size` option. Use `aspectRatio` instead."
              });
            }
            if (seed != null) {
              warnings.push({
                type: "unsupported-setting",
                setting: "seed",
                details: "This model does not support the `seed` option through this provider."
              });
            }
            const googleOptions = await parseProviderOptions({
              provider: "google",
              providerOptions,
              schema: googleImageProviderOptionsSchema
            });
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const parameters = {
              sampleCount: n
            };
            if (aspectRatio != null) {
              parameters.aspectRatio = aspectRatio;
            }
            if (googleOptions) {
              Object.assign(parameters, googleOptions);
            }
            const body = {
              instances: [{ prompt }],
              parameters
            };
            const { responseHeaders, value: response } = await postJsonToApi$1({
              url: `${this.config.baseURL}/models/${this.modelId}:predict`,
              headers: combineHeaders$1(await resolve(this.config.headers), headers),
              body,
              failedResponseHandler: googleFailedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler$1(
                googleImageResponseSchema
              ),
              abortSignal,
              fetch: this.config.fetch
            });
            return {
              images: response.predictions.map(
                (p) => p.bytesBase64Encoded
              ),
              warnings: warnings != null ? warnings : [],
              providerMetadata: {
                google: {
                  images: response.predictions.map((prediction) => ({
                    // Add any prediction-specific metadata here
                  }))
                }
              },
              response: {
                timestamp: currentDate,
                modelId: this.modelId,
                headers: responseHeaders
              }
            };
          }
        };
        var googleImageResponseSchema = lazySchema(
          () => zodSchema(
            object({
              predictions: array(object({ bytesBase64Encoded: string() })).default([])
            })
          )
        );
        var googleImageProviderOptionsSchema = lazySchema(
          () => zodSchema(
            object({
              personGeneration: _enum(["dont_allow", "allow_adult", "allow_all"]).nullish(),
              aspectRatio: _enum(["1:1", "3:4", "4:3", "9:16", "16:9"]).nullish()
            })
          )
        );

        // src/google-provider.ts
        function createGoogleGenerativeAI(options = {}) {
          var _a;
          const baseURL = (_a = withoutTrailingSlash$1(options.baseURL)) != null ? _a : "https://generativelanguage.googleapis.com/v1beta";
          const getHeaders = () => withUserAgentSuffix(
            {
              "x-goog-api-key": loadApiKey$1({
                apiKey: options.apiKey,
                environmentVariableName: "GOOGLE_GENERATIVE_AI_API_KEY",
                description: "Google Generative AI"
              }),
              ...options.headers
            },
            `ai-sdk/google/${VERSION$2}`
          );
          const createChatModel = (modelId) => {
            var _a2;
            return new GoogleGenerativeAILanguageModel(modelId, {
              provider: "google.generative-ai",
              baseURL,
              headers: getHeaders,
              generateId: (_a2 = options.generateId) != null ? _a2 : generateId$1,
              supportedUrls: () => ({
                "*": [
                  // Google Generative Language "files" endpoint
                  // e.g. https://generativelanguage.googleapis.com/v1beta/files/...
                  new RegExp(`^${baseURL}/files/.*$`),
                  // YouTube URLs (public or unlisted videos)
                  new RegExp(
                    `^https://(?:www\\.)?youtube\\.com/watch\\?v=[\\w-]+(?:&[\\w=&.-]*)?$`
                  ),
                  new RegExp(`^https://youtu\\.be/[\\w-]+(?:\\?[\\w=&.-]*)?$`)
                ]
              }),
              fetch: options.fetch
            });
          };
          const createEmbeddingModel = (modelId) => new GoogleGenerativeAIEmbeddingModel(modelId, {
            provider: "google.generative-ai",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch
          });
          const createImageModel = (modelId, settings = {}) => new GoogleGenerativeAIImageModel(modelId, settings, {
            provider: "google.generative-ai",
            baseURL,
            headers: getHeaders,
            fetch: options.fetch
          });
          const provider = function (modelId) {
            if (new.target) {
              throw new Error(
                "The Google Generative AI model function cannot be called with the new keyword."
              );
            }
            return createChatModel(modelId);
          };
          provider.languageModel = createChatModel;
          provider.chat = createChatModel;
          provider.generativeAI = createChatModel;
          provider.embedding = createEmbeddingModel;
          provider.textEmbedding = createEmbeddingModel;
          provider.textEmbeddingModel = createEmbeddingModel;
          provider.image = createImageModel;
          provider.imageModel = createImageModel;
          provider.tools = googleTools;
          return provider;
        }
        createGoogleGenerativeAI();

        // src/anthropic-messages-language-model.ts
        var anthropicErrorDataSchema = lazySchema(
          () => zodSchema(
            object({
              type: literal("error"),
              error: object({
                type: string(),
                message: string()
              })
            })
          )
        );
        createJsonErrorResponseHandler$1({
          errorSchema: anthropicErrorDataSchema,
          errorToMessage: (data) => data.error.message
        });
        object({
          /**
           * Citation configuration for this document.
           * When enabled, this document will generate citations in the response.
           */
          citations: object({
            /**
             * Enable citations for this document
             */
            enabled: boolean()
          }).optional(),
          /**
           * Custom title for the document.
           * If not provided, the filename will be used.
           */
          title: string().optional(),
          /**
           * Context about the document that will be passed to the model
           * but not used towards cited content.
           * Useful for storing document metadata as text or stringified JSON.
           */
          context: string().optional()
        });
        object({
          sendReasoning: boolean().optional(),
          thinking: object({
            type: union([literal("enabled"), literal("disabled")]),
            budgetTokens: number$1().optional()
          }).optional(),
          /**
           * Whether to disable parallel function calling during tool use. Default is false.
           * When set to true, Claude will use at most one tool per response.
           */
          disableParallelToolUse: boolean().optional(),
          /**
           * Cache control settings for this message.
           * See https://docs.anthropic.com/en/docs/build-with-claude/prompt-caching
           */
          cacheControl: object({
            type: literal("ephemeral"),
            ttl: union([literal("5m"), literal("1h")]).optional()
          }).optional(),
          /**
           * Agent Skills configuration. Skills enable Claude to perform specialized tasks
           * like document processing (PPTX, DOCX, PDF, XLSX) and data analysis.
           * Requires code execution tool to be enabled.
           */
          container: object({
            id: string().optional(),
            skills: array(
              object({
                type: union([literal("anthropic"), literal("custom")]),
                skillId: string(),
                version: string().optional()
              })
            ).optional()
          }).optional()
        });

        // src/get-cache-control.ts
        var MAX_CACHE_BREAKPOINTS = 4;
        function getCacheControl$1(providerMetadata) {
          var _a;
          const anthropic = providerMetadata == null ? void 0 : providerMetadata.anthropic;
          const cacheControlValue = (_a = anthropic == null ? void 0 : anthropic.cacheControl) != null ? _a : anthropic == null ? void 0 : anthropic.cache_control;
          return cacheControlValue;
        }
        var CacheControlValidator = class {
          constructor() {
            this.breakpointCount = 0;
            this.warnings = [];
          }
          getCacheControl(providerMetadata, context) {
            const cacheControlValue = getCacheControl$1(providerMetadata);
            if (!cacheControlValue) {
              return void 0;
            }
            if (!context.canCache) {
              this.warnings.push({
                type: "unsupported-setting",
                setting: "cacheControl",
                details: `cache_control cannot be set on ${context.type}. It will be ignored.`
              });
              return void 0;
            }
            this.breakpointCount++;
            if (this.breakpointCount > MAX_CACHE_BREAKPOINTS) {
              this.warnings.push({
                type: "unsupported-setting",
                setting: "cacheControl",
                details: `Maximum ${MAX_CACHE_BREAKPOINTS} cache breakpoints exceeded (found ${this.breakpointCount}). This breakpoint will be ignored.`
              });
              return void 0;
            }
            return cacheControlValue;
          }
          getWarnings() {
            return this.warnings;
          }
        };
        var textEditor_20250728ArgsSchema = lazySchema(
          () => zodSchema(
            object({
              maxCharacters: number$1().optional()
            })
          )
        );
        var textEditor_20250728InputSchema = lazySchema(
          () => zodSchema(
            object({
              command: _enum(["view", "create", "str_replace", "insert"]),
              path: string(),
              file_text: string().optional(),
              insert_line: number$1().int().optional(),
              new_str: string().optional(),
              old_str: string().optional(),
              view_range: array(number$1().int()).optional()
            })
          )
        );
        var factory = createProviderDefinedToolFactory({
          id: "anthropic.text_editor_20250728",
          name: "str_replace_based_edit_tool",
          inputSchema: textEditor_20250728InputSchema
        });
        var textEditor_20250728 = (args = {}) => {
          return factory(args);
        };
        var webSearch_20250305ArgsSchema = lazySchema(
          () => zodSchema(
            object({
              maxUses: number$1().optional(),
              allowedDomains: array(string()).optional(),
              blockedDomains: array(string()).optional(),
              userLocation: object({
                type: literal("approximate"),
                city: string().optional(),
                region: string().optional(),
                country: string().optional(),
                timezone: string().optional()
              }).optional()
            })
          )
        );
        var webSearch_20250305OutputSchema = lazySchema(
          () => zodSchema(
            array(
              object({
                url: string(),
                title: string(),
                pageAge: string().nullable(),
                encryptedContent: string(),
                type: literal("web_search_result")
              })
            )
          )
        );
        var webSearch_20250305InputSchema = lazySchema(
          () => zodSchema(
            object({
              query: string()
            })
          )
        );
        var factory2 = createProviderDefinedToolFactoryWithOutputSchema({
          id: "anthropic.web_search_20250305",
          name: "web_search",
          inputSchema: webSearch_20250305InputSchema,
          outputSchema: webSearch_20250305OutputSchema
        });
        var webSearch_20250305 = (args = {}) => {
          return factory2(args);
        };
        var webFetch_20250910ArgsSchema = lazySchema(
          () => zodSchema(
            object({
              maxUses: number$1().optional(),
              allowedDomains: array(string()).optional(),
              blockedDomains: array(string()).optional(),
              citations: object({ enabled: boolean() }).optional(),
              maxContentTokens: number$1().optional()
            })
          )
        );
        var webFetch_20250910OutputSchema = lazySchema(
          () => zodSchema(
            object({
              type: literal("web_fetch_result"),
              url: string(),
              content: object({
                type: literal("document"),
                title: string(),
                citations: object({ enabled: boolean() }).optional(),
                source: union([
                  object({
                    type: literal("base64"),
                    mediaType: literal("application/pdf"),
                    data: string()
                  }),
                  object({
                    type: literal("text"),
                    mediaType: literal("text/plain"),
                    data: string()
                  })
                ])
              }),
              retrievedAt: string().nullable()
            })
          )
        );
        var webFetch_20250910InputSchema = lazySchema(
          () => zodSchema(
            object({
              url: string()
            })
          )
        );
        var factory3 = createProviderDefinedToolFactoryWithOutputSchema({
          id: "anthropic.web_fetch_20250910",
          name: "web_fetch",
          inputSchema: webFetch_20250910InputSchema,
          outputSchema: webFetch_20250910OutputSchema
        });
        var webFetch_20250910 = (args = {}) => {
          return factory3(args);
        };
        async function prepareTools$2({
          tools,
          toolChoice,
          disableParallelToolUse,
          cacheControlValidator
        }) {
          tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
          const toolWarnings = [];
          const betas = /* @__PURE__ */ new Set();
          const validator = cacheControlValidator || new CacheControlValidator();
          if (tools == null) {
            return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
          }
          const anthropicTools2 = [];
          for (const tool of tools) {
            switch (tool.type) {
              case "function": {
                const cacheControl = validator.getCacheControl(tool.providerOptions, {
                  type: "tool definition",
                  canCache: true
                });
                anthropicTools2.push({
                  name: tool.name,
                  description: tool.description,
                  input_schema: tool.inputSchema,
                  cache_control: cacheControl
                });
                break;
              }
              case "provider-defined": {
                switch (tool.id) {
                  case "anthropic.code_execution_20250522": {
                    betas.add("code-execution-2025-05-22");
                    anthropicTools2.push({
                      type: "code_execution_20250522",
                      name: "code_execution",
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.code_execution_20250825": {
                    betas.add("code-execution-2025-08-25");
                    anthropicTools2.push({
                      type: "code_execution_20250825",
                      name: "code_execution"
                    });
                    break;
                  }
                  case "anthropic.computer_20250124": {
                    betas.add("computer-use-2025-01-24");
                    anthropicTools2.push({
                      name: "computer",
                      type: "computer_20250124",
                      display_width_px: tool.args.displayWidthPx,
                      display_height_px: tool.args.displayHeightPx,
                      display_number: tool.args.displayNumber,
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.computer_20241022": {
                    betas.add("computer-use-2024-10-22");
                    anthropicTools2.push({
                      name: "computer",
                      type: "computer_20241022",
                      display_width_px: tool.args.displayWidthPx,
                      display_height_px: tool.args.displayHeightPx,
                      display_number: tool.args.displayNumber,
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.text_editor_20250124": {
                    betas.add("computer-use-2025-01-24");
                    anthropicTools2.push({
                      name: "str_replace_editor",
                      type: "text_editor_20250124",
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.text_editor_20241022": {
                    betas.add("computer-use-2024-10-22");
                    anthropicTools2.push({
                      name: "str_replace_editor",
                      type: "text_editor_20241022",
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.text_editor_20250429": {
                    betas.add("computer-use-2025-01-24");
                    anthropicTools2.push({
                      name: "str_replace_based_edit_tool",
                      type: "text_editor_20250429",
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.text_editor_20250728": {
                    const args = await validateTypes$1({
                      value: tool.args,
                      schema: textEditor_20250728ArgsSchema
                    });
                    anthropicTools2.push({
                      name: "str_replace_based_edit_tool",
                      type: "text_editor_20250728",
                      max_characters: args.maxCharacters,
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.bash_20250124": {
                    betas.add("computer-use-2025-01-24");
                    anthropicTools2.push({
                      name: "bash",
                      type: "bash_20250124",
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.bash_20241022": {
                    betas.add("computer-use-2024-10-22");
                    anthropicTools2.push({
                      name: "bash",
                      type: "bash_20241022",
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.memory_20250818": {
                    betas.add("context-management-2025-06-27");
                    anthropicTools2.push({
                      name: "memory",
                      type: "memory_20250818"
                    });
                    break;
                  }
                  case "anthropic.web_fetch_20250910": {
                    betas.add("web-fetch-2025-09-10");
                    const args = await validateTypes$1({
                      value: tool.args,
                      schema: webFetch_20250910ArgsSchema
                    });
                    anthropicTools2.push({
                      type: "web_fetch_20250910",
                      name: "web_fetch",
                      max_uses: args.maxUses,
                      allowed_domains: args.allowedDomains,
                      blocked_domains: args.blockedDomains,
                      citations: args.citations,
                      max_content_tokens: args.maxContentTokens,
                      cache_control: void 0
                    });
                    break;
                  }
                  case "anthropic.web_search_20250305": {
                    const args = await validateTypes$1({
                      value: tool.args,
                      schema: webSearch_20250305ArgsSchema
                    });
                    anthropicTools2.push({
                      type: "web_search_20250305",
                      name: "web_search",
                      max_uses: args.maxUses,
                      allowed_domains: args.allowedDomains,
                      blocked_domains: args.blockedDomains,
                      user_location: args.userLocation,
                      cache_control: void 0
                    });
                    break;
                  }
                  default: {
                    toolWarnings.push({ type: "unsupported-tool", tool });
                    break;
                  }
                }
                break;
              }
              default: {
                toolWarnings.push({ type: "unsupported-tool", tool });
                break;
              }
            }
          }
          if (toolChoice == null) {
            return {
              tools: anthropicTools2,
              toolChoice: disableParallelToolUse ? { type: "auto", disable_parallel_tool_use: disableParallelToolUse } : void 0,
              toolWarnings,
              betas
            };
          }
          const type = toolChoice.type;
          switch (type) {
            case "auto":
              return {
                tools: anthropicTools2,
                toolChoice: {
                  type: "auto",
                  disable_parallel_tool_use: disableParallelToolUse
                },
                toolWarnings,
                betas
              };
            case "required":
              return {
                tools: anthropicTools2,
                toolChoice: {
                  type: "any",
                  disable_parallel_tool_use: disableParallelToolUse
                },
                toolWarnings,
                betas
              };
            case "none":
              return { tools: void 0, toolChoice: void 0, toolWarnings, betas };
            case "tool":
              return {
                tools: anthropicTools2,
                toolChoice: {
                  type: "tool",
                  name: toolChoice.toolName,
                  disable_parallel_tool_use: disableParallelToolUse
                },
                toolWarnings,
                betas
              };
            default: {
              const _exhaustiveCheck = type;
              throw new UnsupportedFunctionalityError$1({
                functionality: `tool choice type: ${_exhaustiveCheck}`
              });
            }
          }
        }
        var codeExecution_20250522OutputSchema = lazySchema(
          () => zodSchema(
            object({
              type: literal("code_execution_result"),
              stdout: string(),
              stderr: string(),
              return_code: number$1()
            })
          )
        );
        var codeExecution_20250522InputSchema = lazySchema(
          () => zodSchema(
            object({
              code: string()
            })
          )
        );
        var factory4 = createProviderDefinedToolFactoryWithOutputSchema({
          id: "anthropic.code_execution_20250522",
          name: "code_execution",
          inputSchema: codeExecution_20250522InputSchema,
          outputSchema: codeExecution_20250522OutputSchema
        });
        var codeExecution_20250522 = (args = {}) => {
          return factory4(args);
        };
        var codeExecution_20250825OutputSchema = lazySchema(
          () => zodSchema(
            discriminatedUnion("type", [
              object({
                type: literal("bash_code_execution_result"),
                content: array(
                  object({
                    type: literal("bash_code_execution_output"),
                    file_id: string()
                  })
                ),
                stdout: string(),
                stderr: string(),
                return_code: number$1()
              }),
              object({
                type: literal("bash_code_execution_tool_result_error"),
                error_code: string()
              }),
              object({
                type: literal("text_editor_code_execution_tool_result_error"),
                error_code: string()
              }),
              object({
                type: literal("text_editor_code_execution_view_result"),
                content: string(),
                file_type: string(),
                num_lines: number$1().nullable(),
                start_line: number$1().nullable(),
                total_lines: number$1().nullable()
              }),
              object({
                type: literal("text_editor_code_execution_create_result"),
                is_file_update: boolean()
              }),
              object({
                type: literal("text_editor_code_execution_str_replace_result"),
                lines: array(string()).nullable(),
                new_lines: number$1().nullable(),
                new_start: number$1().nullable(),
                old_lines: number$1().nullable(),
                old_start: number$1().nullable()
              })
            ])
          )
        );
        var codeExecution_20250825InputSchema = lazySchema(
          () => zodSchema(
            discriminatedUnion("type", [
              object({
                type: literal("bash_code_execution"),
                command: string()
              }),
              discriminatedUnion("command", [
                object({
                  type: literal("text_editor_code_execution"),
                  command: literal("view"),
                  path: string()
                }),
                object({
                  type: literal("text_editor_code_execution"),
                  command: literal("create"),
                  path: string(),
                  file_text: string().nullish()
                }),
                object({
                  type: literal("text_editor_code_execution"),
                  command: literal("str_replace"),
                  path: string(),
                  old_str: string(),
                  new_str: string()
                })
              ])
            ])
          )
        );
        var factory5 = createProviderDefinedToolFactoryWithOutputSchema({
          id: "anthropic.code_execution_20250825",
          name: "code_execution",
          inputSchema: codeExecution_20250825InputSchema,
          outputSchema: codeExecution_20250825OutputSchema
        });
        var codeExecution_20250825 = (args = {}) => {
          return factory5(args);
        };
        var bash_20241022InputSchema = lazySchema(
          () => zodSchema(
            object({
              command: string(),
              restart: boolean().optional()
            })
          )
        );
        var bash_20241022 = createProviderDefinedToolFactory({
          id: "anthropic.bash_20241022",
          name: "bash",
          inputSchema: bash_20241022InputSchema
        });
        var bash_20250124InputSchema = lazySchema(
          () => zodSchema(
            object({
              command: string(),
              restart: boolean().optional()
            })
          )
        );
        var bash_20250124 = createProviderDefinedToolFactory({
          id: "anthropic.bash_20250124",
          name: "bash",
          inputSchema: bash_20250124InputSchema
        });
        var computer_20241022InputSchema = lazySchema(
          () => zodSchema(
            object({
              action: _enum([
                "key",
                "type",
                "mouse_move",
                "left_click",
                "left_click_drag",
                "right_click",
                "middle_click",
                "double_click",
                "screenshot",
                "cursor_position"
              ]),
              coordinate: array(number$1().int()).optional(),
              text: string().optional()
            })
          )
        );
        var computer_20241022 = createProviderDefinedToolFactory({
          id: "anthropic.computer_20241022",
          name: "computer",
          inputSchema: computer_20241022InputSchema
        });
        var computer_20250124InputSchema = lazySchema(
          () => zodSchema(
            object({
              action: _enum([
                "key",
                "hold_key",
                "type",
                "cursor_position",
                "mouse_move",
                "left_mouse_down",
                "left_mouse_up",
                "left_click",
                "left_click_drag",
                "right_click",
                "middle_click",
                "double_click",
                "triple_click",
                "scroll",
                "wait",
                "screenshot"
              ]),
              coordinate: tuple([number$1().int(), number$1().int()]).optional(),
              duration: number$1().optional(),
              scroll_amount: number$1().optional(),
              scroll_direction: _enum(["up", "down", "left", "right"]).optional(),
              start_coordinate: tuple([number$1().int(), number$1().int()]).optional(),
              text: string().optional()
            })
          )
        );
        var computer_20250124 = createProviderDefinedToolFactory({
          id: "anthropic.computer_20250124",
          name: "computer",
          inputSchema: computer_20250124InputSchema
        });
        var memory_20250818InputSchema = lazySchema(
          () => zodSchema(
            discriminatedUnion("command", [
              object({
                command: literal("view"),
                path: string(),
                view_range: tuple([number$1(), number$1()]).optional()
              }),
              object({
                command: literal("create"),
                path: string(),
                file_text: string()
              }),
              object({
                command: literal("str_replace"),
                path: string(),
                old_str: string(),
                new_str: string()
              }),
              object({
                command: literal("insert"),
                path: string(),
                insert_line: number$1(),
                insert_text: string()
              }),
              object({
                command: literal("delete"),
                path: string()
              }),
              object({
                command: literal("rename"),
                old_path: string(),
                new_path: string()
              })
            ])
          )
        );
        var memory_20250818 = createProviderDefinedToolFactory({
          id: "anthropic.memory_20250818",
          name: "memory",
          inputSchema: memory_20250818InputSchema
        });
        var textEditor_20241022InputSchema = lazySchema(
          () => zodSchema(
            object({
              command: _enum(["view", "create", "str_replace", "insert", "undo_edit"]),
              path: string(),
              file_text: string().optional(),
              insert_line: number$1().int().optional(),
              new_str: string().optional(),
              old_str: string().optional(),
              view_range: array(number$1().int()).optional()
            })
          )
        );
        var textEditor_20241022 = createProviderDefinedToolFactory({
          id: "anthropic.text_editor_20241022",
          name: "str_replace_editor",
          inputSchema: textEditor_20241022InputSchema
        });
        var textEditor_20250124InputSchema = lazySchema(
          () => zodSchema(
            object({
              command: _enum(["view", "create", "str_replace", "insert", "undo_edit"]),
              path: string(),
              file_text: string().optional(),
              insert_line: number$1().int().optional(),
              new_str: string().optional(),
              old_str: string().optional(),
              view_range: array(number$1().int()).optional()
            })
          )
        );
        var textEditor_20250124 = createProviderDefinedToolFactory({
          id: "anthropic.text_editor_20250124",
          name: "str_replace_editor",
          inputSchema: textEditor_20250124InputSchema
        });
        var textEditor_20250429InputSchema = lazySchema(
          () => zodSchema(
            object({
              command: _enum(["view", "create", "str_replace", "insert"]),
              path: string(),
              file_text: string().optional(),
              insert_line: number$1().int().optional(),
              new_str: string().optional(),
              old_str: string().optional(),
              view_range: array(number$1().int()).optional()
            })
          )
        );
        var textEditor_20250429 = createProviderDefinedToolFactory({
          id: "anthropic.text_editor_20250429",
          name: "str_replace_based_edit_tool",
          inputSchema: textEditor_20250429InputSchema
        });

        // src/anthropic-tools.ts
        var anthropicTools = {
          /**
           * The bash tool enables Claude to execute shell commands in a persistent bash session,
           * allowing system operations, script execution, and command-line automation.
           *
           * Image results are supported.
           *
           * Tool name must be `bash`.
           */
          bash_20241022,
          /**
           * The bash tool enables Claude to execute shell commands in a persistent bash session,
           * allowing system operations, script execution, and command-line automation.
           *
           * Image results are supported.
           *
           * Tool name must be `bash`.
           */
          bash_20250124,
          /**
           * Claude can analyze data, create visualizations, perform complex calculations,
           * run system commands, create and edit files, and process uploaded files directly within
           * the API conversation.
           *
           * The code execution tool allows Claude to run Bash commands and manipulate files,
           * including writing code, in a secure, sandboxed environment.
           *
           * Tool name must be `code_execution`.
           */
          codeExecution_20250522,
          /**
           * Claude can analyze data, create visualizations, perform complex calculations,
           * run system commands, create and edit files, and process uploaded files directly within
           * the API conversation.
           *
           * The code execution tool allows Claude to run both Python and Bash commands and manipulate files,
           * including writing code, in a secure, sandboxed environment.
           *
           * This is the latest version with enhanced Bash support and file operations.
           *
           * Tool name must be `code_execution`.
           */
          codeExecution_20250825,
          /**
           * Claude can interact with computer environments through the computer use tool, which
           * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
           *
           * Image results are supported.
           *
           * Tool name must be `computer`.
           *
           * @param displayWidthPx - The width of the display being controlled by the model in pixels.
           * @param displayHeightPx - The height of the display being controlled by the model in pixels.
           * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
           */
          computer_20241022,
          /**
           * Claude can interact with computer environments through the computer use tool, which
           * provides screenshot capabilities and mouse/keyboard control for autonomous desktop interaction.
           *
           * Image results are supported.
           *
           * Tool name must be `computer`.
           *
           * @param displayWidthPx - The width of the display being controlled by the model in pixels.
           * @param displayHeightPx - The height of the display being controlled by the model in pixels.
           * @param displayNumber - The display number to control (only relevant for X11 environments). If specified, the tool will be provided a display number in the tool definition.
           */
          computer_20250124,
          /**
           * The memory tool enables Claude to store and retrieve information across conversations through a memory file directory.
           * Claude can create, read, update, and delete files that persist between sessions,
           * allowing it to build knowledge over time without keeping everything in the context window.
           * The memory tool operates client-side—you control where and how the data is stored through your own infrastructure.
           *
           * Supported models: Claude Sonnet 4.5, Claude Sonnet 4, Claude Opus 4.1, Claude Opus 4.
           *
           * Tool name must be `memory`.
           */
          memory_20250818,
          /**
           * Claude can use an Anthropic-defined text editor tool to view and modify text files,
           * helping you debug, fix, and improve your code or other text documents. This allows Claude
           * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
           *
           * Supported models: Claude Sonnet 3.5
           *
           * Tool name must be `str_replace_editor`.
           */
          textEditor_20241022,
          /**
           * Claude can use an Anthropic-defined text editor tool to view and modify text files,
           * helping you debug, fix, and improve your code or other text documents. This allows Claude
           * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
           *
           * Supported models: Claude Sonnet 3.7
           *
           * Tool name must be `str_replace_editor`.
           */
          textEditor_20250124,
          /**
           * Claude can use an Anthropic-defined text editor tool to view and modify text files,
           * helping you debug, fix, and improve your code or other text documents. This allows Claude
           * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
           *
           * Note: This version does not support the "undo_edit" command.
           *
           * Tool name must be `str_replace_based_edit_tool`.
           *
           * @deprecated Use textEditor_20250728 instead
           */
          textEditor_20250429,
          /**
           * Claude can use an Anthropic-defined text editor tool to view and modify text files,
           * helping you debug, fix, and improve your code or other text documents. This allows Claude
           * to directly interact with your files, providing hands-on assistance rather than just suggesting changes.
           *
           * Note: This version does not support the "undo_edit" command and adds optional max_characters parameter.
           *
           * Supported models: Claude Sonnet 4, Opus 4, and Opus 4.1
           *
           * Tool name must be `str_replace_based_edit_tool`.
           *
           * @param maxCharacters - Optional maximum number of characters to view in the file
           */
          textEditor_20250728,
          /**
           * Creates a web fetch tool that gives Claude direct access to real-time web content.
           *
           * Tool name must be `web_fetch`.
           *
           * @param maxUses - The max_uses parameter limits the number of web fetches performed
           * @param allowedDomains - Only fetch from these domains
           * @param blockedDomains - Never fetch from these domains
           * @param citations - Unlike web search where citations are always enabled, citations are optional for web fetch. Set "citations": {"enabled": true} to enable Claude to cite specific passages from fetched documents.
           * @param maxContentTokens - The max_content_tokens parameter limits the amount of content that will be included in the context.
           */
          webFetch_20250910,
          /**
           * Creates a web search tool that gives Claude direct access to real-time web content.
           *
           * Tool name must be `web_search`.
           *
           * @param maxUses - Maximum number of web searches Claude can perform during the conversation.
           * @param allowedDomains - Optional list of domains that Claude is allowed to search.
           * @param blockedDomains - Optional list of domains that Claude should avoid when searching.
           * @param userLocation - Optional user location information to provide geographically relevant search results.
           */
          webSearch_20250305
        };

        /******************************************************************************
        Copyright (c) Microsoft Corporation.
        
        Permission to use, copy, modify, and/or distribute this software for any
        purpose with or without fee is hereby granted.
        
        THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
        REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
        AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
        INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
        LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
        OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
        PERFORMANCE OF THIS SOFTWARE.
        ***************************************************************************** */
        /* global Reflect, Promise, SuppressedError, Symbol, Iterator */


        function __values(o) {
          var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
          if (m) return m.call(o);
          if (o && typeof o.length === "number") return {
            next: function () {
              if (o && i >= o.length) o = void 0;
              return { value: o && o[i++], done: !o };
            }
          };
          throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
        }

        typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
          var e = new Error(message);
          return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
        };

        const fromUtf8$1 = (input) => new TextEncoder().encode(input);

        // Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
        // SPDX-License-Identifier: Apache-2.0
        // Quick polyfill
        typeof Buffer !== "undefined" && Buffer.from
          ? function (input) { return Buffer.from(input, "utf8"); }
          : fromUtf8$1;

        // Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.
        // SPDX-License-Identifier: Apache-2.0
        // IE 11 does not support Array.from, so we do it manually
        function uint32ArrayFrom(a_lookUpTable) {
          if (!Uint32Array.from) {
            var return_array = new Uint32Array(a_lookUpTable.length);
            var a_index = 0;
            while (a_index < a_lookUpTable.length) {
              return_array[a_index] = a_lookUpTable[a_index];
              a_index += 1;
            }
            return return_array;
          }
          return Uint32Array.from(a_lookUpTable);
        }

        var Crc32 = /** @class */ (function () {
          function Crc32() {
            this.checksum = 0xffffffff;
          }
          Crc32.prototype.update = function (data) {
            var e_1, _a;
            try {
              for (var data_1 = __values(data), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
                var byte = data_1_1.value;
                this.checksum =
                  (this.checksum >>> 8) ^ lookupTable[(this.checksum ^ byte) & 0xff];
              }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
              try {
                if (data_1_1 && !data_1_1.done && (_a = data_1.return)) _a.call(data_1);
              }
              finally { if (e_1) throw e_1.error; }
            }
            return this;
          };
          Crc32.prototype.digest = function () {
            return (this.checksum ^ 0xffffffff) >>> 0;
          };
          return Crc32;
        }());
        // prettier-ignore
        var a_lookUpTable = [
          0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA,
          0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3,
          0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
          0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91,
          0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE,
          0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
          0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC,
          0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5,
          0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
          0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B,
          0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940,
          0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
          0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116,
          0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F,
          0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
          0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D,
          0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A,
          0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
          0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818,
          0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01,
          0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
          0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457,
          0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C,
          0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
          0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2,
          0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB,
          0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
          0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9,
          0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086,
          0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
          0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4,
          0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD,
          0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
          0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683,
          0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8,
          0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
          0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE,
          0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7,
          0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
          0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5,
          0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252,
          0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
          0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60,
          0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79,
          0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
          0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F,
          0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04,
          0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
          0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A,
          0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713,
          0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
          0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21,
          0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E,
          0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
          0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C,
          0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45,
          0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
          0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB,
          0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0,
          0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
          0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6,
          0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF,
          0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
          0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D,
        ];
        var lookupTable = uint32ArrayFrom(a_lookUpTable);

        const SHORT_TO_HEX = {};
        const HEX_TO_SHORT = {};
        for (let i = 0; i < 256; i++) {
          let encodedByte = i.toString(16).toLowerCase();
          if (encodedByte.length === 1) {
            encodedByte = `0${encodedByte}`;
          }
          SHORT_TO_HEX[i] = encodedByte;
          HEX_TO_SHORT[encodedByte] = i;
        }
        function fromHex(encoded) {
          if (encoded.length % 2 !== 0) {
            throw new Error("Hex encoded strings must have an even number length");
          }
          const out = new Uint8Array(encoded.length / 2);
          for (let i = 0; i < encoded.length; i += 2) {
            const encodedByte = encoded.slice(i, i + 2).toLowerCase();
            if (encodedByte in HEX_TO_SHORT) {
              out[i / 2] = HEX_TO_SHORT[encodedByte];
            }
            else {
              throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
            }
          }
          return out;
        }
        function toHex(bytes) {
          let out = "";
          for (let i = 0; i < bytes.byteLength; i++) {
            out += SHORT_TO_HEX[bytes[i]];
          }
          return out;
        }

        class Int64 {
          constructor(bytes) {
            this.bytes = bytes;
            if (bytes.byteLength !== 8) {
              throw new Error("Int64 buffers must be exactly 8 bytes");
            }
          }
          static fromNumber(number) {
            if (number > 9223372036854776000 || number < -9223372036854776e3) {
              throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
            }
            const bytes = new Uint8Array(8);
            for (let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
              bytes[i] = remaining;
            }
            if (number < 0) {
              negate(bytes);
            }
            return new Int64(bytes);
          }
          valueOf() {
            const bytes = this.bytes.slice(0);
            const negative = bytes[0] & 0b10000000;
            if (negative) {
              negate(bytes);
            }
            return parseInt(toHex(bytes), 16) * (negative ? -1 : 1);
          }
          toString() {
            return String(this.valueOf());
          }
        }
        function negate(bytes) {
          for (let i = 0; i < 8; i++) {
            bytes[i] ^= 0xff;
          }
          for (let i = 7; i > -1; i--) {
            bytes[i]++;
            if (bytes[i] !== 0)
              break;
          }
        }

        class HeaderMarshaller {
          constructor(toUtf8, fromUtf8) {
            this.toUtf8 = toUtf8;
            this.fromUtf8 = fromUtf8;
          }
          format(headers) {
            const chunks = [];
            for (const headerName of Object.keys(headers)) {
              const bytes = this.fromUtf8(headerName);
              chunks.push(Uint8Array.from([bytes.byteLength]), bytes, this.formatHeaderValue(headers[headerName]));
            }
            const out = new Uint8Array(chunks.reduce((carry, bytes) => carry + bytes.byteLength, 0));
            let position = 0;
            for (const chunk of chunks) {
              out.set(chunk, position);
              position += chunk.byteLength;
            }
            return out;
          }
          formatHeaderValue(header) {
            switch (header.type) {
              case "boolean":
                return Uint8Array.from([header.value ? 0 : 1]);
              case "byte":
                return Uint8Array.from([2, header.value]);
              case "short":
                const shortView = new DataView(new ArrayBuffer(3));
                shortView.setUint8(0, 3);
                shortView.setInt16(1, header.value, false);
                return new Uint8Array(shortView.buffer);
              case "integer":
                const intView = new DataView(new ArrayBuffer(5));
                intView.setUint8(0, 4);
                intView.setInt32(1, header.value, false);
                return new Uint8Array(intView.buffer);
              case "long":
                const longBytes = new Uint8Array(9);
                longBytes[0] = 5;
                longBytes.set(header.value.bytes, 1);
                return longBytes;
              case "binary":
                const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
                binView.setUint8(0, 6);
                binView.setUint16(1, header.value.byteLength, false);
                const binBytes = new Uint8Array(binView.buffer);
                binBytes.set(header.value, 3);
                return binBytes;
              case "string":
                const utf8Bytes = this.fromUtf8(header.value);
                const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
                strView.setUint8(0, 7);
                strView.setUint16(1, utf8Bytes.byteLength, false);
                const strBytes = new Uint8Array(strView.buffer);
                strBytes.set(utf8Bytes, 3);
                return strBytes;
              case "timestamp":
                const tsBytes = new Uint8Array(9);
                tsBytes[0] = 8;
                tsBytes.set(Int64.fromNumber(header.value.valueOf()).bytes, 1);
                return tsBytes;
              case "uuid":
                if (!UUID_PATTERN.test(header.value)) {
                  throw new Error(`Invalid UUID received: ${header.value}`);
                }
                const uuidBytes = new Uint8Array(17);
                uuidBytes[0] = 9;
                uuidBytes.set(fromHex(header.value.replace(/\-/g, "")), 1);
                return uuidBytes;
            }
          }
          parse(headers) {
            const out = {};
            let position = 0;
            while (position < headers.byteLength) {
              const nameLength = headers.getUint8(position++);
              const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
              position += nameLength;
              switch (headers.getUint8(position++)) {
                case 0:
                  out[name] = {
                    type: BOOLEAN_TAG,
                    value: true,
                  };
                  break;
                case 1:
                  out[name] = {
                    type: BOOLEAN_TAG,
                    value: false,
                  };
                  break;
                case 2:
                  out[name] = {
                    type: BYTE_TAG,
                    value: headers.getInt8(position++),
                  };
                  break;
                case 3:
                  out[name] = {
                    type: SHORT_TAG,
                    value: headers.getInt16(position, false),
                  };
                  position += 2;
                  break;
                case 4:
                  out[name] = {
                    type: INT_TAG,
                    value: headers.getInt32(position, false),
                  };
                  position += 4;
                  break;
                case 5:
                  out[name] = {
                    type: LONG_TAG,
                    value: new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)),
                  };
                  position += 8;
                  break;
                case 6:
                  const binaryLength = headers.getUint16(position, false);
                  position += 2;
                  out[name] = {
                    type: BINARY_TAG,
                    value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength),
                  };
                  position += binaryLength;
                  break;
                case 7:
                  const stringLength = headers.getUint16(position, false);
                  position += 2;
                  out[name] = {
                    type: STRING_TAG,
                    value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength)),
                  };
                  position += stringLength;
                  break;
                case 8:
                  out[name] = {
                    type: TIMESTAMP_TAG,
                    value: new Date(new Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf()),
                  };
                  position += 8;
                  break;
                case 9:
                  const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
                  position += 16;
                  out[name] = {
                    type: UUID_TAG,
                    value: `${toHex(uuidBytes.subarray(0, 4))}-${toHex(uuidBytes.subarray(4, 6))}-${toHex(uuidBytes.subarray(6, 8))}-${toHex(uuidBytes.subarray(8, 10))}-${toHex(uuidBytes.subarray(10))}`,
                  };
                  break;
                default:
                  throw new Error(`Unrecognized header type tag`);
              }
            }
            return out;
          }
        }
        var HEADER_VALUE_TYPE;
        (function (HEADER_VALUE_TYPE) {
          HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolTrue"] = 0] = "boolTrue";
          HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolFalse"] = 1] = "boolFalse";
          HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byte"] = 2] = "byte";
          HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["short"] = 3] = "short";
          HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["integer"] = 4] = "integer";
          HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["long"] = 5] = "long";
          HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byteArray"] = 6] = "byteArray";
          HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["string"] = 7] = "string";
          HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["timestamp"] = 8] = "timestamp";
          HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["uuid"] = 9] = "uuid";
        })(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
        const BOOLEAN_TAG = "boolean";
        const BYTE_TAG = "byte";
        const SHORT_TAG = "short";
        const INT_TAG = "integer";
        const LONG_TAG = "long";
        const BINARY_TAG = "binary";
        const STRING_TAG = "string";
        const TIMESTAMP_TAG = "timestamp";
        const UUID_TAG = "uuid";
        const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;

        const PRELUDE_MEMBER_LENGTH = 4;
        const PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
        const CHECKSUM_LENGTH = 4;
        const MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
        function splitMessage({ byteLength, byteOffset, buffer }) {
          if (byteLength < MINIMUM_MESSAGE_LENGTH) {
            throw new Error("Provided message too short to accommodate event stream message overhead");
          }
          const view = new DataView(buffer, byteOffset, byteLength);
          const messageLength = view.getUint32(0, false);
          if (byteLength !== messageLength) {
            throw new Error("Reported message length does not match received message length");
          }
          const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
          const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
          const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
          const checksummer = new Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
          if (expectedPreludeChecksum !== checksummer.digest()) {
            throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
          }
          checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
          if (expectedMessageChecksum !== checksummer.digest()) {
            throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
          }
          return {
            headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
            body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH)),
          };
        }

        class EventStreamCodec {
          constructor(toUtf8, fromUtf8) {
            this.headerMarshaller = new HeaderMarshaller(toUtf8, fromUtf8);
            this.messageBuffer = [];
            this.isEndOfStream = false;
          }
          feed(message) {
            this.messageBuffer.push(this.decode(message));
          }
          endOfStream() {
            this.isEndOfStream = true;
          }
          getMessage() {
            const message = this.messageBuffer.pop();
            const isEndOfStream = this.isEndOfStream;
            return {
              getMessage() {
                return message;
              },
              isEndOfStream() {
                return isEndOfStream;
              },
            };
          }
          getAvailableMessages() {
            const messages = this.messageBuffer;
            this.messageBuffer = [];
            const isEndOfStream = this.isEndOfStream;
            return {
              getMessages() {
                return messages;
              },
              isEndOfStream() {
                return isEndOfStream;
              },
            };
          }
          encode({ headers: rawHeaders, body }) {
            const headers = this.headerMarshaller.format(rawHeaders);
            const length = headers.byteLength + body.byteLength + 16;
            const out = new Uint8Array(length);
            const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
            const checksum = new Crc32();
            view.setUint32(0, length, false);
            view.setUint32(4, headers.byteLength, false);
            view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
            out.set(headers, 12);
            out.set(body, headers.byteLength + 12);
            view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
            return out;
          }
          decode(message) {
            const { headers, body } = splitMessage(message);
            return { headers: this.headerMarshaller.parse(headers), body };
          }
          formatHeaders(rawHeaders) {
            return this.headerMarshaller.format(rawHeaders);
          }
        }

        const fromUtf8 = (input) => new TextEncoder().encode(input);

        const toUtf8 = (input) => {
          if (typeof input === "string") {
            return input;
          }
          if (typeof input !== "object" || typeof input.byteOffset !== "number" || typeof input.byteLength !== "number") {
            throw new Error("@smithy/util-utf8: toUtf8 encoder function only accepts string | Uint8Array.");
          }
          return new TextDecoder("utf-8").decode(input);
        };

        /**
         * @license MIT <https://opensource.org/licenses/MIT>
         * @copyright Michael Hart 2024
         */
        const encoder = new TextEncoder();
        const HOST_SERVICES = {
          appstream2: 'appstream',
          cloudhsmv2: 'cloudhsm',
          email: 'ses',
          marketplace: 'aws-marketplace',
          mobile: 'AWSMobileHubService',
          pinpoint: 'mobiletargeting',
          queue: 'sqs',
          'git-codecommit': 'codecommit',
          'mturk-requester-sandbox': 'mturk-requester',
          'personalize-runtime': 'personalize',
        };
        const UNSIGNABLE_HEADERS = new Set([
          'authorization',
          'content-type',
          'content-length',
          'user-agent',
          'presigned-expires',
          'expect',
          'x-amzn-trace-id',
          'range',
          'connection',
        ]);
        class AwsV4Signer {
          constructor({ method, url, headers, body, accessKeyId, secretAccessKey, sessionToken, service, region, cache, datetime, signQuery, appendSessionToken, allHeaders, singleEncode }) {
            if (url == null) throw new TypeError('url is a required option')
            if (accessKeyId == null) throw new TypeError('accessKeyId is a required option')
            if (secretAccessKey == null) throw new TypeError('secretAccessKey is a required option')
            this.method = method || (body ? 'POST' : 'GET');
            this.url = new URL(url);
            this.headers = new Headers(headers || {});
            this.body = body;
            this.accessKeyId = accessKeyId;
            this.secretAccessKey = secretAccessKey;
            this.sessionToken = sessionToken;
            let guessedService, guessedRegion;
            if (!service || !region) {
              [guessedService, guessedRegion] = guessServiceRegion(this.url, this.headers);
            }
            this.service = service || guessedService || '';
            this.region = region || guessedRegion || 'us-east-1';
            this.cache = cache || new Map();
            this.datetime = datetime || new Date().toISOString().replace(/[:-]|\.\d{3}/g, '');
            this.signQuery = signQuery;
            this.appendSessionToken = appendSessionToken || this.service === 'iotdevicegateway';
            this.headers.delete('Host');
            if (this.service === 's3' && !this.signQuery && !this.headers.has('X-Amz-Content-Sha256')) {
              this.headers.set('X-Amz-Content-Sha256', 'UNSIGNED-PAYLOAD');
            }
            const params = this.signQuery ? this.url.searchParams : this.headers;
            params.set('X-Amz-Date', this.datetime);
            if (this.sessionToken && !this.appendSessionToken) {
              params.set('X-Amz-Security-Token', this.sessionToken);
            }
            this.signableHeaders = ['host', ...this.headers.keys()]
              .filter(header => allHeaders || !UNSIGNABLE_HEADERS.has(header))
              .sort();
            this.signedHeaders = this.signableHeaders.join(';');
            this.canonicalHeaders = this.signableHeaders
              .map(header => header + ':' + (header === 'host' ? this.url.host : (this.headers.get(header) || '').replace(/\s+/g, ' ')))
              .join('\n');
            this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, 'aws4_request'].join('/');
            if (this.signQuery) {
              if (this.service === 's3' && !params.has('X-Amz-Expires')) {
                params.set('X-Amz-Expires', '86400');
              }
              params.set('X-Amz-Algorithm', 'AWS4-HMAC-SHA256');
              params.set('X-Amz-Credential', this.accessKeyId + '/' + this.credentialString);
              params.set('X-Amz-SignedHeaders', this.signedHeaders);
            }
            if (this.service === 's3') {
              try {
                this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\+/g, ' '));
              } catch (e) {
                this.encodedPath = this.url.pathname;
              }
            } else {
              this.encodedPath = this.url.pathname.replace(/\/+/g, '/');
            }
            if (!singleEncode) {
              this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, '/');
            }
            this.encodedPath = encodeRfc3986(this.encodedPath);
            const seenKeys = new Set();
            this.encodedSearch = [...this.url.searchParams]
              .filter(([k]) => {
                if (!k) return false
                if (this.service === 's3') {
                  if (seenKeys.has(k)) return false
                  seenKeys.add(k);
                }
                return true
              })
              .map(pair => pair.map(p => encodeRfc3986(encodeURIComponent(p))))
              .sort(([k1, v1], [k2, v2]) => k1 < k2 ? -1 : k1 > k2 ? 1 : v1 < v2 ? -1 : v1 > v2 ? 1 : 0)
              .map(pair => pair.join('='))
              .join('&');
          }
          async sign() {
            if (this.signQuery) {
              this.url.searchParams.set('X-Amz-Signature', await this.signature());
              if (this.sessionToken && this.appendSessionToken) {
                this.url.searchParams.set('X-Amz-Security-Token', this.sessionToken);
              }
            } else {
              this.headers.set('Authorization', await this.authHeader());
            }
            return {
              method: this.method,
              url: this.url,
              headers: this.headers,
              body: this.body,
            }
          }
          async authHeader() {
            return [
              'AWS4-HMAC-SHA256 Credential=' + this.accessKeyId + '/' + this.credentialString,
              'SignedHeaders=' + this.signedHeaders,
              'Signature=' + (await this.signature()),
            ].join(', ')
          }
          async signature() {
            const date = this.datetime.slice(0, 8);
            const cacheKey = [this.secretAccessKey, date, this.region, this.service].join();
            let kCredentials = this.cache.get(cacheKey);
            if (!kCredentials) {
              const kDate = await hmac('AWS4' + this.secretAccessKey, date);
              const kRegion = await hmac(kDate, this.region);
              const kService = await hmac(kRegion, this.service);
              kCredentials = await hmac(kService, 'aws4_request');
              this.cache.set(cacheKey, kCredentials);
            }
            return buf2hex(await hmac(kCredentials, await this.stringToSign()))
          }
          async stringToSign() {
            return [
              'AWS4-HMAC-SHA256',
              this.datetime,
              this.credentialString,
              buf2hex(await hash(await this.canonicalString())),
            ].join('\n')
          }
          async canonicalString() {
            return [
              this.method.toUpperCase(),
              this.encodedPath,
              this.encodedSearch,
              this.canonicalHeaders + '\n',
              this.signedHeaders,
              await this.hexBodyHash(),
            ].join('\n')
          }
          async hexBodyHash() {
            let hashHeader = this.headers.get('X-Amz-Content-Sha256') || (this.service === 's3' && this.signQuery ? 'UNSIGNED-PAYLOAD' : null);
            if (hashHeader == null) {
              if (this.body && typeof this.body !== 'string' && !('byteLength' in this.body)) {
                throw new Error('body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header')
              }
              hashHeader = buf2hex(await hash(this.body || ''));
            }
            return hashHeader
          }
        }
        async function hmac(key, string) {
          const cryptoKey = await crypto.subtle.importKey(
            'raw',
            typeof key === 'string' ? encoder.encode(key) : key,
            { name: 'HMAC', hash: { name: 'SHA-256' } },
            false,
            ['sign'],
          );
          return crypto.subtle.sign('HMAC', cryptoKey, encoder.encode(string))
        }
        async function hash(content) {
          return crypto.subtle.digest('SHA-256', typeof content === 'string' ? encoder.encode(content) : content)
        }
        const HEX_CHARS = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];
        function buf2hex(arrayBuffer) {
          const buffer = new Uint8Array(arrayBuffer);
          let out = '';
          for (let idx = 0; idx < buffer.length; idx++) {
            const n = buffer[idx];
            out += HEX_CHARS[(n >>> 4) & 0xF];
            out += HEX_CHARS[n & 0xF];
          }
          return out
        }
        function encodeRfc3986(urlEncodedStr) {
          return urlEncodedStr.replace(/[!'()*]/g, c => '%' + c.charCodeAt(0).toString(16).toUpperCase())
        }
        function guessServiceRegion(url, headers) {
          const { hostname, pathname } = url;
          if (hostname.endsWith('.on.aws')) {
            const match = hostname.match(/^[^.]{1,63}\.lambda-url\.([^.]{1,63})\.on\.aws$/);
            return match != null ? ['lambda', match[1] || ''] : ['', '']
          }
          if (hostname.endsWith('.r2.cloudflarestorage.com')) {
            return ['s3', 'auto']
          }
          if (hostname.endsWith('.backblazeb2.com')) {
            const match = hostname.match(/^(?:[^.]{1,63}\.)?s3\.([^.]{1,63})\.backblazeb2\.com$/);
            return match != null ? ['s3', match[1] || ''] : ['', '']
          }
          const match = hostname.replace('dualstack.', '').match(/([^.]{1,63})\.(?:([^.]{0,63})\.)?amazonaws\.com(?:\.cn)?$/);
          let service = (match && match[1]) || '';
          let region = match && match[2];
          if (region === 'us-gov') {
            region = 'us-gov-west-1';
          } else if (region === 's3' || region === 's3-accelerate') {
            region = 'us-east-1';
            service = 's3';
          } else if (service === 'iot') {
            if (hostname.startsWith('iot.')) {
              service = 'execute-api';
            } else if (hostname.startsWith('data.jobs.iot.')) {
              service = 'iot-jobs-data';
            } else {
              service = pathname === '/mqtt' ? 'iotdevicegateway' : 'iotdata';
            }
          } else if (service === 'autoscaling') {
            const targetPrefix = (headers.get('X-Amz-Target') || '').split('.')[0];
            if (targetPrefix === 'AnyScaleFrontendService') {
              service = 'application-autoscaling';
            } else if (targetPrefix === 'AnyScaleScalingPlannerFrontendService') {
              service = 'autoscaling-plans';
            }
          } else if (region == null && service.startsWith('s3-')) {
            region = service.slice(3).replace(/^fips-|^external-1/, '');
            service = 's3';
          } else if (service.endsWith('-fips')) {
            service = service.slice(0, -5);
          } else if (region && /-\d$/.test(service) && !/-\d$/.test(region)) {
            [service, region] = [region, service];
          }
          return [HOST_SERVICES[service] || service, region || '']
        }

        // src/bedrock-provider.ts

        // src/version.ts
        var VERSION$1 = "3.0.43";

        // src/bedrock-api-types.ts
        var BEDROCK_CACHE_POINT = {
          cachePoint: { type: "default" }
        };
        var BEDROCK_STOP_REASONS = [
          "stop",
          "stop_sequence",
          "end_turn",
          "length",
          "max_tokens",
          "content-filter",
          "content_filtered",
          "guardrail_intervened",
          "tool-calls",
          "tool_use"
        ];
        var BEDROCK_IMAGE_MIME_TYPES = {
          "image/jpeg": "jpeg",
          "image/png": "png",
          "image/gif": "gif",
          "image/webp": "webp"
        };
        var BEDROCK_DOCUMENT_MIME_TYPES = {
          "application/pdf": "pdf",
          "text/csv": "csv",
          "application/msword": "doc",
          "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
          "application/vnd.ms-excel": "xls",
          "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
          "text/html": "html",
          "text/plain": "txt",
          "text/markdown": "md"
        };
        var bedrockFilePartProviderOptions = object({
          /**
           * Citation configuration for this document.
           * When enabled, this document will generate citations in the response.
           */
          citations: object({
            /**
             * Enable citations for this document
             */
            enabled: boolean()
          }).optional()
        });
        var bedrockProviderOptions = object({
          /**
           * Additional inference parameters that the model supports,
           * beyond the base set of inference parameters that Converse
           * supports in the inferenceConfig field
           */
          additionalModelRequestFields: record(string(), any()).optional(),
          reasoningConfig: object({
            type: union([literal("enabled"), literal("disabled")]).optional(),
            budgetTokens: number$1().optional()
          }).optional()
        });
        var BedrockErrorSchema = object({
          message: string(),
          type: string().nullish()
        });
        var createBedrockEventStreamResponseHandler = (chunkSchema) => async ({ response }) => {
          const responseHeaders = extractResponseHeaders$1(response);
          if (response.body == null) {
            throw new EmptyResponseBodyError$1({});
          }
          const codec = new EventStreamCodec(toUtf8, fromUtf8);
          let buffer = new Uint8Array(0);
          const textDecoder = new TextDecoder();
          return {
            responseHeaders,
            value: response.body.pipeThrough(
              new TransformStream({
                async transform(chunk, controller) {
                  var _a, _b;
                  const newBuffer = new Uint8Array(buffer.length + chunk.length);
                  newBuffer.set(buffer);
                  newBuffer.set(chunk, buffer.length);
                  buffer = newBuffer;
                  while (buffer.length >= 4) {
                    const totalLength = new DataView(
                      buffer.buffer,
                      buffer.byteOffset,
                      buffer.byteLength
                    ).getUint32(0, false);
                    if (buffer.length < totalLength) {
                      break;
                    }
                    try {
                      const subView = buffer.subarray(0, totalLength);
                      const decoded = codec.decode(subView);
                      buffer = buffer.slice(totalLength);
                      if (((_a = decoded.headers[":message-type"]) == null ? void 0 : _a.value) === "event") {
                        const data = textDecoder.decode(decoded.body);
                        const parsedDataResult = await safeParseJSON$1({ text: data });
                        if (!parsedDataResult.success) {
                          controller.enqueue(parsedDataResult);
                          break;
                        }
                        delete parsedDataResult.value.p;
                        let wrappedData = {
                          [(_b = decoded.headers[":event-type"]) == null ? void 0 : _b.value]: parsedDataResult.value
                        };
                        const validatedWrappedData = await safeValidateTypes$1({
                          value: wrappedData,
                          schema: chunkSchema
                        });
                        if (!validatedWrappedData.success) {
                          controller.enqueue(validatedWrappedData);
                        } else {
                          controller.enqueue({
                            success: true,
                            value: validatedWrappedData.value,
                            rawValue: wrappedData
                          });
                        }
                      }
                    } catch (e) {
                      break;
                    }
                  }
                }
              })
            )
          };
        };
        async function prepareTools$1({
          tools,
          toolChoice,
          modelId
        }) {
          const toolWarnings = [];
          const betas = /* @__PURE__ */ new Set();
          if (tools == null || tools.length === 0) {
            return {
              toolConfig: {},
              additionalTools: void 0,
              betas,
              toolWarnings
            };
          }
          const supportedTools = tools.filter((tool) => {
            if (tool.type === "provider-defined" && tool.id === "anthropic.web_search_20250305") {
              toolWarnings.push({
                type: "unsupported-tool",
                tool,
                details: "The web_search_20250305 tool is not supported on Amazon Bedrock."
              });
              return false;
            }
            return true;
          });
          if (supportedTools.length === 0) {
            return {
              toolConfig: {},
              additionalTools: void 0,
              betas,
              toolWarnings
            };
          }
          const isAnthropicModel = modelId.includes("anthropic.");
          const providerDefinedTools = supportedTools.filter(
            (t) => t.type === "provider-defined"
          );
          const functionTools = supportedTools.filter((t) => t.type === "function");
          let additionalTools = void 0;
          const bedrockTools = [];
          const usingAnthropicTools = isAnthropicModel && providerDefinedTools.length > 0;
          if (usingAnthropicTools) {
            if (functionTools.length > 0) {
              toolWarnings.push({
                type: "unsupported-setting",
                setting: "tools",
                details: "Mixed Anthropic provider-defined tools and standard function tools are not supported in a single call to Bedrock. Only Anthropic tools will be used."
              });
            }
            const {
              toolChoice: preparedAnthropicToolChoice,
              toolWarnings: anthropicToolWarnings,
              betas: anthropicBetas
            } = await prepareTools$2({
              tools: providerDefinedTools,
              toolChoice
            });
            toolWarnings.push(...anthropicToolWarnings);
            anthropicBetas.forEach((beta) => betas.add(beta));
            if (preparedAnthropicToolChoice) {
              additionalTools = {
                tool_choice: preparedAnthropicToolChoice
              };
            }
            for (const tool of providerDefinedTools) {
              const toolFactory = Object.values(anthropicTools).find((factory) => {
                const instance = factory({});
                return instance.id === tool.id;
              });
              if (toolFactory != null) {
                const fullToolDefinition = toolFactory({});
                bedrockTools.push({
                  toolSpec: {
                    name: tool.name,
                    inputSchema: {
                      json: asSchema(fullToolDefinition.inputSchema).jsonSchema
                    }
                  }
                });
              } else {
                toolWarnings.push({ type: "unsupported-tool", tool });
              }
            }
          } else {
            for (const tool of providerDefinedTools) {
              toolWarnings.push({ type: "unsupported-tool", tool });
            }
          }
          for (const tool of functionTools) {
            bedrockTools.push({
              toolSpec: {
                name: tool.name,
                description: tool.description,
                inputSchema: {
                  json: tool.inputSchema
                }
              }
            });
          }
          let bedrockToolChoice = void 0;
          if (!usingAnthropicTools && bedrockTools.length > 0 && toolChoice) {
            const type = toolChoice.type;
            switch (type) {
              case "auto":
                bedrockToolChoice = { auto: {} };
                break;
              case "required":
                bedrockToolChoice = { any: {} };
                break;
              case "none":
                bedrockTools.length = 0;
                bedrockToolChoice = void 0;
                break;
              case "tool":
                bedrockToolChoice = { tool: { name: toolChoice.toolName } };
                break;
              default: {
                const _exhaustiveCheck = type;
                throw new UnsupportedFunctionalityError$1({
                  functionality: `tool choice type: ${_exhaustiveCheck}`
                });
              }
            }
          }
          const toolConfig = bedrockTools.length > 0 ? { tools: bedrockTools, toolChoice: bedrockToolChoice } : {};
          return {
            toolConfig,
            additionalTools,
            betas,
            toolWarnings
          };
        }
        function getCachePoint(providerMetadata) {
          var _a;
          return (_a = providerMetadata == null ? void 0 : providerMetadata.bedrock) == null ? void 0 : _a.cachePoint;
        }
        async function shouldEnableCitations(providerMetadata) {
          var _a, _b;
          const bedrockOptions = await parseProviderOptions({
            provider: "bedrock",
            providerOptions: providerMetadata,
            schema: bedrockFilePartProviderOptions
          });
          return (_b = (_a = bedrockOptions == null ? void 0 : bedrockOptions.citations) == null ? void 0 : _a.enabled) != null ? _b : false;
        }
        async function convertToBedrockChatMessages(prompt) {
          var _a;
          const blocks = groupIntoBlocks(prompt);
          let system = [];
          const messages = [];
          let documentCounter = 0;
          const generateDocumentName = () => `document-${++documentCounter}`;
          for (let i = 0; i < blocks.length; i++) {
            const block = blocks[i];
            const isLastBlock = i === blocks.length - 1;
            const type = block.type;
            switch (type) {
              case "system": {
                if (messages.length > 0) {
                  throw new UnsupportedFunctionalityError$1({
                    functionality: "Multiple system messages that are separated by user/assistant messages"
                  });
                }
                for (const message of block.messages) {
                  system.push({ text: message.content });
                  if (getCachePoint(message.providerOptions)) {
                    system.push(BEDROCK_CACHE_POINT);
                  }
                }
                break;
              }
              case "user": {
                const bedrockContent = [];
                for (const message of block.messages) {
                  const { role, content, providerOptions } = message;
                  switch (role) {
                    case "user": {
                      for (let j = 0; j < content.length; j++) {
                        const part = content[j];
                        switch (part.type) {
                          case "text": {
                            bedrockContent.push({
                              text: part.text
                            });
                            break;
                          }
                          case "file": {
                            if (part.data instanceof URL) {
                              throw new UnsupportedFunctionalityError$1({
                                functionality: "File URL data"
                              });
                            }
                            if (part.mediaType.startsWith("image/")) {
                              bedrockContent.push({
                                image: {
                                  format: getBedrockImageFormat(part.mediaType),
                                  source: { bytes: convertToBase64(part.data) }
                                }
                              });
                            } else {
                              if (!part.mediaType) {
                                throw new UnsupportedFunctionalityError$1({
                                  functionality: "file without mime type",
                                  message: "File mime type is required in user message part content"
                                });
                              }
                              const enableCitations = await shouldEnableCitations(
                                part.providerOptions
                              );
                              bedrockContent.push({
                                document: {
                                  format: getBedrockDocumentFormat(part.mediaType),
                                  name: (_a = part.filename) != null ? _a : generateDocumentName(),
                                  source: { bytes: convertToBase64(part.data) },
                                  ...enableCitations && {
                                    citations: { enabled: true }
                                  }
                                }
                              });
                            }
                            break;
                          }
                        }
                      }
                      break;
                    }
                    case "tool": {
                      for (const part of content) {
                        let toolResultContent;
                        const output = part.output;
                        switch (output.type) {
                          case "content": {
                            toolResultContent = output.value.map((contentPart) => {
                              switch (contentPart.type) {
                                case "text":
                                  return { text: contentPart.text };
                                case "media":
                                  if (!contentPart.mediaType.startsWith("image/")) {
                                    throw new UnsupportedFunctionalityError$1({
                                      functionality: `media type: ${contentPart.mediaType}`
                                    });
                                  }
                                  const format = getBedrockImageFormat(
                                    contentPart.mediaType
                                  );
                                  return {
                                    image: {
                                      format,
                                      source: { bytes: contentPart.data }
                                    }
                                  };
                              }
                            });
                            break;
                          }
                          case "text":
                          case "error-text":
                            toolResultContent = [{ text: output.value }];
                            break;
                          case "json":
                          case "error-json":
                          default:
                            toolResultContent = [
                              { text: JSON.stringify(output.value) }
                            ];
                            break;
                        }
                        bedrockContent.push({
                          toolResult: {
                            toolUseId: part.toolCallId,
                            content: toolResultContent
                          }
                        });
                      }
                      break;
                    }
                    default: {
                      const _exhaustiveCheck = role;
                      throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
                    }
                  }
                  if (getCachePoint(providerOptions)) {
                    bedrockContent.push(BEDROCK_CACHE_POINT);
                  }
                }
                messages.push({ role: "user", content: bedrockContent });
                break;
              }
              case "assistant": {
                const bedrockContent = [];
                for (let j = 0; j < block.messages.length; j++) {
                  const message = block.messages[j];
                  const isLastMessage = j === block.messages.length - 1;
                  const { content } = message;
                  for (let k = 0; k < content.length; k++) {
                    const part = content[k];
                    const isLastContentPart = k === content.length - 1;
                    switch (part.type) {
                      case "text": {
                        if (!part.text.trim()) {
                          break;
                        }
                        bedrockContent.push({
                          text: (
                            // trim the last text part if it's the last message in the block
                            // because Bedrock does not allow trailing whitespace
                            // in pre-filled assistant responses
                            trimIfLast(
                              isLastBlock,
                              isLastMessage,
                              isLastContentPart,
                              part.text
                            )
                          )
                        });
                        break;
                      }
                      case "reasoning": {
                        const reasoningMetadata = await parseProviderOptions({
                          provider: "bedrock",
                          providerOptions: part.providerOptions,
                          schema: bedrockReasoningMetadataSchema
                        });
                        if (reasoningMetadata != null) {
                          if (reasoningMetadata.signature != null) {
                            bedrockContent.push({
                              reasoningContent: {
                                reasoningText: {
                                  // trim the last text part if it's the last message in the block
                                  // because Bedrock does not allow trailing whitespace
                                  // in pre-filled assistant responses
                                  text: trimIfLast(
                                    isLastBlock,
                                    isLastMessage,
                                    isLastContentPart,
                                    part.text
                                  ),
                                  signature: reasoningMetadata.signature
                                }
                              }
                            });
                          } else if (reasoningMetadata.redactedData != null) {
                            bedrockContent.push({
                              reasoningContent: {
                                redactedReasoning: {
                                  data: reasoningMetadata.redactedData
                                }
                              }
                            });
                          }
                        }
                        break;
                      }
                      case "tool-call": {
                        bedrockContent.push({
                          toolUse: {
                            toolUseId: part.toolCallId,
                            name: part.toolName,
                            input: part.input
                          }
                        });
                        break;
                      }
                    }
                  }
                  if (getCachePoint(message.providerOptions)) {
                    bedrockContent.push(BEDROCK_CACHE_POINT);
                  }
                }
                messages.push({ role: "assistant", content: bedrockContent });
                break;
              }
              default: {
                const _exhaustiveCheck = type;
                throw new Error(`Unsupported type: ${_exhaustiveCheck}`);
              }
            }
          }
          return { system, messages };
        }
        function getBedrockImageFormat(mimeType) {
          if (!mimeType) {
            throw new UnsupportedFunctionalityError$1({
              functionality: "image without mime type",
              message: "Image mime type is required in user message part content"
            });
          }
          const format = BEDROCK_IMAGE_MIME_TYPES[mimeType];
          if (!format) {
            throw new UnsupportedFunctionalityError$1({
              functionality: `image mime type: ${mimeType}`,
              message: `Unsupported image mime type: ${mimeType}, expected one of: ${Object.keys(BEDROCK_IMAGE_MIME_TYPES).join(", ")}`
            });
          }
          return format;
        }
        function getBedrockDocumentFormat(mimeType) {
          const format = BEDROCK_DOCUMENT_MIME_TYPES[mimeType];
          if (!format) {
            throw new UnsupportedFunctionalityError$1({
              functionality: `file mime type: ${mimeType}`,
              message: `Unsupported file mime type: ${mimeType}, expected one of: ${Object.keys(BEDROCK_DOCUMENT_MIME_TYPES).join(", ")}`
            });
          }
          return format;
        }
        function trimIfLast(isLastBlock, isLastMessage, isLastContentPart, text) {
          return isLastBlock && isLastMessage && isLastContentPart ? text.trim() : text;
        }
        function groupIntoBlocks(prompt) {
          const blocks = [];
          let currentBlock = void 0;
          for (const message of prompt) {
            const { role } = message;
            switch (role) {
              case "system": {
                if ((currentBlock == null ? void 0 : currentBlock.type) !== "system") {
                  currentBlock = { type: "system", messages: [] };
                  blocks.push(currentBlock);
                }
                currentBlock.messages.push(message);
                break;
              }
              case "assistant": {
                if ((currentBlock == null ? void 0 : currentBlock.type) !== "assistant") {
                  currentBlock = { type: "assistant", messages: [] };
                  blocks.push(currentBlock);
                }
                currentBlock.messages.push(message);
                break;
              }
              case "user": {
                if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
                  currentBlock = { type: "user", messages: [] };
                  blocks.push(currentBlock);
                }
                currentBlock.messages.push(message);
                break;
              }
              case "tool": {
                if ((currentBlock == null ? void 0 : currentBlock.type) !== "user") {
                  currentBlock = { type: "user", messages: [] };
                  blocks.push(currentBlock);
                }
                currentBlock.messages.push(message);
                break;
              }
              default: {
                const _exhaustiveCheck = role;
                throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
              }
            }
          }
          return blocks;
        }

        // src/map-bedrock-finish-reason.ts
        function mapBedrockFinishReason(finishReason) {
          switch (finishReason) {
            case "stop_sequence":
            case "end_turn":
              return "stop";
            case "max_tokens":
              return "length";
            case "content_filtered":
            case "guardrail_intervened":
              return "content-filter";
            case "tool_use":
              return "tool-calls";
            default:
              return "unknown";
          }
        }

        // src/bedrock-chat-language-model.ts
        var BedrockChatLanguageModel = class {
          constructor(modelId, config) {
            this.modelId = modelId;
            this.config = config;
            this.specificationVersion = "v2";
            this.provider = "amazon-bedrock";
            this.supportedUrls = {
              // no supported urls for bedrock
            };
          }
          async getArgs({
            prompt,
            maxOutputTokens,
            temperature,
            topP,
            topK,
            frequencyPenalty,
            presencePenalty,
            stopSequences,
            responseFormat,
            seed,
            tools,
            toolChoice,
            providerOptions
          }) {
            var _a, _b, _c, _d, _e, _f;
            const bedrockOptions = (_a = await parseProviderOptions({
              provider: "bedrock",
              providerOptions,
              schema: bedrockProviderOptions
            })) != null ? _a : {};
            const warnings = [];
            if (frequencyPenalty != null) {
              warnings.push({
                type: "unsupported-setting",
                setting: "frequencyPenalty"
              });
            }
            if (presencePenalty != null) {
              warnings.push({
                type: "unsupported-setting",
                setting: "presencePenalty"
              });
            }
            if (seed != null) {
              warnings.push({
                type: "unsupported-setting",
                setting: "seed"
              });
            }
            if (responseFormat != null && responseFormat.type !== "text" && responseFormat.type !== "json") {
              warnings.push({
                type: "unsupported-setting",
                setting: "responseFormat",
                details: "Only text and json response formats are supported."
              });
            }
            if (tools != null && (responseFormat == null ? void 0 : responseFormat.type) === "json") {
              if (tools.length > 0) {
                warnings.push({
                  type: "other",
                  message: "JSON response format does not support tools. The provided tools are ignored."
                });
              }
            }
            const jsonResponseTool = (responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null ? {
              type: "function",
              name: "json",
              description: "Respond with a JSON object.",
              inputSchema: responseFormat.schema
            } : void 0;
            const { toolConfig, additionalTools, toolWarnings, betas } = await prepareTools$1({
              tools: jsonResponseTool ? [jsonResponseTool, ...tools != null ? tools : []] : tools,
              toolChoice: jsonResponseTool != null ? { type: "tool", toolName: jsonResponseTool.name } : toolChoice,
              modelId: this.modelId
            });
            warnings.push(...toolWarnings);
            if (additionalTools) {
              bedrockOptions.additionalModelRequestFields = {
                ...bedrockOptions.additionalModelRequestFields,
                ...additionalTools
              };
            }
            const isThinking = ((_b = bedrockOptions.reasoningConfig) == null ? void 0 : _b.type) === "enabled";
            const thinkingBudget = (_c = bedrockOptions.reasoningConfig) == null ? void 0 : _c.budgetTokens;
            const inferenceConfig = {
              ...maxOutputTokens != null && { maxTokens: maxOutputTokens },
              ...temperature != null && { temperature },
              ...topP != null && { topP },
              ...topK != null && { topK },
              ...stopSequences != null && { stopSequences }
            };
            if (isThinking && thinkingBudget != null) {
              if (inferenceConfig.maxTokens != null) {
                inferenceConfig.maxTokens += thinkingBudget;
              } else {
                inferenceConfig.maxTokens = thinkingBudget + 4096;
              }
              bedrockOptions.additionalModelRequestFields = {
                ...bedrockOptions.additionalModelRequestFields,
                thinking: {
                  type: (_d = bedrockOptions.reasoningConfig) == null ? void 0 : _d.type,
                  budget_tokens: thinkingBudget
                }
              };
            }
            if (isThinking && inferenceConfig.temperature != null) {
              delete inferenceConfig.temperature;
              warnings.push({
                type: "unsupported-setting",
                setting: "temperature",
                details: "temperature is not supported when thinking is enabled"
              });
            }
            if (isThinking && inferenceConfig.topP != null) {
              delete inferenceConfig.topP;
              warnings.push({
                type: "unsupported-setting",
                setting: "topP",
                details: "topP is not supported when thinking is enabled"
              });
            }
            if (isThinking && inferenceConfig.topK != null) {
              delete inferenceConfig.topK;
              warnings.push({
                type: "unsupported-setting",
                setting: "topK",
                details: "topK is not supported when thinking is enabled"
              });
            }
            const hasAnyTools = ((_f = (_e = toolConfig.tools) == null ? void 0 : _e.length) != null ? _f : 0) > 0 || additionalTools;
            let filteredPrompt = prompt;
            if (!hasAnyTools) {
              const hasToolContent = prompt.some(
                (message) => "content" in message && Array.isArray(message.content) && message.content.some(
                  (part) => part.type === "tool-call" || part.type === "tool-result"
                )
              );
              if (hasToolContent) {
                filteredPrompt = prompt.map(
                  (message) => message.role === "system" ? message : {
                    ...message,
                    content: message.content.filter(
                      (part) => part.type !== "tool-call" && part.type !== "tool-result"
                    )
                  }
                ).filter(
                  (message) => message.role === "system" || message.content.length > 0
                );
                warnings.push({
                  type: "unsupported-setting",
                  setting: "toolContent",
                  details: "Tool calls and results removed from conversation because Bedrock does not support tool content without active tools."
                });
              }
            }
            const { system, messages } = await convertToBedrockChatMessages(filteredPrompt);
            const {
              reasoningConfig: _,
              additionalModelRequestFields: __,
              ...filteredBedrockOptions
            } = (providerOptions == null ? void 0 : providerOptions.bedrock) || {};
            return {
              command: {
                system,
                messages,
                additionalModelRequestFields: bedrockOptions.additionalModelRequestFields,
                ...Object.keys(inferenceConfig).length > 0 && {
                  inferenceConfig
                },
                ...filteredBedrockOptions,
                ...toolConfig.tools !== void 0 && toolConfig.tools.length > 0 ? { toolConfig } : {}
              },
              warnings,
              usesJsonResponseTool: jsonResponseTool != null,
              betas
            };
          }
          async getHeaders({
            betas,
            headers
          }) {
            return combineHeaders$1(
              await resolve(this.config.headers),
              betas.size > 0 ? { "anthropic-beta": Array.from(betas).join(",") } : {},
              headers
            );
          }
          async doGenerate(options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
            const {
              command: args,
              warnings,
              usesJsonResponseTool,
              betas
            } = await this.getArgs(options);
            const url = `${this.getUrl(this.modelId)}/converse`;
            const { value: response, responseHeaders } = await postJsonToApi$1({
              url,
              headers: await this.getHeaders({ betas, headers: options.headers }),
              body: args,
              failedResponseHandler: createJsonErrorResponseHandler$1({
                errorSchema: BedrockErrorSchema,
                errorToMessage: (error) => {
                  var _a2;
                  return `${(_a2 = error.message) != null ? _a2 : "Unknown error"}`;
                }
              }),
              successfulResponseHandler: createJsonResponseHandler$1(
                BedrockResponseSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            const content = [];
            for (const part of response.output.message.content) {
              if (part.text) {
                if (!usesJsonResponseTool) {
                  content.push({ type: "text", text: part.text });
                }
              }
              if (part.reasoningContent) {
                if ("reasoningText" in part.reasoningContent) {
                  const reasoning = {
                    type: "reasoning",
                    text: part.reasoningContent.reasoningText.text
                  };
                  if (part.reasoningContent.reasoningText.signature) {
                    reasoning.providerMetadata = {
                      bedrock: {
                        signature: part.reasoningContent.reasoningText.signature
                      }
                    };
                  }
                  content.push(reasoning);
                } else if ("redactedReasoning" in part.reasoningContent) {
                  content.push({
                    type: "reasoning",
                    text: "",
                    providerMetadata: {
                      bedrock: {
                        redactedData: (_a = part.reasoningContent.redactedReasoning.data) != null ? _a : ""
                      }
                    }
                  });
                }
              }
              if (part.toolUse) {
                content.push(
                  // when a json response tool is used, the tool call becomes the text:
                  usesJsonResponseTool ? {
                    type: "text",
                    text: JSON.stringify(part.toolUse.input)
                  } : {
                    type: "tool-call",
                    toolCallId: (_c = (_b = part.toolUse) == null ? void 0 : _b.toolUseId) != null ? _c : this.config.generateId(),
                    toolName: (_e = (_d = part.toolUse) == null ? void 0 : _d.name) != null ? _e : `tool-${this.config.generateId()}`,
                    input: JSON.stringify((_g = (_f = part.toolUse) == null ? void 0 : _f.input) != null ? _g : "")
                  }
                );
              }
            }
            const providerMetadata = response.trace || response.usage || usesJsonResponseTool ? {
              bedrock: {
                ...response.trace && typeof response.trace === "object" ? { trace: response.trace } : {},
                ...((_h = response.usage) == null ? void 0 : _h.cacheWriteInputTokens) != null && {
                  usage: {
                    cacheWriteInputTokens: response.usage.cacheWriteInputTokens
                  }
                },
                ...usesJsonResponseTool && { isJsonResponseFromTool: true }
              }
            } : void 0;
            return {
              content,
              finishReason: mapBedrockFinishReason(
                response.stopReason
              ),
              usage: {
                inputTokens: (_i = response.usage) == null ? void 0 : _i.inputTokens,
                outputTokens: (_j = response.usage) == null ? void 0 : _j.outputTokens,
                totalTokens: ((_k = response.usage) == null ? void 0 : _k.inputTokens) + ((_l = response.usage) == null ? void 0 : _l.outputTokens),
                cachedInputTokens: (_n = (_m = response.usage) == null ? void 0 : _m.cacheReadInputTokens) != null ? _n : void 0
              },
              response: {
                // TODO add id, timestamp, etc
                headers: responseHeaders
              },
              warnings,
              ...providerMetadata && { providerMetadata }
            };
          }
          async doStream(options) {
            const {
              command: args,
              warnings,
              usesJsonResponseTool,
              betas
            } = await this.getArgs(options);
            const url = `${this.getUrl(this.modelId)}/converse-stream`;
            const { value: response, responseHeaders } = await postJsonToApi$1({
              url,
              headers: await this.getHeaders({ betas, headers: options.headers }),
              body: args,
              failedResponseHandler: createJsonErrorResponseHandler$1({
                errorSchema: BedrockErrorSchema,
                errorToMessage: (error) => `${error.type}: ${error.message}`
              }),
              successfulResponseHandler: createBedrockEventStreamResponseHandler(BedrockStreamSchema),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            let finishReason = "unknown";
            const usage = {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            };
            let providerMetadata = void 0;
            const contentBlocks = {};
            return {
              stream: response.pipeThrough(
                new TransformStream({
                  start(controller) {
                    controller.enqueue({ type: "stream-start", warnings });
                  },
                  transform(chunk, controller) {
                    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
                    function enqueueError(bedrockError) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: bedrockError });
                    }
                    if (options.includeRawChunks) {
                      controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                    }
                    if (!chunk.success) {
                      enqueueError(chunk.error);
                      return;
                    }
                    const value = chunk.value;
                    if (value.internalServerException) {
                      enqueueError(value.internalServerException);
                      return;
                    }
                    if (value.modelStreamErrorException) {
                      enqueueError(value.modelStreamErrorException);
                      return;
                    }
                    if (value.throttlingException) {
                      enqueueError(value.throttlingException);
                      return;
                    }
                    if (value.validationException) {
                      enqueueError(value.validationException);
                      return;
                    }
                    if (value.messageStop) {
                      finishReason = mapBedrockFinishReason(
                        value.messageStop.stopReason
                      );
                    }
                    if (value.metadata) {
                      usage.inputTokens = (_b = (_a = value.metadata.usage) == null ? void 0 : _a.inputTokens) != null ? _b : usage.inputTokens;
                      usage.outputTokens = (_d = (_c = value.metadata.usage) == null ? void 0 : _c.outputTokens) != null ? _d : usage.outputTokens;
                      usage.totalTokens = ((_e = usage.inputTokens) != null ? _e : 0) + ((_f = usage.outputTokens) != null ? _f : 0);
                      usage.cachedInputTokens = (_h = (_g = value.metadata.usage) == null ? void 0 : _g.cacheReadInputTokens) != null ? _h : usage.cachedInputTokens;
                      const cacheUsage = ((_i = value.metadata.usage) == null ? void 0 : _i.cacheWriteInputTokens) != null ? {
                        usage: {
                          cacheWriteInputTokens: value.metadata.usage.cacheWriteInputTokens
                        }
                      } : void 0;
                      const trace = value.metadata.trace ? {
                        trace: value.metadata.trace
                      } : void 0;
                      if (cacheUsage || trace || usesJsonResponseTool) {
                        providerMetadata = {
                          bedrock: {
                            ...cacheUsage,
                            ...trace,
                            ...usesJsonResponseTool && {
                              isJsonResponseFromTool: true
                            }
                          }
                        };
                      }
                    }
                    if (((_j = value.contentBlockStart) == null ? void 0 : _j.contentBlockIndex) != null && !((_l = (_k = value.contentBlockStart) == null ? void 0 : _k.start) == null ? void 0 : _l.toolUse)) {
                      const blockIndex = value.contentBlockStart.contentBlockIndex;
                      contentBlocks[blockIndex] = { type: "text" };
                      controller.enqueue({
                        type: "text-start",
                        id: String(blockIndex)
                      });
                    }
                    if (((_m = value.contentBlockDelta) == null ? void 0 : _m.delta) && "text" in value.contentBlockDelta.delta && value.contentBlockDelta.delta.text) {
                      const blockIndex = value.contentBlockDelta.contentBlockIndex || 0;
                      if (contentBlocks[blockIndex] == null) {
                        contentBlocks[blockIndex] = { type: "text" };
                        if (!usesJsonResponseTool) {
                          controller.enqueue({
                            type: "text-start",
                            id: String(blockIndex)
                          });
                        }
                      }
                      if (!usesJsonResponseTool) {
                        controller.enqueue({
                          type: "text-delta",
                          id: String(blockIndex),
                          delta: value.contentBlockDelta.delta.text
                        });
                      }
                    }
                    if (((_n = value.contentBlockStop) == null ? void 0 : _n.contentBlockIndex) != null) {
                      const blockIndex = value.contentBlockStop.contentBlockIndex;
                      const contentBlock = contentBlocks[blockIndex];
                      if (contentBlock != null) {
                        if (contentBlock.type === "reasoning") {
                          controller.enqueue({
                            type: "reasoning-end",
                            id: String(blockIndex)
                          });
                        } else if (contentBlock.type === "text") {
                          if (!usesJsonResponseTool) {
                            controller.enqueue({
                              type: "text-end",
                              id: String(blockIndex)
                            });
                          }
                        } else if (contentBlock.type === "tool-call") {
                          if (usesJsonResponseTool) {
                            controller.enqueue({
                              type: "text-start",
                              id: String(blockIndex)
                            });
                            controller.enqueue({
                              type: "text-delta",
                              id: String(blockIndex),
                              delta: contentBlock.jsonText
                            });
                            controller.enqueue({
                              type: "text-end",
                              id: String(blockIndex)
                            });
                          } else {
                            controller.enqueue({
                              type: "tool-input-end",
                              id: contentBlock.toolCallId
                            });
                            controller.enqueue({
                              type: "tool-call",
                              toolCallId: contentBlock.toolCallId,
                              toolName: contentBlock.toolName,
                              input: contentBlock.jsonText
                            });
                          }
                        }
                        delete contentBlocks[blockIndex];
                      }
                    }
                    if (((_o = value.contentBlockDelta) == null ? void 0 : _o.delta) && "reasoningContent" in value.contentBlockDelta.delta && value.contentBlockDelta.delta.reasoningContent) {
                      const blockIndex = value.contentBlockDelta.contentBlockIndex || 0;
                      const reasoningContent = value.contentBlockDelta.delta.reasoningContent;
                      if ("text" in reasoningContent && reasoningContent.text) {
                        if (contentBlocks[blockIndex] == null) {
                          contentBlocks[blockIndex] = { type: "reasoning" };
                          controller.enqueue({
                            type: "reasoning-start",
                            id: String(blockIndex)
                          });
                        }
                        controller.enqueue({
                          type: "reasoning-delta",
                          id: String(blockIndex),
                          delta: reasoningContent.text
                        });
                      } else if ("signature" in reasoningContent && reasoningContent.signature) {
                        controller.enqueue({
                          type: "reasoning-delta",
                          id: String(blockIndex),
                          delta: "",
                          providerMetadata: {
                            bedrock: {
                              signature: reasoningContent.signature
                            }
                          }
                        });
                      } else if ("data" in reasoningContent && reasoningContent.data) {
                        controller.enqueue({
                          type: "reasoning-delta",
                          id: String(blockIndex),
                          delta: "",
                          providerMetadata: {
                            bedrock: {
                              redactedData: reasoningContent.data
                            }
                          }
                        });
                      }
                    }
                    const contentBlockStart = value.contentBlockStart;
                    if (((_p = contentBlockStart == null ? void 0 : contentBlockStart.start) == null ? void 0 : _p.toolUse) != null) {
                      const toolUse = contentBlockStart.start.toolUse;
                      const blockIndex = contentBlockStart.contentBlockIndex;
                      contentBlocks[blockIndex] = {
                        type: "tool-call",
                        toolCallId: toolUse.toolUseId,
                        toolName: toolUse.name,
                        jsonText: ""
                      };
                      if (!usesJsonResponseTool) {
                        controller.enqueue({
                          type: "tool-input-start",
                          id: toolUse.toolUseId,
                          toolName: toolUse.name
                        });
                      }
                    }
                    const contentBlockDelta = value.contentBlockDelta;
                    if ((contentBlockDelta == null ? void 0 : contentBlockDelta.delta) && "toolUse" in contentBlockDelta.delta && contentBlockDelta.delta.toolUse) {
                      const blockIndex = contentBlockDelta.contentBlockIndex;
                      const contentBlock = contentBlocks[blockIndex];
                      if ((contentBlock == null ? void 0 : contentBlock.type) === "tool-call") {
                        const delta = (_q = contentBlockDelta.delta.toolUse.input) != null ? _q : "";
                        if (!usesJsonResponseTool) {
                          controller.enqueue({
                            type: "tool-input-delta",
                            id: contentBlock.toolCallId,
                            delta
                          });
                        }
                        contentBlock.jsonText += delta;
                      }
                    }
                  },
                  flush(controller) {
                    controller.enqueue({
                      type: "finish",
                      finishReason,
                      usage,
                      ...providerMetadata && { providerMetadata }
                    });
                  }
                })
              ),
              // TODO request?
              response: { headers: responseHeaders }
            };
          }
          getUrl(modelId) {
            const encodedModelId = encodeURIComponent(modelId);
            return `${this.config.baseUrl()}/model/${encodedModelId}`;
          }
        };
        var BedrockStopReasonSchema = union([
          _enum(BEDROCK_STOP_REASONS),
          string()
        ]);
        var BedrockToolUseSchema = object({
          toolUseId: string(),
          name: string(),
          input: unknown()
        });
        var BedrockReasoningTextSchema = object({
          signature: string().nullish(),
          text: string()
        });
        var BedrockRedactedReasoningSchema = object({
          data: string()
        });
        var BedrockResponseSchema = object({
          metrics: object({
            latencyMs: number$1()
          }).nullish(),
          output: object({
            message: object({
              content: array(
                object({
                  text: string().nullish(),
                  toolUse: BedrockToolUseSchema.nullish(),
                  reasoningContent: union([
                    object({
                      reasoningText: BedrockReasoningTextSchema
                    }),
                    object({
                      redactedReasoning: BedrockRedactedReasoningSchema
                    })
                  ]).nullish()
                })
              ),
              role: string()
            })
          }),
          stopReason: BedrockStopReasonSchema,
          trace: unknown().nullish(),
          usage: object({
            inputTokens: number$1(),
            outputTokens: number$1(),
            totalTokens: number$1(),
            cacheReadInputTokens: number$1().nullish(),
            cacheWriteInputTokens: number$1().nullish()
          })
        });
        var BedrockStreamSchema = object({
          contentBlockDelta: object({
            contentBlockIndex: number$1(),
            delta: union([
              object({ text: string() }),
              object({ toolUse: object({ input: string() }) }),
              object({
                reasoningContent: object({ text: string() })
              }),
              object({
                reasoningContent: object({
                  signature: string()
                })
              }),
              object({
                reasoningContent: object({ data: string() })
              })
            ]).nullish()
          }).nullish(),
          contentBlockStart: object({
            contentBlockIndex: number$1(),
            start: object({
              toolUse: BedrockToolUseSchema.nullish()
            }).nullish()
          }).nullish(),
          contentBlockStop: object({
            contentBlockIndex: number$1()
          }).nullish(),
          internalServerException: record(string(), unknown()).nullish(),
          messageStop: object({
            additionalModelResponseFields: record(string(), unknown()).nullish(),
            stopReason: BedrockStopReasonSchema
          }).nullish(),
          metadata: object({
            trace: unknown().nullish(),
            usage: object({
              cacheReadInputTokens: number$1().nullish(),
              cacheWriteInputTokens: number$1().nullish(),
              inputTokens: number$1(),
              outputTokens: number$1()
            }).nullish()
          }).nullish(),
          modelStreamErrorException: record(string(), unknown()).nullish(),
          throttlingException: record(string(), unknown()).nullish(),
          validationException: record(string(), unknown()).nullish()
        });
        var bedrockReasoningMetadataSchema = object({
          signature: string().optional(),
          redactedData: string().optional()
        });
        var bedrockEmbeddingProviderOptions = object({
          /**
          The number of dimensions the resulting output embeddings should have (defaults to 1024).
          Only supported in amazon.titan-embed-text-v2:0.
             */
          dimensions: union([literal(1024), literal(512), literal(256)]).optional(),
          /**
          Flag indicating whether or not to normalize the output embeddings. Defaults to true
          Only supported in amazon.titan-embed-text-v2:0.
           */
          normalize: boolean().optional()
        });
        var BedrockEmbeddingModel = class {
          constructor(modelId, config) {
            this.modelId = modelId;
            this.config = config;
            this.specificationVersion = "v2";
            this.provider = "amazon-bedrock";
            this.maxEmbeddingsPerCall = 1;
            this.supportsParallelCalls = true;
          }
          getUrl(modelId) {
            const encodedModelId = encodeURIComponent(modelId);
            return `${this.config.baseUrl()}/model/${encodedModelId}/invoke`;
          }
          async doEmbed({
            values,
            headers,
            abortSignal,
            providerOptions
          }) {
            var _a;
            if (values.length > this.maxEmbeddingsPerCall) {
              throw new TooManyEmbeddingValuesForCallError({
                provider: this.provider,
                modelId: this.modelId,
                maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
                values
              });
            }
            const bedrockOptions = (_a = await parseProviderOptions({
              provider: "bedrock",
              providerOptions,
              schema: bedrockEmbeddingProviderOptions
            })) != null ? _a : {};
            const args = {
              inputText: values[0],
              dimensions: bedrockOptions.dimensions,
              normalize: bedrockOptions.normalize
            };
            const url = this.getUrl(this.modelId);
            const { value: response } = await postJsonToApi$1({
              url,
              headers: await resolve(
                combineHeaders$1(await resolve(this.config.headers), headers)
              ),
              body: args,
              failedResponseHandler: createJsonErrorResponseHandler$1({
                errorSchema: BedrockErrorSchema,
                errorToMessage: (error) => `${error.type}: ${error.message}`
              }),
              successfulResponseHandler: createJsonResponseHandler$1(
                BedrockEmbeddingResponseSchema
              ),
              fetch: this.config.fetch,
              abortSignal
            });
            return {
              embeddings: [response.embedding],
              usage: { tokens: response.inputTextTokenCount }
            };
          }
        };
        var BedrockEmbeddingResponseSchema = object({
          embedding: array(number$1()),
          inputTextTokenCount: number$1()
        });

        // src/bedrock-image-settings.ts
        var modelMaxImagesPerCall = {
          "amazon.nova-canvas-v1:0": 5
        };
        var BedrockImageModel = class {
          constructor(modelId, config) {
            this.modelId = modelId;
            this.config = config;
            this.specificationVersion = "v2";
            this.provider = "amazon-bedrock";
          }
          get maxImagesPerCall() {
            var _a;
            return (_a = modelMaxImagesPerCall[this.modelId]) != null ? _a : 1;
          }
          getUrl(modelId) {
            const encodedModelId = encodeURIComponent(modelId);
            return `${this.config.baseUrl()}/model/${encodedModelId}/invoke`;
          }
          async doGenerate({
            prompt,
            n,
            size,
            aspectRatio,
            seed,
            providerOptions,
            headers,
            abortSignal
          }) {
            var _a, _b, _c, _d, _e, _f, _g;
            const warnings = [];
            const [width, height] = size ? size.split("x").map(Number) : [];
            const args = {
              taskType: "TEXT_IMAGE",
              textToImageParams: {
                text: prompt,
                ...((_a = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _a.negativeText) ? {
                  negativeText: providerOptions.bedrock.negativeText
                } : {},
                ...((_b = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _b.style) ? {
                  style: providerOptions.bedrock.style
                } : {}
              },
              imageGenerationConfig: {
                ...width ? { width } : {},
                ...height ? { height } : {},
                ...seed ? { seed } : {},
                ...n ? { numberOfImages: n } : {},
                ...((_c = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _c.quality) ? { quality: providerOptions.bedrock.quality } : {},
                ...((_d = providerOptions == null ? void 0 : providerOptions.bedrock) == null ? void 0 : _d.cfgScale) ? { cfgScale: providerOptions.bedrock.cfgScale } : {}
              }
            };
            if (aspectRatio != void 0) {
              warnings.push({
                type: "unsupported-setting",
                setting: "aspectRatio",
                details: "This model does not support aspect ratio. Use `size` instead."
              });
            }
            const currentDate = (_g = (_f = (_e = this.config._internal) == null ? void 0 : _e.currentDate) == null ? void 0 : _f.call(_e)) != null ? _g : /* @__PURE__ */ new Date();
            const { value: response, responseHeaders } = await postJsonToApi$1({
              url: this.getUrl(this.modelId),
              headers: await resolve(
                combineHeaders$1(await resolve(this.config.headers), headers)
              ),
              body: args,
              failedResponseHandler: createJsonErrorResponseHandler$1({
                errorSchema: BedrockErrorSchema,
                errorToMessage: (error) => `${error.type}: ${error.message}`
              }),
              successfulResponseHandler: createJsonResponseHandler$1(
                bedrockImageResponseSchema
              ),
              abortSignal,
              fetch: this.config.fetch
            });
            return {
              images: response.images,
              warnings,
              response: {
                timestamp: currentDate,
                modelId: this.modelId,
                headers: responseHeaders
              }
            };
          }
        };
        var bedrockImageResponseSchema = object({
          images: array(string())
        });

        // src/headers-utils.ts
        function extractHeaders(headers) {
          let originalHeaders = {};
          if (headers) {
            if (headers instanceof Headers) {
              originalHeaders = convertHeadersToRecord(headers);
            } else if (Array.isArray(headers)) {
              for (const [k, v] of headers) {
                originalHeaders[k.toLowerCase()] = v;
              }
            } else {
              originalHeaders = Object.fromEntries(
                Object.entries(headers).map(([k, v]) => [k.toLowerCase(), v])
              );
            }
          }
          return originalHeaders;
        }
        function convertHeadersToRecord(headers) {
          return Object.fromEntries([...headers]);
        }
        function createSigV4FetchFunction(getCredentials, fetch = globalThis.fetch) {
          return async (input, init) => {
            var _a, _b;
            const request = input instanceof Request ? input : void 0;
            const originalHeaders = combineHeaders$1(
              extractHeaders(request == null ? void 0 : request.headers),
              extractHeaders(init == null ? void 0 : init.headers)
            );
            const headersWithUserAgent = withUserAgentSuffix(
              originalHeaders,
              `ai-sdk/amazon-bedrock/${VERSION$1}`,
              getRuntimeEnvironmentUserAgent()
            );
            let effectiveBody = (_a = init == null ? void 0 : init.body) != null ? _a : void 0;
            if (effectiveBody === void 0 && request && request.body !== null) {
              try {
                effectiveBody = await request.clone().text();
              } catch (e) {
              }
            }
            const effectiveMethod = (_b = init == null ? void 0 : init.method) != null ? _b : request == null ? void 0 : request.method;
            if ((effectiveMethod == null ? void 0 : effectiveMethod.toUpperCase()) !== "POST" || !effectiveBody) {
              return fetch(input, {
                ...init,
                headers: headersWithUserAgent
              });
            }
            const url = typeof input === "string" ? input : input instanceof URL ? input.href : input.url;
            const body = prepareBodyString(effectiveBody);
            const credentials = await getCredentials();
            const signer = new AwsV4Signer({
              url,
              method: "POST",
              headers: Object.entries(headersWithUserAgent),
              body,
              region: credentials.region,
              accessKeyId: credentials.accessKeyId,
              secretAccessKey: credentials.secretAccessKey,
              sessionToken: credentials.sessionToken,
              service: "bedrock"
            });
            const signingResult = await signer.sign();
            const signedHeaders = convertHeadersToRecord(signingResult.headers);
            const combinedHeaders = combineHeaders$1(headersWithUserAgent, signedHeaders);
            return fetch(input, {
              ...init,
              body,
              headers: combinedHeaders
            });
          };
        }
        function prepareBodyString(body) {
          if (typeof body === "string") {
            return body;
          } else if (body instanceof Uint8Array) {
            return new TextDecoder().decode(body);
          } else if (body instanceof ArrayBuffer) {
            return new TextDecoder().decode(new Uint8Array(body));
          } else {
            return JSON.stringify(body);
          }
        }
        function createApiKeyFetchFunction(apiKey, fetch = globalThis.fetch) {
          return async (input, init) => {
            const originalHeaders = extractHeaders(init == null ? void 0 : init.headers);
            const headersWithUserAgent = withUserAgentSuffix(
              originalHeaders,
              `ai-sdk/amazon-bedrock/${VERSION$1}`,
              getRuntimeEnvironmentUserAgent()
            );
            const finalHeaders = combineHeaders$1(headersWithUserAgent, {
              Authorization: `Bearer ${apiKey}`
            });
            return fetch(input, {
              ...init,
              headers: finalHeaders
            });
          };
        }

        // src/bedrock-provider.ts
        function createAmazonBedrock(options = {}) {
          const rawApiKey = loadOptionalSetting({
            settingValue: options.apiKey,
            environmentVariableName: "AWS_BEARER_TOKEN_BEDROCK"
          });
          const apiKey = rawApiKey && rawApiKey.trim().length > 0 ? rawApiKey.trim() : void 0;
          const fetchFunction = apiKey ? createApiKeyFetchFunction(apiKey, options.fetch) : createSigV4FetchFunction(async () => {
            const region = loadSetting({
              settingValue: options.region,
              settingName: "region",
              environmentVariableName: "AWS_REGION",
              description: "AWS region"
            });
            if (options.credentialProvider) {
              try {
                return {
                  ...await options.credentialProvider(),
                  region
                };
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                throw new Error(
                  `AWS credential provider failed: ${errorMessage}. Please ensure your credential provider returns valid AWS credentials with accessKeyId and secretAccessKey properties.`
                );
              }
            }
            try {
              return {
                region,
                accessKeyId: loadSetting({
                  settingValue: options.accessKeyId,
                  settingName: "accessKeyId",
                  environmentVariableName: "AWS_ACCESS_KEY_ID",
                  description: "AWS access key ID"
                }),
                secretAccessKey: loadSetting({
                  settingValue: options.secretAccessKey,
                  settingName: "secretAccessKey",
                  environmentVariableName: "AWS_SECRET_ACCESS_KEY",
                  description: "AWS secret access key"
                }),
                sessionToken: loadOptionalSetting({
                  settingValue: options.sessionToken,
                  environmentVariableName: "AWS_SESSION_TOKEN"
                })
              };
            } catch (error) {
              const errorMessage = error instanceof Error ? error.message : String(error);
              if (errorMessage.includes("AWS_ACCESS_KEY_ID") || errorMessage.includes("accessKeyId")) {
                throw new Error(
                  `AWS SigV4 authentication requires AWS credentials. Please provide either:
1. Set AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables
2. Provide accessKeyId and secretAccessKey in options
3. Use a credentialProvider function
4. Use API key authentication with AWS_BEARER_TOKEN_BEDROCK or apiKey option
Original error: ${errorMessage}`
                );
              }
              if (errorMessage.includes("AWS_SECRET_ACCESS_KEY") || errorMessage.includes("secretAccessKey")) {
                throw new Error(
                  `AWS SigV4 authentication requires both AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY. Please ensure both credentials are provided.
Original error: ${errorMessage}`
                );
              }
              throw error;
            }
          }, options.fetch);
          const getBaseUrl = () => {
            var _a, _b;
            return (_b = withoutTrailingSlash$1(
              (_a = options.baseURL) != null ? _a : `https://bedrock-runtime.${loadSetting({
                settingValue: options.region,
                settingName: "region",
                environmentVariableName: "AWS_REGION",
                description: "AWS region"
              })}.amazonaws.com`
            )) != null ? _b : `https://bedrock-runtime.us-east-1.amazonaws.com`;
          };
          const getHeaders = () => {
            var _a;
            const baseHeaders = (_a = options.headers) != null ? _a : {};
            return withUserAgentSuffix(baseHeaders, `ai-sdk/amazon-bedrock/${VERSION$1}`);
          };
          const createChatModel = (modelId) => new BedrockChatLanguageModel(modelId, {
            baseUrl: getBaseUrl,
            headers: getHeaders,
            fetch: fetchFunction,
            generateId: generateId$1
          });
          const provider = function (modelId) {
            if (new.target) {
              throw new Error(
                "The Amazon Bedrock model function cannot be called with the new keyword."
              );
            }
            return createChatModel(modelId);
          };
          const createEmbeddingModel = (modelId) => new BedrockEmbeddingModel(modelId, {
            baseUrl: getBaseUrl,
            headers: getHeaders,
            fetch: fetchFunction
          });
          const createImageModel = (modelId) => new BedrockImageModel(modelId, {
            baseUrl: getBaseUrl,
            headers: getHeaders,
            fetch: fetchFunction
          });
          provider.languageModel = createChatModel;
          provider.embedding = createEmbeddingModel;
          provider.textEmbedding = createEmbeddingModel;
          provider.textEmbeddingModel = createEmbeddingModel;
          provider.image = createImageModel;
          provider.imageModel = createImageModel;
          provider.tools = anthropicTools;
          return provider;
        }
        createAmazonBedrock();

        var __defProp = Object.defineProperty;
        var __defProps = Object.defineProperties;
        var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
        var __getOwnPropSymbols = Object.getOwnPropertySymbols;
        var __hasOwnProp = Object.prototype.hasOwnProperty;
        var __propIsEnum = Object.prototype.propertyIsEnumerable;
        var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
        var __spreadValues = (a, b) => {
          for (var prop in b || (b = {}))
            if (__hasOwnProp.call(b, prop))
              __defNormalProp(a, prop, b[prop]);
          if (__getOwnPropSymbols)
            for (var prop of __getOwnPropSymbols(b)) {
              if (__propIsEnum.call(b, prop))
                __defNormalProp(a, prop, b[prop]);
            }
          return a;
        };
        var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));

        // node_modules/.pnpm/@ai-sdk+provider@2.0.0/node_modules/@ai-sdk/provider/dist/index.mjs
        var marker = "vercel.ai.error";
        var symbol = Symbol.for(marker);
        var _a;
        var _AISDKError = class _AISDKError2 extends Error {
          /**
           * Creates an AI SDK Error.
           *
           * @param {Object} params - The parameters for creating the error.
           * @param {string} params.name - The name of the error.
           * @param {string} params.message - The error message.
           * @param {unknown} [params.cause] - The underlying cause of the error.
           */
          constructor({
            name: name14,
            message,
            cause
          }) {
            super(message);
            this[_a] = true;
            this.name = name14;
            this.cause = cause;
          }
          /**
           * Checks if the given error is an AI SDK Error.
           * @param {unknown} error - The error to check.
           * @returns {boolean} True if the error is an AI SDK Error, false otherwise.
           */
          static isInstance(error) {
            return _AISDKError2.hasMarker(error, marker);
          }
          static hasMarker(error, marker15) {
            const markerSymbol = Symbol.for(marker15);
            return error != null && typeof error === "object" && markerSymbol in error && typeof error[markerSymbol] === "boolean" && error[markerSymbol] === true;
          }
        };
        _a = symbol;
        var AISDKError = _AISDKError;
        var name = "AI_APICallError";
        var marker2 = `vercel.ai.error.${name}`;
        var symbol2 = Symbol.for(marker2);
        var _a2;
        var APICallError = class extends AISDKError {
          constructor({
            message,
            url,
            requestBodyValues,
            statusCode,
            responseHeaders,
            responseBody,
            cause,
            isRetryable = statusCode != null && (statusCode === 408 || // request timeout
              statusCode === 409 || // conflict
              statusCode === 429 || // too many requests
              statusCode >= 500),
            // server error
            data
          }) {
            super({ name, message, cause });
            this[_a2] = true;
            this.url = url;
            this.requestBodyValues = requestBodyValues;
            this.statusCode = statusCode;
            this.responseHeaders = responseHeaders;
            this.responseBody = responseBody;
            this.isRetryable = isRetryable;
            this.data = data;
          }
          static isInstance(error) {
            return AISDKError.hasMarker(error, marker2);
          }
        };
        _a2 = symbol2;
        var name2 = "AI_EmptyResponseBodyError";
        var marker3 = `vercel.ai.error.${name2}`;
        var symbol3 = Symbol.for(marker3);
        var _a3;
        var EmptyResponseBodyError = class extends AISDKError {
          // used in isInstance
          constructor({ message = "Empty response body" } = {}) {
            super({ name: name2, message });
            this[_a3] = true;
          }
          static isInstance(error) {
            return AISDKError.hasMarker(error, marker3);
          }
        };
        _a3 = symbol3;
        function getErrorMessage(error) {
          if (error == null) {
            return "unknown error";
          }
          if (typeof error === "string") {
            return error;
          }
          if (error instanceof Error) {
            return error.message;
          }
          return JSON.stringify(error);
        }
        var name3 = "AI_InvalidArgumentError";
        var marker4 = `vercel.ai.error.${name3}`;
        var symbol4 = Symbol.for(marker4);
        var _a4;
        var InvalidArgumentError = class extends AISDKError {
          constructor({
            message,
            cause,
            argument
          }) {
            super({ name: name3, message, cause });
            this[_a4] = true;
            this.argument = argument;
          }
          static isInstance(error) {
            return AISDKError.hasMarker(error, marker4);
          }
        };
        _a4 = symbol4;
        var name4 = "AI_InvalidPromptError";
        var marker5 = `vercel.ai.error.${name4}`;
        var symbol5 = Symbol.for(marker5);
        var _a5;
        var InvalidPromptError = class extends AISDKError {
          constructor({
            prompt,
            message,
            cause
          }) {
            super({ name: name4, message: `Invalid prompt: ${message}`, cause });
            this[_a5] = true;
            this.prompt = prompt;
          }
          static isInstance(error) {
            return AISDKError.hasMarker(error, marker5);
          }
        };
        _a5 = symbol5;
        var name5 = "AI_InvalidResponseDataError";
        var marker6 = `vercel.ai.error.${name5}`;
        var symbol6 = Symbol.for(marker6);
        var _a6;
        var InvalidResponseDataError = class extends AISDKError {
          constructor({
            data,
            message = `Invalid response data: ${JSON.stringify(data)}.`
          }) {
            super({ name: name5, message });
            this[_a6] = true;
            this.data = data;
          }
          static isInstance(error) {
            return AISDKError.hasMarker(error, marker6);
          }
        };
        _a6 = symbol6;
        var name6 = "AI_JSONParseError";
        var marker7 = `vercel.ai.error.${name6}`;
        var symbol7 = Symbol.for(marker7);
        var _a7;
        var JSONParseError = class extends AISDKError {
          constructor({ text, cause }) {
            super({
              name: name6,
              message: `JSON parsing failed: Text: ${text}.
Error message: ${getErrorMessage(cause)}`,
              cause
            });
            this[_a7] = true;
            this.text = text;
          }
          static isInstance(error) {
            return AISDKError.hasMarker(error, marker7);
          }
        };
        _a7 = symbol7;
        var name7 = "AI_LoadAPIKeyError";
        var marker8 = `vercel.ai.error.${name7}`;
        var symbol8 = Symbol.for(marker8);
        var _a8;
        var LoadAPIKeyError = class extends AISDKError {
          // used in isInstance
          constructor({ message }) {
            super({ name: name7, message });
            this[_a8] = true;
          }
          static isInstance(error) {
            return AISDKError.hasMarker(error, marker8);
          }
        };
        _a8 = symbol8;
        var name12 = "AI_TypeValidationError";
        var marker13 = `vercel.ai.error.${name12}`;
        var symbol13 = Symbol.for(marker13);
        var _a13;
        var _TypeValidationError = class _TypeValidationError2 extends AISDKError {
          constructor({ value, cause }) {
            super({
              name: name12,
              message: `Type validation failed: Value: ${JSON.stringify(value)}.
Error message: ${getErrorMessage(cause)}`,
              cause
            });
            this[_a13] = true;
            this.value = value;
          }
          static isInstance(error) {
            return AISDKError.hasMarker(error, marker13);
          }
          /**
           * Wraps an error into a TypeValidationError.
           * If the cause is already a TypeValidationError with the same value, it returns the cause.
           * Otherwise, it creates a new TypeValidationError.
           *
           * @param {Object} params - The parameters for wrapping the error.
           * @param {unknown} params.value - The value that failed validation.
           * @param {unknown} params.cause - The original error or cause of the validation failure.
           * @returns {TypeValidationError} A TypeValidationError instance.
           */
          static wrap({
            value,
            cause
          }) {
            return _TypeValidationError2.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError2({ value, cause });
          }
        };
        _a13 = symbol13;
        var TypeValidationError = _TypeValidationError;
        var name13 = "AI_UnsupportedFunctionalityError";
        var marker14 = `vercel.ai.error.${name13}`;
        var symbol14 = Symbol.for(marker14);
        var _a14;
        var UnsupportedFunctionalityError = class extends AISDKError {
          constructor({
            functionality,
            message = `'${functionality}' functionality not supported.`
          }) {
            super({ name: name13, message });
            this[_a14] = true;
            this.functionality = functionality;
          }
          static isInstance(error) {
            return AISDKError.hasMarker(error, marker14);
          }
        };
        _a14 = symbol14;

        // node_modules/.pnpm/eventsource-parser@3.0.3/node_modules/eventsource-parser/dist/index.js
        var ParseError = class extends Error {
          constructor(message, options) {
            super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
          }
        };
        function noop(_arg) {
        }
        function createParser(callbacks) {
          if (typeof callbacks == "function")
            throw new TypeError(
              "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
            );
          const { onEvent = noop, onError = noop, onRetry = noop, onComment } = callbacks;
          let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
          function feed(newChunk) {
            const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
            for (const line of complete)
              parseLine(line);
            incompleteLine = incomplete, isFirstChunk = false;
          }
          function parseLine(line) {
            if (line === "") {
              dispatchEvent();
              return;
            }
            if (line.startsWith(":")) {
              onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
              return;
            }
            const fieldSeparatorIndex = line.indexOf(":");
            if (fieldSeparatorIndex !== -1) {
              const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
              processField(field, value, line);
              return;
            }
            processField(line, "", line);
          }
          function processField(field, value, line) {
            switch (field) {
              case "event":
                eventType = value;
                break;
              case "data":
                data = `${data}${value}
`;
                break;
              case "id":
                id = value.includes("\0") ? void 0 : value;
                break;
              case "retry":
                /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
                  new ParseError(`Invalid \`retry\` value: "${value}"`, {
                    type: "invalid-retry",
                    value,
                    line
                  })
                );
                break;
              default:
                onError(
                  new ParseError(
                    `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}\u2026` : field}"`,
                    { type: "unknown-field", field, value, line }
                  )
                );
                break;
            }
          }
          function dispatchEvent() {
            data.length > 0 && onEvent({
              id,
              event: eventType || void 0,
              // If the data buffer's last character is a U+000A LINE FEED (LF) character,
              // then remove the last character from the data buffer.
              data: data.endsWith(`
`) ? data.slice(0, -1) : data
            }), id = void 0, data = "", eventType = "";
          }
          function reset(options = {}) {
            incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
          }
          return { feed, reset };
        }
        function splitLines(chunk) {
          const lines = [];
          let incompleteLine = "", searchIndex = 0;
          for (; searchIndex < chunk.length;) {
            const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
            let lineEnd = -1;
            if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
              incompleteLine = chunk.slice(searchIndex);
              break;
            } else {
              const line = chunk.slice(searchIndex, lineEnd);
              lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
            }
          }
          return [lines, incompleteLine];
        }

        // node_modules/.pnpm/eventsource-parser@3.0.3/node_modules/eventsource-parser/dist/stream.js
        var EventSourceParserStream = class extends TransformStream {
          constructor({ onError, onRetry, onComment } = {}) {
            let parser;
            super({
              start(controller) {
                parser = createParser({
                  onEvent: (event) => {
                    controller.enqueue(event);
                  },
                  onError(error) {
                    onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
                  },
                  onRetry,
                  onComment
                });
              },
              transform(chunk) {
                parser.feed(chunk);
              }
            });
          }
        };

        // node_modules/.pnpm/zod-to-json-schema@3.24.6_zod@3.25.76/node_modules/zod-to-json-schema/dist/esm/parsers/string.js
        new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

        // node_modules/.pnpm/@ai-sdk+provider-utils@3.0.1_zod@3.25.76/node_modules/@ai-sdk/provider-utils/dist/index.mjs
        function combineHeaders(...headers) {
          return headers.reduce(
            (combinedHeaders, currentHeaders) => __spreadValues(__spreadValues({}, combinedHeaders), currentHeaders != null ? currentHeaders : {}),
            {}
          );
        }
        function extractResponseHeaders(response) {
          return Object.fromEntries([...response.headers]);
        }
        var createIdGenerator = ({
          prefix,
          size = 16,
          alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
          separator = "-"
        } = {}) => {
          const generator = () => {
            const alphabetLength = alphabet.length;
            const chars = new Array(size);
            for (let i = 0; i < size; i++) {
              chars[i] = alphabet[Math.random() * alphabetLength | 0];
            }
            return chars.join("");
          };
          if (prefix == null) {
            return generator;
          }
          if (alphabet.includes(separator)) {
            throw new InvalidArgumentError({
              argument: "separator",
              message: `The separator "${separator}" must not be part of the alphabet "${alphabet}".`
            });
          }
          return () => `${prefix}${separator}${generator()}`;
        };
        var generateId = createIdGenerator();
        function isAbortError(error) {
          return (error instanceof Error || error instanceof DOMException) && (error.name === "AbortError" || error.name === "ResponseAborted" || // Next.js
            error.name === "TimeoutError");
        }
        var FETCH_FAILED_ERROR_MESSAGES = ["fetch failed", "failed to fetch"];
        function handleFetchError({
          error,
          url,
          requestBodyValues
        }) {
          if (isAbortError(error)) {
            return error;
          }
          if (error instanceof TypeError && FETCH_FAILED_ERROR_MESSAGES.includes(error.message.toLowerCase())) {
            const cause = error.cause;
            if (cause != null) {
              return new APICallError({
                message: `Cannot connect to API: ${cause.message}`,
                cause,
                url,
                requestBodyValues,
                isRetryable: true
                // retry when network error
              });
            }
          }
          return error;
        }
        function removeUndefinedEntries(record) {
          return Object.fromEntries(
            Object.entries(record).filter(([_key, value]) => value != null)
          );
        }
        function loadApiKey({
          apiKey,
          environmentVariableName,
          apiKeyParameterName = "apiKey",
          description
        }) {
          if (typeof apiKey === "string") {
            return apiKey;
          }
          if (apiKey != null) {
            throw new LoadAPIKeyError({
              message: `${description} API key must be a string.`
            });
          }
          if (typeof process === "undefined") {
            throw new LoadAPIKeyError({
              message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`
            });
          }
          apiKey = process.env[environmentVariableName];
          if (apiKey == null) {
            throw new LoadAPIKeyError({
              message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`
            });
          }
          if (typeof apiKey !== "string") {
            throw new LoadAPIKeyError({
              message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`
            });
          }
          return apiKey;
        }
        var suspectProtoRx = /"__proto__"\s*:/;
        var suspectConstructorRx = /"constructor"\s*:/;
        function _parse(text) {
          const obj = JSON.parse(text);
          if (obj === null || typeof obj !== "object") {
            return obj;
          }
          if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
            return obj;
          }
          return filter(obj);
        }
        function filter(obj) {
          let next = [obj];
          while (next.length) {
            const nodes = next;
            next = [];
            for (const node of nodes) {
              if (Object.prototype.hasOwnProperty.call(node, "__proto__")) {
                throw new SyntaxError("Object contains forbidden prototype property");
              }
              if (Object.prototype.hasOwnProperty.call(node, "constructor") && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
                throw new SyntaxError("Object contains forbidden prototype property");
              }
              for (const key in node) {
                const value = node[key];
                if (value && typeof value === "object") {
                  next.push(value);
                }
              }
            }
          }
          return obj;
        }
        function secureJsonParse(text) {
          const { stackTraceLimit } = Error;
          Error.stackTraceLimit = 0;
          try {
            return _parse(text);
          } finally {
            Error.stackTraceLimit = stackTraceLimit;
          }
        }
        var validatorSymbol = Symbol.for("vercel.ai.validator");
        function validator(validate) {
          return { [validatorSymbol]: true, validate };
        }
        function isValidator(value) {
          return typeof value === "object" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && "validate" in value;
        }
        function asValidator(value) {
          return isValidator(value) ? value : standardSchemaValidator(value);
        }
        function standardSchemaValidator(standardSchema) {
          return validator(async (value) => {
            const result = await standardSchema["~standard"].validate(value);
            return result.issues == null ? { success: true, value: result.value } : {
              success: false,
              error: new TypeValidationError({
                value,
                cause: result.issues
              })
            };
          });
        }
        async function validateTypes({
          value,
          schema
        }) {
          const result = await safeValidateTypes({ value, schema });
          if (!result.success) {
            throw TypeValidationError.wrap({ value, cause: result.error });
          }
          return result.value;
        }
        async function safeValidateTypes({
          value,
          schema
        }) {
          const validator2 = asValidator(schema);
          try {
            if (validator2.validate == null) {
              return { success: true, value, rawValue: value };
            }
            const result = await validator2.validate(value);
            if (result.success) {
              return { success: true, value: result.value, rawValue: value };
            }
            return {
              success: false,
              error: TypeValidationError.wrap({ value, cause: result.error }),
              rawValue: value
            };
          } catch (error) {
            return {
              success: false,
              error: TypeValidationError.wrap({ value, cause: error }),
              rawValue: value
            };
          }
        }
        async function parseJSON({
          text,
          schema
        }) {
          try {
            const value = secureJsonParse(text);
            if (schema == null) {
              return value;
            }
            return validateTypes({ value, schema });
          } catch (error) {
            if (JSONParseError.isInstance(error) || TypeValidationError.isInstance(error)) {
              throw error;
            }
            throw new JSONParseError({ text, cause: error });
          }
        }
        async function safeParseJSON({
          text,
          schema
        }) {
          try {
            const value = secureJsonParse(text);
            if (schema == null) {
              return { success: true, value, rawValue: value };
            }
            return await safeValidateTypes({ value, schema });
          } catch (error) {
            return {
              success: false,
              error: JSONParseError.isInstance(error) ? error : new JSONParseError({ text, cause: error }),
              rawValue: void 0
            };
          }
        }
        function isParsableJson(input) {
          try {
            secureJsonParse(input);
            return true;
          } catch (e) {
            return false;
          }
        }
        function parseJsonEventStream({
          stream,
          schema
        }) {
          return stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream()).pipeThrough(
            new TransformStream({
              async transform({ data }, controller) {
                if (data === "[DONE]") {
                  return;
                }
                controller.enqueue(await safeParseJSON({ text: data, schema }));
              }
            })
          );
        }
        var getOriginalFetch2 = () => globalThis.fetch;
        var postJsonToApi = async ({
          url,
          headers,
          body,
          failedResponseHandler,
          successfulResponseHandler,
          abortSignal,
          fetch
        }) => postToApi({
          url,
          headers: __spreadValues({
            "Content-Type": "application/json"
          }, headers),
          body: {
            content: JSON.stringify(body),
            values: body
          },
          failedResponseHandler,
          successfulResponseHandler,
          abortSignal,
          fetch
        });
        var postToApi = async ({
          url,
          headers = {},
          body,
          successfulResponseHandler,
          failedResponseHandler,
          abortSignal,
          fetch = getOriginalFetch2()
        }) => {
          try {
            const response = await fetch(url, {
              method: "POST",
              headers: removeUndefinedEntries(headers),
              body: body.content,
              signal: abortSignal
            });
            const responseHeaders = extractResponseHeaders(response);
            if (!response.ok) {
              let errorInformation;
              try {
                errorInformation = await failedResponseHandler({
                  response,
                  url,
                  requestBodyValues: body.values
                });
              } catch (error) {
                if (isAbortError(error) || APICallError.isInstance(error)) {
                  throw error;
                }
                throw new APICallError({
                  message: "Failed to process error response",
                  cause: error,
                  statusCode: response.status,
                  url,
                  responseHeaders,
                  requestBodyValues: body.values
                });
              }
              throw errorInformation.value;
            }
            try {
              return await successfulResponseHandler({
                response,
                url,
                requestBodyValues: body.values
              });
            } catch (error) {
              if (error instanceof Error) {
                if (isAbortError(error) || APICallError.isInstance(error)) {
                  throw error;
                }
              }
              throw new APICallError({
                message: "Failed to process successful response",
                cause: error,
                statusCode: response.status,
                url,
                responseHeaders,
                requestBodyValues: body.values
              });
            }
          } catch (error) {
            throw handleFetchError({ error, url, requestBodyValues: body.values });
          }
        };
        var createJsonErrorResponseHandler = ({
          errorSchema,
          errorToMessage,
          isRetryable
        }) => async ({ response, url, requestBodyValues }) => {
          const responseBody = await response.text();
          const responseHeaders = extractResponseHeaders(response);
          if (responseBody.trim() === "") {
            return {
              responseHeaders,
              value: new APICallError({
                message: response.statusText,
                url,
                requestBodyValues,
                statusCode: response.status,
                responseHeaders,
                responseBody,
                isRetryable: isRetryable == null ? void 0 : isRetryable(response)
              })
            };
          }
          try {
            const parsedError = await parseJSON({
              text: responseBody,
              schema: errorSchema
            });
            return {
              responseHeaders,
              value: new APICallError({
                message: errorToMessage(parsedError),
                url,
                requestBodyValues,
                statusCode: response.status,
                responseHeaders,
                responseBody,
                data: parsedError,
                isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)
              })
            };
          } catch (parseError) {
            return {
              responseHeaders,
              value: new APICallError({
                message: response.statusText,
                url,
                requestBodyValues,
                statusCode: response.status,
                responseHeaders,
                responseBody,
                isRetryable: isRetryable == null ? void 0 : isRetryable(response)
              })
            };
          }
        };
        var createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {
          const responseHeaders = extractResponseHeaders(response);
          if (response.body == null) {
            throw new EmptyResponseBodyError({});
          }
          return {
            responseHeaders,
            value: parseJsonEventStream({
              stream: response.body,
              schema: chunkSchema
            })
          };
        };
        var createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {
          const responseBody = await response.text();
          const parsedResult = await safeParseJSON({
            text: responseBody,
            schema: responseSchema
          });
          const responseHeaders = extractResponseHeaders(response);
          if (!parsedResult.success) {
            throw new APICallError({
              message: "Invalid JSON response",
              cause: parsedResult.error,
              statusCode: response.status,
              responseHeaders,
              responseBody,
              url,
              requestBodyValues
            });
          }
          return {
            responseHeaders,
            value: parsedResult.value,
            rawValue: parsedResult.rawValue
          };
        };
        var { btoa } = globalThis;
        function convertUint8ArrayToBase64(array) {
          let latin1string = "";
          for (let i = 0; i < array.length; i++) {
            latin1string += String.fromCodePoint(array[i]);
          }
          return btoa(latin1string);
        }
        function withoutTrailingSlash(url) {
          return url == null ? void 0 : url.replace(/\/$/, "");
        }
        var ReasoningDetailSummarySchema = object({
          type: literal("reasoning.summary" /* Summary */),
          summary: string()
        });
        var ReasoningDetailEncryptedSchema = object({
          type: literal("reasoning.encrypted" /* Encrypted */),
          data: string()
        });
        var ReasoningDetailTextSchema = object({
          type: literal("reasoning.text" /* Text */),
          text: string().nullish(),
          signature: string().nullish()
        });
        var ReasoningDetailUnionSchema = union([
          ReasoningDetailSummarySchema,
          ReasoningDetailEncryptedSchema,
          ReasoningDetailTextSchema
        ]);
        var ReasoningDetailsWithUnknownSchema = union([
          ReasoningDetailUnionSchema,
          unknown().transform(() => null)
        ]);
        var ReasoningDetailArraySchema = array(ReasoningDetailsWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));
        var OpenRouterErrorResponseSchema = object({
          error: object({
            code: union([string(), number$1()]).nullable().optional().default(null),
            message: string(),
            type: string().nullable().optional().default(null),
            param: any().nullable().optional().default(null)
          })
        });
        var openrouterFailedResponseHandler = createJsonErrorResponseHandler({
          errorSchema: OpenRouterErrorResponseSchema,
          errorToMessage: (data) => data.error.message
        });

        // src/utils/map-finish-reason.ts
        function mapOpenRouterFinishReason(finishReason) {
          switch (finishReason) {
            case "stop":
              return "stop";
            case "length":
              return "length";
            case "content_filter":
              return "content-filter";
            case "function_call":
            case "tool_calls":
              return "tool-calls";
            default:
              return "unknown";
          }
        }

        // src/chat/is-url.ts
        function isUrl({
          url,
          protocols
        }) {
          try {
            const urlObj = new URL(url);
            return protocols.has(urlObj.protocol);
          } catch (_) {
            return false;
          }
        }

        // src/chat/file-url-utils.ts
        function getFileUrl({
          part,
          defaultMediaType
        }) {
          var _a15, _b;
          if (part.data instanceof Uint8Array) {
            const base64 = convertUint8ArrayToBase64(part.data);
            return `data:${(_a15 = part.mediaType) != null ? _a15 : defaultMediaType};base64,${base64}`;
          }
          const stringUrl = part.data.toString();
          if (isUrl({
            url: stringUrl,
            protocols: /* @__PURE__ */ new Set(["http:", "https:"])
          })) {
            return stringUrl;
          }
          return stringUrl.startsWith("data:") ? stringUrl : `data:${(_b = part.mediaType) != null ? _b : defaultMediaType};base64,${stringUrl}`;
        }
        function getMediaType(dataUrl, defaultMediaType) {
          var _a15;
          const match = dataUrl.match(/^data:([^;]+)/);
          return match ? (_a15 = match[1]) != null ? _a15 : defaultMediaType : defaultMediaType;
        }
        function getBase64FromDataUrl(dataUrl) {
          const match = dataUrl.match(/^data:[^;]*;base64,(.+)$/);
          return match ? match[1] : dataUrl;
        }

        // src/chat/convert-to-openrouter-chat-messages.ts
        function getCacheControl(providerMetadata) {
          var _a15, _b, _c;
          const anthropic = providerMetadata == null ? void 0 : providerMetadata.anthropic;
          const openrouter2 = providerMetadata == null ? void 0 : providerMetadata.openrouter;
          return (_c = (_b = (_a15 = openrouter2 == null ? void 0 : openrouter2.cacheControl) != null ? _a15 : openrouter2 == null ? void 0 : openrouter2.cache_control) != null ? _b : anthropic == null ? void 0 : anthropic.cacheControl) != null ? _c : anthropic == null ? void 0 : anthropic.cache_control;
        }
        function convertToOpenRouterChatMessages(prompt) {
          var _a15, _b, _c;
          const messages = [];
          for (const { role, content, providerOptions } of prompt) {
            switch (role) {
              case "system": {
                messages.push({
                  role: "system",
                  content,
                  cache_control: getCacheControl(providerOptions)
                });
                break;
              }
              case "user": {
                if (content.length === 1 && ((_a15 = content[0]) == null ? void 0 : _a15.type) === "text") {
                  const cacheControl = (_b = getCacheControl(providerOptions)) != null ? _b : getCacheControl(content[0].providerOptions);
                  const contentWithCacheControl = cacheControl ? [
                    {
                      type: "text",
                      text: content[0].text,
                      cache_control: cacheControl
                    }
                  ] : content[0].text;
                  messages.push({
                    role: "user",
                    content: contentWithCacheControl
                  });
                  break;
                }
                const messageCacheControl = getCacheControl(providerOptions);
                const contentParts = content.map(
                  (part) => {
                    var _a16, _b2, _c2, _d, _e, _f;
                    const cacheControl = (_a16 = getCacheControl(part.providerOptions)) != null ? _a16 : messageCacheControl;
                    switch (part.type) {
                      case "text":
                        return {
                          type: "text",
                          text: part.text,
                          // For text parts, only use part-specific cache control
                          cache_control: cacheControl
                        };
                      case "file": {
                        if ((_b2 = part.mediaType) == null ? void 0 : _b2.startsWith("image/")) {
                          const url = getFileUrl({
                            part,
                            defaultMediaType: "image/jpeg"
                          });
                          return {
                            type: "image_url",
                            image_url: {
                              url
                            },
                            // For image parts, use part-specific or message-level cache control
                            cache_control: cacheControl
                          };
                        }
                        const fileName = String(
                          (_f = (_e = (_d = (_c2 = part.providerOptions) == null ? void 0 : _c2.openrouter) == null ? void 0 : _d.filename) != null ? _e : part.filename) != null ? _f : ""
                        );
                        const fileData = getFileUrl({
                          part,
                          defaultMediaType: "application/pdf"
                        });
                        if (isUrl({
                          url: fileData,
                          protocols: /* @__PURE__ */ new Set(["http:", "https:"])
                        })) {
                          return {
                            type: "file",
                            file: {
                              filename: fileName,
                              file_data: fileData
                            }
                          };
                        }
                        return {
                          type: "file",
                          file: {
                            filename: fileName,
                            file_data: fileData
                          },
                          cache_control: cacheControl
                        };
                      }
                      default: {
                        return {
                          type: "text",
                          text: "",
                          cache_control: cacheControl
                        };
                      }
                    }
                  }
                );
                messages.push({
                  role: "user",
                  content: contentParts
                });
                break;
              }
              case "assistant": {
                let text = "";
                let reasoning = "";
                const reasoningDetails = [];
                const toolCalls = [];
                for (const part of content) {
                  switch (part.type) {
                    case "text": {
                      text += part.text;
                      break;
                    }
                    case "tool-call": {
                      toolCalls.push({
                        id: part.toolCallId,
                        type: "function",
                        function: {
                          name: part.toolName,
                          arguments: JSON.stringify(part.input)
                        }
                      });
                      break;
                    }
                    case "reasoning": {
                      reasoning += part.text;
                      reasoningDetails.push({
                        type: "reasoning.text" /* Text */,
                        text: part.text
                      });
                      break;
                    }
                  }
                }
                messages.push({
                  role: "assistant",
                  content: text,
                  tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
                  reasoning: reasoning || void 0,
                  reasoning_details: reasoningDetails.length > 0 ? reasoningDetails : void 0,
                  cache_control: getCacheControl(providerOptions)
                });
                break;
              }
              case "tool": {
                for (const toolResponse of content) {
                  const content2 = getToolResultContent(toolResponse);
                  messages.push({
                    role: "tool",
                    tool_call_id: toolResponse.toolCallId,
                    content: content2,
                    cache_control: (_c = getCacheControl(providerOptions)) != null ? _c : getCacheControl(toolResponse.providerOptions)
                  });
                }
                break;
              }
            }
          }
          return messages;
        }
        function getToolResultContent(input) {
          return input.output.type === "text" ? input.output.value : JSON.stringify(input.output.value);
        }
        union([
          literal("auto"),
          literal("none"),
          literal("required"),
          object({
            type: literal("function"),
            function: object({
              name: string()
            })
          })
        ]);
        function getChatCompletionToolChoice(toolChoice) {
          switch (toolChoice.type) {
            case "auto":
            case "none":
            case "required":
              return toolChoice.type;
            case "tool": {
              return {
                type: "function",
                function: { name: toolChoice.toolName }
              };
            }
            default: {
              throw new Error(`Invalid tool choice type: ${toolChoice}`);
            }
          }
        }
        var ImageResponseSchema = object({
          type: literal("image_url"),
          image_url: object({
            url: string()
          })
        });
        var ImageResponseWithUnknownSchema = union([
          ImageResponseSchema,
          unknown().transform(() => null)
        ]);
        var ImageResponseArraySchema = array(ImageResponseWithUnknownSchema).transform((d) => d.filter((d2) => !!d2));

        // src/chat/schemas.ts
        var OpenRouterChatCompletionBaseResponseSchema = object({
          id: string().optional(),
          model: string().optional(),
          provider: string().optional(),
          usage: object({
            prompt_tokens: number$1(),
            prompt_tokens_details: object({
              cached_tokens: number$1()
            }).nullish(),
            completion_tokens: number$1(),
            completion_tokens_details: object({
              reasoning_tokens: number$1()
            }).nullish(),
            total_tokens: number$1(),
            cost: number$1().optional(),
            cost_details: object({
              upstream_inference_cost: number$1().nullish()
            }).nullish()
          }).nullish()
        });
        var OpenRouterNonStreamChatCompletionResponseSchema = OpenRouterChatCompletionBaseResponseSchema.extend({
          choices: array(
            object({
              message: object({
                role: literal("assistant"),
                content: string().nullable().optional(),
                reasoning: string().nullable().optional(),
                reasoning_details: ReasoningDetailArraySchema.nullish(),
                images: ImageResponseArraySchema.nullish(),
                tool_calls: array(
                  object({
                    id: string().optional().nullable(),
                    type: literal("function"),
                    function: object({
                      name: string(),
                      arguments: string()
                    })
                  })
                ).optional(),
                annotations: array(
                  object({
                    type: _enum(["url_citation"]),
                    url_citation: object({
                      end_index: number$1(),
                      start_index: number$1(),
                      title: string(),
                      url: string(),
                      content: string().optional()
                    })
                  })
                ).nullish()
              }),
              index: number$1().nullish(),
              logprobs: object({
                content: array(
                  object({
                    token: string(),
                    logprob: number$1(),
                    top_logprobs: array(
                      object({
                        token: string(),
                        logprob: number$1()
                      })
                    )
                  })
                ).nullable()
              }).nullable().optional(),
              finish_reason: string().optional().nullable()
            })
          )
        });
        var OpenRouterStreamChatCompletionChunkSchema = union([
          OpenRouterChatCompletionBaseResponseSchema.extend({
            choices: array(
              object({
                delta: object({
                  role: _enum(["assistant"]).optional(),
                  content: string().nullish(),
                  reasoning: string().nullish().optional(),
                  reasoning_details: ReasoningDetailArraySchema.nullish(),
                  images: ImageResponseArraySchema.nullish(),
                  tool_calls: array(
                    object({
                      index: number$1().nullish(),
                      id: string().nullish(),
                      type: literal("function").optional(),
                      function: object({
                        name: string().nullish(),
                        arguments: string().nullish()
                      })
                    })
                  ).nullish(),
                  annotations: array(
                    object({
                      type: _enum(["url_citation"]),
                      url_citation: object({
                        end_index: number$1(),
                        start_index: number$1(),
                        title: string(),
                        url: string(),
                        content: string().optional()
                      })
                    })
                  ).nullish()
                }).nullish(),
                logprobs: object({
                  content: array(
                    object({
                      token: string(),
                      logprob: number$1(),
                      top_logprobs: array(
                        object({
                          token: string(),
                          logprob: number$1()
                        })
                      )
                    })
                  ).nullable()
                }).nullish(),
                finish_reason: string().nullable().optional(),
                index: number$1().nullish()
              })
            )
          }),
          OpenRouterErrorResponseSchema
        ]);

        // src/chat/index.ts
        var OpenRouterChatLanguageModel = class {
          constructor(modelId, settings, config) {
            this.specificationVersion = "v2";
            this.provider = "openrouter";
            this.defaultObjectGenerationMode = "tool";
            this.supportedUrls = {
              "image/*": [
                /^data:image\/[a-zA-Z]+;base64,/,
                /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
              ],
              // 'text/*': [/^data:text\//, /^https?:\/\/.+$/],
              "application/*": [/^data:application\//, /^https?:\/\/.+$/]
            };
            this.modelId = modelId;
            this.settings = settings;
            this.config = config;
          }
          getArgs({
            prompt,
            maxOutputTokens,
            temperature,
            topP,
            frequencyPenalty,
            presencePenalty,
            seed,
            stopSequences,
            responseFormat,
            topK,
            tools,
            toolChoice
          }) {
            var _a15;
            const baseArgs = __spreadValues(__spreadValues({
              // model id:
              model: this.modelId,
              models: this.settings.models,
              // model specific settings:
              logit_bias: this.settings.logitBias,
              logprobs: this.settings.logprobs === true || typeof this.settings.logprobs === "number" ? true : void 0,
              top_logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
              user: this.settings.user,
              parallel_tool_calls: this.settings.parallelToolCalls,
              // standardized settings:
              max_tokens: maxOutputTokens,
              temperature,
              top_p: topP,
              frequency_penalty: frequencyPenalty,
              presence_penalty: presencePenalty,
              seed,
              stop: stopSequences,
              response_format: responseFormat,
              top_k: topK,
              // messages:
              messages: convertToOpenRouterChatMessages(prompt),
              // OpenRouter specific settings:
              include_reasoning: this.settings.includeReasoning,
              reasoning: this.settings.reasoning,
              usage: this.settings.usage,
              // Web search settings:
              plugins: this.settings.plugins,
              web_search_options: this.settings.web_search_options,
              // Provider routing settings:
              provider: this.settings.provider
            }, this.config.extraBody), this.settings.extraBody);
            if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null) {
              return __spreadProps(__spreadValues({}, baseArgs), {
                response_format: {
                  type: "json_schema",
                  json_schema: __spreadValues({
                    schema: responseFormat.schema,
                    strict: true,
                    name: (_a15 = responseFormat.name) != null ? _a15 : "response"
                  }, responseFormat.description && {
                    description: responseFormat.description
                  })
                }
              });
            }
            if (tools && tools.length > 0) {
              const mappedTools = tools.filter((tool) => tool.type === "function").map((tool) => ({
                type: "function",
                function: {
                  name: tool.name,
                  description: tool.description,
                  parameters: tool.inputSchema
                }
              }));
              return __spreadProps(__spreadValues({}, baseArgs), {
                tools: mappedTools,
                tool_choice: toolChoice ? getChatCompletionToolChoice(toolChoice) : void 0
              });
            }
            return baseArgs;
          }
          async doGenerate(options) {
            var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
            const providerOptions = options.providerOptions || {};
            const openrouterOptions = providerOptions.openrouter || {};
            const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
            const { value: response, responseHeaders } = await postJsonToApi({
              url: this.config.url({
                path: "/chat/completions",
                modelId: this.modelId
              }),
              headers: combineHeaders(this.config.headers(), options.headers),
              body: args,
              failedResponseHandler: openrouterFailedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler(
                OpenRouterNonStreamChatCompletionResponseSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            const choice = response.choices[0];
            if (!choice) {
              throw new Error("No choice in response");
            }
            const usageInfo = response.usage ? {
              inputTokens: (_a15 = response.usage.prompt_tokens) != null ? _a15 : 0,
              outputTokens: (_b = response.usage.completion_tokens) != null ? _b : 0,
              totalTokens: ((_c = response.usage.prompt_tokens) != null ? _c : 0) + ((_d = response.usage.completion_tokens) != null ? _d : 0),
              reasoningTokens: (_f = (_e = response.usage.completion_tokens_details) == null ? void 0 : _e.reasoning_tokens) != null ? _f : 0,
              cachedInputTokens: (_h = (_g = response.usage.prompt_tokens_details) == null ? void 0 : _g.cached_tokens) != null ? _h : 0
            } : {
              inputTokens: 0,
              outputTokens: 0,
              totalTokens: 0,
              reasoningTokens: 0,
              cachedInputTokens: 0
            };
            const reasoningDetails = (_i = choice.message.reasoning_details) != null ? _i : [];
            const reasoning = reasoningDetails.length > 0 ? reasoningDetails.map((detail) => {
              switch (detail.type) {
                case "reasoning.text" /* Text */: {
                  if (detail.text) {
                    return {
                      type: "reasoning",
                      text: detail.text
                    };
                  }
                  break;
                }
                case "reasoning.summary" /* Summary */: {
                  if (detail.summary) {
                    return {
                      type: "reasoning",
                      text: detail.summary
                    };
                  }
                  break;
                }
                case "reasoning.encrypted" /* Encrypted */: {
                  if (detail.data) {
                    return {
                      type: "reasoning",
                      text: "[REDACTED]"
                    };
                  }
                  break;
                }
              }
              return null;
            }).filter((p) => p !== null) : choice.message.reasoning ? [
              {
                type: "reasoning",
                text: choice.message.reasoning
              }
            ] : [];
            const content = [];
            content.push(...reasoning);
            if (choice.message.content) {
              content.push({
                type: "text",
                text: choice.message.content
              });
            }
            if (choice.message.tool_calls) {
              for (const toolCall of choice.message.tool_calls) {
                content.push({
                  type: "tool-call",
                  toolCallId: (_j = toolCall.id) != null ? _j : generateId(),
                  toolName: toolCall.function.name,
                  input: toolCall.function.arguments
                });
              }
            }
            if (choice.message.images) {
              for (const image of choice.message.images) {
                content.push({
                  type: "file",
                  mediaType: getMediaType(image.image_url.url, "image/jpeg"),
                  data: getBase64FromDataUrl(image.image_url.url)
                });
              }
            }
            if (choice.message.annotations) {
              for (const annotation of choice.message.annotations) {
                if (annotation.type === "url_citation") {
                  content.push({
                    type: "source",
                    sourceType: "url",
                    id: annotation.url_citation.url,
                    url: annotation.url_citation.url,
                    title: annotation.url_citation.title,
                    providerMetadata: {
                      openrouter: {
                        content: annotation.url_citation.content || ""
                      }
                    }
                  });
                }
              }
            }
            return {
              content,
              finishReason: mapOpenRouterFinishReason(choice.finish_reason),
              usage: usageInfo,
              warnings: [],
              providerMetadata: {
                openrouter: {
                  provider: (_k = response.provider) != null ? _k : "",
                  usage: {
                    promptTokens: (_l = usageInfo.inputTokens) != null ? _l : 0,
                    completionTokens: (_m = usageInfo.outputTokens) != null ? _m : 0,
                    totalTokens: (_n = usageInfo.totalTokens) != null ? _n : 0,
                    cost: (_o = response.usage) == null ? void 0 : _o.cost,
                    promptTokensDetails: {
                      cachedTokens: (_r = (_q = (_p = response.usage) == null ? void 0 : _p.prompt_tokens_details) == null ? void 0 : _q.cached_tokens) != null ? _r : 0
                    },
                    completionTokensDetails: {
                      reasoningTokens: (_u = (_t = (_s = response.usage) == null ? void 0 : _s.completion_tokens_details) == null ? void 0 : _t.reasoning_tokens) != null ? _u : 0
                    },
                    costDetails: {
                      upstreamInferenceCost: (_x = (_w = (_v = response.usage) == null ? void 0 : _v.cost_details) == null ? void 0 : _w.upstream_inference_cost) != null ? _x : 0
                    }
                  }
                }
              },
              request: { body: args },
              response: {
                id: response.id,
                modelId: response.model,
                headers: responseHeaders
              }
            };
          }
          async doStream(options) {
            var _a15;
            const providerOptions = options.providerOptions || {};
            const openrouterOptions = providerOptions.openrouter || {};
            const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
            const { value: response, responseHeaders } = await postJsonToApi({
              url: this.config.url({
                path: "/chat/completions",
                modelId: this.modelId
              }),
              headers: combineHeaders(this.config.headers(), options.headers),
              body: __spreadProps(__spreadValues({}, args), {
                stream: true,
                // only include stream_options when in strict compatibility mode:
                stream_options: this.config.compatibility === "strict" ? __spreadValues({
                  include_usage: true
                }, ((_a15 = this.settings.usage) == null ? void 0 : _a15.include) ? { include_usage: true } : {}) : void 0
              }),
              failedResponseHandler: openrouterFailedResponseHandler,
              successfulResponseHandler: createEventSourceResponseHandler(
                OpenRouterStreamChatCompletionChunkSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            const toolCalls = [];
            let finishReason = "other";
            const usage = {
              inputTokens: Number.NaN,
              outputTokens: Number.NaN,
              totalTokens: Number.NaN,
              reasoningTokens: Number.NaN,
              cachedInputTokens: Number.NaN
            };
            const openrouterUsage = {};
            let textStarted = false;
            let reasoningStarted = false;
            let textId;
            let reasoningId;
            let openrouterResponseId;
            let provider;
            return {
              stream: response.pipeThrough(
                new TransformStream({
                  transform(chunk, controller) {
                    var _a16, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
                    if (!chunk.success) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: chunk.error });
                      return;
                    }
                    const value = chunk.value;
                    if ("error" in value) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: value.error });
                      return;
                    }
                    if (value.provider) {
                      provider = value.provider;
                    }
                    if (value.id) {
                      openrouterResponseId = value.id;
                      controller.enqueue({
                        type: "response-metadata",
                        id: value.id
                      });
                    }
                    if (value.model) {
                      controller.enqueue({
                        type: "response-metadata",
                        modelId: value.model
                      });
                    }
                    if (value.usage != null) {
                      usage.inputTokens = value.usage.prompt_tokens;
                      usage.outputTokens = value.usage.completion_tokens;
                      usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;
                      openrouterUsage.promptTokens = value.usage.prompt_tokens;
                      if (value.usage.prompt_tokens_details) {
                        const cachedInputTokens = (_a16 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a16 : 0;
                        usage.cachedInputTokens = cachedInputTokens;
                        openrouterUsage.promptTokensDetails = {
                          cachedTokens: cachedInputTokens
                        };
                      }
                      openrouterUsage.completionTokens = value.usage.completion_tokens;
                      if (value.usage.completion_tokens_details) {
                        const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;
                        usage.reasoningTokens = reasoningTokens;
                        openrouterUsage.completionTokensDetails = {
                          reasoningTokens
                        };
                      }
                      openrouterUsage.cost = value.usage.cost;
                      openrouterUsage.totalTokens = value.usage.total_tokens;
                    }
                    const choice = value.choices[0];
                    if ((choice == null ? void 0 : choice.finish_reason) != null) {
                      finishReason = mapOpenRouterFinishReason(choice.finish_reason);
                    }
                    if ((choice == null ? void 0 : choice.delta) == null) {
                      return;
                    }
                    const delta = choice.delta;
                    const emitReasoningChunk = (chunkText) => {
                      if (!reasoningStarted) {
                        reasoningId = openrouterResponseId || generateId();
                        controller.enqueue({
                          type: "reasoning-start",
                          id: reasoningId
                        });
                        reasoningStarted = true;
                      }
                      controller.enqueue({
                        type: "reasoning-delta",
                        delta: chunkText,
                        id: reasoningId || generateId()
                      });
                    };
                    if (delta.reasoning_details && delta.reasoning_details.length > 0) {
                      for (const detail of delta.reasoning_details) {
                        switch (detail.type) {
                          case "reasoning.text" /* Text */: {
                            if (detail.text) {
                              emitReasoningChunk(detail.text);
                            }
                            break;
                          }
                          case "reasoning.encrypted" /* Encrypted */: {
                            if (detail.data) {
                              emitReasoningChunk("[REDACTED]");
                            }
                            break;
                          }
                          case "reasoning.summary" /* Summary */: {
                            if (detail.summary) {
                              emitReasoningChunk(detail.summary);
                            }
                            break;
                          }
                        }
                      }
                    } else if (delta.reasoning) {
                      emitReasoningChunk(delta.reasoning);
                    }
                    if (delta.content) {
                      if (reasoningStarted && !textStarted) {
                        controller.enqueue({
                          type: "reasoning-end",
                          id: reasoningId || generateId()
                        });
                        reasoningStarted = false;
                      }
                      if (!textStarted) {
                        textId = openrouterResponseId || generateId();
                        controller.enqueue({
                          type: "text-start",
                          id: textId
                        });
                        textStarted = true;
                      }
                      controller.enqueue({
                        type: "text-delta",
                        delta: delta.content,
                        id: textId || generateId()
                      });
                    }
                    if (delta.annotations) {
                      for (const annotation of delta.annotations) {
                        if (annotation.type === "url_citation") {
                          controller.enqueue({
                            type: "source",
                            sourceType: "url",
                            id: annotation.url_citation.url,
                            url: annotation.url_citation.url,
                            title: annotation.url_citation.title,
                            providerMetadata: {
                              openrouter: {
                                content: annotation.url_citation.content || ""
                              }
                            }
                          });
                        }
                      }
                    }
                    if (delta.tool_calls != null) {
                      for (const toolCallDelta of delta.tool_calls) {
                        const index = (_c = toolCallDelta.index) != null ? _c : toolCalls.length - 1;
                        if (toolCalls[index] == null) {
                          if (toolCallDelta.type !== "function") {
                            throw new InvalidResponseDataError({
                              data: toolCallDelta,
                              message: `Expected 'function' type.`
                            });
                          }
                          if (toolCallDelta.id == null) {
                            throw new InvalidResponseDataError({
                              data: toolCallDelta,
                              message: `Expected 'id' to be a string.`
                            });
                          }
                          if (((_d = toolCallDelta.function) == null ? void 0 : _d.name) == null) {
                            throw new InvalidResponseDataError({
                              data: toolCallDelta,
                              message: `Expected 'function.name' to be a string.`
                            });
                          }
                          toolCalls[index] = {
                            id: toolCallDelta.id,
                            type: "function",
                            function: {
                              name: toolCallDelta.function.name,
                              arguments: (_e = toolCallDelta.function.arguments) != null ? _e : ""
                            },
                            inputStarted: false,
                            sent: false
                          };
                          const toolCall2 = toolCalls[index];
                          if (toolCall2 == null) {
                            throw new Error("Tool call is missing");
                          }
                          if (((_f = toolCall2.function) == null ? void 0 : _f.name) != null && ((_g = toolCall2.function) == null ? void 0 : _g.arguments) != null && isParsableJson(toolCall2.function.arguments)) {
                            toolCall2.inputStarted = true;
                            controller.enqueue({
                              type: "tool-input-start",
                              id: toolCall2.id,
                              toolName: toolCall2.function.name
                            });
                            controller.enqueue({
                              type: "tool-input-delta",
                              id: toolCall2.id,
                              delta: toolCall2.function.arguments
                            });
                            controller.enqueue({
                              type: "tool-input-end",
                              id: toolCall2.id
                            });
                            controller.enqueue({
                              type: "tool-call",
                              toolCallId: toolCall2.id,
                              toolName: toolCall2.function.name,
                              input: toolCall2.function.arguments
                            });
                            toolCall2.sent = true;
                          }
                          continue;
                        }
                        const toolCall = toolCalls[index];
                        if (toolCall == null) {
                          throw new Error("Tool call is missing");
                        }
                        if (!toolCall.inputStarted) {
                          toolCall.inputStarted = true;
                          controller.enqueue({
                            type: "tool-input-start",
                            id: toolCall.id,
                            toolName: toolCall.function.name
                          });
                        }
                        if (((_h = toolCallDelta.function) == null ? void 0 : _h.arguments) != null) {
                          toolCall.function.arguments += (_j = (_i = toolCallDelta.function) == null ? void 0 : _i.arguments) != null ? _j : "";
                        }
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall.id,
                          delta: (_k = toolCallDelta.function.arguments) != null ? _k : ""
                        });
                        if (((_l = toolCall.function) == null ? void 0 : _l.name) != null && ((_m = toolCall.function) == null ? void 0 : _m.arguments) != null && isParsableJson(toolCall.function.arguments)) {
                          controller.enqueue({
                            type: "tool-call",
                            toolCallId: (_n = toolCall.id) != null ? _n : generateId(),
                            toolName: toolCall.function.name,
                            input: toolCall.function.arguments
                          });
                          toolCall.sent = true;
                        }
                      }
                    }
                    if (delta.images != null) {
                      for (const image of delta.images) {
                        controller.enqueue({
                          type: "file",
                          mediaType: getMediaType(image.image_url.url, "image/jpeg"),
                          data: getBase64FromDataUrl(image.image_url.url)
                        });
                      }
                    }
                  },
                  flush(controller) {
                    var _a16;
                    if (finishReason === "tool-calls") {
                      for (const toolCall of toolCalls) {
                        if (toolCall && !toolCall.sent) {
                          controller.enqueue({
                            type: "tool-call",
                            toolCallId: (_a16 = toolCall.id) != null ? _a16 : generateId(),
                            toolName: toolCall.function.name,
                            // Coerce invalid arguments to an empty JSON object
                            input: isParsableJson(toolCall.function.arguments) ? toolCall.function.arguments : "{}"
                          });
                          toolCall.sent = true;
                        }
                      }
                    }
                    if (reasoningStarted) {
                      controller.enqueue({
                        type: "reasoning-end",
                        id: reasoningId || generateId()
                      });
                    }
                    if (textStarted) {
                      controller.enqueue({
                        type: "text-end",
                        id: textId || generateId()
                      });
                    }
                    const openrouterMetadata = {
                      usage: openrouterUsage
                    };
                    if (provider !== void 0) {
                      openrouterMetadata.provider = provider;
                    }
                    controller.enqueue({
                      type: "finish",
                      finishReason,
                      usage,
                      providerMetadata: {
                        openrouter: openrouterMetadata
                      }
                    });
                  }
                })
              ),
              warnings: [],
              request: { body: args },
              response: { headers: responseHeaders }
            };
          }
        };

        // src/completion/convert-to-openrouter-completion-prompt.ts
        function convertToOpenRouterCompletionPrompt({
          prompt,
          inputFormat,
          user = "user",
          assistant = "assistant"
        }) {
          if (prompt.length === 1 && prompt[0] && prompt[0].role === "user" && prompt[0].content.length === 1 && prompt[0].content[0] && prompt[0].content[0].type === "text") {
            return { prompt: prompt[0].content[0].text };
          }
          let text = "";
          if (prompt[0] && prompt[0].role === "system") {
            text += `${prompt[0].content}

`;
            prompt = prompt.slice(1);
          }
          for (const { role, content } of prompt) {
            switch (role) {
              case "system": {
                throw new InvalidPromptError({
                  message: `Unexpected system message in prompt: ${content}`,
                  prompt
                });
              }
              case "user": {
                const userMessage = content.map((part) => {
                  switch (part.type) {
                    case "text": {
                      return part.text;
                    }
                    case "file": {
                      throw new UnsupportedFunctionalityError({
                        functionality: "file attachments"
                      });
                    }
                    default: {
                      return "";
                    }
                  }
                }).join("");
                text += `${user}:
${userMessage}

`;
                break;
              }
              case "assistant": {
                const assistantMessage = content.map(
                  (part) => {
                    switch (part.type) {
                      case "text": {
                        return part.text;
                      }
                      case "tool-call": {
                        throw new UnsupportedFunctionalityError({
                          functionality: "tool-call messages"
                        });
                      }
                      case "tool-result": {
                        throw new UnsupportedFunctionalityError({
                          functionality: "tool-result messages"
                        });
                      }
                      case "reasoning": {
                        throw new UnsupportedFunctionalityError({
                          functionality: "reasoning messages"
                        });
                      }
                      case "file": {
                        throw new UnsupportedFunctionalityError({
                          functionality: "file attachments"
                        });
                      }
                      default: {
                        return "";
                      }
                    }
                  }
                ).join("");
                text += `${assistant}:
${assistantMessage}

`;
                break;
              }
              case "tool": {
                throw new UnsupportedFunctionalityError({
                  functionality: "tool messages"
                });
              }
            }
          }
          text += `${assistant}:
`;
          return {
            prompt: text
          };
        }
        var OpenRouterCompletionChunkSchema = union([
          object({
            id: string().optional(),
            model: string().optional(),
            choices: array(
              object({
                text: string(),
                reasoning: string().nullish().optional(),
                reasoning_details: ReasoningDetailArraySchema.nullish(),
                finish_reason: string().nullish(),
                index: number$1().nullish(),
                logprobs: object({
                  tokens: array(string()),
                  token_logprobs: array(number$1()),
                  top_logprobs: array(record(string(), number$1())).nullable()
                }).nullable().optional()
              })
            ),
            usage: object({
              prompt_tokens: number$1(),
              prompt_tokens_details: object({
                cached_tokens: number$1()
              }).nullish(),
              completion_tokens: number$1(),
              completion_tokens_details: object({
                reasoning_tokens: number$1()
              }).nullish(),
              total_tokens: number$1(),
              cost: number$1().optional()
            }).nullish()
          }),
          OpenRouterErrorResponseSchema
        ]);

        // src/completion/index.ts
        var OpenRouterCompletionLanguageModel = class {
          constructor(modelId, settings, config) {
            this.specificationVersion = "v2";
            this.provider = "openrouter";
            this.supportedUrls = {
              "image/*": [
                /^data:image\/[a-zA-Z]+;base64,/,
                /^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i
              ],
              "text/*": [/^data:text\//, /^https?:\/\/.+$/],
              "application/*": [/^data:application\//, /^https?:\/\/.+$/]
            };
            this.defaultObjectGenerationMode = void 0;
            this.modelId = modelId;
            this.settings = settings;
            this.config = config;
          }
          getArgs({
            prompt,
            maxOutputTokens,
            temperature,
            topP,
            frequencyPenalty,
            presencePenalty,
            seed,
            responseFormat,
            topK,
            stopSequences,
            tools,
            toolChoice
          }) {
            const { prompt: completionPrompt } = convertToOpenRouterCompletionPrompt({
              prompt,
              inputFormat: "prompt"
            });
            if (tools == null ? void 0 : tools.length) {
              throw new UnsupportedFunctionalityError({
                functionality: "tools"
              });
            }
            if (toolChoice) {
              throw new UnsupportedFunctionalityError({
                functionality: "toolChoice"
              });
            }
            return __spreadValues(__spreadValues({
              // model id:
              model: this.modelId,
              models: this.settings.models,
              // model specific settings:
              logit_bias: this.settings.logitBias,
              logprobs: typeof this.settings.logprobs === "number" ? this.settings.logprobs : typeof this.settings.logprobs === "boolean" ? this.settings.logprobs ? 0 : void 0 : void 0,
              suffix: this.settings.suffix,
              user: this.settings.user,
              // standardized settings:
              max_tokens: maxOutputTokens,
              temperature,
              top_p: topP,
              frequency_penalty: frequencyPenalty,
              presence_penalty: presencePenalty,
              seed,
              stop: stopSequences,
              response_format: responseFormat,
              top_k: topK,
              // prompt:
              prompt: completionPrompt,
              // OpenRouter specific settings:
              include_reasoning: this.settings.includeReasoning,
              reasoning: this.settings.reasoning
            }, this.config.extraBody), this.settings.extraBody);
          }
          async doGenerate(options) {
            var _a15, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
            const providerOptions = options.providerOptions || {};
            const openrouterOptions = providerOptions.openrouter || {};
            const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
            const { value: response, responseHeaders } = await postJsonToApi({
              url: this.config.url({
                path: "/completions",
                modelId: this.modelId
              }),
              headers: combineHeaders(this.config.headers(), options.headers),
              body: args,
              failedResponseHandler: openrouterFailedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler(
                OpenRouterCompletionChunkSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            if ("error" in response) {
              throw new Error(`${response.error.message}`);
            }
            const choice = response.choices[0];
            if (!choice) {
              throw new Error("No choice in OpenRouter completion response");
            }
            return {
              content: [
                {
                  type: "text",
                  text: (_a15 = choice.text) != null ? _a15 : ""
                }
              ],
              finishReason: mapOpenRouterFinishReason(choice.finish_reason),
              usage: {
                inputTokens: (_c = (_b = response.usage) == null ? void 0 : _b.prompt_tokens) != null ? _c : 0,
                outputTokens: (_e = (_d = response.usage) == null ? void 0 : _d.completion_tokens) != null ? _e : 0,
                totalTokens: ((_g = (_f = response.usage) == null ? void 0 : _f.prompt_tokens) != null ? _g : 0) + ((_i = (_h = response.usage) == null ? void 0 : _h.completion_tokens) != null ? _i : 0),
                reasoningTokens: (_l = (_k = (_j = response.usage) == null ? void 0 : _j.completion_tokens_details) == null ? void 0 : _k.reasoning_tokens) != null ? _l : 0,
                cachedInputTokens: (_o = (_n = (_m = response.usage) == null ? void 0 : _m.prompt_tokens_details) == null ? void 0 : _n.cached_tokens) != null ? _o : 0
              },
              warnings: [],
              response: {
                headers: responseHeaders
              }
            };
          }
          async doStream(options) {
            const providerOptions = options.providerOptions || {};
            const openrouterOptions = providerOptions.openrouter || {};
            const args = __spreadValues(__spreadValues({}, this.getArgs(options)), openrouterOptions);
            const { value: response, responseHeaders } = await postJsonToApi({
              url: this.config.url({
                path: "/completions",
                modelId: this.modelId
              }),
              headers: combineHeaders(this.config.headers(), options.headers),
              body: __spreadProps(__spreadValues({}, args), {
                stream: true,
                // only include stream_options when in strict compatibility mode:
                stream_options: this.config.compatibility === "strict" ? { include_usage: true } : void 0
              }),
              failedResponseHandler: openrouterFailedResponseHandler,
              successfulResponseHandler: createEventSourceResponseHandler(
                OpenRouterCompletionChunkSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            let finishReason = "other";
            const usage = {
              inputTokens: Number.NaN,
              outputTokens: Number.NaN,
              totalTokens: Number.NaN,
              reasoningTokens: Number.NaN,
              cachedInputTokens: Number.NaN
            };
            const openrouterUsage = {};
            return {
              stream: response.pipeThrough(
                new TransformStream({
                  transform(chunk, controller) {
                    var _a15, _b;
                    if (!chunk.success) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: chunk.error });
                      return;
                    }
                    const value = chunk.value;
                    if ("error" in value) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: value.error });
                      return;
                    }
                    if (value.usage != null) {
                      usage.inputTokens = value.usage.prompt_tokens;
                      usage.outputTokens = value.usage.completion_tokens;
                      usage.totalTokens = value.usage.prompt_tokens + value.usage.completion_tokens;
                      openrouterUsage.promptTokens = value.usage.prompt_tokens;
                      if (value.usage.prompt_tokens_details) {
                        const cachedInputTokens = (_a15 = value.usage.prompt_tokens_details.cached_tokens) != null ? _a15 : 0;
                        usage.cachedInputTokens = cachedInputTokens;
                        openrouterUsage.promptTokensDetails = {
                          cachedTokens: cachedInputTokens
                        };
                      }
                      openrouterUsage.completionTokens = value.usage.completion_tokens;
                      if (value.usage.completion_tokens_details) {
                        const reasoningTokens = (_b = value.usage.completion_tokens_details.reasoning_tokens) != null ? _b : 0;
                        usage.reasoningTokens = reasoningTokens;
                        openrouterUsage.completionTokensDetails = {
                          reasoningTokens
                        };
                      }
                      openrouterUsage.cost = value.usage.cost;
                      openrouterUsage.totalTokens = value.usage.total_tokens;
                    }
                    const choice = value.choices[0];
                    if ((choice == null ? void 0 : choice.finish_reason) != null) {
                      finishReason = mapOpenRouterFinishReason(choice.finish_reason);
                    }
                    if ((choice == null ? void 0 : choice.text) != null) {
                      controller.enqueue({
                        type: "text-delta",
                        delta: choice.text,
                        id: generateId()
                      });
                    }
                  },
                  flush(controller) {
                    controller.enqueue({
                      type: "finish",
                      finishReason,
                      usage,
                      providerMetadata: {
                        openrouter: {
                          usage: openrouterUsage
                        }
                      }
                    });
                  }
                })
              ),
              response: {
                headers: responseHeaders
              }
            };
          }
        };

        // src/provider.ts
        function createOpenRouter(options = {}) {
          var _a15, _b, _c;
          const baseURL = (_b = withoutTrailingSlash((_a15 = options.baseURL) != null ? _a15 : options.baseUrl)) != null ? _b : "https://openrouter.ai/api/v1";
          const compatibility = (_c = options.compatibility) != null ? _c : "compatible";
          const getHeaders = () => __spreadValues({
            Authorization: `Bearer ${loadApiKey({
              apiKey: options.apiKey,
              environmentVariableName: "OPENROUTER_API_KEY",
              description: "OpenRouter"
            })}`
          }, options.headers);
          const createChatModel = (modelId, settings = {}) => new OpenRouterChatLanguageModel(modelId, settings, {
            provider: "openrouter.chat",
            url: ({ path }) => `${baseURL}${path}`,
            headers: getHeaders,
            compatibility,
            fetch: options.fetch,
            extraBody: options.extraBody
          });
          const createCompletionModel = (modelId, settings = {}) => new OpenRouterCompletionLanguageModel(modelId, settings, {
            provider: "openrouter.completion",
            url: ({ path }) => `${baseURL}${path}`,
            headers: getHeaders,
            compatibility,
            fetch: options.fetch,
            extraBody: options.extraBody
          });
          const createLanguageModel = (modelId, settings) => {
            if (new.target) {
              throw new Error(
                "The OpenRouter model function cannot be called with the new keyword."
              );
            }
            if (modelId === "openai/gpt-3.5-turbo-instruct") {
              return createCompletionModel(
                modelId,
                settings
              );
            }
            return createChatModel(modelId, settings);
          };
          const provider = (modelId, settings) => createLanguageModel(modelId, settings);
          provider.languageModel = createLanguageModel;
          provider.chat = createChatModel;
          provider.completion = createCompletionModel;
          return provider;
        }
        createOpenRouter({
          compatibility: "strict"
          // strict for OpenRouter API
        });

        // src/chat/openai-compatible-chat-language-model.ts
        function getOpenAIMetadata(message) {
          var _a, _b;
          return (_b = (_a = message == null ? void 0 : message.providerOptions) == null ? void 0 : _a.openaiCompatible) != null ? _b : {};
        }
        function convertToOpenAICompatibleChatMessages(prompt) {
          const messages = [];
          for (const { role, content, ...message } of prompt) {
            const metadata = getOpenAIMetadata({ ...message });
            switch (role) {
              case "system": {
                messages.push({ role: "system", content, ...metadata });
                break;
              }
              case "user": {
                if (content.length === 1 && content[0].type === "text") {
                  messages.push({
                    role: "user",
                    content: content[0].text,
                    ...getOpenAIMetadata(content[0])
                  });
                  break;
                }
                messages.push({
                  role: "user",
                  content: content.map((part) => {
                    const partMetadata = getOpenAIMetadata(part);
                    switch (part.type) {
                      case "text": {
                        return { type: "text", text: part.text, ...partMetadata };
                      }
                      case "file": {
                        if (part.mediaType.startsWith("image/")) {
                          const mediaType = part.mediaType === "image/*" ? "image/jpeg" : part.mediaType;
                          return {
                            type: "image_url",
                            image_url: {
                              url: part.data instanceof URL ? part.data.toString() : `data:${mediaType};base64,${convertToBase64(part.data)}`
                            },
                            ...partMetadata
                          };
                        } else {
                          throw new UnsupportedFunctionalityError$1({
                            functionality: `file part media type ${part.mediaType}`
                          });
                        }
                      }
                    }
                  }),
                  ...metadata
                });
                break;
              }
              case "assistant": {
                let text = "";
                const toolCalls = [];
                for (const part of content) {
                  const partMetadata = getOpenAIMetadata(part);
                  switch (part.type) {
                    case "text": {
                      text += part.text;
                      break;
                    }
                    case "tool-call": {
                      toolCalls.push({
                        id: part.toolCallId,
                        type: "function",
                        function: {
                          name: part.toolName,
                          arguments: JSON.stringify(part.input)
                        },
                        ...partMetadata
                      });
                      break;
                    }
                  }
                }
                messages.push({
                  role: "assistant",
                  content: text,
                  tool_calls: toolCalls.length > 0 ? toolCalls : void 0,
                  ...metadata
                });
                break;
              }
              case "tool": {
                for (const toolResponse of content) {
                  const output = toolResponse.output;
                  let contentValue;
                  switch (output.type) {
                    case "text":
                    case "error-text":
                      contentValue = output.value;
                      break;
                    case "content":
                    case "json":
                    case "error-json":
                      contentValue = JSON.stringify(output.value);
                      break;
                  }
                  const toolResponseMetadata = getOpenAIMetadata(toolResponse);
                  messages.push({
                    role: "tool",
                    tool_call_id: toolResponse.toolCallId,
                    content: contentValue,
                    ...toolResponseMetadata
                  });
                }
                break;
              }
              default: {
                const _exhaustiveCheck = role;
                throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
              }
            }
          }
          return messages;
        }

        // src/chat/get-response-metadata.ts
        function getResponseMetadata({
          id,
          model,
          created
        }) {
          return {
            id: id != null ? id : void 0,
            modelId: model != null ? model : void 0,
            timestamp: created != null ? new Date(created * 1e3) : void 0
          };
        }

        // src/chat/map-openai-compatible-finish-reason.ts
        function mapOpenAICompatibleFinishReason(finishReason) {
          switch (finishReason) {
            case "stop":
              return "stop";
            case "length":
              return "length";
            case "content_filter":
              return "content-filter";
            case "function_call":
            case "tool_calls":
              return "tool-calls";
            default:
              return "unknown";
          }
        }
        var openaiCompatibleProviderOptions = object({
          /**
           * A unique identifier representing your end-user, which can help the provider to
           * monitor and detect abuse.
           */
          user: string().optional(),
          /**
           * Reasoning effort for reasoning models. Defaults to `medium`.
           */
          reasoningEffort: string().optional(),
          /**
           * Controls the verbosity of the generated text. Defaults to `medium`.
           */
          textVerbosity: string().optional()
        });
        var openaiCompatibleErrorDataSchema = object({
          error: object({
            message: string(),
            // The additional information below is handled loosely to support
            // OpenAI-compatible providers that have slightly different error
            // responses:
            type: string().nullish(),
            param: any().nullish(),
            code: union([string(), number$1()]).nullish()
          })
        });
        var defaultOpenAICompatibleErrorStructure = {
          errorSchema: openaiCompatibleErrorDataSchema,
          errorToMessage: (data) => data.error.message
        };
        function prepareTools({
          tools,
          toolChoice
        }) {
          tools = (tools == null ? void 0 : tools.length) ? tools : void 0;
          const toolWarnings = [];
          if (tools == null) {
            return { tools: void 0, toolChoice: void 0, toolWarnings };
          }
          const openaiCompatTools = [];
          for (const tool of tools) {
            if (tool.type === "provider-defined") {
              toolWarnings.push({ type: "unsupported-tool", tool });
            } else {
              openaiCompatTools.push({
                type: "function",
                function: {
                  name: tool.name,
                  description: tool.description,
                  parameters: tool.inputSchema
                }
              });
            }
          }
          if (toolChoice == null) {
            return { tools: openaiCompatTools, toolChoice: void 0, toolWarnings };
          }
          const type = toolChoice.type;
          switch (type) {
            case "auto":
            case "none":
            case "required":
              return { tools: openaiCompatTools, toolChoice: type, toolWarnings };
            case "tool":
              return {
                tools: openaiCompatTools,
                toolChoice: {
                  type: "function",
                  function: { name: toolChoice.toolName }
                },
                toolWarnings
              };
            default: {
              const _exhaustiveCheck = type;
              throw new UnsupportedFunctionalityError$1({
                functionality: `tool choice type: ${_exhaustiveCheck}`
              });
            }
          }
        }

        // src/chat/openai-compatible-chat-language-model.ts
        var OpenAICompatibleChatLanguageModel = class {
          // type inferred via constructor
          constructor(modelId, config) {
            this.specificationVersion = "v2";
            var _a, _b;
            this.modelId = modelId;
            this.config = config;
            const errorStructure = (_a = config.errorStructure) != null ? _a : defaultOpenAICompatibleErrorStructure;
            this.chunkSchema = createOpenAICompatibleChatChunkSchema(
              errorStructure.errorSchema
            );
            this.failedResponseHandler = createJsonErrorResponseHandler$1(errorStructure);
            this.supportsStructuredOutputs = (_b = config.supportsStructuredOutputs) != null ? _b : false;
          }
          get provider() {
            return this.config.provider;
          }
          get providerOptionsName() {
            return this.config.provider.split(".")[0].trim();
          }
          get supportedUrls() {
            var _a, _b, _c;
            return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
          }
          async getArgs({
            prompt,
            maxOutputTokens,
            temperature,
            topP,
            topK,
            frequencyPenalty,
            presencePenalty,
            providerOptions,
            stopSequences,
            responseFormat,
            seed,
            toolChoice,
            tools
          }) {
            var _a, _b, _c, _d;
            const warnings = [];
            const compatibleOptions = Object.assign(
              (_a = await parseProviderOptions({
                provider: "openai-compatible",
                providerOptions,
                schema: openaiCompatibleProviderOptions
              })) != null ? _a : {},
              (_b = await parseProviderOptions({
                provider: this.providerOptionsName,
                providerOptions,
                schema: openaiCompatibleProviderOptions
              })) != null ? _b : {}
            );
            if (topK != null) {
              warnings.push({ type: "unsupported-setting", setting: "topK" });
            }
            if ((responseFormat == null ? void 0 : responseFormat.type) === "json" && responseFormat.schema != null && !this.supportsStructuredOutputs) {
              warnings.push({
                type: "unsupported-setting",
                setting: "responseFormat",
                details: "JSON response format schema is only supported with structuredOutputs"
              });
            }
            const {
              tools: openaiTools,
              toolChoice: openaiToolChoice,
              toolWarnings
            } = prepareTools({
              tools,
              toolChoice
            });
            return {
              args: {
                // model id:
                model: this.modelId,
                // model specific settings:
                user: compatibleOptions.user,
                // standardized settings:
                max_tokens: maxOutputTokens,
                temperature,
                top_p: topP,
                frequency_penalty: frequencyPenalty,
                presence_penalty: presencePenalty,
                response_format: (responseFormat == null ? void 0 : responseFormat.type) === "json" ? this.supportsStructuredOutputs === true && responseFormat.schema != null ? {
                  type: "json_schema",
                  json_schema: {
                    schema: responseFormat.schema,
                    name: (_c = responseFormat.name) != null ? _c : "response",
                    description: responseFormat.description
                  }
                } : { type: "json_object" } : void 0,
                stop: stopSequences,
                seed,
                ...Object.fromEntries(
                  Object.entries(
                    (_d = providerOptions == null ? void 0 : providerOptions[this.providerOptionsName]) != null ? _d : {}
                  ).filter(
                    ([key]) => !Object.keys(openaiCompatibleProviderOptions.shape).includes(key)
                  )
                ),
                reasoning_effort: compatibleOptions.reasoningEffort,
                verbosity: compatibleOptions.textVerbosity,
                // messages:
                messages: convertToOpenAICompatibleChatMessages(prompt),
                // tools:
                tools: openaiTools,
                tool_choice: openaiToolChoice
              },
              warnings: [...warnings, ...toolWarnings]
            };
          }
          async doGenerate(options) {
            var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
            const { args, warnings } = await this.getArgs({ ...options });
            const body = JSON.stringify(args);
            const {
              responseHeaders,
              value: responseBody,
              rawValue: rawResponse
            } = await postJsonToApi$1({
              url: this.config.url({
                path: "/chat/completions",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), options.headers),
              body: args,
              failedResponseHandler: this.failedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler$1(
                OpenAICompatibleChatResponseSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            const choice = responseBody.choices[0];
            const content = [];
            const text = choice.message.content;
            if (text != null && text.length > 0) {
              content.push({ type: "text", text });
            }
            const reasoning = (_a = choice.message.reasoning_content) != null ? _a : choice.message.reasoning;
            if (reasoning != null && reasoning.length > 0) {
              content.push({
                type: "reasoning",
                text: reasoning
              });
            }
            if (choice.message.tool_calls != null) {
              for (const toolCall of choice.message.tool_calls) {
                content.push({
                  type: "tool-call",
                  toolCallId: (_b = toolCall.id) != null ? _b : generateId$1(),
                  toolName: toolCall.function.name,
                  input: toolCall.function.arguments
                });
              }
            }
            const providerMetadata = {
              [this.providerOptionsName]: {},
              ...await ((_d = (_c = this.config.metadataExtractor) == null ? void 0 : _c.extractMetadata) == null ? void 0 : _d.call(_c, {
                parsedBody: rawResponse
              }))
            };
            const completionTokenDetails = (_e = responseBody.usage) == null ? void 0 : _e.completion_tokens_details;
            if ((completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens) != null) {
              providerMetadata[this.providerOptionsName].acceptedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.accepted_prediction_tokens;
            }
            if ((completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens) != null) {
              providerMetadata[this.providerOptionsName].rejectedPredictionTokens = completionTokenDetails == null ? void 0 : completionTokenDetails.rejected_prediction_tokens;
            }
            return {
              content,
              finishReason: mapOpenAICompatibleFinishReason(choice.finish_reason),
              usage: {
                inputTokens: (_g = (_f = responseBody.usage) == null ? void 0 : _f.prompt_tokens) != null ? _g : void 0,
                outputTokens: (_i = (_h = responseBody.usage) == null ? void 0 : _h.completion_tokens) != null ? _i : void 0,
                totalTokens: (_k = (_j = responseBody.usage) == null ? void 0 : _j.total_tokens) != null ? _k : void 0,
                reasoningTokens: (_n = (_m = (_l = responseBody.usage) == null ? void 0 : _l.completion_tokens_details) == null ? void 0 : _m.reasoning_tokens) != null ? _n : void 0,
                cachedInputTokens: (_q = (_p = (_o = responseBody.usage) == null ? void 0 : _o.prompt_tokens_details) == null ? void 0 : _p.cached_tokens) != null ? _q : void 0
              },
              providerMetadata,
              request: { body },
              response: {
                ...getResponseMetadata(responseBody),
                headers: responseHeaders,
                body: rawResponse
              },
              warnings
            };
          }
          async doStream(options) {
            var _a;
            const { args, warnings } = await this.getArgs({ ...options });
            const body = {
              ...args,
              stream: true,
              // only include stream_options when in strict compatibility mode:
              stream_options: this.config.includeUsage ? { include_usage: true } : void 0
            };
            const metadataExtractor = (_a = this.config.metadataExtractor) == null ? void 0 : _a.createStreamExtractor();
            const { responseHeaders, value: response } = await postJsonToApi$1({
              url: this.config.url({
                path: "/chat/completions",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), options.headers),
              body,
              failedResponseHandler: this.failedResponseHandler,
              successfulResponseHandler: createEventSourceResponseHandler$1(
                this.chunkSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            const toolCalls = [];
            let finishReason = "unknown";
            const usage = {
              completionTokens: void 0,
              completionTokensDetails: {
                reasoningTokens: void 0,
                acceptedPredictionTokens: void 0,
                rejectedPredictionTokens: void 0
              },
              promptTokens: void 0,
              promptTokensDetails: {
                cachedTokens: void 0
              },
              totalTokens: void 0
            };
            let isFirstChunk = true;
            const providerOptionsName = this.providerOptionsName;
            let isActiveReasoning = false;
            let isActiveText = false;
            return {
              stream: response.pipeThrough(
                new TransformStream({
                  start(controller) {
                    controller.enqueue({ type: "stream-start", warnings });
                  },
                  // TODO we lost type safety on Chunk, most likely due to the error schema. MUST FIX
                  transform(chunk, controller) {
                    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
                    if (options.includeRawChunks) {
                      controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                    }
                    if (!chunk.success) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: chunk.error });
                      return;
                    }
                    const value = chunk.value;
                    metadataExtractor == null ? void 0 : metadataExtractor.processChunk(chunk.rawValue);
                    if ("error" in value) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: value.error.message });
                      return;
                    }
                    if (isFirstChunk) {
                      isFirstChunk = false;
                      controller.enqueue({
                        type: "response-metadata",
                        ...getResponseMetadata(value)
                      });
                    }
                    if (value.usage != null) {
                      const {
                        prompt_tokens,
                        completion_tokens,
                        total_tokens,
                        prompt_tokens_details,
                        completion_tokens_details
                      } = value.usage;
                      usage.promptTokens = prompt_tokens != null ? prompt_tokens : void 0;
                      usage.completionTokens = completion_tokens != null ? completion_tokens : void 0;
                      usage.totalTokens = total_tokens != null ? total_tokens : void 0;
                      if ((completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens) != null) {
                        usage.completionTokensDetails.reasoningTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.reasoning_tokens;
                      }
                      if ((completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens) != null) {
                        usage.completionTokensDetails.acceptedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.accepted_prediction_tokens;
                      }
                      if ((completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens) != null) {
                        usage.completionTokensDetails.rejectedPredictionTokens = completion_tokens_details == null ? void 0 : completion_tokens_details.rejected_prediction_tokens;
                      }
                      if ((prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens) != null) {
                        usage.promptTokensDetails.cachedTokens = prompt_tokens_details == null ? void 0 : prompt_tokens_details.cached_tokens;
                      }
                    }
                    const choice = value.choices[0];
                    if ((choice == null ? void 0 : choice.finish_reason) != null) {
                      finishReason = mapOpenAICompatibleFinishReason(
                        choice.finish_reason
                      );
                    }
                    if ((choice == null ? void 0 : choice.delta) == null) {
                      return;
                    }
                    const delta = choice.delta;
                    const reasoningContent = (_a2 = delta.reasoning_content) != null ? _a2 : delta.reasoning;
                    if (reasoningContent) {
                      if (!isActiveReasoning) {
                        controller.enqueue({
                          type: "reasoning-start",
                          id: "reasoning-0"
                        });
                        isActiveReasoning = true;
                      }
                      controller.enqueue({
                        type: "reasoning-delta",
                        id: "reasoning-0",
                        delta: reasoningContent
                      });
                    }
                    if (delta.content) {
                      if (!isActiveText) {
                        controller.enqueue({ type: "text-start", id: "txt-0" });
                        isActiveText = true;
                      }
                      controller.enqueue({
                        type: "text-delta",
                        id: "txt-0",
                        delta: delta.content
                      });
                    }
                    if (delta.tool_calls != null) {
                      for (const toolCallDelta of delta.tool_calls) {
                        const index = toolCallDelta.index;
                        if (toolCalls[index] == null) {
                          if (toolCallDelta.id == null) {
                            throw new InvalidResponseDataError$1({
                              data: toolCallDelta,
                              message: `Expected 'id' to be a string.`
                            });
                          }
                          if (((_b = toolCallDelta.function) == null ? void 0 : _b.name) == null) {
                            throw new InvalidResponseDataError$1({
                              data: toolCallDelta,
                              message: `Expected 'function.name' to be a string.`
                            });
                          }
                          controller.enqueue({
                            type: "tool-input-start",
                            id: toolCallDelta.id,
                            toolName: toolCallDelta.function.name
                          });
                          toolCalls[index] = {
                            id: toolCallDelta.id,
                            type: "function",
                            function: {
                              name: toolCallDelta.function.name,
                              arguments: (_c = toolCallDelta.function.arguments) != null ? _c : ""
                            },
                            hasFinished: false
                          };
                          const toolCall2 = toolCalls[index];
                          if (((_d = toolCall2.function) == null ? void 0 : _d.name) != null && ((_e = toolCall2.function) == null ? void 0 : _e.arguments) != null) {
                            if (toolCall2.function.arguments.length > 0) {
                              controller.enqueue({
                                type: "tool-input-delta",
                                id: toolCall2.id,
                                delta: toolCall2.function.arguments
                              });
                            }
                            if (isParsableJson$1(toolCall2.function.arguments)) {
                              controller.enqueue({
                                type: "tool-input-end",
                                id: toolCall2.id
                              });
                              controller.enqueue({
                                type: "tool-call",
                                toolCallId: (_f = toolCall2.id) != null ? _f : generateId$1(),
                                toolName: toolCall2.function.name,
                                input: toolCall2.function.arguments
                              });
                              toolCall2.hasFinished = true;
                            }
                          }
                          continue;
                        }
                        const toolCall = toolCalls[index];
                        if (toolCall.hasFinished) {
                          continue;
                        }
                        if (((_g = toolCallDelta.function) == null ? void 0 : _g.arguments) != null) {
                          toolCall.function.arguments += (_i = (_h = toolCallDelta.function) == null ? void 0 : _h.arguments) != null ? _i : "";
                        }
                        controller.enqueue({
                          type: "tool-input-delta",
                          id: toolCall.id,
                          delta: (_j = toolCallDelta.function.arguments) != null ? _j : ""
                        });
                        if (((_k = toolCall.function) == null ? void 0 : _k.name) != null && ((_l = toolCall.function) == null ? void 0 : _l.arguments) != null && isParsableJson$1(toolCall.function.arguments)) {
                          controller.enqueue({
                            type: "tool-input-end",
                            id: toolCall.id
                          });
                          controller.enqueue({
                            type: "tool-call",
                            toolCallId: (_m = toolCall.id) != null ? _m : generateId$1(),
                            toolName: toolCall.function.name,
                            input: toolCall.function.arguments
                          });
                          toolCall.hasFinished = true;
                        }
                      }
                    }
                  },
                  flush(controller) {
                    var _a2, _b, _c, _d, _e, _f;
                    if (isActiveReasoning) {
                      controller.enqueue({ type: "reasoning-end", id: "reasoning-0" });
                    }
                    if (isActiveText) {
                      controller.enqueue({ type: "text-end", id: "txt-0" });
                    }
                    for (const toolCall of toolCalls.filter(
                      (toolCall2) => !toolCall2.hasFinished
                    )) {
                      controller.enqueue({
                        type: "tool-input-end",
                        id: toolCall.id
                      });
                      controller.enqueue({
                        type: "tool-call",
                        toolCallId: (_a2 = toolCall.id) != null ? _a2 : generateId$1(),
                        toolName: toolCall.function.name,
                        input: toolCall.function.arguments
                      });
                    }
                    const providerMetadata = {
                      [providerOptionsName]: {},
                      ...metadataExtractor == null ? void 0 : metadataExtractor.buildMetadata()
                    };
                    if (usage.completionTokensDetails.acceptedPredictionTokens != null) {
                      providerMetadata[providerOptionsName].acceptedPredictionTokens = usage.completionTokensDetails.acceptedPredictionTokens;
                    }
                    if (usage.completionTokensDetails.rejectedPredictionTokens != null) {
                      providerMetadata[providerOptionsName].rejectedPredictionTokens = usage.completionTokensDetails.rejectedPredictionTokens;
                    }
                    controller.enqueue({
                      type: "finish",
                      finishReason,
                      usage: {
                        inputTokens: (_b = usage.promptTokens) != null ? _b : void 0,
                        outputTokens: (_c = usage.completionTokens) != null ? _c : void 0,
                        totalTokens: (_d = usage.totalTokens) != null ? _d : void 0,
                        reasoningTokens: (_e = usage.completionTokensDetails.reasoningTokens) != null ? _e : void 0,
                        cachedInputTokens: (_f = usage.promptTokensDetails.cachedTokens) != null ? _f : void 0
                      },
                      providerMetadata
                    });
                  }
                })
              ),
              request: { body },
              response: { headers: responseHeaders }
            };
          }
        };
        var openaiCompatibleTokenUsageSchema = object({
          prompt_tokens: number$1().nullish(),
          completion_tokens: number$1().nullish(),
          total_tokens: number$1().nullish(),
          prompt_tokens_details: object({
            cached_tokens: number$1().nullish()
          }).nullish(),
          completion_tokens_details: object({
            reasoning_tokens: number$1().nullish(),
            accepted_prediction_tokens: number$1().nullish(),
            rejected_prediction_tokens: number$1().nullish()
          }).nullish()
        }).nullish();
        var OpenAICompatibleChatResponseSchema = object({
          id: string().nullish(),
          created: number$1().nullish(),
          model: string().nullish(),
          choices: array(
            object({
              message: object({
                role: literal("assistant").nullish(),
                content: string().nullish(),
                reasoning_content: string().nullish(),
                reasoning: string().nullish(),
                tool_calls: array(
                  object({
                    id: string().nullish(),
                    function: object({
                      name: string(),
                      arguments: string()
                    })
                  })
                ).nullish()
              }),
              finish_reason: string().nullish()
            })
          ),
          usage: openaiCompatibleTokenUsageSchema
        });
        var createOpenAICompatibleChatChunkSchema = (errorSchema) => union([
          object({
            id: string().nullish(),
            created: number$1().nullish(),
            model: string().nullish(),
            choices: array(
              object({
                delta: object({
                  role: _enum(["assistant"]).nullish(),
                  content: string().nullish(),
                  // Most openai-compatible models set `reasoning_content`, but some
                  // providers serving `gpt-oss` set `reasoning`. See #7866
                  reasoning_content: string().nullish(),
                  reasoning: string().nullish(),
                  tool_calls: array(
                    object({
                      index: number$1(),
                      id: string().nullish(),
                      function: object({
                        name: string().nullish(),
                        arguments: string().nullish()
                      })
                    })
                  ).nullish()
                }).nullish(),
                finish_reason: string().nullish()
              })
            ),
            usage: openaiCompatibleTokenUsageSchema
          }),
          errorSchema
        ]);
        function convertToOpenAICompatibleCompletionPrompt({
          prompt,
          user = "user",
          assistant = "assistant"
        }) {
          let text = "";
          if (prompt[0].role === "system") {
            text += `${prompt[0].content}

`;
            prompt = prompt.slice(1);
          }
          for (const { role, content } of prompt) {
            switch (role) {
              case "system": {
                throw new InvalidPromptError$1({
                  message: "Unexpected system message in prompt: ${content}",
                  prompt
                });
              }
              case "user": {
                const userMessage = content.map((part) => {
                  switch (part.type) {
                    case "text": {
                      return part.text;
                    }
                  }
                }).filter(Boolean).join("");
                text += `${user}:
${userMessage}

`;
                break;
              }
              case "assistant": {
                const assistantMessage = content.map((part) => {
                  switch (part.type) {
                    case "text": {
                      return part.text;
                    }
                    case "tool-call": {
                      throw new UnsupportedFunctionalityError$1({
                        functionality: "tool-call messages"
                      });
                    }
                  }
                }).join("");
                text += `${assistant}:
${assistantMessage}

`;
                break;
              }
              case "tool": {
                throw new UnsupportedFunctionalityError$1({
                  functionality: "tool messages"
                });
              }
              default: {
                const _exhaustiveCheck = role;
                throw new Error(`Unsupported role: ${_exhaustiveCheck}`);
              }
            }
          }
          text += `${assistant}:
`;
          return {
            prompt: text,
            stopSequences: [`
${user}:`]
          };
        }

        // src/completion/get-response-metadata.ts
        function getResponseMetadata2({
          id,
          model,
          created
        }) {
          return {
            id: id != null ? id : void 0,
            modelId: model != null ? model : void 0,
            timestamp: created != null ? new Date(created * 1e3) : void 0
          };
        }

        // src/completion/map-openai-compatible-finish-reason.ts
        function mapOpenAICompatibleFinishReason2(finishReason) {
          switch (finishReason) {
            case "stop":
              return "stop";
            case "length":
              return "length";
            case "content_filter":
              return "content-filter";
            case "function_call":
            case "tool_calls":
              return "tool-calls";
            default:
              return "unknown";
          }
        }
        var openaiCompatibleCompletionProviderOptions = object({
          /**
           * Echo back the prompt in addition to the completion.
           */
          echo: boolean().optional(),
          /**
           * Modify the likelihood of specified tokens appearing in the completion.
           *
           * Accepts a JSON object that maps tokens (specified by their token ID in
           * the GPT tokenizer) to an associated bias value from -100 to 100.
           */
          logitBias: record(string(), number$1()).optional(),
          /**
           * The suffix that comes after a completion of inserted text.
           */
          suffix: string().optional(),
          /**
           * A unique identifier representing your end-user, which can help providers to
           * monitor and detect abuse.
           */
          user: string().optional()
        });

        // src/completion/openai-compatible-completion-language-model.ts
        var OpenAICompatibleCompletionLanguageModel = class {
          // type inferred via constructor
          constructor(modelId, config) {
            this.specificationVersion = "v2";
            var _a;
            this.modelId = modelId;
            this.config = config;
            const errorStructure = (_a = config.errorStructure) != null ? _a : defaultOpenAICompatibleErrorStructure;
            this.chunkSchema = createOpenAICompatibleCompletionChunkSchema(
              errorStructure.errorSchema
            );
            this.failedResponseHandler = createJsonErrorResponseHandler$1(errorStructure);
          }
          get provider() {
            return this.config.provider;
          }
          get providerOptionsName() {
            return this.config.provider.split(".")[0].trim();
          }
          get supportedUrls() {
            var _a, _b, _c;
            return (_c = (_b = (_a = this.config).supportedUrls) == null ? void 0 : _b.call(_a)) != null ? _c : {};
          }
          async getArgs({
            prompt,
            maxOutputTokens,
            temperature,
            topP,
            topK,
            frequencyPenalty,
            presencePenalty,
            stopSequences: userStopSequences,
            responseFormat,
            seed,
            providerOptions,
            tools,
            toolChoice
          }) {
            var _a;
            const warnings = [];
            const completionOptions = (_a = await parseProviderOptions({
              provider: this.providerOptionsName,
              providerOptions,
              schema: openaiCompatibleCompletionProviderOptions
            })) != null ? _a : {};
            if (topK != null) {
              warnings.push({ type: "unsupported-setting", setting: "topK" });
            }
            if (tools == null ? void 0 : tools.length) {
              warnings.push({ type: "unsupported-setting", setting: "tools" });
            }
            if (toolChoice != null) {
              warnings.push({ type: "unsupported-setting", setting: "toolChoice" });
            }
            if (responseFormat != null && responseFormat.type !== "text") {
              warnings.push({
                type: "unsupported-setting",
                setting: "responseFormat",
                details: "JSON response format is not supported."
              });
            }
            const { prompt: completionPrompt, stopSequences } = convertToOpenAICompatibleCompletionPrompt({ prompt });
            const stop = [...stopSequences != null ? stopSequences : [], ...userStopSequences != null ? userStopSequences : []];
            return {
              args: {
                // model id:
                model: this.modelId,
                // model specific settings:
                echo: completionOptions.echo,
                logit_bias: completionOptions.logitBias,
                suffix: completionOptions.suffix,
                user: completionOptions.user,
                // standardized settings:
                max_tokens: maxOutputTokens,
                temperature,
                top_p: topP,
                frequency_penalty: frequencyPenalty,
                presence_penalty: presencePenalty,
                seed,
                ...providerOptions == null ? void 0 : providerOptions[this.providerOptionsName],
                // prompt:
                prompt: completionPrompt,
                // stop sequences:
                stop: stop.length > 0 ? stop : void 0
              },
              warnings
            };
          }
          async doGenerate(options) {
            var _a, _b, _c, _d, _e, _f;
            const { args, warnings } = await this.getArgs(options);
            const {
              responseHeaders,
              value: response,
              rawValue: rawResponse
            } = await postJsonToApi$1({
              url: this.config.url({
                path: "/completions",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), options.headers),
              body: args,
              failedResponseHandler: this.failedResponseHandler,
              successfulResponseHandler: createJsonResponseHandler$1(
                openaiCompatibleCompletionResponseSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            const choice = response.choices[0];
            const content = [];
            if (choice.text != null && choice.text.length > 0) {
              content.push({ type: "text", text: choice.text });
            }
            return {
              content,
              usage: {
                inputTokens: (_b = (_a = response.usage) == null ? void 0 : _a.prompt_tokens) != null ? _b : void 0,
                outputTokens: (_d = (_c = response.usage) == null ? void 0 : _c.completion_tokens) != null ? _d : void 0,
                totalTokens: (_f = (_e = response.usage) == null ? void 0 : _e.total_tokens) != null ? _f : void 0
              },
              finishReason: mapOpenAICompatibleFinishReason2(choice.finish_reason),
              request: { body: args },
              response: {
                ...getResponseMetadata2(response),
                headers: responseHeaders,
                body: rawResponse
              },
              warnings
            };
          }
          async doStream(options) {
            const { args, warnings } = await this.getArgs(options);
            const body = {
              ...args,
              stream: true,
              // only include stream_options when in strict compatibility mode:
              stream_options: this.config.includeUsage ? { include_usage: true } : void 0
            };
            const { responseHeaders, value: response } = await postJsonToApi$1({
              url: this.config.url({
                path: "/completions",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), options.headers),
              body,
              failedResponseHandler: this.failedResponseHandler,
              successfulResponseHandler: createEventSourceResponseHandler$1(
                this.chunkSchema
              ),
              abortSignal: options.abortSignal,
              fetch: this.config.fetch
            });
            let finishReason = "unknown";
            const usage = {
              inputTokens: void 0,
              outputTokens: void 0,
              totalTokens: void 0
            };
            let isFirstChunk = true;
            return {
              stream: response.pipeThrough(
                new TransformStream({
                  start(controller) {
                    controller.enqueue({ type: "stream-start", warnings });
                  },
                  transform(chunk, controller) {
                    var _a, _b, _c;
                    if (options.includeRawChunks) {
                      controller.enqueue({ type: "raw", rawValue: chunk.rawValue });
                    }
                    if (!chunk.success) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: chunk.error });
                      return;
                    }
                    const value = chunk.value;
                    if ("error" in value) {
                      finishReason = "error";
                      controller.enqueue({ type: "error", error: value.error });
                      return;
                    }
                    if (isFirstChunk) {
                      isFirstChunk = false;
                      controller.enqueue({
                        type: "response-metadata",
                        ...getResponseMetadata2(value)
                      });
                      controller.enqueue({
                        type: "text-start",
                        id: "0"
                      });
                    }
                    if (value.usage != null) {
                      usage.inputTokens = (_a = value.usage.prompt_tokens) != null ? _a : void 0;
                      usage.outputTokens = (_b = value.usage.completion_tokens) != null ? _b : void 0;
                      usage.totalTokens = (_c = value.usage.total_tokens) != null ? _c : void 0;
                    }
                    const choice = value.choices[0];
                    if ((choice == null ? void 0 : choice.finish_reason) != null) {
                      finishReason = mapOpenAICompatibleFinishReason2(
                        choice.finish_reason
                      );
                    }
                    if ((choice == null ? void 0 : choice.text) != null) {
                      controller.enqueue({
                        type: "text-delta",
                        id: "0",
                        delta: choice.text
                      });
                    }
                  },
                  flush(controller) {
                    if (!isFirstChunk) {
                      controller.enqueue({ type: "text-end", id: "0" });
                    }
                    controller.enqueue({
                      type: "finish",
                      finishReason,
                      usage
                    });
                  }
                })
              ),
              request: { body },
              response: { headers: responseHeaders }
            };
          }
        };
        var usageSchema = object({
          prompt_tokens: number$1(),
          completion_tokens: number$1(),
          total_tokens: number$1()
        });
        var openaiCompatibleCompletionResponseSchema = object({
          id: string().nullish(),
          created: number$1().nullish(),
          model: string().nullish(),
          choices: array(
            object({
              text: string(),
              finish_reason: string()
            })
          ),
          usage: usageSchema.nullish()
        });
        var createOpenAICompatibleCompletionChunkSchema = (errorSchema) => union([
          object({
            id: string().nullish(),
            created: number$1().nullish(),
            model: string().nullish(),
            choices: array(
              object({
                text: string(),
                finish_reason: string().nullish(),
                index: number$1()
              })
            ),
            usage: usageSchema.nullish()
          }),
          errorSchema
        ]);
        var openaiCompatibleEmbeddingProviderOptions = object({
          /**
           * The number of dimensions the resulting output embeddings should have.
           * Only supported in text-embedding-3 and later models.
           */
          dimensions: number$1().optional(),
          /**
           * A unique identifier representing your end-user, which can help providers to
           * monitor and detect abuse.
           */
          user: string().optional()
        });

        // src/embedding/openai-compatible-embedding-model.ts
        var OpenAICompatibleEmbeddingModel = class {
          constructor(modelId, config) {
            this.specificationVersion = "v2";
            this.modelId = modelId;
            this.config = config;
          }
          get provider() {
            return this.config.provider;
          }
          get maxEmbeddingsPerCall() {
            var _a;
            return (_a = this.config.maxEmbeddingsPerCall) != null ? _a : 2048;
          }
          get supportsParallelCalls() {
            var _a;
            return (_a = this.config.supportsParallelCalls) != null ? _a : true;
          }
          get providerOptionsName() {
            return this.config.provider.split(".")[0].trim();
          }
          async doEmbed({
            values,
            headers,
            abortSignal,
            providerOptions
          }) {
            var _a, _b, _c;
            const compatibleOptions = Object.assign(
              (_a = await parseProviderOptions({
                provider: "openai-compatible",
                providerOptions,
                schema: openaiCompatibleEmbeddingProviderOptions
              })) != null ? _a : {},
              (_b = await parseProviderOptions({
                provider: this.providerOptionsName,
                providerOptions,
                schema: openaiCompatibleEmbeddingProviderOptions
              })) != null ? _b : {}
            );
            if (values.length > this.maxEmbeddingsPerCall) {
              throw new TooManyEmbeddingValuesForCallError({
                provider: this.provider,
                modelId: this.modelId,
                maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,
                values
              });
            }
            const {
              responseHeaders,
              value: response,
              rawValue
            } = await postJsonToApi$1({
              url: this.config.url({
                path: "/embeddings",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), headers),
              body: {
                model: this.modelId,
                input: values,
                encoding_format: "float",
                dimensions: compatibleOptions.dimensions,
                user: compatibleOptions.user
              },
              failedResponseHandler: createJsonErrorResponseHandler$1(
                (_c = this.config.errorStructure) != null ? _c : defaultOpenAICompatibleErrorStructure
              ),
              successfulResponseHandler: createJsonResponseHandler$1(
                openaiTextEmbeddingResponseSchema
              ),
              abortSignal,
              fetch: this.config.fetch
            });
            return {
              embeddings: response.data.map((item) => item.embedding),
              usage: response.usage ? { tokens: response.usage.prompt_tokens } : void 0,
              providerMetadata: response.providerMetadata,
              response: { headers: responseHeaders, body: rawValue }
            };
          }
        };
        var openaiTextEmbeddingResponseSchema = object({
          data: array(object({ embedding: array(number$1()) })),
          usage: object({ prompt_tokens: number$1() }).nullish(),
          providerMetadata: record(string(), record(string(), any())).optional()
        });
        var OpenAICompatibleImageModel = class {
          constructor(modelId, config) {
            this.modelId = modelId;
            this.config = config;
            this.specificationVersion = "v2";
            this.maxImagesPerCall = 10;
          }
          get provider() {
            return this.config.provider;
          }
          async doGenerate({
            prompt,
            n,
            size,
            aspectRatio,
            seed,
            providerOptions,
            headers,
            abortSignal
          }) {
            var _a, _b, _c, _d, _e;
            const warnings = [];
            if (aspectRatio != null) {
              warnings.push({
                type: "unsupported-setting",
                setting: "aspectRatio",
                details: "This model does not support aspect ratio. Use `size` instead."
              });
            }
            if (seed != null) {
              warnings.push({ type: "unsupported-setting", setting: "seed" });
            }
            const currentDate = (_c = (_b = (_a = this.config._internal) == null ? void 0 : _a.currentDate) == null ? void 0 : _b.call(_a)) != null ? _c : /* @__PURE__ */ new Date();
            const { value: response, responseHeaders } = await postJsonToApi$1({
              url: this.config.url({
                path: "/images/generations",
                modelId: this.modelId
              }),
              headers: combineHeaders$1(this.config.headers(), headers),
              body: {
                model: this.modelId,
                prompt,
                n,
                size,
                ...(_d = providerOptions.openai) != null ? _d : {},
                response_format: "b64_json"
              },
              failedResponseHandler: createJsonErrorResponseHandler$1(
                (_e = this.config.errorStructure) != null ? _e : defaultOpenAICompatibleErrorStructure
              ),
              successfulResponseHandler: createJsonResponseHandler$1(
                openaiCompatibleImageResponseSchema
              ),
              abortSignal,
              fetch: this.config.fetch
            });
            return {
              images: response.data.map((item) => item.b64_json),
              warnings,
              response: {
                timestamp: currentDate,
                modelId: this.modelId,
                headers: responseHeaders
              }
            };
          }
        };
        var openaiCompatibleImageResponseSchema = object({
          data: array(object({ b64_json: string() }))
        });

        // src/version.ts
        var VERSION = "1.0.22";

        // src/openai-compatible-provider.ts
        function createOpenAICompatible(options) {
          const baseURL = withoutTrailingSlash$1(options.baseURL);
          const providerName = options.name;
          const headers = {
            ...options.apiKey && { Authorization: `Bearer ${options.apiKey}` },
            ...options.headers
          };
          const getHeaders = () => withUserAgentSuffix(headers, `ai-sdk/openai-compatible/${VERSION}`);
          const getCommonModelConfig = (modelType) => ({
            provider: `${providerName}.${modelType}`,
            url: ({ path }) => {
              const url = new URL(`${baseURL}${path}`);
              if (options.queryParams) {
                url.search = new URLSearchParams(options.queryParams).toString();
              }
              return url.toString();
            },
            headers: getHeaders,
            fetch: options.fetch
          });
          const createLanguageModel = (modelId) => createChatModel(modelId);
          const createChatModel = (modelId) => new OpenAICompatibleChatLanguageModel(modelId, {
            ...getCommonModelConfig("chat"),
            includeUsage: options.includeUsage,
            supportsStructuredOutputs: options.supportsStructuredOutputs
          });
          const createCompletionModel = (modelId) => new OpenAICompatibleCompletionLanguageModel(modelId, {
            ...getCommonModelConfig("completion"),
            includeUsage: options.includeUsage
          });
          const createEmbeddingModel = (modelId) => new OpenAICompatibleEmbeddingModel(modelId, {
            ...getCommonModelConfig("embedding")
          });
          const createImageModel = (modelId) => new OpenAICompatibleImageModel(modelId, getCommonModelConfig("image"));
          const provider = (modelId) => createLanguageModel(modelId);
          provider.languageModel = createLanguageModel;
          provider.chatModel = createChatModel;
          provider.completionModel = createCompletionModel;
          provider.textEmbeddingModel = createEmbeddingModel;
          provider.imageModel = createImageModel;
          return provider;
        }

        function buildAgentTree(agents) {
          // Detect and handle circular dependencies
          const safeAgents = detectAndBreakCycles(agents);
          if (safeAgents.length === 0) {
            throw new Error("No executable agent");
          }
          // Establish dependency relationship mapping
          const agentMap = new Map();
          const dependents = new Map();
          for (const agent of safeAgents) {
            agentMap.set(agent.id, agent);
            dependents.set(agent.id, []);
          }
          for (const agent of safeAgents) {
            for (const depId of agent.dependsOn) {
              if (dependents.has(depId)) {
                dependents.get(depId).push(agent);
              }
            }
          }
          let entryAgents = safeAgents.filter((agent) => agent.dependsOn.length === 0);
          if (entryAgents.length === 0) {
            entryAgents = safeAgents.filter((agent) => agent.dependsOn.length == 1 && agent.dependsOn[0].endsWith("00"));
          }
          const processedAgents = new Set();
          function buildNodeRecursive(currentAgents) {
            if (currentAgents.length === 0) {
              return undefined;
            }
            for (const agent of currentAgents) {
              processedAgents.add(agent.id);
            }
            const nextLevelAgents = [];
            const nextLevelSet = new Set();
            for (const agent of currentAgents) {
              const dependentAgents = dependents.get(agent.id) || [];
              for (const dependentAgent of dependentAgents) {
                const allDependenciesProcessed = dependentAgent.dependsOn.every((depId) => processedAgents.has(depId));
                if (allDependenciesProcessed && !nextLevelSet.has(dependentAgent.id)) {
                  nextLevelAgents.push(dependentAgent);
                  nextLevelSet.add(dependentAgent.id);
                }
              }
            }
            const nextNode = buildNodeRecursive(nextLevelAgents);
            if (currentAgents.length === 1) {
              return {
                type: "normal",
                agent: currentAgents[0],
                nextAgent: nextNode,
              };
            }
            else {
              const parallelNodes = currentAgents.map((agent) => ({
                type: "normal",
                agent: agent,
                nextAgent: undefined,
              }));
              return {
                type: "parallel",
                agents: parallelNodes,
                nextAgent: nextNode,
              };
            }
          }
          const rootNode = buildNodeRecursive(entryAgents);
          if (!rootNode) {
            throw new Error("Unable to build execution tree");
          }
          return rootNode;
        }
        function detectAndBreakCycles(agents) {
          // Detect cyclic dependencies and return a safe dependency relationship
          // Use topological sorting algorithm to detect cycles, if a cycle is found, break some dependencies.
          const agentMap = new Map();
          const inDegree = new Map();
          const adjList = new Map();
          for (const agent of agents) {
            agentMap.set(agent.id, agent);
            inDegree.set(agent.id, 0);
            adjList.set(agent.id, []);
          }
          for (const agent of agents) {
            for (const depId of agent.dependsOn) {
              if (agentMap.has(depId)) {
                // depId -> agent.id indicates that the agent depends on depId.
                adjList.get(depId).push(agent.id);
                inDegree.set(agent.id, inDegree.get(agent.id) + 1);
              }
            }
          }
          // Topological Sorting Detects Cycles
          const queue = [];
          const processedCount = new Map();
          for (const [agentId, degree] of inDegree.entries()) {
            if (degree === 0) {
              queue.push(agentId);
            }
            processedCount.set(agentId, 0);
          }
          let processedNodes = 0;
          while (queue.length > 0) {
            const currentId = queue.shift();
            processedNodes++;
            for (const neighborId of adjList.get(currentId)) {
              const newInDegree = inDegree.get(neighborId) - 1;
              inDegree.set(neighborId, newInDegree);
              if (newInDegree === 0) {
                queue.push(neighborId);
              }
            }
          }
          if (processedNodes < agents.length) {
            console.warn("Detected a circular dependency, automatically disconnecting the circular link...");
            const cyclicNodes = new Set();
            for (const [agentId, degree] of inDegree.entries()) {
              if (degree > 0) {
                cyclicNodes.add(agentId);
              }
            }
            const fixedAgents = [];
            for (const agent of agents) {
              if (cyclicNodes.has(agent.id)) {
                const filteredDependsOn = agent.dependsOn.filter((depId) => !cyclicNodes.has(depId) || !agentMap.has(depId));
                // Preserve the shortest path dependency
                if (filteredDependsOn.length === 0 && agent.dependsOn.length > 0) {
                  const firstValidDep = agent.dependsOn.find((depId) => agentMap.has(depId));
                  if (firstValidDep && !cyclicNodes.has(firstValidDep)) {
                    filteredDependsOn.push(firstValidDep);
                  }
                }
                agent.dependsOn = filteredDependsOn;
                fixedAgents.push(agent);
                if (filteredDependsOn.length !== agent.dependsOn.length) {
                  console.warn(`The partial cyclic dependency of agent ${agent.id} has been disconnected.`);
                }
              }
              else {
                // Non-cyclic node, filter out non-existent dependencies
                const validDependsOn = agent.dependsOn.filter((depId) => agentMap.has(depId));
                agent.dependsOn = validDependsOn;
                fixedAgents.push(agent);
              }
            }
            return fixedAgents;
          }
          // No loops, just need to filter out non-existent dependencies
          return agents.map((agent) => {
            agent.dependsOn = agent.dependsOn.filter((depId) => agentMap.has(depId));
            return agent;
          });
        }

        var lib = {};

        var dom = {};

        var conventions = {};

        var hasRequiredConventions;

        function requireConventions() {
          if (hasRequiredConventions) return conventions;
          hasRequiredConventions = 1;

          /**
           * Ponyfill for `Array.prototype.find` which is only available in ES6 runtimes.
           *
           * Works with anything that has a `length` property and index access properties, including NodeList.
           *
           * @template {unknown} T
           * @param {Array<T> | ({length:number, [number]: T})} list
           * @param {function (item: T, index: number, list:Array<T> | ({length:number, [number]: T})):boolean} predicate
           * @param {Partial<Pick<ArrayConstructor['prototype'], 'find'>>?} ac `Array.prototype` by default,
           * 				allows injecting a custom implementation in tests
           * @returns {T | undefined}
           *
           * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/find
           * @see https://tc39.es/ecma262/multipage/indexed-collections.html#sec-array.prototype.find
           */
          function find(list, predicate, ac) {
            if (ac === undefined) {
              ac = Array.prototype;
            }
            if (list && typeof ac.find === 'function') {
              return ac.find.call(list, predicate);
            }
            for (var i = 0; i < list.length; i++) {
              if (Object.prototype.hasOwnProperty.call(list, i)) {
                var item = list[i];
                if (predicate.call(undefined, item, i, list)) {
                  return item;
                }
              }
            }
          }

          /**
           * "Shallow freezes" an object to render it immutable.
           * Uses `Object.freeze` if available,
           * otherwise the immutability is only in the type.
           *
           * Is used to create "enum like" objects.
           *
           * @template T
           * @param {T} object the object to freeze
           * @param {Pick<ObjectConstructor, 'freeze'> = Object} oc `Object` by default,
           * 				allows to inject custom object constructor for tests
           * @returns {Readonly<T>}
           *
           * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze
           */
          function freeze(object, oc) {
            if (oc === undefined) {
              oc = Object;
            }
            return oc && typeof oc.freeze === 'function' ? oc.freeze(object) : object
          }

          /**
           * Since we can not rely on `Object.assign` we provide a simplified version
           * that is sufficient for our needs.
           *
           * @param {Object} target
           * @param {Object | null | undefined} source
           *
           * @returns {Object} target
           * @throws TypeError if target is not an object
           *
           * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
           * @see https://tc39.es/ecma262/multipage/fundamental-objects.html#sec-object.assign
           */
          function assign(target, source) {
            if (target === null || typeof target !== 'object') {
              throw new TypeError('target is not an object')
            }
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
            return target
          }

          /**
           * All mime types that are allowed as input to `DOMParser.parseFromString`
           *
           * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString#Argument02 MDN
           * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#domparsersupportedtype WHATWG HTML Spec
           * @see DOMParser.prototype.parseFromString
           */
          var MIME_TYPE = freeze({
            /**
             * `text/html`, the only mime type that triggers treating an XML document as HTML.
             *
             * @see DOMParser.SupportedType.isHTML
             * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
             * @see https://en.wikipedia.org/wiki/HTML Wikipedia
             * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
             * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
             */
            HTML: 'text/html',

            /**
             * Helper method to check a mime type if it indicates an HTML document
             *
             * @param {string} [value]
             * @returns {boolean}
             *
             * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
             * @see https://en.wikipedia.org/wiki/HTML Wikipedia
             * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
             * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
            isHTML: function (value) {
              return value === MIME_TYPE.HTML
            },

            /**
             * `application/xml`, the standard mime type for XML documents.
             *
             * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
             * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
             * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
             */
            XML_APPLICATION: 'application/xml',

            /**
             * `text/html`, an alias for `application/xml`.
             *
             * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
             * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
             * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
             */
            XML_TEXT: 'text/xml',

            /**
             * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
             * but is parsed as an XML document.
             *
             * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
             * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
             * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
             */
            XML_XHTML_APPLICATION: 'application/xhtml+xml',

            /**
             * `image/svg+xml`,
             *
             * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
             * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
             * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
             */
            XML_SVG_IMAGE: 'image/svg+xml',
          });

          /**
           * Namespaces that are used in this code base.
           *
           * @see http://www.w3.org/TR/REC-xml-names
           */
          var NAMESPACE = freeze({
            /**
             * The XHTML namespace.
             *
             * @see http://www.w3.org/1999/xhtml
             */
            HTML: 'http://www.w3.org/1999/xhtml',

            /**
             * Checks if `uri` equals `NAMESPACE.HTML`.
             *
             * @param {string} [uri]
             *
             * @see NAMESPACE.HTML
             */
            isHTML: function (uri) {
              return uri === NAMESPACE.HTML
            },

            /**
             * The SVG namespace.
             *
             * @see http://www.w3.org/2000/svg
             */
            SVG: 'http://www.w3.org/2000/svg',

            /**
             * The `xml:` namespace.
             *
             * @see http://www.w3.org/XML/1998/namespace
             */
            XML: 'http://www.w3.org/XML/1998/namespace',

            /**
             * The `xmlns:` namespace
             *
             * @see https://www.w3.org/2000/xmlns/
             */
            XMLNS: 'http://www.w3.org/2000/xmlns/',
          });

          conventions.assign = assign;
          conventions.find = find;
          conventions.freeze = freeze;
          conventions.MIME_TYPE = MIME_TYPE;
          conventions.NAMESPACE = NAMESPACE;
          return conventions;
        }

        var hasRequiredDom;

        function requireDom() {
          if (hasRequiredDom) return dom;
          hasRequiredDom = 1;
          var conventions = requireConventions();

          var find = conventions.find;
          var NAMESPACE = conventions.NAMESPACE;

          /**
           * A prerequisite for `[].filter`, to drop elements that are empty
           * @param {string} input
           * @returns {boolean}
           */
          function notEmptyString(input) {
            return input !== ''
          }
          /**
           * @see https://infra.spec.whatwg.org/#split-on-ascii-whitespace
           * @see https://infra.spec.whatwg.org/#ascii-whitespace
           *
           * @param {string} input
           * @returns {string[]} (can be empty)
           */
          function splitOnASCIIWhitespace(input) {
            // U+0009 TAB, U+000A LF, U+000C FF, U+000D CR, U+0020 SPACE
            return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : []
          }

          /**
           * Adds element as a key to current if it is not already present.
           *
           * @param {Record<string, boolean | undefined>} current
           * @param {string} element
           * @returns {Record<string, boolean | undefined>}
           */
          function orderedSetReducer(current, element) {
            if (!current.hasOwnProperty(element)) {
              current[element] = true;
            }
            return current;
          }

          /**
           * @see https://infra.spec.whatwg.org/#ordered-set
           * @param {string} input
           * @returns {string[]}
           */
          function toOrderedSet(input) {
            if (!input) return [];
            var list = splitOnASCIIWhitespace(input);
            return Object.keys(list.reduce(orderedSetReducer, {}))
          }

          /**
           * Uses `list.indexOf` to implement something like `Array.prototype.includes`,
           * which we can not rely on being available.
           *
           * @param {any[]} list
           * @returns {function(any): boolean}
           */
          function arrayIncludes(list) {
            return function (element) {
              return list && list.indexOf(element) !== -1;
            }
          }

          function copy(src, dest) {
            for (var p in src) {
              if (Object.prototype.hasOwnProperty.call(src, p)) {
                dest[p] = src[p];
              }
            }
          }

          /**
          ^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
          ^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
           */
          function _extends(Class, Super) {
            var pt = Class.prototype;
            if (!(pt instanceof Super)) {
              function t() { } t.prototype = Super.prototype;
              t = new t();
              copy(pt, t);
              Class.prototype = pt = t;
            }
            if (pt.constructor != Class) {
              if (typeof Class != 'function') {
                console.error("unknown Class:" + Class);
              }
              pt.constructor = Class;
            }
          }

          // Node Types
          var NodeType = {};
          var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
          var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
          var TEXT_NODE = NodeType.TEXT_NODE = 3;
          var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
          var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
          var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
          var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
          var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
          var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
          var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
          var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
          var NOTATION_NODE = NodeType.NOTATION_NODE = 12;

          // ExceptionCode
          var ExceptionCode = {};
          var ExceptionMessage = {};
          ExceptionCode.INDEX_SIZE_ERR = ((ExceptionMessage[1] = "Index size error"), 1);
          ExceptionCode.DOMSTRING_SIZE_ERR = ((ExceptionMessage[2] = "DOMString size error"), 2);
          var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = ((ExceptionMessage[3] = "Hierarchy request error"), 3);
          ExceptionCode.WRONG_DOCUMENT_ERR = ((ExceptionMessage[4] = "Wrong document"), 4);
          ExceptionCode.INVALID_CHARACTER_ERR = ((ExceptionMessage[5] = "Invalid character"), 5);
          ExceptionCode.NO_DATA_ALLOWED_ERR = ((ExceptionMessage[6] = "No data allowed"), 6);
          ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7] = "No modification allowed"), 7);
          var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = ((ExceptionMessage[8] = "Not found"), 8);
          ExceptionCode.NOT_SUPPORTED_ERR = ((ExceptionMessage[9] = "Not supported"), 9);
          var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = ((ExceptionMessage[10] = "Attribute in use"), 10);
          //level2
          ExceptionCode.INVALID_STATE_ERR = ((ExceptionMessage[11] = "Invalid state"), 11);
          ExceptionCode.SYNTAX_ERR = ((ExceptionMessage[12] = "Syntax error"), 12);
          ExceptionCode.INVALID_MODIFICATION_ERR = ((ExceptionMessage[13] = "Invalid modification"), 13);
          ExceptionCode.NAMESPACE_ERR = ((ExceptionMessage[14] = "Invalid namespace"), 14);
          ExceptionCode.INVALID_ACCESS_ERR = ((ExceptionMessage[15] = "Invalid access"), 15);

          /**
           * DOM Level 2
           * Object DOMException
           * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
           * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
           */
          function DOMException(code, message) {
            if (message instanceof Error) {
              var error = message;
            } else {
              error = this;
              Error.call(this, ExceptionMessage[code]);
              this.message = ExceptionMessage[code];
              if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
            }
            error.code = code;
            if (message) this.message = this.message + ": " + message;
            return error;
          } DOMException.prototype = Error.prototype;
          copy(ExceptionCode, DOMException);

          /**
           * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
           * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
           * The items in the NodeList are accessible via an integral index, starting from 0.
           */
          function NodeList() {
          } NodeList.prototype = {
            /**
             * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
             * @standard level1
             */
            length: 0,
            /**
             * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
             * @standard level1
             * @param index  unsigned long
             *   Index into the collection.
             * @return Node
             * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
             */
            item: function (index) {
              return index >= 0 && index < this.length ? this[index] : null;
            },
            toString: function (isHTML, nodeFilter) {
              for (var buf = [], i = 0; i < this.length; i++) {
                serializeToString(this[i], buf, isHTML, nodeFilter);
              }
              return buf.join('');
            },
            /**
             * @private
             * @param {function (Node):boolean} predicate
             * @returns {Node[]}
             */
            filter: function (predicate) {
              return Array.prototype.filter.call(this, predicate);
            },
            /**
             * @private
             * @param {Node} item
             * @returns {number}
             */
            indexOf: function (item) {
              return Array.prototype.indexOf.call(this, item);
            },
          };

          function LiveNodeList(node, refresh) {
            this._node = node;
            this._refresh = refresh;
            _updateLiveList(this);
          }
          function _updateLiveList(list) {
            var inc = list._node._inc || list._node.ownerDocument._inc;
            if (list._inc !== inc) {
              var ls = list._refresh(list._node);
              __set__(list, 'length', ls.length);
              if (!list.$$length || ls.length < list.$$length) {
                for (var i = ls.length; i in list; i++) {
                  if (Object.prototype.hasOwnProperty.call(list, i)) {
                    delete list[i];
                  }
                }
              }
              copy(ls, list);
              list._inc = inc;
            }
          }
          LiveNodeList.prototype.item = function (i) {
            _updateLiveList(this);
            return this[i] || null;
          };

          _extends(LiveNodeList, NodeList);

          /**
           * Objects implementing the NamedNodeMap interface are used
           * to represent collections of nodes that can be accessed by name.
           * Note that NamedNodeMap does not inherit from NodeList;
           * NamedNodeMaps are not maintained in any particular order.
           * Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index,
           * but this is simply to allow convenient enumeration of the contents of a NamedNodeMap,
           * and does not imply that the DOM specifies an order to these Nodes.
           * NamedNodeMap objects in the DOM are live.
           * used for attributes or DocumentType entities
           */
          function NamedNodeMap() {
          }
          function _findNodeIndex(list, node) {
            var i = list.length;
            while (i--) {
              if (list[i] === node) { return i }
            }
          }

          function _addNamedNode(el, list, newAttr, oldAttr) {
            if (oldAttr) {
              list[_findNodeIndex(list, oldAttr)] = newAttr;
            } else {
              list[list.length++] = newAttr;
            }
            if (el) {
              newAttr.ownerElement = el;
              var doc = el.ownerDocument;
              if (doc) {
                oldAttr && _onRemoveAttribute(doc, el, oldAttr);
                _onAddAttribute(doc, el, newAttr);
              }
            }
          }
          function _removeNamedNode(el, list, attr) {
            //console.log('remove attr:'+attr)
            var i = _findNodeIndex(list, attr);
            if (i >= 0) {
              var lastIndex = list.length - 1;
              while (i < lastIndex) {
                list[i] = list[++i];
              }
              list.length = lastIndex;
              if (el) {
                var doc = el.ownerDocument;
                if (doc) {
                  _onRemoveAttribute(doc, el, attr);
                  attr.ownerElement = null;
                }
              }
            } else {
              throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + '@' + attr))
            }
          }
          NamedNodeMap.prototype = {
            length: 0,
            item: NodeList.prototype.item,
            getNamedItem: function (key) {
              //		if(key.indexOf(':')>0 || key == 'xmlns'){
              //			return null;
              //		}
              //console.log()
              var i = this.length;
              while (i--) {
                var attr = this[i];
                //console.log(attr.nodeName,key)
                if (attr.nodeName == key) {
                  return attr;
                }
              }
            },
            setNamedItem: function (attr) {
              var el = attr.ownerElement;
              if (el && el != this._ownerElement) {
                throw new DOMException(INUSE_ATTRIBUTE_ERR);
              }
              var oldAttr = this.getNamedItem(attr.nodeName);
              _addNamedNode(this._ownerElement, this, attr, oldAttr);
              return oldAttr;
            },
            /* returns Node */
            setNamedItemNS: function (attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
              var el = attr.ownerElement, oldAttr;
              if (el && el != this._ownerElement) {
                throw new DOMException(INUSE_ATTRIBUTE_ERR);
              }
              oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
              _addNamedNode(this._ownerElement, this, attr, oldAttr);
              return oldAttr;
            },

            /* returns Node */
            removeNamedItem: function (key) {
              var attr = this.getNamedItem(key);
              _removeNamedNode(this._ownerElement, this, attr);
              return attr;


            },// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR

            //for level2
            removeNamedItemNS: function (namespaceURI, localName) {
              var attr = this.getNamedItemNS(namespaceURI, localName);
              _removeNamedNode(this._ownerElement, this, attr);
              return attr;
            },
            getNamedItemNS: function (namespaceURI, localName) {
              var i = this.length;
              while (i--) {
                var node = this[i];
                if (node.localName == localName && node.namespaceURI == namespaceURI) {
                  return node;
                }
              }
              return null;
            }
          };

          /**
           * The DOMImplementation interface represents an object providing methods
           * which are not dependent on any particular document.
           * Such an object is returned by the `Document.implementation` property.
           *
           * __The individual methods describe the differences compared to the specs.__
           *
           * @constructor
           *
           * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation MDN
           * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490 DOM Level 1 Core (Initial)
           * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#ID-102161490 DOM Level 2 Core
           * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-102161490 DOM Level 3 Core
           * @see https://dom.spec.whatwg.org/#domimplementation DOM Living Standard
           */
          function DOMImplementation() {
          }

          DOMImplementation.prototype = {
            /**
             * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
             * The different implementations fairly diverged in what kind of features were reported.
             * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
             *
             * @deprecated It is deprecated and modern browsers return true in all cases.
             *
             * @param {string} feature
             * @param {string} [version]
             * @returns {boolean} always true
             *
             * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
             * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
             * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
             */
            hasFeature: function (feature, version) {
              return true;
            },
            /**
             * Creates an XML Document object of the specified type with its document element.
             *
             * __It behaves slightly different from the description in the living standard__:
             * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
             * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
             * - this implementation is not validating names or qualified names
             *   (when parsing XML strings, the SAX parser takes care of that)
             *
             * @param {string|null} namespaceURI
             * @param {string} qualifiedName
             * @param {DocumentType=null} doctype
             * @returns {Document}
             *
             * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
             * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
             * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
             *
             * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
             * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
             * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
             */
            createDocument: function (namespaceURI, qualifiedName, doctype) {
              var doc = new Document();
              doc.implementation = this;
              doc.childNodes = new NodeList();
              doc.doctype = doctype || null;
              if (doctype) {
                doc.appendChild(doctype);
              }
              if (qualifiedName) {
                var root = doc.createElementNS(namespaceURI, qualifiedName);
                doc.appendChild(root);
              }
              return doc;
            },
            /**
             * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
             *
             * __This behavior is slightly different from the in the specs__:
             * - this implementation is not validating names or qualified names
             *   (when parsing XML strings, the SAX parser takes care of that)
             *
             * @param {string} qualifiedName
             * @param {string} [publicId]
             * @param {string} [systemId]
             * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
             * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
             *
             * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
             * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
             * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
             *
             * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
             * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
             * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
             */
            createDocumentType: function (qualifiedName, publicId, systemId) {
              var node = new DocumentType();
              node.name = qualifiedName;
              node.nodeName = qualifiedName;
              node.publicId = publicId || '';
              node.systemId = systemId || '';

              return node;
            }
          };


          /**
           * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
           */

          function Node() {
          }
          Node.prototype = {
            firstChild: null,
            lastChild: null,
            previousSibling: null,
            nextSibling: null,
            attributes: null,
            parentNode: null,
            childNodes: null,
            ownerDocument: null,
            nodeValue: null,
            namespaceURI: null,
            prefix: null,
            localName: null,
            // Modified in DOM Level 2:
            insertBefore: function (newChild, refChild) {//raises
              return _insertBefore(this, newChild, refChild);
            },
            replaceChild: function (newChild, oldChild) {//raises
              _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
              if (oldChild) {
                this.removeChild(oldChild);
              }
            },
            removeChild: function (oldChild) {
              return _removeChild(this, oldChild);
            },
            appendChild: function (newChild) {
              return this.insertBefore(newChild, null);
            },
            hasChildNodes: function () {
              return this.firstChild != null;
            },
            cloneNode: function (deep) {
              return cloneNode(this.ownerDocument || this, this, deep);
            },
            // Modified in DOM Level 2:
            normalize: function () {
              var child = this.firstChild;
              while (child) {
                var next = child.nextSibling;
                if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
                  this.removeChild(next);
                  child.appendData(next.data);
                } else {
                  child.normalize();
                  child = next;
                }
              }
            },
            // Introduced in DOM Level 2:
            isSupported: function (feature, version) {
              return this.ownerDocument.implementation.hasFeature(feature, version);
            },
            // Introduced in DOM Level 2:
            hasAttributes: function () {
              return this.attributes.length > 0;
            },
            /**
             * Look up the prefix associated to the given namespace URI, starting from this node.
             * **The default namespace declarations are ignored by this method.**
             * See Namespace Prefix Lookup for details on the algorithm used by this method.
             *
             * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
             *
             * @param {string | null} namespaceURI
             * @returns {string | null}
             * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
             * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
             * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
             * @see https://github.com/xmldom/xmldom/issues/322
             */
            lookupPrefix: function (namespaceURI) {
              var el = this;
              while (el) {
                var map = el._nsMap;
                //console.dir(map)
                if (map) {
                  for (var n in map) {
                    if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
                      return n;
                    }
                  }
                }
                el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
              }
              return null;
            },
            // Introduced in DOM Level 3:
            lookupNamespaceURI: function (prefix) {
              var el = this;
              while (el) {
                var map = el._nsMap;
                //console.dir(map)
                if (map) {
                  if (Object.prototype.hasOwnProperty.call(map, prefix)) {
                    return map[prefix];
                  }
                }
                el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
              }
              return null;
            },
            // Introduced in DOM Level 3:
            isDefaultNamespace: function (namespaceURI) {
              var prefix = this.lookupPrefix(namespaceURI);
              return prefix == null;
            }
          };


          function _xmlEncoder(c) {
            return c == '<' && '&lt;' ||
              c == '>' && '&gt;' ||
              c == '&' && '&amp;' ||
              c == '"' && '&quot;' ||
              '&#' + c.charCodeAt() + ';'
          }


          copy(NodeType, Node);
          copy(NodeType, Node.prototype);

          /**
           * @param callback return true for continue,false for break
           * @return boolean true: break visit;
           */
          function _visitNode(node, callback) {
            if (callback(node)) {
              return true;
            }
            if (node = node.firstChild) {
              do {
                if (_visitNode(node, callback)) { return true }
              } while (node = node.nextSibling)
            }
          }



          function Document() {
            this.ownerDocument = this;
          }

          function _onAddAttribute(doc, el, newAttr) {
            doc && doc._inc++;
            var ns = newAttr.namespaceURI;
            if (ns === NAMESPACE.XMLNS) {
              //update namespace
              el._nsMap[newAttr.prefix ? newAttr.localName : ''] = newAttr.value;
            }
          }

          function _onRemoveAttribute(doc, el, newAttr, remove) {
            doc && doc._inc++;
            var ns = newAttr.namespaceURI;
            if (ns === NAMESPACE.XMLNS) {
              //update namespace
              delete el._nsMap[newAttr.prefix ? newAttr.localName : ''];
            }
          }

          /**
           * Updates `el.childNodes`, updating the indexed items and it's `length`.
           * Passing `newChild` means it will be appended.
           * Otherwise it's assumed that an item has been removed,
           * and `el.firstNode` and it's `.nextSibling` are used
           * to walk the current list of child nodes.
           *
           * @param {Document} doc
           * @param {Node} el
           * @param {Node} [newChild]
           * @private
           */
          function _onUpdateChild(doc, el, newChild) {
            if (doc && doc._inc) {
              doc._inc++;
              //update childNodes
              var cs = el.childNodes;
              if (newChild) {
                cs[cs.length++] = newChild;
              } else {
                var child = el.firstChild;
                var i = 0;
                while (child) {
                  cs[i++] = child;
                  child = child.nextSibling;
                }
                cs.length = i;
                delete cs[cs.length];
              }
            }
          }

          /**
           * Removes the connections between `parentNode` and `child`
           * and any existing `child.previousSibling` or `child.nextSibling`.
           *
           * @see https://github.com/xmldom/xmldom/issues/135
           * @see https://github.com/xmldom/xmldom/issues/145
           *
           * @param {Node} parentNode
           * @param {Node} child
           * @returns {Node} the child that was removed.
           * @private
           */
          function _removeChild(parentNode, child) {
            var previous = child.previousSibling;
            var next = child.nextSibling;
            if (previous) {
              previous.nextSibling = next;
            } else {
              parentNode.firstChild = next;
            }
            if (next) {
              next.previousSibling = previous;
            } else {
              parentNode.lastChild = previous;
            }
            child.parentNode = null;
            child.previousSibling = null;
            child.nextSibling = null;
            _onUpdateChild(parentNode.ownerDocument, parentNode);
            return child;
          }

          /**
           * Returns `true` if `node` can be a parent for insertion.
           * @param {Node} node
           * @returns {boolean}
           */
          function hasValidParentNodeType(node) {
            return (
              node &&
              (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE)
            );
          }

          /**
           * Returns `true` if `node` can be inserted according to it's `nodeType`.
           * @param {Node} node
           * @returns {boolean}
           */
          function hasInsertableNodeType(node) {
            return (
              node &&
              (isElementNode(node) ||
                isTextNode(node) ||
                isDocTypeNode(node) ||
                node.nodeType === Node.DOCUMENT_FRAGMENT_NODE ||
                node.nodeType === Node.COMMENT_NODE ||
                node.nodeType === Node.PROCESSING_INSTRUCTION_NODE)
            );
          }

          /**
           * Returns true if `node` is a DOCTYPE node
           * @param {Node} node
           * @returns {boolean}
           */
          function isDocTypeNode(node) {
            return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
          }

          /**
           * Returns true if the node is an element
           * @param {Node} node
           * @returns {boolean}
           */
          function isElementNode(node) {
            return node && node.nodeType === Node.ELEMENT_NODE;
          }
          /**
           * Returns true if `node` is a text node
           * @param {Node} node
           * @returns {boolean}
           */
          function isTextNode(node) {
            return node && node.nodeType === Node.TEXT_NODE;
          }

          /**
           * Check if en element node can be inserted before `child`, or at the end if child is falsy,
           * according to the presence and position of a doctype node on the same level.
           *
           * @param {Document} doc The document node
           * @param {Node} child the node that would become the nextSibling if the element would be inserted
           * @returns {boolean} `true` if an element can be inserted before child
           * @private
           * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
           */
          function isElementInsertionPossible(doc, child) {
            var parentChildNodes = doc.childNodes || [];
            if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
              return false;
            }
            var docTypeNode = find(parentChildNodes, isDocTypeNode);
            return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
          }

          /**
           * Check if en element node can be inserted before `child`, or at the end if child is falsy,
           * according to the presence and position of a doctype node on the same level.
           *
           * @param {Node} doc The document node
           * @param {Node} child the node that would become the nextSibling if the element would be inserted
           * @returns {boolean} `true` if an element can be inserted before child
           * @private
           * https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
           */
          function isElementReplacementPossible(doc, child) {
            var parentChildNodes = doc.childNodes || [];

            function hasElementChildThatIsNotChild(node) {
              return isElementNode(node) && node !== child;
            }

            if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
              return false;
            }
            var docTypeNode = find(parentChildNodes, isDocTypeNode);
            return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
          }

          /**
           * @private
           * Steps 1-5 of the checks before inserting and before replacing a child are the same.
           *
           * @param {Node} parent the parent node to insert `node` into
           * @param {Node} node the node to insert
           * @param {Node=} child the node that should become the `nextSibling` of `node`
           * @returns {Node}
           * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
           * @throws DOMException if `child` is provided but is not a child of `parent`.
           * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
           * @see https://dom.spec.whatwg.org/#concept-node-replace
           */
          function assertPreInsertionValidity1to5(parent, node, child) {
            // 1. If `parent` is not a Document, DocumentFragment, or Element node, then throw a "HierarchyRequestError" DOMException.
            if (!hasValidParentNodeType(parent)) {
              throw new DOMException(HIERARCHY_REQUEST_ERR, 'Unexpected parent node type ' + parent.nodeType);
            }
            // 2. If `node` is a host-including inclusive ancestor of `parent`, then throw a "HierarchyRequestError" DOMException.
            // not implemented!
            // 3. If `child` is non-null and its parent is not `parent`, then throw a "NotFoundError" DOMException.
            if (child && child.parentNode !== parent) {
              throw new DOMException(NOT_FOUND_ERR, 'child not in parent');
            }
            if (
              // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
              !hasInsertableNodeType(node) ||
              // 5. If either `node` is a Text node and `parent` is a document,
              // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
              // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
              // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
              (isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE)
            ) {
              throw new DOMException(
                HIERARCHY_REQUEST_ERR,
                'Unexpected node type ' + node.nodeType + ' for parent node type ' + parent.nodeType
              );
            }
          }

          /**
           * @private
           * Step 6 of the checks before inserting and before replacing a child are different.
           *
           * @param {Document} parent the parent node to insert `node` into
           * @param {Node} node the node to insert
           * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
           * @returns {Node}
           * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
           * @throws DOMException if `child` is provided but is not a child of `parent`.
           * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
           * @see https://dom.spec.whatwg.org/#concept-node-replace
           */
          function assertPreInsertionValidityInDocument(parent, node, child) {
            var parentChildNodes = parent.childNodes || [];
            var nodeChildNodes = node.childNodes || [];

            // DocumentFragment
            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
              var nodeChildElements = nodeChildNodes.filter(isElementNode);
              // If node has more than one element child or has a Text node child.
              if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
              }
              // Otherwise, if `node` has one element child and either `parent` has an element child,
              // `child` is a doctype, or `child` is non-null and a doctype is following `child`.
              if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
              }
            }
            // Element
            if (isElementNode(node)) {
              // `parent` has an element child, `child` is a doctype,
              // or `child` is non-null and a doctype is following `child`.
              if (!isElementInsertionPossible(parent, child)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
              }
            }
            // DocumentType
            if (isDocTypeNode(node)) {
              // `parent` has a doctype child,
              if (find(parentChildNodes, isDocTypeNode)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
              }
              var parentElementChild = find(parentChildNodes, isElementNode);
              // `child` is non-null and an element is preceding `child`,
              if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
              }
              // or `child` is null and `parent` has an element child.
              if (!child && parentElementChild) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can not be appended since element is present');
              }
            }
          }

          /**
           * @private
           * Step 6 of the checks before inserting and before replacing a child are different.
           *
           * @param {Document} parent the parent node to insert `node` into
           * @param {Node} node the node to insert
           * @param {Node | undefined} child the node that should become the `nextSibling` of `node`
           * @returns {Node}
           * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
           * @throws DOMException if `child` is provided but is not a child of `parent`.
           * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
           * @see https://dom.spec.whatwg.org/#concept-node-replace
           */
          function assertPreReplacementValidityInDocument(parent, node, child) {
            var parentChildNodes = parent.childNodes || [];
            var nodeChildNodes = node.childNodes || [];

            // DocumentFragment
            if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
              var nodeChildElements = nodeChildNodes.filter(isElementNode);
              // If `node` has more than one element child or has a Text node child.
              if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, 'More than one element or text in fragment');
              }
              // Otherwise, if `node` has one element child and either `parent` has an element child that is not `child` or a doctype is following `child`.
              if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Element in fragment can not be inserted before doctype');
              }
            }
            // Element
            if (isElementNode(node)) {
              // `parent` has an element child that is not `child` or a doctype is following `child`.
              if (!isElementReplacementPossible(parent, child)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one element can be added and only after doctype');
              }
            }
            // DocumentType
            if (isDocTypeNode(node)) {
              function hasDoctypeChildThatIsNotChild(node) {
                return isDocTypeNode(node) && node !== child;
              }

              // `parent` has a doctype child that is not `child`,
              if (find(parentChildNodes, hasDoctypeChildThatIsNotChild)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Only one doctype is allowed');
              }
              var parentElementChild = find(parentChildNodes, isElementNode);
              // or an element is preceding `child`.
              if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
                throw new DOMException(HIERARCHY_REQUEST_ERR, 'Doctype can only be inserted before an element');
              }
            }
          }

          /**
           * @private
           * @param {Node} parent the parent node to insert `node` into
           * @param {Node} node the node to insert
           * @param {Node=} child the node that should become the `nextSibling` of `node`
           * @returns {Node}
           * @throws DOMException for several node combinations that would create a DOM that is not well-formed.
           * @throws DOMException if `child` is provided but is not a child of `parent`.
           * @see https://dom.spec.whatwg.org/#concept-node-ensure-pre-insertion-validity
           */
          function _insertBefore(parent, node, child, _inDocumentAssertion) {
            // To ensure pre-insertion validity of a node into a parent before a child, run these steps:
            assertPreInsertionValidity1to5(parent, node, child);

            // If parent is a document, and any of the statements below, switched on the interface node implements,
            // are true, then throw a "HierarchyRequestError" DOMException.
            if (parent.nodeType === Node.DOCUMENT_NODE) {
              (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
            }

            var cp = node.parentNode;
            if (cp) {
              cp.removeChild(node);//remove and update
            }
            if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
              var newFirst = node.firstChild;
              if (newFirst == null) {
                return node;
              }
              var newLast = node.lastChild;
            } else {
              newFirst = newLast = node;
            }
            var pre = child ? child.previousSibling : parent.lastChild;

            newFirst.previousSibling = pre;
            newLast.nextSibling = child;


            if (pre) {
              pre.nextSibling = newFirst;
            } else {
              parent.firstChild = newFirst;
            }
            if (child == null) {
              parent.lastChild = newLast;
            } else {
              child.previousSibling = newLast;
            }
            do {
              newFirst.parentNode = parent;
              // Update ownerDocument for each node being inserted
              var targetDoc = parent.ownerDocument || parent;
              _updateOwnerDocument(newFirst, targetDoc);
            } while (newFirst !== newLast && (newFirst = newFirst.nextSibling))
            _onUpdateChild(parent.ownerDocument || parent, parent);
            //console.log(parent.lastChild.nextSibling == null)
            if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
              node.firstChild = node.lastChild = null;
            }
            return node;
          }

          /**
           * Recursively updates the ownerDocument property for a node and all its descendants
           * @param {Node} node
           * @param {Document} newOwnerDocument
           * @private
           */
          function _updateOwnerDocument(node, newOwnerDocument) {
            if (node.ownerDocument === newOwnerDocument) {
              return;
            }

            node.ownerDocument = newOwnerDocument;

            // Update attributes if this is an element
            if (node.nodeType === ELEMENT_NODE && node.attributes) {
              for (var i = 0; i < node.attributes.length; i++) {
                var attr = node.attributes.item(i);
                if (attr) {
                  attr.ownerDocument = newOwnerDocument;
                }
              }
            }

            // Recursively update child nodes
            var child = node.firstChild;
            while (child) {
              _updateOwnerDocument(child, newOwnerDocument);
              child = child.nextSibling;
            }
          }

          /**
           * Appends `newChild` to `parentNode`.
           * If `newChild` is already connected to a `parentNode` it is first removed from it.
           *
           * @see https://github.com/xmldom/xmldom/issues/135
           * @see https://github.com/xmldom/xmldom/issues/145
           * @param {Node} parentNode
           * @param {Node} newChild
           * @returns {Node}
           * @private
           */
          function _appendSingleChild(parentNode, newChild) {
            if (newChild.parentNode) {
              newChild.parentNode.removeChild(newChild);
            }
            newChild.parentNode = parentNode;
            newChild.previousSibling = parentNode.lastChild;
            newChild.nextSibling = null;
            if (newChild.previousSibling) {
              newChild.previousSibling.nextSibling = newChild;
            } else {
              parentNode.firstChild = newChild;
            }
            parentNode.lastChild = newChild;
            _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);

            // Update ownerDocument for the new child and all its descendants
            var targetDoc = parentNode.ownerDocument || parentNode;
            _updateOwnerDocument(newChild, targetDoc);

            return newChild;
          }

          Document.prototype = {
            //implementation : null,
            nodeName: '#document',
            nodeType: DOCUMENT_NODE,
            /**
             * The DocumentType node of the document.
             *
             * @readonly
             * @type DocumentType
             */
            doctype: null,
            documentElement: null,
            _inc: 1,

            insertBefore: function (newChild, refChild) {//raises
              if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
                var child = newChild.firstChild;
                while (child) {
                  var next = child.nextSibling;
                  this.insertBefore(child, refChild);
                  child = next;
                }
                return newChild;
              }
              _insertBefore(this, newChild, refChild);
              _updateOwnerDocument(newChild, this);
              if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
                this.documentElement = newChild;
              }

              return newChild;
            },
            removeChild: function (oldChild) {
              if (this.documentElement == oldChild) {
                this.documentElement = null;
              }
              return _removeChild(this, oldChild);
            },
            replaceChild: function (newChild, oldChild) {
              //raises
              _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
              _updateOwnerDocument(newChild, this);
              if (oldChild) {
                this.removeChild(oldChild);
              }
              if (isElementNode(newChild)) {
                this.documentElement = newChild;
              }
            },
            // Introduced in DOM Level 2:
            importNode: function (importedNode, deep) {
              return importNode(this, importedNode, deep);
            },
            // Introduced in DOM Level 2:
            getElementById: function (id) {
              var rtv = null;
              _visitNode(this.documentElement, function (node) {
                if (node.nodeType == ELEMENT_NODE) {
                  if (node.getAttribute('id') == id) {
                    rtv = node;
                    return true;
                  }
                }
              });
              return rtv;
            },

            /**
             * The `getElementsByClassName` method of `Document` interface returns an array-like object
             * of all child elements which have **all** of the given class name(s).
             *
             * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
             *
             *
             * Warning: This is a live LiveNodeList.
             * Changes in the DOM will reflect in the array as the changes occur.
             * If an element selected by this array no longer qualifies for the selector,
             * it will automatically be removed. Be aware of this for iteration purposes.
             *
             * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
             *
             * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
             * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
             */
            getElementsByClassName: function (classNames) {
              var classNamesSet = toOrderedSet(classNames);
              return new LiveNodeList(this, function (base) {
                var ls = [];
                if (classNamesSet.length > 0) {
                  _visitNode(base.documentElement, function (node) {
                    if (node !== base && node.nodeType === ELEMENT_NODE) {
                      var nodeClassNames = node.getAttribute('class');
                      // can be null if the attribute does not exist
                      if (nodeClassNames) {
                        // before splitting and iterating just compare them for the most common case
                        var matches = classNames === nodeClassNames;
                        if (!matches) {
                          var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                          matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                        }
                        if (matches) {
                          ls.push(node);
                        }
                      }
                    }
                  });
                }
                return ls;
              });
            },

            //document factory method:
            createElement: function (tagName) {
              var node = new Element();
              node.ownerDocument = this;
              node.nodeName = tagName;
              node.tagName = tagName;
              node.localName = tagName;
              node.childNodes = new NodeList();
              var attrs = node.attributes = new NamedNodeMap();
              attrs._ownerElement = node;
              return node;
            },
            createDocumentFragment: function () {
              var node = new DocumentFragment();
              node.ownerDocument = this;
              node.childNodes = new NodeList();
              return node;
            },
            createTextNode: function (data) {
              var node = new Text();
              node.ownerDocument = this;
              node.appendData(data);
              return node;
            },
            createComment: function (data) {
              var node = new Comment();
              node.ownerDocument = this;
              node.appendData(data);
              return node;
            },
            createCDATASection: function (data) {
              var node = new CDATASection();
              node.ownerDocument = this;
              node.appendData(data);
              return node;
            },
            createProcessingInstruction: function (target, data) {
              var node = new ProcessingInstruction();
              node.ownerDocument = this;
              node.tagName = node.nodeName = node.target = target;
              node.nodeValue = node.data = data;
              return node;
            },
            createAttribute: function (name) {
              var node = new Attr();
              node.ownerDocument = this;
              node.name = name;
              node.nodeName = name;
              node.localName = name;
              node.specified = true;
              return node;
            },
            createEntityReference: function (name) {
              var node = new EntityReference();
              node.ownerDocument = this;
              node.nodeName = name;
              return node;
            },
            // Introduced in DOM Level 2:
            createElementNS: function (namespaceURI, qualifiedName) {
              var node = new Element();
              var pl = qualifiedName.split(':');
              var attrs = node.attributes = new NamedNodeMap();
              node.childNodes = new NodeList();
              node.ownerDocument = this;
              node.nodeName = qualifiedName;
              node.tagName = qualifiedName;
              node.namespaceURI = namespaceURI;
              if (pl.length == 2) {
                node.prefix = pl[0];
                node.localName = pl[1];
              } else {
                //el.prefix = null;
                node.localName = qualifiedName;
              }
              attrs._ownerElement = node;
              return node;
            },
            // Introduced in DOM Level 2:
            createAttributeNS: function (namespaceURI, qualifiedName) {
              var node = new Attr();
              var pl = qualifiedName.split(':');
              node.ownerDocument = this;
              node.nodeName = qualifiedName;
              node.name = qualifiedName;
              node.namespaceURI = namespaceURI;
              node.specified = true;
              if (pl.length == 2) {
                node.prefix = pl[0];
                node.localName = pl[1];
              } else {
                //el.prefix = null;
                node.localName = qualifiedName;
              }
              return node;
            }
          };
          _extends(Document, Node);


          function Element() {
            this._nsMap = {};
          } Element.prototype = {
            nodeType: ELEMENT_NODE,
            hasAttribute: function (name) {
              return this.getAttributeNode(name) != null;
            },
            getAttribute: function (name) {
              var attr = this.getAttributeNode(name);
              return attr && attr.value || '';
            },
            getAttributeNode: function (name) {
              return this.attributes.getNamedItem(name);
            },
            setAttribute: function (name, value) {
              var attr = this.ownerDocument.createAttribute(name);
              attr.value = attr.nodeValue = "" + value;
              this.setAttributeNode(attr);
            },
            removeAttribute: function (name) {
              var attr = this.getAttributeNode(name);
              attr && this.removeAttributeNode(attr);
            },

            //four real opeartion method
            appendChild: function (newChild) {
              if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
                return this.insertBefore(newChild, null);
              } else {
                return _appendSingleChild(this, newChild);
              }
            },
            setAttributeNode: function (newAttr) {
              return this.attributes.setNamedItem(newAttr);
            },
            setAttributeNodeNS: function (newAttr) {
              return this.attributes.setNamedItemNS(newAttr);
            },
            removeAttributeNode: function (oldAttr) {
              //console.log(this == oldAttr.ownerElement)
              return this.attributes.removeNamedItem(oldAttr.nodeName);
            },
            //get real attribute name,and remove it by removeAttributeNode
            removeAttributeNS: function (namespaceURI, localName) {
              var old = this.getAttributeNodeNS(namespaceURI, localName);
              old && this.removeAttributeNode(old);
            },

            hasAttributeNS: function (namespaceURI, localName) {
              return this.getAttributeNodeNS(namespaceURI, localName) != null;
            },
            getAttributeNS: function (namespaceURI, localName) {
              var attr = this.getAttributeNodeNS(namespaceURI, localName);
              return attr && attr.value || '';
            },
            setAttributeNS: function (namespaceURI, qualifiedName, value) {
              var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
              attr.value = attr.nodeValue = "" + value;
              this.setAttributeNode(attr);
            },
            getAttributeNodeNS: function (namespaceURI, localName) {
              return this.attributes.getNamedItemNS(namespaceURI, localName);
            },

            getElementsByTagName: function (tagName) {
              return new LiveNodeList(this, function (base) {
                var ls = [];
                _visitNode(base, function (node) {
                  if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)) {
                    ls.push(node);
                  }
                });
                return ls;
              });
            },
            getElementsByTagNameNS: function (namespaceURI, localName) {
              return new LiveNodeList(this, function (base) {
                var ls = [];
                _visitNode(base, function (node) {
                  if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)) {
                    ls.push(node);
                  }
                });
                return ls;

              });
            }
          };
          Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
          Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


          _extends(Element, Node);
          function Attr() {
          } Attr.prototype.nodeType = ATTRIBUTE_NODE;
          _extends(Attr, Node);


          function CharacterData() {
          } CharacterData.prototype = {
            data: '',
            substringData: function (offset, count) {
              return this.data.substring(offset, offset + count);
            },
            appendData: function (text) {
              text = this.data + text;
              this.nodeValue = this.data = text;
              this.length = text.length;
            },
            insertData: function (offset, text) {
              this.replaceData(offset, 0, text);

            },
            appendChild: function (newChild) {
              throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
            },
            deleteData: function (offset, count) {
              this.replaceData(offset, count, "");
            },
            replaceData: function (offset, count, text) {
              var start = this.data.substring(0, offset);
              var end = this.data.substring(offset + count);
              text = start + text + end;
              this.nodeValue = this.data = text;
              this.length = text.length;
            }
          };
          _extends(CharacterData, Node);
          function Text() {
          } Text.prototype = {
            nodeName: "#text",
            nodeType: TEXT_NODE,
            splitText: function (offset) {
              var text = this.data;
              var newText = text.substring(offset);
              text = text.substring(0, offset);
              this.data = this.nodeValue = text;
              this.length = text.length;
              var newNode = this.ownerDocument.createTextNode(newText);
              if (this.parentNode) {
                this.parentNode.insertBefore(newNode, this.nextSibling);
              }
              return newNode;
            }
          };
          _extends(Text, CharacterData);
          function Comment() {
          } Comment.prototype = {
            nodeName: "#comment",
            nodeType: COMMENT_NODE
          };
          _extends(Comment, CharacterData);

          function CDATASection() {
          } CDATASection.prototype = {
            nodeName: "#cdata-section",
            nodeType: CDATA_SECTION_NODE
          };
          _extends(CDATASection, CharacterData);


          function DocumentType() {
          } DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
          _extends(DocumentType, Node);

          function Notation() {
          } Notation.prototype.nodeType = NOTATION_NODE;
          _extends(Notation, Node);

          function Entity() {
          } Entity.prototype.nodeType = ENTITY_NODE;
          _extends(Entity, Node);

          function EntityReference() {
          } EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
          _extends(EntityReference, Node);

          function DocumentFragment() {
          } DocumentFragment.prototype.nodeName = "#document-fragment";
          DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
          _extends(DocumentFragment, Node);


          function ProcessingInstruction() {
          }
          ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
          _extends(ProcessingInstruction, Node);
          function XMLSerializer() { }
          XMLSerializer.prototype.serializeToString = function (node, isHtml, nodeFilter) {
            return nodeSerializeToString.call(node, isHtml, nodeFilter);
          };
          Node.prototype.toString = nodeSerializeToString;
          function nodeSerializeToString(isHtml, nodeFilter) {
            var buf = [];
            var refNode = this.nodeType == 9 && this.documentElement || this;
            var prefix = refNode.prefix;
            var uri = refNode.namespaceURI;

            if (uri && prefix == null) {
              //console.log(prefix)
              var prefix = refNode.lookupPrefix(uri);
              if (prefix == null) {
                //isHTML = true;
                var visibleNamespaces = [
                  { namespace: uri, prefix: null }
                  //{namespace:uri,prefix:''}
                ];
              }
            }
            serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
            //console.log('###',this.nodeType,uri,prefix,buf.join(''))
            return buf.join('');
          }

          function needNamespaceDefine(node, isHTML, visibleNamespaces) {
            var prefix = node.prefix || '';
            var uri = node.namespaceURI;
            // According to [Namespaces in XML 1.0](https://www.w3.org/TR/REC-xml-names/#ns-using) ,
            // and more specifically https://www.w3.org/TR/REC-xml-names/#nsc-NoPrefixUndecl :
            // > In a namespace declaration for a prefix [...], the attribute value MUST NOT be empty.
            // in a similar manner [Namespaces in XML 1.1](https://www.w3.org/TR/xml-names11/#ns-using)
            // and more specifically https://www.w3.org/TR/xml-names11/#nsc-NSDeclared :
            // > [...] Furthermore, the attribute value [...] must not be an empty string.
            // so serializing empty namespace value like xmlns:ds="" would produce an invalid XML document.
            if (!uri) {
              return false;
            }
            if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
              return false;
            }

            var i = visibleNamespaces.length;
            while (i--) {
              var ns = visibleNamespaces[i];
              // get namespace prefix
              if (ns.prefix === prefix) {
                return ns.namespace !== uri;
              }
            }
            return true;
          }
          /**
           * Well-formed constraint: No < in Attribute Values
           * > The replacement text of any entity referred to directly or indirectly
           * > in an attribute value must not contain a <.
           * @see https://www.w3.org/TR/xml11/#CleanAttrVals
           * @see https://www.w3.org/TR/xml11/#NT-AttValue
           *
           * Literal whitespace other than space that appear in attribute values
           * are serialized as their entity references, so they will be preserved.
           * (In contrast to whitespace literals in the input which are normalized to spaces)
           * @see https://www.w3.org/TR/xml11/#AVNormalize
           * @see https://w3c.github.io/DOM-Parsing/#serializing-an-element-s-attributes
           */
          function addSerializedAttribute(buf, qualifiedName, value) {
            buf.push(' ', qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
          }

          function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
            if (!visibleNamespaces) {
              visibleNamespaces = [];
            }

            if (nodeFilter) {
              node = nodeFilter(node);
              if (node) {
                if (typeof node == 'string') {
                  buf.push(node);
                  return;
                }
              } else {
                return;
              }
              //buf.sort.apply(attrs, attributeSorter);
            }

            switch (node.nodeType) {
              case ELEMENT_NODE:
                var attrs = node.attributes;
                var len = attrs.length;
                var child = node.firstChild;
                var nodeName = node.tagName;

                isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;

                var prefixedNodeName = nodeName;
                if (!isHTML && !node.prefix && node.namespaceURI) {
                  var defaultNS;
                  // lookup current default ns from `xmlns` attribute
                  for (var ai = 0; ai < attrs.length; ai++) {
                    if (attrs.item(ai).name === 'xmlns') {
                      defaultNS = attrs.item(ai).value;
                      break
                    }
                  }
                  if (!defaultNS) {
                    // lookup current default ns in visibleNamespaces
                    for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                      var namespace = visibleNamespaces[nsi];
                      if (namespace.prefix === '' && namespace.namespace === node.namespaceURI) {
                        defaultNS = namespace.namespace;
                        break
                      }
                    }
                  }
                  if (defaultNS !== node.namespaceURI) {
                    for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                      var namespace = visibleNamespaces[nsi];
                      if (namespace.namespace === node.namespaceURI) {
                        if (namespace.prefix) {
                          prefixedNodeName = namespace.prefix + ':' + nodeName;
                        }
                        break
                      }
                    }
                  }
                }

                buf.push('<', prefixedNodeName);

                for (var i = 0; i < len; i++) {
                  // add namespaces for attributes
                  var attr = attrs.item(i);
                  if (attr.prefix == 'xmlns') {
                    visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
                  } else if (attr.nodeName == 'xmlns') {
                    visibleNamespaces.push({ prefix: '', namespace: attr.value });
                  }
                }

                for (var i = 0; i < len; i++) {
                  var attr = attrs.item(i);
                  if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
                    var prefix = attr.prefix || '';
                    var uri = attr.namespaceURI;
                    addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
                    visibleNamespaces.push({ prefix: prefix, namespace: uri });
                  }
                  serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
                }

                // add namespace for current node
                if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
                  var prefix = node.prefix || '';
                  var uri = node.namespaceURI;
                  addSerializedAttribute(buf, prefix ? 'xmlns:' + prefix : "xmlns", uri);
                  visibleNamespaces.push({ prefix: prefix, namespace: uri });
                }

                if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
                  buf.push('>');
                  //if is cdata child node
                  if (isHTML && /^script$/i.test(nodeName)) {
                    while (child) {
                      if (child.data) {
                        buf.push(child.data);
                      } else {
                        serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                      }
                      child = child.nextSibling;
                    }
                  } else {
                    while (child) {
                      serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                      child = child.nextSibling;
                    }
                  }
                  buf.push('</', prefixedNodeName, '>');
                } else {
                  buf.push('/>');
                }
                // remove added visible namespaces
                //visibleNamespaces.length = startVisibleNamespaces;
                return;
              case DOCUMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                var child = node.firstChild;
                while (child) {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                  child = child.nextSibling;
                }
                return;
              case ATTRIBUTE_NODE:
                return addSerializedAttribute(buf, node.name, node.value);
              case TEXT_NODE:
                /**
                 * The ampersand character (&) and the left angle bracket (<) must not appear in their literal form,
                 * except when used as markup delimiters, or within a comment, a processing instruction, or a CDATA section.
                 * If they are needed elsewhere, they must be escaped using either numeric character references or the strings
                 * `&amp;` and `&lt;` respectively.
                 * The right angle bracket (>) may be represented using the string " &gt; ", and must, for compatibility,
                 * be escaped using either `&gt;` or a character reference when it appears in the string `]]>` in content,
                 * when that string is not marking the end of a CDATA section.
                 *
                 * In the content of elements, character data is any string of characters
                 * which does not contain the start-delimiter of any markup
                 * and does not include the CDATA-section-close delimiter, `]]>`.
                 *
                 * @see https://www.w3.org/TR/xml/#NT-CharData
                 * @see https://w3c.github.io/DOM-Parsing/#xml-serializing-a-text-node
                 */
                return buf.push(node.data
                  .replace(/[<&>]/g, _xmlEncoder)
                );
              case CDATA_SECTION_NODE:
                return buf.push('<![CDATA[', node.data, ']]>');
              case COMMENT_NODE:
                return buf.push("<!--", node.data, "-->");
              case DOCUMENT_TYPE_NODE:
                var pubid = node.publicId;
                var sysid = node.systemId;
                buf.push('<!DOCTYPE ', node.name);
                if (pubid) {
                  buf.push(' PUBLIC ', pubid);
                  if (sysid && sysid != '.') {
                    buf.push(' ', sysid);
                  }
                  buf.push('>');
                } else if (sysid && sysid != '.') {
                  buf.push(' SYSTEM ', sysid, '>');
                } else {
                  var sub = node.internalSubset;
                  if (sub) {
                    buf.push(" [", sub, "]");
                  }
                  buf.push(">");
                }
                return;
              case PROCESSING_INSTRUCTION_NODE:
                return buf.push("<?", node.target, " ", node.data, "?>");
              case ENTITY_REFERENCE_NODE:
                return buf.push('&', node.nodeName, ';');
              //case ENTITY_NODE:
              //case NOTATION_NODE:
              default:
                buf.push('??', node.nodeName);
            }
          }
          function importNode(doc, node, deep) {
            var node2;
            switch (node.nodeType) {
              case ELEMENT_NODE:
                node2 = node.cloneNode(false);
                node2.ownerDocument = doc;
              //var attrs = node2.attributes;
              //var len = attrs.length;
              //for(var i=0;i<len;i++){
              //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
              //}
              case DOCUMENT_FRAGMENT_NODE:
                break;
              case ATTRIBUTE_NODE:
                deep = true;
                break;
              //case ENTITY_REFERENCE_NODE:
              //case PROCESSING_INSTRUCTION_NODE:
              ////case TEXT_NODE:
              //case CDATA_SECTION_NODE:
              //case COMMENT_NODE:
              //	deep = false;
              //	break;
              //case DOCUMENT_NODE:
              //case DOCUMENT_TYPE_NODE:
              //cannot be imported.
              //case ENTITY_NODE:
              //case NOTATION_NODE：
              //can not hit in level3
              //default:throw e;
            }
            if (!node2) {
              node2 = node.cloneNode(false);//false
            }
            node2.ownerDocument = doc;
            node2.parentNode = null;
            if (deep) {
              var child = node.firstChild;
              while (child) {
                node2.appendChild(importNode(doc, child, deep));
                child = child.nextSibling;
              }
            }
            return node2;
          }
          //
          //var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
          //					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
          function cloneNode(doc, node, deep) {
            var node2 = new node.constructor();
            for (var n in node) {
              if (Object.prototype.hasOwnProperty.call(node, n)) {
                var v = node[n];
                if (typeof v != "object") {
                  if (v != node2[n]) {
                    node2[n] = v;
                  }
                }
              }
            }
            if (node.childNodes) {
              node2.childNodes = new NodeList();
            }
            node2.ownerDocument = doc;
            switch (node2.nodeType) {
              case ELEMENT_NODE:
                var attrs = node.attributes;
                var attrs2 = node2.attributes = new NamedNodeMap();
                var len = attrs.length;
                attrs2._ownerElement = node2;
                for (var i = 0; i < len; i++) {
                  node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
                }
                break; case ATTRIBUTE_NODE:
                deep = true;
            }
            if (deep) {
              var child = node.firstChild;
              while (child) {
                node2.appendChild(cloneNode(doc, child, deep));
                child = child.nextSibling;
              }
            }
            return node2;
          }

          function __set__(object, key, value) {
            object[key] = value;
          }
          //do dynamic
          try {
            if (Object.defineProperty) {
              Object.defineProperty(LiveNodeList.prototype, 'length', {
                get: function () {
                  _updateLiveList(this);
                  return this.$$length;
                }
              });

              Object.defineProperty(Node.prototype, 'textContent', {
                get: function () {
                  return getTextContent(this);
                },

                set: function (data) {
                  switch (this.nodeType) {
                    case ELEMENT_NODE:
                    case DOCUMENT_FRAGMENT_NODE:
                      while (this.firstChild) {
                        this.removeChild(this.firstChild);
                      }
                      if (data || String(data)) {
                        this.appendChild(this.ownerDocument.createTextNode(data));
                      }
                      break;

                    default:
                      this.data = data;
                      this.value = data;
                      this.nodeValue = data;
                  }
                }
              });

              function getTextContent(node) {
                switch (node.nodeType) {
                  case ELEMENT_NODE:
                  case DOCUMENT_FRAGMENT_NODE:
                    var buf = [];
                    node = node.firstChild;
                    while (node) {
                      if (node.nodeType !== 7 && node.nodeType !== 8) {
                        buf.push(getTextContent(node));
                      }
                      node = node.nextSibling;
                    }
                    return buf.join('');
                  default:
                    return node.nodeValue;
                }
              }

              __set__ = function (object, key, value) {
                //console.log(value)
                object['$$' + key] = value;
              };
            }
          } catch (e) {//ie8
          }

          //if(typeof require == 'function'){
          dom.DocumentType = DocumentType;
          dom.DOMException = DOMException;
          dom.DOMImplementation = DOMImplementation;
          dom.Element = Element;
          dom.Node = Node;
          dom.NodeList = NodeList;
          dom.XMLSerializer = XMLSerializer;
          //}
          return dom;
        }

        var domParser = {};

        var entities = {};

        var hasRequiredEntities;

        function requireEntities() {
          if (hasRequiredEntities) return entities;
          hasRequiredEntities = 1;
          (function (exports) {

            var freeze = requireConventions().freeze;

            /**
             * The entities that are predefined in every XML document.
             *
             * @see https://www.w3.org/TR/2006/REC-xml11-20060816/#sec-predefined-ent W3C XML 1.1
             * @see https://www.w3.org/TR/2008/REC-xml-20081126/#sec-predefined-ent W3C XML 1.0
             * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Predefined_entities_in_XML Wikipedia
             */
            exports.XML_ENTITIES = freeze({
              amp: '&',
              apos: "'",
              gt: '>',
              lt: '<',
              quot: '"',
            });

            /**
             * A map of all entities that are detected in an HTML document.
             * They contain all entries from `XML_ENTITIES`.
             *
             * @see XML_ENTITIES
             * @see DOMParser.parseFromString
             * @see DOMImplementation.prototype.createHTMLDocument
             * @see https://html.spec.whatwg.org/#named-character-references WHATWG HTML(5) Spec
             * @see https://html.spec.whatwg.org/entities.json JSON
             * @see https://www.w3.org/TR/xml-entity-names/ W3C XML Entity Names
             * @see https://www.w3.org/TR/html4/sgml/entities.html W3C HTML4/SGML
             * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Character_entity_references_in_HTML Wikipedia (HTML)
             * @see https://en.wikipedia.org/wiki/List_of_XML_and_HTML_character_entity_references#Entities_representing_special_characters_in_XHTML Wikpedia (XHTML)
             */
            exports.HTML_ENTITIES = freeze({
              Aacute: '\u00C1',
              aacute: '\u00E1',
              Abreve: '\u0102',
              abreve: '\u0103',
              ac: '\u223E',
              acd: '\u223F',
              acE: '\u223E\u0333',
              Acirc: '\u00C2',
              acirc: '\u00E2',
              acute: '\u00B4',
              Acy: '\u0410',
              acy: '\u0430',
              AElig: '\u00C6',
              aelig: '\u00E6',
              af: '\u2061',
              Afr: '\uD835\uDD04',
              afr: '\uD835\uDD1E',
              Agrave: '\u00C0',
              agrave: '\u00E0',
              alefsym: '\u2135',
              aleph: '\u2135',
              Alpha: '\u0391',
              alpha: '\u03B1',
              Amacr: '\u0100',
              amacr: '\u0101',
              amalg: '\u2A3F',
              AMP: '\u0026',
              amp: '\u0026',
              And: '\u2A53',
              and: '\u2227',
              andand: '\u2A55',
              andd: '\u2A5C',
              andslope: '\u2A58',
              andv: '\u2A5A',
              ang: '\u2220',
              ange: '\u29A4',
              angle: '\u2220',
              angmsd: '\u2221',
              angmsdaa: '\u29A8',
              angmsdab: '\u29A9',
              angmsdac: '\u29AA',
              angmsdad: '\u29AB',
              angmsdae: '\u29AC',
              angmsdaf: '\u29AD',
              angmsdag: '\u29AE',
              angmsdah: '\u29AF',
              angrt: '\u221F',
              angrtvb: '\u22BE',
              angrtvbd: '\u299D',
              angsph: '\u2222',
              angst: '\u00C5',
              angzarr: '\u237C',
              Aogon: '\u0104',
              aogon: '\u0105',
              Aopf: '\uD835\uDD38',
              aopf: '\uD835\uDD52',
              ap: '\u2248',
              apacir: '\u2A6F',
              apE: '\u2A70',
              ape: '\u224A',
              apid: '\u224B',
              apos: '\u0027',
              ApplyFunction: '\u2061',
              approx: '\u2248',
              approxeq: '\u224A',
              Aring: '\u00C5',
              aring: '\u00E5',
              Ascr: '\uD835\uDC9C',
              ascr: '\uD835\uDCB6',
              Assign: '\u2254',
              ast: '\u002A',
              asymp: '\u2248',
              asympeq: '\u224D',
              Atilde: '\u00C3',
              atilde: '\u00E3',
              Auml: '\u00C4',
              auml: '\u00E4',
              awconint: '\u2233',
              awint: '\u2A11',
              backcong: '\u224C',
              backepsilon: '\u03F6',
              backprime: '\u2035',
              backsim: '\u223D',
              backsimeq: '\u22CD',
              Backslash: '\u2216',
              Barv: '\u2AE7',
              barvee: '\u22BD',
              Barwed: '\u2306',
              barwed: '\u2305',
              barwedge: '\u2305',
              bbrk: '\u23B5',
              bbrktbrk: '\u23B6',
              bcong: '\u224C',
              Bcy: '\u0411',
              bcy: '\u0431',
              bdquo: '\u201E',
              becaus: '\u2235',
              Because: '\u2235',
              because: '\u2235',
              bemptyv: '\u29B0',
              bepsi: '\u03F6',
              bernou: '\u212C',
              Bernoullis: '\u212C',
              Beta: '\u0392',
              beta: '\u03B2',
              beth: '\u2136',
              between: '\u226C',
              Bfr: '\uD835\uDD05',
              bfr: '\uD835\uDD1F',
              bigcap: '\u22C2',
              bigcirc: '\u25EF',
              bigcup: '\u22C3',
              bigodot: '\u2A00',
              bigoplus: '\u2A01',
              bigotimes: '\u2A02',
              bigsqcup: '\u2A06',
              bigstar: '\u2605',
              bigtriangledown: '\u25BD',
              bigtriangleup: '\u25B3',
              biguplus: '\u2A04',
              bigvee: '\u22C1',
              bigwedge: '\u22C0',
              bkarow: '\u290D',
              blacklozenge: '\u29EB',
              blacksquare: '\u25AA',
              blacktriangle: '\u25B4',
              blacktriangledown: '\u25BE',
              blacktriangleleft: '\u25C2',
              blacktriangleright: '\u25B8',
              blank: '\u2423',
              blk12: '\u2592',
              blk14: '\u2591',
              blk34: '\u2593',
              block: '\u2588',
              bne: '\u003D\u20E5',
              bnequiv: '\u2261\u20E5',
              bNot: '\u2AED',
              bnot: '\u2310',
              Bopf: '\uD835\uDD39',
              bopf: '\uD835\uDD53',
              bot: '\u22A5',
              bottom: '\u22A5',
              bowtie: '\u22C8',
              boxbox: '\u29C9',
              boxDL: '\u2557',
              boxDl: '\u2556',
              boxdL: '\u2555',
              boxdl: '\u2510',
              boxDR: '\u2554',
              boxDr: '\u2553',
              boxdR: '\u2552',
              boxdr: '\u250C',
              boxH: '\u2550',
              boxh: '\u2500',
              boxHD: '\u2566',
              boxHd: '\u2564',
              boxhD: '\u2565',
              boxhd: '\u252C',
              boxHU: '\u2569',
              boxHu: '\u2567',
              boxhU: '\u2568',
              boxhu: '\u2534',
              boxminus: '\u229F',
              boxplus: '\u229E',
              boxtimes: '\u22A0',
              boxUL: '\u255D',
              boxUl: '\u255C',
              boxuL: '\u255B',
              boxul: '\u2518',
              boxUR: '\u255A',
              boxUr: '\u2559',
              boxuR: '\u2558',
              boxur: '\u2514',
              boxV: '\u2551',
              boxv: '\u2502',
              boxVH: '\u256C',
              boxVh: '\u256B',
              boxvH: '\u256A',
              boxvh: '\u253C',
              boxVL: '\u2563',
              boxVl: '\u2562',
              boxvL: '\u2561',
              boxvl: '\u2524',
              boxVR: '\u2560',
              boxVr: '\u255F',
              boxvR: '\u255E',
              boxvr: '\u251C',
              bprime: '\u2035',
              Breve: '\u02D8',
              breve: '\u02D8',
              brvbar: '\u00A6',
              Bscr: '\u212C',
              bscr: '\uD835\uDCB7',
              bsemi: '\u204F',
              bsim: '\u223D',
              bsime: '\u22CD',
              bsol: '\u005C',
              bsolb: '\u29C5',
              bsolhsub: '\u27C8',
              bull: '\u2022',
              bullet: '\u2022',
              bump: '\u224E',
              bumpE: '\u2AAE',
              bumpe: '\u224F',
              Bumpeq: '\u224E',
              bumpeq: '\u224F',
              Cacute: '\u0106',
              cacute: '\u0107',
              Cap: '\u22D2',
              cap: '\u2229',
              capand: '\u2A44',
              capbrcup: '\u2A49',
              capcap: '\u2A4B',
              capcup: '\u2A47',
              capdot: '\u2A40',
              CapitalDifferentialD: '\u2145',
              caps: '\u2229\uFE00',
              caret: '\u2041',
              caron: '\u02C7',
              Cayleys: '\u212D',
              ccaps: '\u2A4D',
              Ccaron: '\u010C',
              ccaron: '\u010D',
              Ccedil: '\u00C7',
              ccedil: '\u00E7',
              Ccirc: '\u0108',
              ccirc: '\u0109',
              Cconint: '\u2230',
              ccups: '\u2A4C',
              ccupssm: '\u2A50',
              Cdot: '\u010A',
              cdot: '\u010B',
              cedil: '\u00B8',
              Cedilla: '\u00B8',
              cemptyv: '\u29B2',
              cent: '\u00A2',
              CenterDot: '\u00B7',
              centerdot: '\u00B7',
              Cfr: '\u212D',
              cfr: '\uD835\uDD20',
              CHcy: '\u0427',
              chcy: '\u0447',
              check: '\u2713',
              checkmark: '\u2713',
              Chi: '\u03A7',
              chi: '\u03C7',
              cir: '\u25CB',
              circ: '\u02C6',
              circeq: '\u2257',
              circlearrowleft: '\u21BA',
              circlearrowright: '\u21BB',
              circledast: '\u229B',
              circledcirc: '\u229A',
              circleddash: '\u229D',
              CircleDot: '\u2299',
              circledR: '\u00AE',
              circledS: '\u24C8',
              CircleMinus: '\u2296',
              CirclePlus: '\u2295',
              CircleTimes: '\u2297',
              cirE: '\u29C3',
              cire: '\u2257',
              cirfnint: '\u2A10',
              cirmid: '\u2AEF',
              cirscir: '\u29C2',
              ClockwiseContourIntegral: '\u2232',
              CloseCurlyDoubleQuote: '\u201D',
              CloseCurlyQuote: '\u2019',
              clubs: '\u2663',
              clubsuit: '\u2663',
              Colon: '\u2237',
              colon: '\u003A',
              Colone: '\u2A74',
              colone: '\u2254',
              coloneq: '\u2254',
              comma: '\u002C',
              commat: '\u0040',
              comp: '\u2201',
              compfn: '\u2218',
              complement: '\u2201',
              complexes: '\u2102',
              cong: '\u2245',
              congdot: '\u2A6D',
              Congruent: '\u2261',
              Conint: '\u222F',
              conint: '\u222E',
              ContourIntegral: '\u222E',
              Copf: '\u2102',
              copf: '\uD835\uDD54',
              coprod: '\u2210',
              Coproduct: '\u2210',
              COPY: '\u00A9',
              copy: '\u00A9',
              copysr: '\u2117',
              CounterClockwiseContourIntegral: '\u2233',
              crarr: '\u21B5',
              Cross: '\u2A2F',
              cross: '\u2717',
              Cscr: '\uD835\uDC9E',
              cscr: '\uD835\uDCB8',
              csub: '\u2ACF',
              csube: '\u2AD1',
              csup: '\u2AD0',
              csupe: '\u2AD2',
              ctdot: '\u22EF',
              cudarrl: '\u2938',
              cudarrr: '\u2935',
              cuepr: '\u22DE',
              cuesc: '\u22DF',
              cularr: '\u21B6',
              cularrp: '\u293D',
              Cup: '\u22D3',
              cup: '\u222A',
              cupbrcap: '\u2A48',
              CupCap: '\u224D',
              cupcap: '\u2A46',
              cupcup: '\u2A4A',
              cupdot: '\u228D',
              cupor: '\u2A45',
              cups: '\u222A\uFE00',
              curarr: '\u21B7',
              curarrm: '\u293C',
              curlyeqprec: '\u22DE',
              curlyeqsucc: '\u22DF',
              curlyvee: '\u22CE',
              curlywedge: '\u22CF',
              curren: '\u00A4',
              curvearrowleft: '\u21B6',
              curvearrowright: '\u21B7',
              cuvee: '\u22CE',
              cuwed: '\u22CF',
              cwconint: '\u2232',
              cwint: '\u2231',
              cylcty: '\u232D',
              Dagger: '\u2021',
              dagger: '\u2020',
              daleth: '\u2138',
              Darr: '\u21A1',
              dArr: '\u21D3',
              darr: '\u2193',
              dash: '\u2010',
              Dashv: '\u2AE4',
              dashv: '\u22A3',
              dbkarow: '\u290F',
              dblac: '\u02DD',
              Dcaron: '\u010E',
              dcaron: '\u010F',
              Dcy: '\u0414',
              dcy: '\u0434',
              DD: '\u2145',
              dd: '\u2146',
              ddagger: '\u2021',
              ddarr: '\u21CA',
              DDotrahd: '\u2911',
              ddotseq: '\u2A77',
              deg: '\u00B0',
              Del: '\u2207',
              Delta: '\u0394',
              delta: '\u03B4',
              demptyv: '\u29B1',
              dfisht: '\u297F',
              Dfr: '\uD835\uDD07',
              dfr: '\uD835\uDD21',
              dHar: '\u2965',
              dharl: '\u21C3',
              dharr: '\u21C2',
              DiacriticalAcute: '\u00B4',
              DiacriticalDot: '\u02D9',
              DiacriticalDoubleAcute: '\u02DD',
              DiacriticalGrave: '\u0060',
              DiacriticalTilde: '\u02DC',
              diam: '\u22C4',
              Diamond: '\u22C4',
              diamond: '\u22C4',
              diamondsuit: '\u2666',
              diams: '\u2666',
              die: '\u00A8',
              DifferentialD: '\u2146',
              digamma: '\u03DD',
              disin: '\u22F2',
              div: '\u00F7',
              divide: '\u00F7',
              divideontimes: '\u22C7',
              divonx: '\u22C7',
              DJcy: '\u0402',
              djcy: '\u0452',
              dlcorn: '\u231E',
              dlcrop: '\u230D',
              dollar: '\u0024',
              Dopf: '\uD835\uDD3B',
              dopf: '\uD835\uDD55',
              Dot: '\u00A8',
              dot: '\u02D9',
              DotDot: '\u20DC',
              doteq: '\u2250',
              doteqdot: '\u2251',
              DotEqual: '\u2250',
              dotminus: '\u2238',
              dotplus: '\u2214',
              dotsquare: '\u22A1',
              doublebarwedge: '\u2306',
              DoubleContourIntegral: '\u222F',
              DoubleDot: '\u00A8',
              DoubleDownArrow: '\u21D3',
              DoubleLeftArrow: '\u21D0',
              DoubleLeftRightArrow: '\u21D4',
              DoubleLeftTee: '\u2AE4',
              DoubleLongLeftArrow: '\u27F8',
              DoubleLongLeftRightArrow: '\u27FA',
              DoubleLongRightArrow: '\u27F9',
              DoubleRightArrow: '\u21D2',
              DoubleRightTee: '\u22A8',
              DoubleUpArrow: '\u21D1',
              DoubleUpDownArrow: '\u21D5',
              DoubleVerticalBar: '\u2225',
              DownArrow: '\u2193',
              Downarrow: '\u21D3',
              downarrow: '\u2193',
              DownArrowBar: '\u2913',
              DownArrowUpArrow: '\u21F5',
              DownBreve: '\u0311',
              downdownarrows: '\u21CA',
              downharpoonleft: '\u21C3',
              downharpoonright: '\u21C2',
              DownLeftRightVector: '\u2950',
              DownLeftTeeVector: '\u295E',
              DownLeftVector: '\u21BD',
              DownLeftVectorBar: '\u2956',
              DownRightTeeVector: '\u295F',
              DownRightVector: '\u21C1',
              DownRightVectorBar: '\u2957',
              DownTee: '\u22A4',
              DownTeeArrow: '\u21A7',
              drbkarow: '\u2910',
              drcorn: '\u231F',
              drcrop: '\u230C',
              Dscr: '\uD835\uDC9F',
              dscr: '\uD835\uDCB9',
              DScy: '\u0405',
              dscy: '\u0455',
              dsol: '\u29F6',
              Dstrok: '\u0110',
              dstrok: '\u0111',
              dtdot: '\u22F1',
              dtri: '\u25BF',
              dtrif: '\u25BE',
              duarr: '\u21F5',
              duhar: '\u296F',
              dwangle: '\u29A6',
              DZcy: '\u040F',
              dzcy: '\u045F',
              dzigrarr: '\u27FF',
              Eacute: '\u00C9',
              eacute: '\u00E9',
              easter: '\u2A6E',
              Ecaron: '\u011A',
              ecaron: '\u011B',
              ecir: '\u2256',
              Ecirc: '\u00CA',
              ecirc: '\u00EA',
              ecolon: '\u2255',
              Ecy: '\u042D',
              ecy: '\u044D',
              eDDot: '\u2A77',
              Edot: '\u0116',
              eDot: '\u2251',
              edot: '\u0117',
              ee: '\u2147',
              efDot: '\u2252',
              Efr: '\uD835\uDD08',
              efr: '\uD835\uDD22',
              eg: '\u2A9A',
              Egrave: '\u00C8',
              egrave: '\u00E8',
              egs: '\u2A96',
              egsdot: '\u2A98',
              el: '\u2A99',
              Element: '\u2208',
              elinters: '\u23E7',
              ell: '\u2113',
              els: '\u2A95',
              elsdot: '\u2A97',
              Emacr: '\u0112',
              emacr: '\u0113',
              empty: '\u2205',
              emptyset: '\u2205',
              EmptySmallSquare: '\u25FB',
              emptyv: '\u2205',
              EmptyVerySmallSquare: '\u25AB',
              emsp: '\u2003',
              emsp13: '\u2004',
              emsp14: '\u2005',
              ENG: '\u014A',
              eng: '\u014B',
              ensp: '\u2002',
              Eogon: '\u0118',
              eogon: '\u0119',
              Eopf: '\uD835\uDD3C',
              eopf: '\uD835\uDD56',
              epar: '\u22D5',
              eparsl: '\u29E3',
              eplus: '\u2A71',
              epsi: '\u03B5',
              Epsilon: '\u0395',
              epsilon: '\u03B5',
              epsiv: '\u03F5',
              eqcirc: '\u2256',
              eqcolon: '\u2255',
              eqsim: '\u2242',
              eqslantgtr: '\u2A96',
              eqslantless: '\u2A95',
              Equal: '\u2A75',
              equals: '\u003D',
              EqualTilde: '\u2242',
              equest: '\u225F',
              Equilibrium: '\u21CC',
              equiv: '\u2261',
              equivDD: '\u2A78',
              eqvparsl: '\u29E5',
              erarr: '\u2971',
              erDot: '\u2253',
              Escr: '\u2130',
              escr: '\u212F',
              esdot: '\u2250',
              Esim: '\u2A73',
              esim: '\u2242',
              Eta: '\u0397',
              eta: '\u03B7',
              ETH: '\u00D0',
              eth: '\u00F0',
              Euml: '\u00CB',
              euml: '\u00EB',
              euro: '\u20AC',
              excl: '\u0021',
              exist: '\u2203',
              Exists: '\u2203',
              expectation: '\u2130',
              ExponentialE: '\u2147',
              exponentiale: '\u2147',
              fallingdotseq: '\u2252',
              Fcy: '\u0424',
              fcy: '\u0444',
              female: '\u2640',
              ffilig: '\uFB03',
              fflig: '\uFB00',
              ffllig: '\uFB04',
              Ffr: '\uD835\uDD09',
              ffr: '\uD835\uDD23',
              filig: '\uFB01',
              FilledSmallSquare: '\u25FC',
              FilledVerySmallSquare: '\u25AA',
              fjlig: '\u0066\u006A',
              flat: '\u266D',
              fllig: '\uFB02',
              fltns: '\u25B1',
              fnof: '\u0192',
              Fopf: '\uD835\uDD3D',
              fopf: '\uD835\uDD57',
              ForAll: '\u2200',
              forall: '\u2200',
              fork: '\u22D4',
              forkv: '\u2AD9',
              Fouriertrf: '\u2131',
              fpartint: '\u2A0D',
              frac12: '\u00BD',
              frac13: '\u2153',
              frac14: '\u00BC',
              frac15: '\u2155',
              frac16: '\u2159',
              frac18: '\u215B',
              frac23: '\u2154',
              frac25: '\u2156',
              frac34: '\u00BE',
              frac35: '\u2157',
              frac38: '\u215C',
              frac45: '\u2158',
              frac56: '\u215A',
              frac58: '\u215D',
              frac78: '\u215E',
              frasl: '\u2044',
              frown: '\u2322',
              Fscr: '\u2131',
              fscr: '\uD835\uDCBB',
              gacute: '\u01F5',
              Gamma: '\u0393',
              gamma: '\u03B3',
              Gammad: '\u03DC',
              gammad: '\u03DD',
              gap: '\u2A86',
              Gbreve: '\u011E',
              gbreve: '\u011F',
              Gcedil: '\u0122',
              Gcirc: '\u011C',
              gcirc: '\u011D',
              Gcy: '\u0413',
              gcy: '\u0433',
              Gdot: '\u0120',
              gdot: '\u0121',
              gE: '\u2267',
              ge: '\u2265',
              gEl: '\u2A8C',
              gel: '\u22DB',
              geq: '\u2265',
              geqq: '\u2267',
              geqslant: '\u2A7E',
              ges: '\u2A7E',
              gescc: '\u2AA9',
              gesdot: '\u2A80',
              gesdoto: '\u2A82',
              gesdotol: '\u2A84',
              gesl: '\u22DB\uFE00',
              gesles: '\u2A94',
              Gfr: '\uD835\uDD0A',
              gfr: '\uD835\uDD24',
              Gg: '\u22D9',
              gg: '\u226B',
              ggg: '\u22D9',
              gimel: '\u2137',
              GJcy: '\u0403',
              gjcy: '\u0453',
              gl: '\u2277',
              gla: '\u2AA5',
              glE: '\u2A92',
              glj: '\u2AA4',
              gnap: '\u2A8A',
              gnapprox: '\u2A8A',
              gnE: '\u2269',
              gne: '\u2A88',
              gneq: '\u2A88',
              gneqq: '\u2269',
              gnsim: '\u22E7',
              Gopf: '\uD835\uDD3E',
              gopf: '\uD835\uDD58',
              grave: '\u0060',
              GreaterEqual: '\u2265',
              GreaterEqualLess: '\u22DB',
              GreaterFullEqual: '\u2267',
              GreaterGreater: '\u2AA2',
              GreaterLess: '\u2277',
              GreaterSlantEqual: '\u2A7E',
              GreaterTilde: '\u2273',
              Gscr: '\uD835\uDCA2',
              gscr: '\u210A',
              gsim: '\u2273',
              gsime: '\u2A8E',
              gsiml: '\u2A90',
              Gt: '\u226B',
              GT: '\u003E',
              gt: '\u003E',
              gtcc: '\u2AA7',
              gtcir: '\u2A7A',
              gtdot: '\u22D7',
              gtlPar: '\u2995',
              gtquest: '\u2A7C',
              gtrapprox: '\u2A86',
              gtrarr: '\u2978',
              gtrdot: '\u22D7',
              gtreqless: '\u22DB',
              gtreqqless: '\u2A8C',
              gtrless: '\u2277',
              gtrsim: '\u2273',
              gvertneqq: '\u2269\uFE00',
              gvnE: '\u2269\uFE00',
              Hacek: '\u02C7',
              hairsp: '\u200A',
              half: '\u00BD',
              hamilt: '\u210B',
              HARDcy: '\u042A',
              hardcy: '\u044A',
              hArr: '\u21D4',
              harr: '\u2194',
              harrcir: '\u2948',
              harrw: '\u21AD',
              Hat: '\u005E',
              hbar: '\u210F',
              Hcirc: '\u0124',
              hcirc: '\u0125',
              hearts: '\u2665',
              heartsuit: '\u2665',
              hellip: '\u2026',
              hercon: '\u22B9',
              Hfr: '\u210C',
              hfr: '\uD835\uDD25',
              HilbertSpace: '\u210B',
              hksearow: '\u2925',
              hkswarow: '\u2926',
              hoarr: '\u21FF',
              homtht: '\u223B',
              hookleftarrow: '\u21A9',
              hookrightarrow: '\u21AA',
              Hopf: '\u210D',
              hopf: '\uD835\uDD59',
              horbar: '\u2015',
              HorizontalLine: '\u2500',
              Hscr: '\u210B',
              hscr: '\uD835\uDCBD',
              hslash: '\u210F',
              Hstrok: '\u0126',
              hstrok: '\u0127',
              HumpDownHump: '\u224E',
              HumpEqual: '\u224F',
              hybull: '\u2043',
              hyphen: '\u2010',
              Iacute: '\u00CD',
              iacute: '\u00ED',
              ic: '\u2063',
              Icirc: '\u00CE',
              icirc: '\u00EE',
              Icy: '\u0418',
              icy: '\u0438',
              Idot: '\u0130',
              IEcy: '\u0415',
              iecy: '\u0435',
              iexcl: '\u00A1',
              iff: '\u21D4',
              Ifr: '\u2111',
              ifr: '\uD835\uDD26',
              Igrave: '\u00CC',
              igrave: '\u00EC',
              ii: '\u2148',
              iiiint: '\u2A0C',
              iiint: '\u222D',
              iinfin: '\u29DC',
              iiota: '\u2129',
              IJlig: '\u0132',
              ijlig: '\u0133',
              Im: '\u2111',
              Imacr: '\u012A',
              imacr: '\u012B',
              image: '\u2111',
              ImaginaryI: '\u2148',
              imagline: '\u2110',
              imagpart: '\u2111',
              imath: '\u0131',
              imof: '\u22B7',
              imped: '\u01B5',
              Implies: '\u21D2',
              in: '\u2208',
              incare: '\u2105',
              infin: '\u221E',
              infintie: '\u29DD',
              inodot: '\u0131',
              Int: '\u222C',
              int: '\u222B',
              intcal: '\u22BA',
              integers: '\u2124',
              Integral: '\u222B',
              intercal: '\u22BA',
              Intersection: '\u22C2',
              intlarhk: '\u2A17',
              intprod: '\u2A3C',
              InvisibleComma: '\u2063',
              InvisibleTimes: '\u2062',
              IOcy: '\u0401',
              iocy: '\u0451',
              Iogon: '\u012E',
              iogon: '\u012F',
              Iopf: '\uD835\uDD40',
              iopf: '\uD835\uDD5A',
              Iota: '\u0399',
              iota: '\u03B9',
              iprod: '\u2A3C',
              iquest: '\u00BF',
              Iscr: '\u2110',
              iscr: '\uD835\uDCBE',
              isin: '\u2208',
              isindot: '\u22F5',
              isinE: '\u22F9',
              isins: '\u22F4',
              isinsv: '\u22F3',
              isinv: '\u2208',
              it: '\u2062',
              Itilde: '\u0128',
              itilde: '\u0129',
              Iukcy: '\u0406',
              iukcy: '\u0456',
              Iuml: '\u00CF',
              iuml: '\u00EF',
              Jcirc: '\u0134',
              jcirc: '\u0135',
              Jcy: '\u0419',
              jcy: '\u0439',
              Jfr: '\uD835\uDD0D',
              jfr: '\uD835\uDD27',
              jmath: '\u0237',
              Jopf: '\uD835\uDD41',
              jopf: '\uD835\uDD5B',
              Jscr: '\uD835\uDCA5',
              jscr: '\uD835\uDCBF',
              Jsercy: '\u0408',
              jsercy: '\u0458',
              Jukcy: '\u0404',
              jukcy: '\u0454',
              Kappa: '\u039A',
              kappa: '\u03BA',
              kappav: '\u03F0',
              Kcedil: '\u0136',
              kcedil: '\u0137',
              Kcy: '\u041A',
              kcy: '\u043A',
              Kfr: '\uD835\uDD0E',
              kfr: '\uD835\uDD28',
              kgreen: '\u0138',
              KHcy: '\u0425',
              khcy: '\u0445',
              KJcy: '\u040C',
              kjcy: '\u045C',
              Kopf: '\uD835\uDD42',
              kopf: '\uD835\uDD5C',
              Kscr: '\uD835\uDCA6',
              kscr: '\uD835\uDCC0',
              lAarr: '\u21DA',
              Lacute: '\u0139',
              lacute: '\u013A',
              laemptyv: '\u29B4',
              lagran: '\u2112',
              Lambda: '\u039B',
              lambda: '\u03BB',
              Lang: '\u27EA',
              lang: '\u27E8',
              langd: '\u2991',
              langle: '\u27E8',
              lap: '\u2A85',
              Laplacetrf: '\u2112',
              laquo: '\u00AB',
              Larr: '\u219E',
              lArr: '\u21D0',
              larr: '\u2190',
              larrb: '\u21E4',
              larrbfs: '\u291F',
              larrfs: '\u291D',
              larrhk: '\u21A9',
              larrlp: '\u21AB',
              larrpl: '\u2939',
              larrsim: '\u2973',
              larrtl: '\u21A2',
              lat: '\u2AAB',
              lAtail: '\u291B',
              latail: '\u2919',
              late: '\u2AAD',
              lates: '\u2AAD\uFE00',
              lBarr: '\u290E',
              lbarr: '\u290C',
              lbbrk: '\u2772',
              lbrace: '\u007B',
              lbrack: '\u005B',
              lbrke: '\u298B',
              lbrksld: '\u298F',
              lbrkslu: '\u298D',
              Lcaron: '\u013D',
              lcaron: '\u013E',
              Lcedil: '\u013B',
              lcedil: '\u013C',
              lceil: '\u2308',
              lcub: '\u007B',
              Lcy: '\u041B',
              lcy: '\u043B',
              ldca: '\u2936',
              ldquo: '\u201C',
              ldquor: '\u201E',
              ldrdhar: '\u2967',
              ldrushar: '\u294B',
              ldsh: '\u21B2',
              lE: '\u2266',
              le: '\u2264',
              LeftAngleBracket: '\u27E8',
              LeftArrow: '\u2190',
              Leftarrow: '\u21D0',
              leftarrow: '\u2190',
              LeftArrowBar: '\u21E4',
              LeftArrowRightArrow: '\u21C6',
              leftarrowtail: '\u21A2',
              LeftCeiling: '\u2308',
              LeftDoubleBracket: '\u27E6',
              LeftDownTeeVector: '\u2961',
              LeftDownVector: '\u21C3',
              LeftDownVectorBar: '\u2959',
              LeftFloor: '\u230A',
              leftharpoondown: '\u21BD',
              leftharpoonup: '\u21BC',
              leftleftarrows: '\u21C7',
              LeftRightArrow: '\u2194',
              Leftrightarrow: '\u21D4',
              leftrightarrow: '\u2194',
              leftrightarrows: '\u21C6',
              leftrightharpoons: '\u21CB',
              leftrightsquigarrow: '\u21AD',
              LeftRightVector: '\u294E',
              LeftTee: '\u22A3',
              LeftTeeArrow: '\u21A4',
              LeftTeeVector: '\u295A',
              leftthreetimes: '\u22CB',
              LeftTriangle: '\u22B2',
              LeftTriangleBar: '\u29CF',
              LeftTriangleEqual: '\u22B4',
              LeftUpDownVector: '\u2951',
              LeftUpTeeVector: '\u2960',
              LeftUpVector: '\u21BF',
              LeftUpVectorBar: '\u2958',
              LeftVector: '\u21BC',
              LeftVectorBar: '\u2952',
              lEg: '\u2A8B',
              leg: '\u22DA',
              leq: '\u2264',
              leqq: '\u2266',
              leqslant: '\u2A7D',
              les: '\u2A7D',
              lescc: '\u2AA8',
              lesdot: '\u2A7F',
              lesdoto: '\u2A81',
              lesdotor: '\u2A83',
              lesg: '\u22DA\uFE00',
              lesges: '\u2A93',
              lessapprox: '\u2A85',
              lessdot: '\u22D6',
              lesseqgtr: '\u22DA',
              lesseqqgtr: '\u2A8B',
              LessEqualGreater: '\u22DA',
              LessFullEqual: '\u2266',
              LessGreater: '\u2276',
              lessgtr: '\u2276',
              LessLess: '\u2AA1',
              lesssim: '\u2272',
              LessSlantEqual: '\u2A7D',
              LessTilde: '\u2272',
              lfisht: '\u297C',
              lfloor: '\u230A',
              Lfr: '\uD835\uDD0F',
              lfr: '\uD835\uDD29',
              lg: '\u2276',
              lgE: '\u2A91',
              lHar: '\u2962',
              lhard: '\u21BD',
              lharu: '\u21BC',
              lharul: '\u296A',
              lhblk: '\u2584',
              LJcy: '\u0409',
              ljcy: '\u0459',
              Ll: '\u22D8',
              ll: '\u226A',
              llarr: '\u21C7',
              llcorner: '\u231E',
              Lleftarrow: '\u21DA',
              llhard: '\u296B',
              lltri: '\u25FA',
              Lmidot: '\u013F',
              lmidot: '\u0140',
              lmoust: '\u23B0',
              lmoustache: '\u23B0',
              lnap: '\u2A89',
              lnapprox: '\u2A89',
              lnE: '\u2268',
              lne: '\u2A87',
              lneq: '\u2A87',
              lneqq: '\u2268',
              lnsim: '\u22E6',
              loang: '\u27EC',
              loarr: '\u21FD',
              lobrk: '\u27E6',
              LongLeftArrow: '\u27F5',
              Longleftarrow: '\u27F8',
              longleftarrow: '\u27F5',
              LongLeftRightArrow: '\u27F7',
              Longleftrightarrow: '\u27FA',
              longleftrightarrow: '\u27F7',
              longmapsto: '\u27FC',
              LongRightArrow: '\u27F6',
              Longrightarrow: '\u27F9',
              longrightarrow: '\u27F6',
              looparrowleft: '\u21AB',
              looparrowright: '\u21AC',
              lopar: '\u2985',
              Lopf: '\uD835\uDD43',
              lopf: '\uD835\uDD5D',
              loplus: '\u2A2D',
              lotimes: '\u2A34',
              lowast: '\u2217',
              lowbar: '\u005F',
              LowerLeftArrow: '\u2199',
              LowerRightArrow: '\u2198',
              loz: '\u25CA',
              lozenge: '\u25CA',
              lozf: '\u29EB',
              lpar: '\u0028',
              lparlt: '\u2993',
              lrarr: '\u21C6',
              lrcorner: '\u231F',
              lrhar: '\u21CB',
              lrhard: '\u296D',
              lrm: '\u200E',
              lrtri: '\u22BF',
              lsaquo: '\u2039',
              Lscr: '\u2112',
              lscr: '\uD835\uDCC1',
              Lsh: '\u21B0',
              lsh: '\u21B0',
              lsim: '\u2272',
              lsime: '\u2A8D',
              lsimg: '\u2A8F',
              lsqb: '\u005B',
              lsquo: '\u2018',
              lsquor: '\u201A',
              Lstrok: '\u0141',
              lstrok: '\u0142',
              Lt: '\u226A',
              LT: '\u003C',
              lt: '\u003C',
              ltcc: '\u2AA6',
              ltcir: '\u2A79',
              ltdot: '\u22D6',
              lthree: '\u22CB',
              ltimes: '\u22C9',
              ltlarr: '\u2976',
              ltquest: '\u2A7B',
              ltri: '\u25C3',
              ltrie: '\u22B4',
              ltrif: '\u25C2',
              ltrPar: '\u2996',
              lurdshar: '\u294A',
              luruhar: '\u2966',
              lvertneqq: '\u2268\uFE00',
              lvnE: '\u2268\uFE00',
              macr: '\u00AF',
              male: '\u2642',
              malt: '\u2720',
              maltese: '\u2720',
              Map: '\u2905',
              map: '\u21A6',
              mapsto: '\u21A6',
              mapstodown: '\u21A7',
              mapstoleft: '\u21A4',
              mapstoup: '\u21A5',
              marker: '\u25AE',
              mcomma: '\u2A29',
              Mcy: '\u041C',
              mcy: '\u043C',
              mdash: '\u2014',
              mDDot: '\u223A',
              measuredangle: '\u2221',
              MediumSpace: '\u205F',
              Mellintrf: '\u2133',
              Mfr: '\uD835\uDD10',
              mfr: '\uD835\uDD2A',
              mho: '\u2127',
              micro: '\u00B5',
              mid: '\u2223',
              midast: '\u002A',
              midcir: '\u2AF0',
              middot: '\u00B7',
              minus: '\u2212',
              minusb: '\u229F',
              minusd: '\u2238',
              minusdu: '\u2A2A',
              MinusPlus: '\u2213',
              mlcp: '\u2ADB',
              mldr: '\u2026',
              mnplus: '\u2213',
              models: '\u22A7',
              Mopf: '\uD835\uDD44',
              mopf: '\uD835\uDD5E',
              mp: '\u2213',
              Mscr: '\u2133',
              mscr: '\uD835\uDCC2',
              mstpos: '\u223E',
              Mu: '\u039C',
              mu: '\u03BC',
              multimap: '\u22B8',
              mumap: '\u22B8',
              nabla: '\u2207',
              Nacute: '\u0143',
              nacute: '\u0144',
              nang: '\u2220\u20D2',
              nap: '\u2249',
              napE: '\u2A70\u0338',
              napid: '\u224B\u0338',
              napos: '\u0149',
              napprox: '\u2249',
              natur: '\u266E',
              natural: '\u266E',
              naturals: '\u2115',
              nbsp: '\u00A0',
              nbump: '\u224E\u0338',
              nbumpe: '\u224F\u0338',
              ncap: '\u2A43',
              Ncaron: '\u0147',
              ncaron: '\u0148',
              Ncedil: '\u0145',
              ncedil: '\u0146',
              ncong: '\u2247',
              ncongdot: '\u2A6D\u0338',
              ncup: '\u2A42',
              Ncy: '\u041D',
              ncy: '\u043D',
              ndash: '\u2013',
              ne: '\u2260',
              nearhk: '\u2924',
              neArr: '\u21D7',
              nearr: '\u2197',
              nearrow: '\u2197',
              nedot: '\u2250\u0338',
              NegativeMediumSpace: '\u200B',
              NegativeThickSpace: '\u200B',
              NegativeThinSpace: '\u200B',
              NegativeVeryThinSpace: '\u200B',
              nequiv: '\u2262',
              nesear: '\u2928',
              nesim: '\u2242\u0338',
              NestedGreaterGreater: '\u226B',
              NestedLessLess: '\u226A',
              NewLine: '\u000A',
              nexist: '\u2204',
              nexists: '\u2204',
              Nfr: '\uD835\uDD11',
              nfr: '\uD835\uDD2B',
              ngE: '\u2267\u0338',
              nge: '\u2271',
              ngeq: '\u2271',
              ngeqq: '\u2267\u0338',
              ngeqslant: '\u2A7E\u0338',
              nges: '\u2A7E\u0338',
              nGg: '\u22D9\u0338',
              ngsim: '\u2275',
              nGt: '\u226B\u20D2',
              ngt: '\u226F',
              ngtr: '\u226F',
              nGtv: '\u226B\u0338',
              nhArr: '\u21CE',
              nharr: '\u21AE',
              nhpar: '\u2AF2',
              ni: '\u220B',
              nis: '\u22FC',
              nisd: '\u22FA',
              niv: '\u220B',
              NJcy: '\u040A',
              njcy: '\u045A',
              nlArr: '\u21CD',
              nlarr: '\u219A',
              nldr: '\u2025',
              nlE: '\u2266\u0338',
              nle: '\u2270',
              nLeftarrow: '\u21CD',
              nleftarrow: '\u219A',
              nLeftrightarrow: '\u21CE',
              nleftrightarrow: '\u21AE',
              nleq: '\u2270',
              nleqq: '\u2266\u0338',
              nleqslant: '\u2A7D\u0338',
              nles: '\u2A7D\u0338',
              nless: '\u226E',
              nLl: '\u22D8\u0338',
              nlsim: '\u2274',
              nLt: '\u226A\u20D2',
              nlt: '\u226E',
              nltri: '\u22EA',
              nltrie: '\u22EC',
              nLtv: '\u226A\u0338',
              nmid: '\u2224',
              NoBreak: '\u2060',
              NonBreakingSpace: '\u00A0',
              Nopf: '\u2115',
              nopf: '\uD835\uDD5F',
              Not: '\u2AEC',
              not: '\u00AC',
              NotCongruent: '\u2262',
              NotCupCap: '\u226D',
              NotDoubleVerticalBar: '\u2226',
              NotElement: '\u2209',
              NotEqual: '\u2260',
              NotEqualTilde: '\u2242\u0338',
              NotExists: '\u2204',
              NotGreater: '\u226F',
              NotGreaterEqual: '\u2271',
              NotGreaterFullEqual: '\u2267\u0338',
              NotGreaterGreater: '\u226B\u0338',
              NotGreaterLess: '\u2279',
              NotGreaterSlantEqual: '\u2A7E\u0338',
              NotGreaterTilde: '\u2275',
              NotHumpDownHump: '\u224E\u0338',
              NotHumpEqual: '\u224F\u0338',
              notin: '\u2209',
              notindot: '\u22F5\u0338',
              notinE: '\u22F9\u0338',
              notinva: '\u2209',
              notinvb: '\u22F7',
              notinvc: '\u22F6',
              NotLeftTriangle: '\u22EA',
              NotLeftTriangleBar: '\u29CF\u0338',
              NotLeftTriangleEqual: '\u22EC',
              NotLess: '\u226E',
              NotLessEqual: '\u2270',
              NotLessGreater: '\u2278',
              NotLessLess: '\u226A\u0338',
              NotLessSlantEqual: '\u2A7D\u0338',
              NotLessTilde: '\u2274',
              NotNestedGreaterGreater: '\u2AA2\u0338',
              NotNestedLessLess: '\u2AA1\u0338',
              notni: '\u220C',
              notniva: '\u220C',
              notnivb: '\u22FE',
              notnivc: '\u22FD',
              NotPrecedes: '\u2280',
              NotPrecedesEqual: '\u2AAF\u0338',
              NotPrecedesSlantEqual: '\u22E0',
              NotReverseElement: '\u220C',
              NotRightTriangle: '\u22EB',
              NotRightTriangleBar: '\u29D0\u0338',
              NotRightTriangleEqual: '\u22ED',
              NotSquareSubset: '\u228F\u0338',
              NotSquareSubsetEqual: '\u22E2',
              NotSquareSuperset: '\u2290\u0338',
              NotSquareSupersetEqual: '\u22E3',
              NotSubset: '\u2282\u20D2',
              NotSubsetEqual: '\u2288',
              NotSucceeds: '\u2281',
              NotSucceedsEqual: '\u2AB0\u0338',
              NotSucceedsSlantEqual: '\u22E1',
              NotSucceedsTilde: '\u227F\u0338',
              NotSuperset: '\u2283\u20D2',
              NotSupersetEqual: '\u2289',
              NotTilde: '\u2241',
              NotTildeEqual: '\u2244',
              NotTildeFullEqual: '\u2247',
              NotTildeTilde: '\u2249',
              NotVerticalBar: '\u2224',
              npar: '\u2226',
              nparallel: '\u2226',
              nparsl: '\u2AFD\u20E5',
              npart: '\u2202\u0338',
              npolint: '\u2A14',
              npr: '\u2280',
              nprcue: '\u22E0',
              npre: '\u2AAF\u0338',
              nprec: '\u2280',
              npreceq: '\u2AAF\u0338',
              nrArr: '\u21CF',
              nrarr: '\u219B',
              nrarrc: '\u2933\u0338',
              nrarrw: '\u219D\u0338',
              nRightarrow: '\u21CF',
              nrightarrow: '\u219B',
              nrtri: '\u22EB',
              nrtrie: '\u22ED',
              nsc: '\u2281',
              nsccue: '\u22E1',
              nsce: '\u2AB0\u0338',
              Nscr: '\uD835\uDCA9',
              nscr: '\uD835\uDCC3',
              nshortmid: '\u2224',
              nshortparallel: '\u2226',
              nsim: '\u2241',
              nsime: '\u2244',
              nsimeq: '\u2244',
              nsmid: '\u2224',
              nspar: '\u2226',
              nsqsube: '\u22E2',
              nsqsupe: '\u22E3',
              nsub: '\u2284',
              nsubE: '\u2AC5\u0338',
              nsube: '\u2288',
              nsubset: '\u2282\u20D2',
              nsubseteq: '\u2288',
              nsubseteqq: '\u2AC5\u0338',
              nsucc: '\u2281',
              nsucceq: '\u2AB0\u0338',
              nsup: '\u2285',
              nsupE: '\u2AC6\u0338',
              nsupe: '\u2289',
              nsupset: '\u2283\u20D2',
              nsupseteq: '\u2289',
              nsupseteqq: '\u2AC6\u0338',
              ntgl: '\u2279',
              Ntilde: '\u00D1',
              ntilde: '\u00F1',
              ntlg: '\u2278',
              ntriangleleft: '\u22EA',
              ntrianglelefteq: '\u22EC',
              ntriangleright: '\u22EB',
              ntrianglerighteq: '\u22ED',
              Nu: '\u039D',
              nu: '\u03BD',
              num: '\u0023',
              numero: '\u2116',
              numsp: '\u2007',
              nvap: '\u224D\u20D2',
              nVDash: '\u22AF',
              nVdash: '\u22AE',
              nvDash: '\u22AD',
              nvdash: '\u22AC',
              nvge: '\u2265\u20D2',
              nvgt: '\u003E\u20D2',
              nvHarr: '\u2904',
              nvinfin: '\u29DE',
              nvlArr: '\u2902',
              nvle: '\u2264\u20D2',
              nvlt: '\u003C\u20D2',
              nvltrie: '\u22B4\u20D2',
              nvrArr: '\u2903',
              nvrtrie: '\u22B5\u20D2',
              nvsim: '\u223C\u20D2',
              nwarhk: '\u2923',
              nwArr: '\u21D6',
              nwarr: '\u2196',
              nwarrow: '\u2196',
              nwnear: '\u2927',
              Oacute: '\u00D3',
              oacute: '\u00F3',
              oast: '\u229B',
              ocir: '\u229A',
              Ocirc: '\u00D4',
              ocirc: '\u00F4',
              Ocy: '\u041E',
              ocy: '\u043E',
              odash: '\u229D',
              Odblac: '\u0150',
              odblac: '\u0151',
              odiv: '\u2A38',
              odot: '\u2299',
              odsold: '\u29BC',
              OElig: '\u0152',
              oelig: '\u0153',
              ofcir: '\u29BF',
              Ofr: '\uD835\uDD12',
              ofr: '\uD835\uDD2C',
              ogon: '\u02DB',
              Ograve: '\u00D2',
              ograve: '\u00F2',
              ogt: '\u29C1',
              ohbar: '\u29B5',
              ohm: '\u03A9',
              oint: '\u222E',
              olarr: '\u21BA',
              olcir: '\u29BE',
              olcross: '\u29BB',
              oline: '\u203E',
              olt: '\u29C0',
              Omacr: '\u014C',
              omacr: '\u014D',
              Omega: '\u03A9',
              omega: '\u03C9',
              Omicron: '\u039F',
              omicron: '\u03BF',
              omid: '\u29B6',
              ominus: '\u2296',
              Oopf: '\uD835\uDD46',
              oopf: '\uD835\uDD60',
              opar: '\u29B7',
              OpenCurlyDoubleQuote: '\u201C',
              OpenCurlyQuote: '\u2018',
              operp: '\u29B9',
              oplus: '\u2295',
              Or: '\u2A54',
              or: '\u2228',
              orarr: '\u21BB',
              ord: '\u2A5D',
              order: '\u2134',
              orderof: '\u2134',
              ordf: '\u00AA',
              ordm: '\u00BA',
              origof: '\u22B6',
              oror: '\u2A56',
              orslope: '\u2A57',
              orv: '\u2A5B',
              oS: '\u24C8',
              Oscr: '\uD835\uDCAA',
              oscr: '\u2134',
              Oslash: '\u00D8',
              oslash: '\u00F8',
              osol: '\u2298',
              Otilde: '\u00D5',
              otilde: '\u00F5',
              Otimes: '\u2A37',
              otimes: '\u2297',
              otimesas: '\u2A36',
              Ouml: '\u00D6',
              ouml: '\u00F6',
              ovbar: '\u233D',
              OverBar: '\u203E',
              OverBrace: '\u23DE',
              OverBracket: '\u23B4',
              OverParenthesis: '\u23DC',
              par: '\u2225',
              para: '\u00B6',
              parallel: '\u2225',
              parsim: '\u2AF3',
              parsl: '\u2AFD',
              part: '\u2202',
              PartialD: '\u2202',
              Pcy: '\u041F',
              pcy: '\u043F',
              percnt: '\u0025',
              period: '\u002E',
              permil: '\u2030',
              perp: '\u22A5',
              pertenk: '\u2031',
              Pfr: '\uD835\uDD13',
              pfr: '\uD835\uDD2D',
              Phi: '\u03A6',
              phi: '\u03C6',
              phiv: '\u03D5',
              phmmat: '\u2133',
              phone: '\u260E',
              Pi: '\u03A0',
              pi: '\u03C0',
              pitchfork: '\u22D4',
              piv: '\u03D6',
              planck: '\u210F',
              planckh: '\u210E',
              plankv: '\u210F',
              plus: '\u002B',
              plusacir: '\u2A23',
              plusb: '\u229E',
              pluscir: '\u2A22',
              plusdo: '\u2214',
              plusdu: '\u2A25',
              pluse: '\u2A72',
              PlusMinus: '\u00B1',
              plusmn: '\u00B1',
              plussim: '\u2A26',
              plustwo: '\u2A27',
              pm: '\u00B1',
              Poincareplane: '\u210C',
              pointint: '\u2A15',
              Popf: '\u2119',
              popf: '\uD835\uDD61',
              pound: '\u00A3',
              Pr: '\u2ABB',
              pr: '\u227A',
              prap: '\u2AB7',
              prcue: '\u227C',
              prE: '\u2AB3',
              pre: '\u2AAF',
              prec: '\u227A',
              precapprox: '\u2AB7',
              preccurlyeq: '\u227C',
              Precedes: '\u227A',
              PrecedesEqual: '\u2AAF',
              PrecedesSlantEqual: '\u227C',
              PrecedesTilde: '\u227E',
              preceq: '\u2AAF',
              precnapprox: '\u2AB9',
              precneqq: '\u2AB5',
              precnsim: '\u22E8',
              precsim: '\u227E',
              Prime: '\u2033',
              prime: '\u2032',
              primes: '\u2119',
              prnap: '\u2AB9',
              prnE: '\u2AB5',
              prnsim: '\u22E8',
              prod: '\u220F',
              Product: '\u220F',
              profalar: '\u232E',
              profline: '\u2312',
              profsurf: '\u2313',
              prop: '\u221D',
              Proportion: '\u2237',
              Proportional: '\u221D',
              propto: '\u221D',
              prsim: '\u227E',
              prurel: '\u22B0',
              Pscr: '\uD835\uDCAB',
              pscr: '\uD835\uDCC5',
              Psi: '\u03A8',
              psi: '\u03C8',
              puncsp: '\u2008',
              Qfr: '\uD835\uDD14',
              qfr: '\uD835\uDD2E',
              qint: '\u2A0C',
              Qopf: '\u211A',
              qopf: '\uD835\uDD62',
              qprime: '\u2057',
              Qscr: '\uD835\uDCAC',
              qscr: '\uD835\uDCC6',
              quaternions: '\u210D',
              quatint: '\u2A16',
              quest: '\u003F',
              questeq: '\u225F',
              QUOT: '\u0022',
              quot: '\u0022',
              rAarr: '\u21DB',
              race: '\u223D\u0331',
              Racute: '\u0154',
              racute: '\u0155',
              radic: '\u221A',
              raemptyv: '\u29B3',
              Rang: '\u27EB',
              rang: '\u27E9',
              rangd: '\u2992',
              range: '\u29A5',
              rangle: '\u27E9',
              raquo: '\u00BB',
              Rarr: '\u21A0',
              rArr: '\u21D2',
              rarr: '\u2192',
              rarrap: '\u2975',
              rarrb: '\u21E5',
              rarrbfs: '\u2920',
              rarrc: '\u2933',
              rarrfs: '\u291E',
              rarrhk: '\u21AA',
              rarrlp: '\u21AC',
              rarrpl: '\u2945',
              rarrsim: '\u2974',
              Rarrtl: '\u2916',
              rarrtl: '\u21A3',
              rarrw: '\u219D',
              rAtail: '\u291C',
              ratail: '\u291A',
              ratio: '\u2236',
              rationals: '\u211A',
              RBarr: '\u2910',
              rBarr: '\u290F',
              rbarr: '\u290D',
              rbbrk: '\u2773',
              rbrace: '\u007D',
              rbrack: '\u005D',
              rbrke: '\u298C',
              rbrksld: '\u298E',
              rbrkslu: '\u2990',
              Rcaron: '\u0158',
              rcaron: '\u0159',
              Rcedil: '\u0156',
              rcedil: '\u0157',
              rceil: '\u2309',
              rcub: '\u007D',
              Rcy: '\u0420',
              rcy: '\u0440',
              rdca: '\u2937',
              rdldhar: '\u2969',
              rdquo: '\u201D',
              rdquor: '\u201D',
              rdsh: '\u21B3',
              Re: '\u211C',
              real: '\u211C',
              realine: '\u211B',
              realpart: '\u211C',
              reals: '\u211D',
              rect: '\u25AD',
              REG: '\u00AE',
              reg: '\u00AE',
              ReverseElement: '\u220B',
              ReverseEquilibrium: '\u21CB',
              ReverseUpEquilibrium: '\u296F',
              rfisht: '\u297D',
              rfloor: '\u230B',
              Rfr: '\u211C',
              rfr: '\uD835\uDD2F',
              rHar: '\u2964',
              rhard: '\u21C1',
              rharu: '\u21C0',
              rharul: '\u296C',
              Rho: '\u03A1',
              rho: '\u03C1',
              rhov: '\u03F1',
              RightAngleBracket: '\u27E9',
              RightArrow: '\u2192',
              Rightarrow: '\u21D2',
              rightarrow: '\u2192',
              RightArrowBar: '\u21E5',
              RightArrowLeftArrow: '\u21C4',
              rightarrowtail: '\u21A3',
              RightCeiling: '\u2309',
              RightDoubleBracket: '\u27E7',
              RightDownTeeVector: '\u295D',
              RightDownVector: '\u21C2',
              RightDownVectorBar: '\u2955',
              RightFloor: '\u230B',
              rightharpoondown: '\u21C1',
              rightharpoonup: '\u21C0',
              rightleftarrows: '\u21C4',
              rightleftharpoons: '\u21CC',
              rightrightarrows: '\u21C9',
              rightsquigarrow: '\u219D',
              RightTee: '\u22A2',
              RightTeeArrow: '\u21A6',
              RightTeeVector: '\u295B',
              rightthreetimes: '\u22CC',
              RightTriangle: '\u22B3',
              RightTriangleBar: '\u29D0',
              RightTriangleEqual: '\u22B5',
              RightUpDownVector: '\u294F',
              RightUpTeeVector: '\u295C',
              RightUpVector: '\u21BE',
              RightUpVectorBar: '\u2954',
              RightVector: '\u21C0',
              RightVectorBar: '\u2953',
              ring: '\u02DA',
              risingdotseq: '\u2253',
              rlarr: '\u21C4',
              rlhar: '\u21CC',
              rlm: '\u200F',
              rmoust: '\u23B1',
              rmoustache: '\u23B1',
              rnmid: '\u2AEE',
              roang: '\u27ED',
              roarr: '\u21FE',
              robrk: '\u27E7',
              ropar: '\u2986',
              Ropf: '\u211D',
              ropf: '\uD835\uDD63',
              roplus: '\u2A2E',
              rotimes: '\u2A35',
              RoundImplies: '\u2970',
              rpar: '\u0029',
              rpargt: '\u2994',
              rppolint: '\u2A12',
              rrarr: '\u21C9',
              Rrightarrow: '\u21DB',
              rsaquo: '\u203A',
              Rscr: '\u211B',
              rscr: '\uD835\uDCC7',
              Rsh: '\u21B1',
              rsh: '\u21B1',
              rsqb: '\u005D',
              rsquo: '\u2019',
              rsquor: '\u2019',
              rthree: '\u22CC',
              rtimes: '\u22CA',
              rtri: '\u25B9',
              rtrie: '\u22B5',
              rtrif: '\u25B8',
              rtriltri: '\u29CE',
              RuleDelayed: '\u29F4',
              ruluhar: '\u2968',
              rx: '\u211E',
              Sacute: '\u015A',
              sacute: '\u015B',
              sbquo: '\u201A',
              Sc: '\u2ABC',
              sc: '\u227B',
              scap: '\u2AB8',
              Scaron: '\u0160',
              scaron: '\u0161',
              sccue: '\u227D',
              scE: '\u2AB4',
              sce: '\u2AB0',
              Scedil: '\u015E',
              scedil: '\u015F',
              Scirc: '\u015C',
              scirc: '\u015D',
              scnap: '\u2ABA',
              scnE: '\u2AB6',
              scnsim: '\u22E9',
              scpolint: '\u2A13',
              scsim: '\u227F',
              Scy: '\u0421',
              scy: '\u0441',
              sdot: '\u22C5',
              sdotb: '\u22A1',
              sdote: '\u2A66',
              searhk: '\u2925',
              seArr: '\u21D8',
              searr: '\u2198',
              searrow: '\u2198',
              sect: '\u00A7',
              semi: '\u003B',
              seswar: '\u2929',
              setminus: '\u2216',
              setmn: '\u2216',
              sext: '\u2736',
              Sfr: '\uD835\uDD16',
              sfr: '\uD835\uDD30',
              sfrown: '\u2322',
              sharp: '\u266F',
              SHCHcy: '\u0429',
              shchcy: '\u0449',
              SHcy: '\u0428',
              shcy: '\u0448',
              ShortDownArrow: '\u2193',
              ShortLeftArrow: '\u2190',
              shortmid: '\u2223',
              shortparallel: '\u2225',
              ShortRightArrow: '\u2192',
              ShortUpArrow: '\u2191',
              shy: '\u00AD',
              Sigma: '\u03A3',
              sigma: '\u03C3',
              sigmaf: '\u03C2',
              sigmav: '\u03C2',
              sim: '\u223C',
              simdot: '\u2A6A',
              sime: '\u2243',
              simeq: '\u2243',
              simg: '\u2A9E',
              simgE: '\u2AA0',
              siml: '\u2A9D',
              simlE: '\u2A9F',
              simne: '\u2246',
              simplus: '\u2A24',
              simrarr: '\u2972',
              slarr: '\u2190',
              SmallCircle: '\u2218',
              smallsetminus: '\u2216',
              smashp: '\u2A33',
              smeparsl: '\u29E4',
              smid: '\u2223',
              smile: '\u2323',
              smt: '\u2AAA',
              smte: '\u2AAC',
              smtes: '\u2AAC\uFE00',
              SOFTcy: '\u042C',
              softcy: '\u044C',
              sol: '\u002F',
              solb: '\u29C4',
              solbar: '\u233F',
              Sopf: '\uD835\uDD4A',
              sopf: '\uD835\uDD64',
              spades: '\u2660',
              spadesuit: '\u2660',
              spar: '\u2225',
              sqcap: '\u2293',
              sqcaps: '\u2293\uFE00',
              sqcup: '\u2294',
              sqcups: '\u2294\uFE00',
              Sqrt: '\u221A',
              sqsub: '\u228F',
              sqsube: '\u2291',
              sqsubset: '\u228F',
              sqsubseteq: '\u2291',
              sqsup: '\u2290',
              sqsupe: '\u2292',
              sqsupset: '\u2290',
              sqsupseteq: '\u2292',
              squ: '\u25A1',
              Square: '\u25A1',
              square: '\u25A1',
              SquareIntersection: '\u2293',
              SquareSubset: '\u228F',
              SquareSubsetEqual: '\u2291',
              SquareSuperset: '\u2290',
              SquareSupersetEqual: '\u2292',
              SquareUnion: '\u2294',
              squarf: '\u25AA',
              squf: '\u25AA',
              srarr: '\u2192',
              Sscr: '\uD835\uDCAE',
              sscr: '\uD835\uDCC8',
              ssetmn: '\u2216',
              ssmile: '\u2323',
              sstarf: '\u22C6',
              Star: '\u22C6',
              star: '\u2606',
              starf: '\u2605',
              straightepsilon: '\u03F5',
              straightphi: '\u03D5',
              strns: '\u00AF',
              Sub: '\u22D0',
              sub: '\u2282',
              subdot: '\u2ABD',
              subE: '\u2AC5',
              sube: '\u2286',
              subedot: '\u2AC3',
              submult: '\u2AC1',
              subnE: '\u2ACB',
              subne: '\u228A',
              subplus: '\u2ABF',
              subrarr: '\u2979',
              Subset: '\u22D0',
              subset: '\u2282',
              subseteq: '\u2286',
              subseteqq: '\u2AC5',
              SubsetEqual: '\u2286',
              subsetneq: '\u228A',
              subsetneqq: '\u2ACB',
              subsim: '\u2AC7',
              subsub: '\u2AD5',
              subsup: '\u2AD3',
              succ: '\u227B',
              succapprox: '\u2AB8',
              succcurlyeq: '\u227D',
              Succeeds: '\u227B',
              SucceedsEqual: '\u2AB0',
              SucceedsSlantEqual: '\u227D',
              SucceedsTilde: '\u227F',
              succeq: '\u2AB0',
              succnapprox: '\u2ABA',
              succneqq: '\u2AB6',
              succnsim: '\u22E9',
              succsim: '\u227F',
              SuchThat: '\u220B',
              Sum: '\u2211',
              sum: '\u2211',
              sung: '\u266A',
              Sup: '\u22D1',
              sup: '\u2283',
              sup1: '\u00B9',
              sup2: '\u00B2',
              sup3: '\u00B3',
              supdot: '\u2ABE',
              supdsub: '\u2AD8',
              supE: '\u2AC6',
              supe: '\u2287',
              supedot: '\u2AC4',
              Superset: '\u2283',
              SupersetEqual: '\u2287',
              suphsol: '\u27C9',
              suphsub: '\u2AD7',
              suplarr: '\u297B',
              supmult: '\u2AC2',
              supnE: '\u2ACC',
              supne: '\u228B',
              supplus: '\u2AC0',
              Supset: '\u22D1',
              supset: '\u2283',
              supseteq: '\u2287',
              supseteqq: '\u2AC6',
              supsetneq: '\u228B',
              supsetneqq: '\u2ACC',
              supsim: '\u2AC8',
              supsub: '\u2AD4',
              supsup: '\u2AD6',
              swarhk: '\u2926',
              swArr: '\u21D9',
              swarr: '\u2199',
              swarrow: '\u2199',
              swnwar: '\u292A',
              szlig: '\u00DF',
              Tab: '\u0009',
              target: '\u2316',
              Tau: '\u03A4',
              tau: '\u03C4',
              tbrk: '\u23B4',
              Tcaron: '\u0164',
              tcaron: '\u0165',
              Tcedil: '\u0162',
              tcedil: '\u0163',
              Tcy: '\u0422',
              tcy: '\u0442',
              tdot: '\u20DB',
              telrec: '\u2315',
              Tfr: '\uD835\uDD17',
              tfr: '\uD835\uDD31',
              there4: '\u2234',
              Therefore: '\u2234',
              therefore: '\u2234',
              Theta: '\u0398',
              theta: '\u03B8',
              thetasym: '\u03D1',
              thetav: '\u03D1',
              thickapprox: '\u2248',
              thicksim: '\u223C',
              ThickSpace: '\u205F\u200A',
              thinsp: '\u2009',
              ThinSpace: '\u2009',
              thkap: '\u2248',
              thksim: '\u223C',
              THORN: '\u00DE',
              thorn: '\u00FE',
              Tilde: '\u223C',
              tilde: '\u02DC',
              TildeEqual: '\u2243',
              TildeFullEqual: '\u2245',
              TildeTilde: '\u2248',
              times: '\u00D7',
              timesb: '\u22A0',
              timesbar: '\u2A31',
              timesd: '\u2A30',
              tint: '\u222D',
              toea: '\u2928',
              top: '\u22A4',
              topbot: '\u2336',
              topcir: '\u2AF1',
              Topf: '\uD835\uDD4B',
              topf: '\uD835\uDD65',
              topfork: '\u2ADA',
              tosa: '\u2929',
              tprime: '\u2034',
              TRADE: '\u2122',
              trade: '\u2122',
              triangle: '\u25B5',
              triangledown: '\u25BF',
              triangleleft: '\u25C3',
              trianglelefteq: '\u22B4',
              triangleq: '\u225C',
              triangleright: '\u25B9',
              trianglerighteq: '\u22B5',
              tridot: '\u25EC',
              trie: '\u225C',
              triminus: '\u2A3A',
              TripleDot: '\u20DB',
              triplus: '\u2A39',
              trisb: '\u29CD',
              tritime: '\u2A3B',
              trpezium: '\u23E2',
              Tscr: '\uD835\uDCAF',
              tscr: '\uD835\uDCC9',
              TScy: '\u0426',
              tscy: '\u0446',
              TSHcy: '\u040B',
              tshcy: '\u045B',
              Tstrok: '\u0166',
              tstrok: '\u0167',
              twixt: '\u226C',
              twoheadleftarrow: '\u219E',
              twoheadrightarrow: '\u21A0',
              Uacute: '\u00DA',
              uacute: '\u00FA',
              Uarr: '\u219F',
              uArr: '\u21D1',
              uarr: '\u2191',
              Uarrocir: '\u2949',
              Ubrcy: '\u040E',
              ubrcy: '\u045E',
              Ubreve: '\u016C',
              ubreve: '\u016D',
              Ucirc: '\u00DB',
              ucirc: '\u00FB',
              Ucy: '\u0423',
              ucy: '\u0443',
              udarr: '\u21C5',
              Udblac: '\u0170',
              udblac: '\u0171',
              udhar: '\u296E',
              ufisht: '\u297E',
              Ufr: '\uD835\uDD18',
              ufr: '\uD835\uDD32',
              Ugrave: '\u00D9',
              ugrave: '\u00F9',
              uHar: '\u2963',
              uharl: '\u21BF',
              uharr: '\u21BE',
              uhblk: '\u2580',
              ulcorn: '\u231C',
              ulcorner: '\u231C',
              ulcrop: '\u230F',
              ultri: '\u25F8',
              Umacr: '\u016A',
              umacr: '\u016B',
              uml: '\u00A8',
              UnderBar: '\u005F',
              UnderBrace: '\u23DF',
              UnderBracket: '\u23B5',
              UnderParenthesis: '\u23DD',
              Union: '\u22C3',
              UnionPlus: '\u228E',
              Uogon: '\u0172',
              uogon: '\u0173',
              Uopf: '\uD835\uDD4C',
              uopf: '\uD835\uDD66',
              UpArrow: '\u2191',
              Uparrow: '\u21D1',
              uparrow: '\u2191',
              UpArrowBar: '\u2912',
              UpArrowDownArrow: '\u21C5',
              UpDownArrow: '\u2195',
              Updownarrow: '\u21D5',
              updownarrow: '\u2195',
              UpEquilibrium: '\u296E',
              upharpoonleft: '\u21BF',
              upharpoonright: '\u21BE',
              uplus: '\u228E',
              UpperLeftArrow: '\u2196',
              UpperRightArrow: '\u2197',
              Upsi: '\u03D2',
              upsi: '\u03C5',
              upsih: '\u03D2',
              Upsilon: '\u03A5',
              upsilon: '\u03C5',
              UpTee: '\u22A5',
              UpTeeArrow: '\u21A5',
              upuparrows: '\u21C8',
              urcorn: '\u231D',
              urcorner: '\u231D',
              urcrop: '\u230E',
              Uring: '\u016E',
              uring: '\u016F',
              urtri: '\u25F9',
              Uscr: '\uD835\uDCB0',
              uscr: '\uD835\uDCCA',
              utdot: '\u22F0',
              Utilde: '\u0168',
              utilde: '\u0169',
              utri: '\u25B5',
              utrif: '\u25B4',
              uuarr: '\u21C8',
              Uuml: '\u00DC',
              uuml: '\u00FC',
              uwangle: '\u29A7',
              vangrt: '\u299C',
              varepsilon: '\u03F5',
              varkappa: '\u03F0',
              varnothing: '\u2205',
              varphi: '\u03D5',
              varpi: '\u03D6',
              varpropto: '\u221D',
              vArr: '\u21D5',
              varr: '\u2195',
              varrho: '\u03F1',
              varsigma: '\u03C2',
              varsubsetneq: '\u228A\uFE00',
              varsubsetneqq: '\u2ACB\uFE00',
              varsupsetneq: '\u228B\uFE00',
              varsupsetneqq: '\u2ACC\uFE00',
              vartheta: '\u03D1',
              vartriangleleft: '\u22B2',
              vartriangleright: '\u22B3',
              Vbar: '\u2AEB',
              vBar: '\u2AE8',
              vBarv: '\u2AE9',
              Vcy: '\u0412',
              vcy: '\u0432',
              VDash: '\u22AB',
              Vdash: '\u22A9',
              vDash: '\u22A8',
              vdash: '\u22A2',
              Vdashl: '\u2AE6',
              Vee: '\u22C1',
              vee: '\u2228',
              veebar: '\u22BB',
              veeeq: '\u225A',
              vellip: '\u22EE',
              Verbar: '\u2016',
              verbar: '\u007C',
              Vert: '\u2016',
              vert: '\u007C',
              VerticalBar: '\u2223',
              VerticalLine: '\u007C',
              VerticalSeparator: '\u2758',
              VerticalTilde: '\u2240',
              VeryThinSpace: '\u200A',
              Vfr: '\uD835\uDD19',
              vfr: '\uD835\uDD33',
              vltri: '\u22B2',
              vnsub: '\u2282\u20D2',
              vnsup: '\u2283\u20D2',
              Vopf: '\uD835\uDD4D',
              vopf: '\uD835\uDD67',
              vprop: '\u221D',
              vrtri: '\u22B3',
              Vscr: '\uD835\uDCB1',
              vscr: '\uD835\uDCCB',
              vsubnE: '\u2ACB\uFE00',
              vsubne: '\u228A\uFE00',
              vsupnE: '\u2ACC\uFE00',
              vsupne: '\u228B\uFE00',
              Vvdash: '\u22AA',
              vzigzag: '\u299A',
              Wcirc: '\u0174',
              wcirc: '\u0175',
              wedbar: '\u2A5F',
              Wedge: '\u22C0',
              wedge: '\u2227',
              wedgeq: '\u2259',
              weierp: '\u2118',
              Wfr: '\uD835\uDD1A',
              wfr: '\uD835\uDD34',
              Wopf: '\uD835\uDD4E',
              wopf: '\uD835\uDD68',
              wp: '\u2118',
              wr: '\u2240',
              wreath: '\u2240',
              Wscr: '\uD835\uDCB2',
              wscr: '\uD835\uDCCC',
              xcap: '\u22C2',
              xcirc: '\u25EF',
              xcup: '\u22C3',
              xdtri: '\u25BD',
              Xfr: '\uD835\uDD1B',
              xfr: '\uD835\uDD35',
              xhArr: '\u27FA',
              xharr: '\u27F7',
              Xi: '\u039E',
              xi: '\u03BE',
              xlArr: '\u27F8',
              xlarr: '\u27F5',
              xmap: '\u27FC',
              xnis: '\u22FB',
              xodot: '\u2A00',
              Xopf: '\uD835\uDD4F',
              xopf: '\uD835\uDD69',
              xoplus: '\u2A01',
              xotime: '\u2A02',
              xrArr: '\u27F9',
              xrarr: '\u27F6',
              Xscr: '\uD835\uDCB3',
              xscr: '\uD835\uDCCD',
              xsqcup: '\u2A06',
              xuplus: '\u2A04',
              xutri: '\u25B3',
              xvee: '\u22C1',
              xwedge: '\u22C0',
              Yacute: '\u00DD',
              yacute: '\u00FD',
              YAcy: '\u042F',
              yacy: '\u044F',
              Ycirc: '\u0176',
              ycirc: '\u0177',
              Ycy: '\u042B',
              ycy: '\u044B',
              yen: '\u00A5',
              Yfr: '\uD835\uDD1C',
              yfr: '\uD835\uDD36',
              YIcy: '\u0407',
              yicy: '\u0457',
              Yopf: '\uD835\uDD50',
              yopf: '\uD835\uDD6A',
              Yscr: '\uD835\uDCB4',
              yscr: '\uD835\uDCCE',
              YUcy: '\u042E',
              yucy: '\u044E',
              Yuml: '\u0178',
              yuml: '\u00FF',
              Zacute: '\u0179',
              zacute: '\u017A',
              Zcaron: '\u017D',
              zcaron: '\u017E',
              Zcy: '\u0417',
              zcy: '\u0437',
              Zdot: '\u017B',
              zdot: '\u017C',
              zeetrf: '\u2128',
              ZeroWidthSpace: '\u200B',
              Zeta: '\u0396',
              zeta: '\u03B6',
              Zfr: '\u2128',
              zfr: '\uD835\uDD37',
              ZHcy: '\u0416',
              zhcy: '\u0436',
              zigrarr: '\u21DD',
              Zopf: '\u2124',
              zopf: '\uD835\uDD6B',
              Zscr: '\uD835\uDCB5',
              zscr: '\uD835\uDCCF',
              zwj: '\u200D',
              zwnj: '\u200C',
            });

            /**
             * @deprecated use `HTML_ENTITIES` instead
             * @see HTML_ENTITIES
             */
            exports.entityMap = exports.HTML_ENTITIES;
          }(entities));
          return entities;
        }

        var sax = {};

        var hasRequiredSax;

        function requireSax() {
          if (hasRequiredSax) return sax;
          hasRequiredSax = 1;
          var NAMESPACE = requireConventions().NAMESPACE;

          //[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
          //[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
          //[5]   	Name	   ::=   	NameStartChar (NameChar)*
          var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;//\u10000-\uEFFFF
          var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
          var tagNamePattern = new RegExp('^' + nameStartChar.source + nameChar.source + '*(?:\:' + nameStartChar.source + nameChar.source + '*)?$');
          //var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
          //var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

          //S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
          //S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
          var S_TAG = 0;//tag name offerring
          var S_ATTR = 1;//attr name offerring
          var S_ATTR_SPACE = 2;//attr name end and space offer
          var S_EQ = 3;//=space?
          var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
          var S_ATTR_END = 5;//attr value end and no space(quot end)
          var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
          var S_TAG_CLOSE = 7;//closed el<el />

          /**
           * Creates an error that will not be caught by XMLReader aka the SAX parser.
           *
           * @param {string} message
           * @param {any?} locator Optional, can provide details about the location in the source
           * @constructor
           */
          function ParseError(message, locator) {
            this.message = message;
            this.locator = locator;
            if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
          }
          ParseError.prototype = new Error();
          ParseError.prototype.name = ParseError.name;

          function XMLReader() {

          }

          XMLReader.prototype = {
            parse: function (source, defaultNSMap, entityMap) {
              var domBuilder = this.domBuilder;
              domBuilder.startDocument();
              _copy(defaultNSMap, defaultNSMap = {});
              parse(source, defaultNSMap, entityMap,
                domBuilder, this.errorHandler);
              domBuilder.endDocument();
            }
          };
          function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
            function fixedFromCharCode(code) {
              // String.prototype.fromCharCode does not supports
              // > 2 bytes unicode chars directly
              if (code > 0xffff) {
                code -= 0x10000;
                var surrogate1 = 0xd800 + (code >> 10)
                  , surrogate2 = 0xdc00 + (code & 0x3ff);

                return String.fromCharCode(surrogate1, surrogate2);
              } else {
                return String.fromCharCode(code);
              }
            }
            function entityReplacer(a) {
              var k = a.slice(1, -1);
              if (Object.hasOwnProperty.call(entityMap, k)) {
                return entityMap[k];
              } else if (k.charAt(0) === '#') {
                return fixedFromCharCode(parseInt(k.substr(1).replace('x', '0x')))
              } else {
                errorHandler.error('entity not found:' + a);
                return a;
              }
            }
            function appendText(end) {//has some bugs
              if (end > start) {
                var xt = source.substring(start, end).replace(/&#?\w+;/g, entityReplacer);
                locator && position(start);
                domBuilder.characters(xt, 0, end - start);
                start = end;
              }
            }
            function position(p, m) {
              while (p >= lineEnd && (m = linePattern.exec(source))) {
                lineStart = m.index;
                lineEnd = lineStart + m[0].length;
                locator.lineNumber++;
                //console.log('line++:',locator,startPos,endPos)
              }
              locator.columnNumber = p - lineStart + 1;
            }
            var lineStart = 0;
            var lineEnd = 0;
            var linePattern = /.*(?:\r\n?|\n)|.*$/g;
            var locator = domBuilder.locator;

            var parseStack = [{ currentNSMap: defaultNSMapCopy }];
            var closeMap = {};
            var start = 0;
            while (true) {
              try {
                var tagStart = source.indexOf('<', start);
                if (tagStart < 0) {
                  if (!source.substr(start).match(/^\s*$/)) {
                    var doc = domBuilder.doc;
                    var text = doc.createTextNode(source.substr(start));
                    doc.appendChild(text);
                    domBuilder.currentElement = text;
                  }
                  return;
                }
                if (tagStart > start) {
                  appendText(tagStart);
                }
                switch (source.charAt(tagStart + 1)) {
                  case '/':
                    var end = source.indexOf('>', tagStart + 3);
                    var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, '');
                    var config = parseStack.pop();
                    if (end < 0) {

                      tagName = source.substring(tagStart + 2).replace(/[\s<].*/, '');
                      errorHandler.error("end tag name: " + tagName + ' is not complete:' + config.tagName);
                      end = tagStart + 1 + tagName.length;
                    } else if (tagName.match(/\s</)) {
                      tagName = tagName.replace(/[\s<].*/, '');
                      errorHandler.error("end tag name: " + tagName + ' maybe not complete');
                      end = tagStart + 1 + tagName.length;
                    }
                    var localNSMap = config.localNSMap;
                    var endMatch = config.tagName == tagName;
                    var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
                    if (endIgnoreCaseMach) {
                      domBuilder.endElement(config.uri, config.localName, tagName);
                      if (localNSMap) {
                        for (var prefix in localNSMap) {
                          if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                            domBuilder.endPrefixMapping(prefix);
                          }
                        }
                      }
                      if (!endMatch) {
                        errorHandler.fatalError("end tag name: " + tagName + ' is not match the current start tagName:' + config.tagName); // No known test case
                      }
                    } else {
                      parseStack.push(config);
                    }

                    end++;
                    break;
                  // end elment
                  case '?':// <?...?>
                    locator && position(tagStart);
                    end = parseInstruction(source, tagStart, domBuilder);
                    break;
                  case '!':// <!doctype,<![CDATA,<!--
                    locator && position(tagStart);
                    end = parseDCC(source, tagStart, domBuilder, errorHandler);
                    break;
                  default:
                    locator && position(tagStart);
                    var el = new ElementAttributes();
                    var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
                    //elStartEnd
                    var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
                    var len = el.length;


                    if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                      el.closed = true;
                      if (!entityMap.nbsp) {
                        errorHandler.warning('unclosed xml attribute');
                      }
                    }
                    if (locator && len) {
                      var locator2 = copyLocator(locator, {});
                      //try{//attribute position fixed
                      for (var i = 0; i < len; i++) {
                        var a = el[i];
                        position(a.offset);
                        a.locator = copyLocator(locator, {});
                      }
                      domBuilder.locator = locator2;
                      if (appendElement(el, domBuilder, currentNSMap)) {
                        parseStack.push(el);
                      }
                      domBuilder.locator = locator;
                    } else {
                      if (appendElement(el, domBuilder, currentNSMap)) {
                        parseStack.push(el);
                      }
                    }

                    if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                      end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
                    } else {
                      end++;
                    }
                }
              } catch (e) {
                if (e instanceof ParseError) {
                  throw e;
                }
                errorHandler.error('element parse error: ' + e);
                end = -1;
              }
              if (end > start) {
                start = end;
              } else {
                //TODO: 这里有可能sax回退，有位置错误风险
                appendText(Math.max(tagStart, start) + 1);
              }
            }
          }
          function copyLocator(f, t) {
            t.lineNumber = f.lineNumber;
            t.columnNumber = f.columnNumber;
            return t;
          }

          /**
           * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
           * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
           */
          function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {

            /**
             * @param {string} qname
             * @param {string} value
             * @param {number} startIndex
             */
            function addAttribute(qname, value, startIndex) {
              if (el.attributeNames.hasOwnProperty(qname)) {
                errorHandler.fatalError('Attribute ' + qname + ' redefined');
              }
              el.addValue(
                qname,
                // @see https://www.w3.org/TR/xml/#AVNormalize
                // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
                // - recursive replacement of (DTD) entity references
                // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
                value.replace(/[\t\n\r]/g, ' ').replace(/&#?\w+;/g, entityReplacer),
                startIndex
              );
            }
            var attrName;
            var value;
            var p = ++start;
            var s = S_TAG;//status
            while (true) {
              var c = source.charAt(p);
              switch (c) {
                case '=':
                  if (s === S_ATTR) {//attrName
                    attrName = source.slice(start, p);
                    s = S_EQ;
                  } else if (s === S_ATTR_SPACE) {
                    s = S_EQ;
                  } else {
                    //fatalError: equal must after attrName or space after attrName
                    throw new Error('attribute equal must after attrName'); // No known test case
                  }
                  break;
                case '\'':
                case '"':
                  if (s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
                  ) {//equal
                    if (s === S_ATTR) {
                      errorHandler.warning('attribute value must after "="');
                      attrName = source.slice(start, p);
                    }
                    start = p + 1;
                    p = source.indexOf(c, start);
                    if (p > 0) {
                      value = source.slice(start, p);
                      addAttribute(attrName, value, start - 1);
                      s = S_ATTR_END;
                    } else {
                      //fatalError: no end quot match
                      throw new Error('attribute value no end \'' + c + '\' match');
                    }
                  } else if (s == S_ATTR_NOQUOT_VALUE) {
                    value = source.slice(start, p);
                    addAttribute(attrName, value, start);
                    errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ')!!');
                    start = p + 1;
                    s = S_ATTR_END;
                  } else {
                    //fatalError: no equal before
                    throw new Error('attribute value must after "="'); // No known test case
                  }
                  break;
                case '/':
                  switch (s) {
                    case S_TAG:
                      el.setTagName(source.slice(start, p));
                    case S_ATTR_END:
                    case S_TAG_SPACE:
                    case S_TAG_CLOSE:
                      s = S_TAG_CLOSE;
                      el.closed = true;
                    case S_ATTR_NOQUOT_VALUE:
                    case S_ATTR:
                      break;
                    case S_ATTR_SPACE:
                      el.closed = true;
                      break;
                    //case S_EQ:
                    default:
                      throw new Error("attribute invalid close char('/')") // No known test case
                  }
                  break;
                case ''://end document
                  errorHandler.error('unexpected end of input');
                  if (s == S_TAG) {
                    el.setTagName(source.slice(start, p));
                  }
                  return p;
                case '>':
                  switch (s) {
                    case S_TAG:
                      el.setTagName(source.slice(start, p));
                    case S_ATTR_END:
                    case S_TAG_SPACE:
                    case S_TAG_CLOSE:
                      break;//normal
                    case S_ATTR_NOQUOT_VALUE://Compatible state
                    case S_ATTR:
                      value = source.slice(start, p);
                      if (value.slice(-1) === '/') {
                        el.closed = true;
                        value = value.slice(0, -1);
                      }
                    case S_ATTR_SPACE:
                      if (s === S_ATTR_SPACE) {
                        value = attrName;
                      }
                      if (s == S_ATTR_NOQUOT_VALUE) {
                        errorHandler.warning('attribute "' + value + '" missed quot(")!');
                        addAttribute(attrName, value, start);
                      } else {
                        if (!NAMESPACE.isHTML(currentNSMap['']) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                          errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                        }
                        addAttribute(value, value, start);
                      }
                      break;
                    case S_EQ:
                      throw new Error('attribute value missed!!');
                  }
                  //			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
                  return p;
                /*xml space '\x20' | #x9 | #xD | #xA; */
                case '\u0080':
                  c = ' ';
                default:
                  if (c <= ' ') {//space
                    switch (s) {
                      case S_TAG:
                        el.setTagName(source.slice(start, p));//tagName
                        s = S_TAG_SPACE;
                        break;
                      case S_ATTR:
                        attrName = source.slice(start, p);
                        s = S_ATTR_SPACE;
                        break;
                      case S_ATTR_NOQUOT_VALUE:
                        var value = source.slice(start, p);
                        errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                        addAttribute(attrName, value, start);
                      case S_ATTR_END:
                        s = S_TAG_SPACE;
                        break;
                      //case S_TAG_SPACE:
                      //case S_EQ:
                      //case S_ATTR_SPACE:
                      //	void();break;
                      //case S_TAG_CLOSE:
                      //ignore warning
                    }
                  } else {//not space
                    //S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
                    //S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
                    switch (s) {
                      //case S_TAG:void();break;
                      //case S_ATTR:void();break;
                      //case S_ATTR_NOQUOT_VALUE:void();break;
                      case S_ATTR_SPACE:
                        el.tagName;
                        if (!NAMESPACE.isHTML(currentNSMap['']) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                          errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                        }
                        addAttribute(attrName, attrName, start);
                        start = p;
                        s = S_ATTR;
                        break;
                      case S_ATTR_END:
                        errorHandler.warning('attribute space is required"' + attrName + '"!!');
                      case S_TAG_SPACE:
                        s = S_ATTR;
                        start = p;
                        break;
                      case S_EQ:
                        s = S_ATTR_NOQUOT_VALUE;
                        start = p;
                        break;
                      case S_TAG_CLOSE:
                        throw new Error("elements closed character '/' and '>' must be connected to");
                    }
                  }
              }//end outer switch
              //console.log('p++',p)
              p++;
            }
          }
          /**
           * @return true if has new namespace define
           */
          function appendElement(el, domBuilder, currentNSMap) {
            var tagName = el.tagName;
            var localNSMap = null;
            //var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
            var i = el.length;
            while (i--) {
              var a = el[i];
              var qName = a.qName;
              var value = a.value;
              var nsp = qName.indexOf(':');
              if (nsp > 0) {
                var prefix = a.prefix = qName.slice(0, nsp);
                var localName = qName.slice(nsp + 1);
                var nsPrefix = prefix === 'xmlns' && localName;
              } else {
                localName = qName;
                prefix = null;
                nsPrefix = qName === 'xmlns' && '';
              }
              //can not set prefix,because prefix !== ''
              a.localName = localName;
              //prefix == null for no ns prefix attribute
              if (nsPrefix !== false) {//hack!!
                if (localNSMap == null) {
                  localNSMap = {};
                  //console.log(currentNSMap,0)
                  _copy(currentNSMap, currentNSMap = {});
                  //console.log(currentNSMap,1)
                }
                currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
                a.uri = NAMESPACE.XMLNS;
                domBuilder.startPrefixMapping(nsPrefix, value);
              }
            }
            var i = el.length;
            while (i--) {
              a = el[i];
              var prefix = a.prefix;
              if (prefix) {//no prefix attribute has no namespace
                if (prefix === 'xml') {
                  a.uri = NAMESPACE.XML;
                } if (prefix !== 'xmlns') {
                  a.uri = currentNSMap[prefix || ''];

                  //{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
                }
              }
            }
            var nsp = tagName.indexOf(':');
            if (nsp > 0) {
              prefix = el.prefix = tagName.slice(0, nsp);
              localName = el.localName = tagName.slice(nsp + 1);
            } else {
              prefix = null;//important!!
              localName = el.localName = tagName;
            }
            //no prefix element has default namespace
            var ns = el.uri = currentNSMap[prefix || ''];
            domBuilder.startElement(ns, localName, tagName, el);
            //endPrefixMapping and startPrefixMapping have not any help for dom builder
            //localNSMap = null
            if (el.closed) {
              domBuilder.endElement(ns, localName, tagName);
              if (localNSMap) {
                for (prefix in localNSMap) {
                  if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                    domBuilder.endPrefixMapping(prefix);
                  }
                }
              }
            } else {
              el.currentNSMap = currentNSMap;
              el.localNSMap = localNSMap;
              //parseStack.push(el);
              return true;
            }
          }
          function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
            if (/^(?:script|textarea)$/i.test(tagName)) {
              var elEndStart = source.indexOf('</' + tagName + '>', elStartEnd);
              var text = source.substring(elStartEnd + 1, elEndStart);
              if (/[&<]/.test(text)) {
                if (/^script$/i.test(tagName)) {
                  //if(!/\]\]>/.test(text)){
                  //lexHandler.startCDATA();
                  domBuilder.characters(text, 0, text.length);
                  //lexHandler.endCDATA();
                  return elEndStart;
                  //}
                }//}else{//text area
                text = text.replace(/&#?\w+;/g, entityReplacer);
                domBuilder.characters(text, 0, text.length);
                return elEndStart;
                //}

              }
            }
            return elStartEnd + 1;
          }
          function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
            //if(tagName in closeMap){
            var pos = closeMap[tagName];
            if (pos == null) {
              //console.log(tagName)
              pos = source.lastIndexOf('</' + tagName + '>');
              if (pos < elStartEnd) {//忘记闭合
                pos = source.lastIndexOf('</' + tagName);
              }
              closeMap[tagName] = pos;
            }
            return pos < elStartEnd;
            //}
          }

          function _copy(source, target) {
            for (var n in source) {
              if (Object.prototype.hasOwnProperty.call(source, n)) {
                target[n] = source[n];
              }
            }
          }

          function parseDCC(source, start, domBuilder, errorHandler) {//sure start with '<!'
            var next = source.charAt(start + 2);
            switch (next) {
              case '-':
                if (source.charAt(start + 3) === '-') {
                  var end = source.indexOf('-->', start + 4);
                  //append comment source.substring(4,end)//<!--
                  if (end > start) {
                    domBuilder.comment(source, start + 4, end - start - 4);
                    return end + 3;
                  } else {
                    errorHandler.error("Unclosed comment");
                    return -1;
                  }
                } else {
                  //error
                  return -1;
                }
              default:
                if (source.substr(start + 3, 6) == 'CDATA[') {
                  var end = source.indexOf(']]>', start + 9);
                  domBuilder.startCDATA();
                  domBuilder.characters(source, start + 9, end - start - 9);
                  domBuilder.endCDATA();
                  return end + 3;
                }
                //<!DOCTYPE
                //startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)
                var matchs = split(source, start);
                var len = matchs.length;
                if (len > 1 && /!doctype/i.test(matchs[0][0])) {
                  var name = matchs[1][0];
                  var pubid = false;
                  var sysid = false;
                  if (len > 3) {
                    if (/^public$/i.test(matchs[2][0])) {
                      pubid = matchs[3][0];
                      sysid = len > 4 && matchs[4][0];
                    } else if (/^system$/i.test(matchs[2][0])) {
                      sysid = matchs[3][0];
                    }
                  }
                  var lastMatch = matchs[len - 1];
                  domBuilder.startDTD(name, pubid, sysid);
                  domBuilder.endDTD();

                  return lastMatch.index + lastMatch[0].length
                }
            }
            return -1;
          }



          function parseInstruction(source, start, domBuilder) {
            var end = source.indexOf('?>', start);
            if (end) {
              var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
              if (match) {
                match[0].length;
                domBuilder.processingInstruction(match[1], match[2]);
                return end + 2;
              } else {//error
                return -1;
              }
            }
            return -1;
          }

          function ElementAttributes() {
            this.attributeNames = {};
          }
          ElementAttributes.prototype = {
            setTagName: function (tagName) {
              if (!tagNamePattern.test(tagName)) {
                throw new Error('invalid tagName:' + tagName)
              }
              this.tagName = tagName;
            },
            addValue: function (qName, value, offset) {
              if (!tagNamePattern.test(qName)) {
                throw new Error('invalid attribute:' + qName)
              }
              this.attributeNames[qName] = this.length;
              this[this.length++] = { qName: qName, value: value, offset: offset };
            },
            length: 0,
            getLocalName: function (i) { return this[i].localName },
            getLocator: function (i) { return this[i].locator },
            getQName: function (i) { return this[i].qName },
            getURI: function (i) { return this[i].uri },
            getValue: function (i) { return this[i].value }
            //	,getIndex:function(uri, localName)){
            //		if(localName){
            //
            //		}else{
            //			var qName = uri
            //		}
            //	},
            //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
            //	getType:function(uri,localName){}
            //	getType:function(i){},
          };



          function split(source, start) {
            var match;
            var buf = [];
            var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
            reg.lastIndex = start;
            reg.exec(source);//skip <
            while (match = reg.exec(source)) {
              buf.push(match);
              if (match[1]) return buf;
            }
          }

          sax.XMLReader = XMLReader;
          sax.ParseError = ParseError;
          return sax;
        }

        var hasRequiredDomParser;

        function requireDomParser() {
          if (hasRequiredDomParser) return domParser;
          hasRequiredDomParser = 1;
          var conventions = requireConventions();
          var dom = requireDom();
          var entities = requireEntities();
          var sax = requireSax();

          var DOMImplementation = dom.DOMImplementation;

          var NAMESPACE = conventions.NAMESPACE;

          var ParseError = sax.ParseError;
          var XMLReader = sax.XMLReader;

          /**
           * Normalizes line ending according to https://www.w3.org/TR/xml11/#sec-line-ends:
           *
           * > XML parsed entities are often stored in computer files which,
           * > for editing convenience, are organized into lines.
           * > These lines are typically separated by some combination
           * > of the characters CARRIAGE RETURN (#xD) and LINE FEED (#xA).
           * >
           * > To simplify the tasks of applications, the XML processor must behave
           * > as if it normalized all line breaks in external parsed entities (including the document entity)
           * > on input, before parsing, by translating all of the following to a single #xA character:
           * >
           * > 1. the two-character sequence #xD #xA
           * > 2. the two-character sequence #xD #x85
           * > 3. the single character #x85
           * > 4. the single character #x2028
           * > 5. any #xD character that is not immediately followed by #xA or #x85.
           *
           * @param {string} input
           * @returns {string}
           */
          function normalizeLineEndings(input) {
            return input
              .replace(/\r[\n\u0085]/g, '\n')
              .replace(/[\r\u0085\u2028]/g, '\n')
          }

          /**
           * @typedef Locator
           * @property {number} [columnNumber]
           * @property {number} [lineNumber]
           */

          /**
           * @typedef DOMParserOptions
           * @property {DOMHandler} [domBuilder]
           * @property {Function} [errorHandler]
           * @property {(string) => string} [normalizeLineEndings] used to replace line endings before parsing
           * 						defaults to `normalizeLineEndings`
           * @property {Locator} [locator]
           * @property {Record<string, string>} [xmlns]
           *
           * @see normalizeLineEndings
           */

          /**
           * The DOMParser interface provides the ability to parse XML or HTML source code
           * from a string into a DOM `Document`.
           *
           * _xmldom is different from the spec in that it allows an `options` parameter,
           * to override the default behavior._
           *
           * @param {DOMParserOptions} [options]
           * @constructor
           *
           * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser
           * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-parsing-and-serialization
           */
          function DOMParser(options) {
            this.options = options || { locator: {} };
          }

          DOMParser.prototype.parseFromString = function (source, mimeType) {
            var options = this.options;
            var sax = new XMLReader();
            var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
            var errorHandler = options.errorHandler;
            var locator = options.locator;
            var defaultNSMap = options.xmlns || {};
            var isHTML = /\/x?html?$/.test(mimeType);//mimeType.toLowerCase().indexOf('html') > -1;
            var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
            if (locator) {
              domBuilder.setDocumentLocator(locator);
            }

            sax.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
            sax.domBuilder = options.domBuilder || domBuilder;
            if (isHTML) {
              defaultNSMap[''] = NAMESPACE.HTML;
            }
            defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
            var normalize = options.normalizeLineEndings || normalizeLineEndings;
            if (source && typeof source === 'string') {
              sax.parse(
                normalize(source),
                defaultNSMap,
                entityMap
              );
            } else {
              sax.errorHandler.error('invalid doc source');
            }
            return domBuilder.doc;
          };
          function buildErrorHandler(errorImpl, domBuilder, locator) {
            if (!errorImpl) {
              if (domBuilder instanceof DOMHandler) {
                return domBuilder;
              }
              errorImpl = domBuilder;
            }
            var errorHandler = {};
            var isCallback = errorImpl instanceof Function;
            locator = locator || {};
            function build(key) {
              var fn = errorImpl[key];
              if (!fn && isCallback) {
                fn = errorImpl.length == 2 ? function (msg) { errorImpl(key, msg); } : errorImpl;
              }
              errorHandler[key] = fn && function (msg) {
                fn('[xmldom ' + key + ']\t' + msg + _locator(locator));
              } || function () { };
            }
            build('warning');
            build('error');
            build('fatalError');
            return errorHandler;
          }

          //console.log('#\n\n\n\n\n\n\n####')
          /**
           * +ContentHandler+ErrorHandler
           * +LexicalHandler+EntityResolver2
           * -DeclHandler-DTDHandler
           *
           * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
           * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
           * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
           */
          function DOMHandler() {
            this.cdata = false;
          }
          function position(locator, node) {
            node.lineNumber = locator.lineNumber;
            node.columnNumber = locator.columnNumber;
          }
          /**
           * @see org.xml.sax.ContentHandler#startDocument
           * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
           */
          DOMHandler.prototype = {
            startDocument: function () {
              this.doc = new DOMImplementation().createDocument(null, null, null);
              if (this.locator) {
                this.doc.documentURI = this.locator.systemId;
              }
            },
            startElement: function (namespaceURI, localName, qName, attrs) {
              var doc = this.doc;
              var el = doc.createElementNS(namespaceURI, qName || localName);
              var len = attrs.length;
              appendElement(this, el);
              this.currentElement = el;

              this.locator && position(this.locator, el);
              for (var i = 0; i < len; i++) {
                var namespaceURI = attrs.getURI(i);
                var value = attrs.getValue(i);
                var qName = attrs.getQName(i);
                var attr = doc.createAttributeNS(namespaceURI, qName);
                this.locator && position(attrs.getLocator(i), attr);
                attr.value = attr.nodeValue = value;
                el.setAttributeNode(attr);
              }
            },
            endElement: function (namespaceURI, localName, qName) {
              var current = this.currentElement;
              current.tagName;
              this.currentElement = current.parentNode;
            },
            startPrefixMapping: function (prefix, uri) {
            },
            endPrefixMapping: function (prefix) {
            },
            processingInstruction: function (target, data) {
              var ins = this.doc.createProcessingInstruction(target, data);
              this.locator && position(this.locator, ins);
              appendElement(this, ins);
            },
            ignorableWhitespace: function (ch, start, length) {
            },
            characters: function (chars, start, length) {
              chars = _toString.apply(this, arguments);
              //console.log(chars)
              if (chars) {
                if (this.cdata) {
                  var charNode = this.doc.createCDATASection(chars);
                } else {
                  var charNode = this.doc.createTextNode(chars);
                }
                if (this.currentElement) {
                  this.currentElement.appendChild(charNode);
                } else if (/^\s*$/.test(chars)) {
                  this.doc.appendChild(charNode);
                  //process xml
                }
                this.locator && position(this.locator, charNode);
              }
            },
            skippedEntity: function (name) {
            },
            endDocument: function () {
              this.doc.normalize();
            },
            setDocumentLocator: function (locator) {
              if (this.locator = locator) {// && !('lineNumber' in locator)){
                locator.lineNumber = 0;
              }
            },
            //LexicalHandler
            comment: function (chars, start, length) {
              chars = _toString.apply(this, arguments);
              var comm = this.doc.createComment(chars);
              this.locator && position(this.locator, comm);
              appendElement(this, comm);
            },

            startCDATA: function () {
              //used in characters() methods
              this.cdata = true;
            },
            endCDATA: function () {
              this.cdata = false;
            },

            startDTD: function (name, publicId, systemId) {
              var impl = this.doc.implementation;
              if (impl && impl.createDocumentType) {
                var dt = impl.createDocumentType(name, publicId, systemId);
                this.locator && position(this.locator, dt);
                appendElement(this, dt);
                this.doc.doctype = dt;
              }
            },
            /**
             * @see org.xml.sax.ErrorHandler
             * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
             */
            warning: function (error) {
              console.warn('[xmldom warning]\t' + error, _locator(this.locator));
            },
            error: function (error) {
              console.error('[xmldom error]\t' + error, _locator(this.locator));
            },
            fatalError: function (error) {
              throw new ParseError(error, this.locator);
            }
          };
          function _locator(l) {
            if (l) {
              return '\n@' + (l.systemId || '') + '#[line:' + l.lineNumber + ',col:' + l.columnNumber + ']'
            }
          }
          function _toString(chars, start, length) {
            if (typeof chars == 'string') {
              return chars.substr(start, length)
            } else {//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
              if (chars.length >= start + length || start) {
                return new java.lang.String(chars, start, length) + '';
              }
              return chars;
            }
          }

          /*
           * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
           * used method of org.xml.sax.ext.LexicalHandler:
           *  #comment(chars, start, length)
           *  #startCDATA()
           *  #endCDATA()
           *  #startDTD(name, publicId, systemId)
           *
           *
           * IGNORED method of org.xml.sax.ext.LexicalHandler:
           *  #endDTD()
           *  #startEntity(name)
           *  #endEntity(name)
           *
           *
           * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
           * IGNORED method of org.xml.sax.ext.DeclHandler
           * 	#attributeDecl(eName, aName, type, mode, value)
           *  #elementDecl(name, model)
           *  #externalEntityDecl(name, publicId, systemId)
           *  #internalEntityDecl(name, value)
           * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
           * IGNORED method of org.xml.sax.EntityResolver2
           *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
           *  #resolveEntity(publicId, systemId)
           *  #getExternalSubset(name, baseURI)
           * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
           * IGNORED method of org.xml.sax.DTDHandler
           *  #notationDecl(name, publicId, systemId) {};
           *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
           */
          "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function (key) {
            DOMHandler.prototype[key] = function () { return null };
          });

          /* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
          function appendElement(hander, node) {
            if (!hander.currentElement) {
              hander.doc.appendChild(node);
            } else {
              hander.currentElement.appendChild(node);
            }
          }//appendChild and setAttributeNS are preformance key

          domParser.__DOMHandler = DOMHandler;
          domParser.normalizeLineEndings = normalizeLineEndings;
          domParser.DOMParser = DOMParser;
          return domParser;
        }

        var hasRequiredLib;

        function requireLib() {
          if (hasRequiredLib) return lib;
          hasRequiredLib = 1;
          var dom = requireDom();
          lib.DOMImplementation = dom.DOMImplementation;
          lib.XMLSerializer = dom.XMLSerializer;
          lib.DOMParser = requireDomParser().DOMParser;
          return lib;
        }

        var libExports = requireLib();

        function parseWorkflow(taskId, xml, done, thinking) {
          let _workflow = null;
          try {
            if (thinking) {
              _workflow = {
                taskId: taskId,
                name: "",
                thought: thinking,
                agents: [],
                xml: xml,
              };
            }
            let sIdx = xml.indexOf("<root>");
            if (sIdx == -1) {
              return _workflow;
            }
            xml = xml.substring(sIdx);
            let eIdx = xml.indexOf("</root>");
            if (eIdx > -1) {
              xml = xml.substring(0, eIdx + 7);
            }
            if (!done) {
              xml = fixXmlTag(xml);
            }
            const parser = new libExports.DOMParser();
            const doc = parser.parseFromString(xml, "text/xml");
            let root = doc.documentElement;
            if (root.tagName !== "root") {
              return _workflow;
            }
            const agents = [];
            const thought = root.getElementsByTagName("thought")[0]?.textContent || "";
            const workflow = {
              taskId: taskId,
              name: root.getElementsByTagName("name")[0]?.textContent || "",
              thought: thinking ? thinking + "\n" + thought : thought,
              agents: agents,
              xml: xml,
            };
            let agentsNode = root.getElementsByTagName("agents");
            let agentsNodes = agentsNode.length > 0 ? agentsNode[0].getElementsByTagName("agent") : [];
            for (let i = 0; i < agentsNodes.length; i++) {
              let agentNode = agentsNodes[i];
              let name = agentNode.getAttribute("name");
              if (!name) {
                break;
              }
              let index = agentNode.getAttribute("id") || i;
              let dependsOn = agentNode.getAttribute("dependsOn") || "";
              let nodes = [];
              let agent = {
                name: name,
                id: getAgentId(taskId, index),
                dependsOn: dependsOn.split(",").filter(idx => idx.trim() != "").map(idx => getAgentId(taskId, idx)),
                task: agentNode.getElementsByTagName("task")[0]?.textContent || "",
                nodes: nodes,
                status: "init",
                parallel: undefined,
                xml: agentNode.toString(),
              };
              let xmlNodes = agentNode.getElementsByTagName("nodes");
              if (xmlNodes.length > 0) {
                parseWorkflowNodes(nodes, xmlNodes[0].childNodes);
              }
              agents.push(agent);
            }
            if (done) {
              let agentTree = buildAgentTree(workflow.agents);
              while (true) {
                if (agentTree.type === "normal") {
                  agentTree.agent.parallel = false;
                }
                else {
                  const parallelAgents = agentTree.agents;
                  for (let i = 0; i < parallelAgents.length; i++) {
                    const agentNode = parallelAgents[i];
                    agentNode.agent.parallel = true;
                  }
                }
                if (!agentTree.nextAgent) {
                  break;
                }
                agentTree = agentTree.nextAgent;
              }
            }
            return workflow;
          }
          catch (e) {
            if (done) {
              throw e;
            }
            else {
              return _workflow;
            }
          }
        }
        function getAgentId(taskId, index) {
          return taskId + "-" + (+index < 10 ? "0" + index : index);
        }
        function parseWorkflowNodes(nodes, xmlNodes) {
          for (let i = 0; i < xmlNodes.length; i++) {
            if (xmlNodes[i].nodeType !== 1) {
              continue;
            }
            let xmlNode = xmlNodes[i];
            switch (xmlNode.tagName) {
              case "node": {
                let node = {
                  type: "normal",
                  text: xmlNode.textContent || "",
                  input: xmlNode.getAttribute("input"),
                  output: xmlNode.getAttribute("output"),
                };
                nodes.push(node);
                break;
              }
              case "forEach": {
                let _nodes = [];
                let node = {
                  type: "forEach",
                  items: (xmlNode.getAttribute("items") || "list"),
                  nodes: _nodes,
                };
                let _xmlNodes = xmlNode.getElementsByTagName("node");
                if (_xmlNodes.length > 0) {
                  parseWorkflowNodes(_nodes, _xmlNodes);
                }
                nodes.push(node);
                break;
              }
              case "watch": {
                let _nodes = [];
                let node = {
                  type: "watch",
                  event: (xmlNode.getAttribute("event") || ""),
                  loop: xmlNode.getAttribute("loop") == "true",
                  description: xmlNode.getElementsByTagName("description")[0]?.textContent || "",
                  triggerNodes: _nodes,
                };
                let triggerNode = xmlNode.getElementsByTagName("trigger");
                if (triggerNode.length > 0) {
                  parseWorkflowNodes(_nodes, triggerNode[0].childNodes);
                }
                nodes.push(node);
                break;
              }
            }
          }
        }
        function buildAgentRootXml(agentXml, mainTaskPrompt, nodeCallback) {
          const parser = new libExports.DOMParser();
          const doc = parser.parseFromString(agentXml, "text/xml");
          let agentNode = doc.getElementsByTagName("agent");
          let nodesNode = doc.getElementsByTagName("nodes");
          if (nodesNode.length > 0) {
            let nodes = nodesNode[0].childNodes;
            let nodeId = 0;
            for (let i = 0; i < nodes.length; i++) {
              let node = nodes[i];
              if (node.nodeType == 1) {
                node.setAttribute("id", nodeId + "");
                nodeCallback && nodeCallback(nodeId, node);
                nodeId++;
              }
            }
          }
          // <root><mainTask></mainTask><currentTask></currentTask><nodes><node id="0"></node></nodes></root>
          let agentInnerHTML = getInnerXML(agentNode[0]);
          let prefix = agentInnerHTML.substring(0, agentInnerHTML.indexOf("<task>"));
          agentInnerHTML = agentInnerHTML
            .replace("<task>", "<currentTask>")
            .replace("</task>", "</currentTask>");
          const xmlPrompt = `<root>${prefix}<mainTask>${mainTaskPrompt}</mainTask>${agentInnerHTML}</root>`;
          return xmlPrompt.replace(/      /g, "  ").replace("    </root>", "</root>");
        }
        function extractAgentXmlNode(agentXml, nodeId) {
          const parser = new libExports.DOMParser();
          const doc = parser.parseFromString(agentXml, "text/xml");
          let nodesNode = doc.getElementsByTagName("nodes");
          if (nodesNode.length > 0) {
            let nodes = nodesNode[0].childNodes;
            let _nodeId = 0;
            for (let i = 0; i < nodes.length; i++) {
              let node = nodes[i];
              if (node.nodeType == 1) {
                if (node.getAttribute("id") == null || node.getAttribute("id") == "") {
                  node.setAttribute("id", _nodeId + "");
                }
                _nodeId++;
                if (node.getAttribute("id") == nodeId + "") {
                  return node;
                }
              }
            }
          }
          return null;
        }
        function getInnerXML(node) {
          let result = "";
          const serializer = new libExports.XMLSerializer();
          for (let i = 0; i < node.childNodes.length; i++) {
            result += serializer.serializeToString(node.childNodes[i]);
          }
          return result;
        }
        function buildSimpleAgentWorkflow({ taskId, name, agentName, task, taskNodes, }) {
          if (!taskNodes || taskNodes.length == 0) {
            taskNodes = [task];
          }
          const workflow = {
            taskId: taskId,
            name: name,
            thought: "",
            agents: [
              {
                id: taskId + "-00",
                dependsOn: [],
                name: agentName,
                task: task,
                nodes: taskNodes.map((node) => {
                  return {
                    type: "normal",
                    text: node,
                  };
                }),
                status: "init",
                parallel: false,
                xml: "",
              },
            ],
            xml: "",
          };
          workflow.taskPrompt = task;
          resetWorkflowXml(workflow);
          return workflow;
        }
        function resetWorkflowXml(workflow) {
          const agents = [];
          for (let i = 0; i < workflow.agents.length; i++) {
            const agent = workflow.agents[i];
            const agentDependsAttr = ` id="${i}" dependsOn="${(agent.dependsOn || []).filter(s => parseInt(s.split("-")[s.split("-").length - 1])).join(",")}"`;
            const nodes = agent.nodes
              .map((node) => {
                if (node.type == "forEach") {
                  const forEachNodes = [];
                  for (let j = 0; j < node.nodes.length; j++) {
                    const _node = node.nodes[j];
                    const input = _node.input ? ` input="${_node.input}"` : "";
                    const output = _node.output ? ` output="${_node.output}"` : "";
                    forEachNodes.push(`          <node${input}${output}>${_node.text}</node>`);
                  }
                  return `        <forEach items="${node.items || ""}">
${forEachNodes.join("\n")}
        </forEach>`;
                }
                else if (node.type == "watch") {
                  const watchNodes = [];
                  for (let j = 0; j < node.triggerNodes.length; j++) {
                    const _node = node.triggerNodes[j];
                    const input = _node.input ? ` input="${_node.input}"` : "";
                    const output = _node.output ? ` output="${_node.output}"` : "";
                    watchNodes.push(`            <node${input}${output}>${_node.text}</node>`);
                  }
                  return `        <watch event="${node.event || "dom"}" loop="${node.loop ? "true" : "false"}">
          <description>${node.description}</description>
          <trigger>
${watchNodes.join("\n")}
          </trigger>
        </watch>`;
                }
                else {
                  const input = node.input ? ` input="${node.input}"` : "";
                  const output = node.output ? ` output="${node.output}"` : "";
                  return `        <node${input}${output}>${node.text}</node>`;
                }
              })
              .join("\n");
            const agentXml = `    <agent name="${agent.name}"${agentDependsAttr}>
      <task>${agent.task}</task>
      <nodes>
${nodes}
      </nodes>
    </agent>`;
            agent.xml = agentXml;
            agents.push(agentXml);
          }
          const xml = `<root>
  <name>${workflow.name}</name>
  <thought>${workflow.thought}</thought>
  <agents>
${agents.join("\n")}
  </agents>
</root>`;
          workflow.xml = xml;
        }

        const TOOL_NAME$b = "task_snapshot";
        class TaskSnapshotTool {
          constructor() {
            this.name = TOOL_NAME$b;
            this.description = `Task snapshot archive, recording key information of the current task, updating task node status, facilitating subsequent continuation of operation.`;
            this.parameters = {
              type: "object",
              properties: {
                doneIds: {
                  type: "array",
                  description: "Update task node completion status, list of completed node IDs.",
                  items: {
                    type: "number",
                  },
                },
                taskSnapshot: {
                  type: "string",
                  description: "Current task important information, as detailed as possible, ensure that the task progress can be restored through this information later, output records of completed task information, contextual information, variables used, pending tasks information, etc.",
                },
              },
              required: ["doneIds", "taskSnapshot"],
            };
          }
          async execute(args, agentContext) {
            let doneIds = args.doneIds;
            let taskSnapshot = args.taskSnapshot;
            let agentNode = agentContext.agentChain.agent;
            let taskPrompt = agentContext.context.chain.taskPrompt;
            let agentXml = buildAgentRootXml(agentNode.xml, taskPrompt, (nodeId, node) => {
              let done = doneIds.indexOf(nodeId) > -1;
              node.setAttribute("status", done ? "done" : "todo");
            });
            let text = "The current task has been interrupted. Below is a snapshot of the task execution history.\n" +
              "# Task Snapshot\n" +
              taskSnapshot.trim() +
              "\n\n# Task\n" +
              agentXml;
            return {
              content: [
                {
                  type: "text",
                  text: text,
                },
              ],
            };
          }
        }

        function extractUsedTool(messages, agentTools) {
          let tools = [];
          let toolNames = [];
          for (let i = 0; i < messages.length; i++) {
            let message = messages[i];
            if (message.role == "tool") {
              for (let j = 0; j < message.content.length; j++) {
                let toolName = message.content[j].toolName;
                if (toolNames.indexOf(toolName) > -1) {
                  continue;
                }
                toolNames.push(toolName);
                let tool = agentTools.filter((tool) => tool.name === toolName)[0];
                if (tool) {
                  tools.push(tool);
                }
              }
            }
          }
          return tools;
        }
        async function compressAgentMessages(agentContext, messages, tools) {
          if (messages.length < 5) {
            return;
          }
          try {
            await doCompressAgentMessages(agentContext, messages, tools);
          }
          catch (e) {
            Log.error("Error compressing agent messages:", e);
          }
        }
        async function doCompressAgentMessages(agentContext, messages, tools) {
          const ekoConfig = agentContext.context.config;
          const rlm = new RetryLanguageModel(ekoConfig.llms, ekoConfig.compressLlms);
          rlm.setContext(agentContext);
          // extract used tool
          const usedTools = extractUsedTool(messages, tools);
          const snapshotTool = new TaskSnapshotTool();
          const newTools = mergeTools(usedTools, [
            {
              type: "function",
              name: snapshotTool.name,
              description: snapshotTool.description,
              inputSchema: snapshotTool.parameters,
            },
          ]);
          // handle messages
          let lastToolIndex = messages.length - 1;
          let newMessages = messages;
          for (let r = newMessages.length - 1; r > 3; r--) {
            if (newMessages[r].role == "tool") {
              newMessages = newMessages.slice(0, r + 1);
              lastToolIndex = r;
              break;
            }
          }
          compressLargeContextMessages(newMessages);
          newMessages.push({
            role: "user",
            content: [
              {
                type: "text",
                text: "Please create a snapshot backup of the current task, keeping only key important information and node completion status.",
              },
            ],
          });
          // compress snapshot
          const result = await callAgentLLM(agentContext, rlm, newMessages, newTools, true, {
            type: "tool",
            toolName: snapshotTool.name,
          });
          const toolCall = result.filter((s) => s.type == "tool-call")[0];
          const args = typeof toolCall.input == "string"
            ? JSON.parse(toolCall.input || "{}")
            : toolCall.input || {};
          const toolResult = await snapshotTool.execute(args, agentContext);
          const callback = agentContext.context.config.callback;
          if (callback) {
            await callback.onMessage({
              streamType: "agent",
              chatId: agentContext.context.chatId,
              taskId: agentContext.context.taskId,
              agentName: agentContext.agent.Name,
              nodeId: agentContext.agentChain.agent.id,
              type: "tool_result",
              toolCallId: toolCall.toolCallId,
              toolName: toolCall.toolName,
              params: args,
              toolResult: toolResult,
            }, agentContext);
          }
          // handle original messages
          let firstToolIndex = 3;
          for (let i = 0; i < messages.length; i++) {
            if (messages[0].role == "tool") {
              firstToolIndex = i;
              break;
            }
          }
          // system, user, assistant, tool(first), [...], <user>, assistant, tool(last), ...
          messages.splice(firstToolIndex + 1, lastToolIndex - firstToolIndex - 2, {
            role: "user",
            content: toolResult.content.filter((s) => s.type == "text"),
          });
        }
        function compressLargeContextMessages(messages) {
          for (let r = 2; r < messages.length; r++) {
            const message = messages[r];
            if (message.role == "assistant") {
              message.content = message.content.map((c) => {
                if (c.type == "text" && c.text.length > config$1.largeTextLength) {
                  return {
                    ...c,
                    text: sub(c.text, config$1.largeTextLength, true),
                  };
                }
                return c;
              });
            }
            else if (message.role == "user") {
              message.content = message.content.map((c) => {
                if (c.type == "text" && c.text.length > config$1.largeTextLength) {
                  return {
                    ...c,
                    text: sub(c.text, config$1.largeTextLength, true),
                  };
                }
                return c;
              });
            }
            else if (message.role == "tool") {
              message.content = message.content.map((c) => {
                if (c.type == "tool-result" && c.output) {
                  const output = c.output;
                  if ((output.type == "text" || output.type == "error-text") &&
                    output.value.length > config$1.largeTextLength) {
                    return {
                      ...c,
                      output: {
                        ...output,
                        value: sub(output.value, config$1.largeTextLength, true),
                      },
                    };
                  }
                  else if ((output.type == "json" || output.type == "error-json") &&
                    JSON.stringify(output.value).length > config$1.largeTextLength) {
                    const json_str = sub(JSON.stringify(output.value), config$1.largeTextLength, false);
                    const json_obj = fixJson(json_str);
                    if (JSON.stringify(json_obj).length < 10) {
                      return {
                        ...c,
                        output: {
                          ...output,
                          value: json_str,
                          type: output.type == "error-json" ? "error-text" : "text",
                        },
                      };
                    }
                    else {
                      return {
                        ...c,
                        output: {
                          ...output,
                          value: json_obj,
                        },
                      };
                    }
                  }
                  else if (output.type == "content") {
                    for (let i = 0; i < output.value.length; i++) {
                      const content = output.value[i];
                      if (content.type == "text" &&
                        content.text.length > config$1.largeTextLength) {
                        content.text = sub(content.text, config$1.largeTextLength, true);
                      }
                    }
                  }
                }
                return c;
              });
            }
          }
        }
        function handleLargeContextMessages(messages) {
          let imageNum = 0;
          let fileNum = 0;
          let maxNum = config$1.maxDialogueImgFileNum;
          let longTextTools = {};
          for (let i = messages.length - 1; i >= 0; i--) {
            let message = messages[i];
            if (message.role == "user") {
              for (let j = 0; j < message.content.length; j++) {
                let content = message.content[j];
                if (content.type == "file" && content.mediaType.startsWith("image/")) {
                  if (++imageNum <= maxNum) {
                    break;
                  }
                  content = {
                    type: "text",
                    text: "[image]",
                  };
                  message.content[j] = content;
                }
                else if (content.type == "file") {
                  if (++fileNum <= maxNum) {
                    break;
                  }
                  content = {
                    type: "text",
                    text: "[file]",
                  };
                  message.content[j] = content;
                }
              }
            }
            else if (message.role == "tool") {
              for (let j = 0; j < message.content.length; j++) {
                let toolResult = message.content[j];
                let toolContent = toolResult.output;
                if (!toolContent || toolContent.type != "content") {
                  continue;
                }
                for (let r = 0; r < toolContent.value.length; r++) {
                  let _content = toolContent.value[r];
                  if (_content.type == "media" &&
                    _content.mediaType.startsWith("image/")) {
                    if (++imageNum <= maxNum) {
                      break;
                    }
                    _content = {
                      type: "text",
                      text: "[image]",
                    };
                    toolContent.value[r] = _content;
                  }
                }
                for (let r = 0; r < toolContent.value.length; r++) {
                  let _content = toolContent.value[r];
                  if (_content.type == "text" &&
                    _content.text?.length > config$1.largeTextLength) {
                    if (!longTextTools[toolResult.toolName]) {
                      longTextTools[toolResult.toolName] = 1;
                      break;
                    }
                    else {
                      longTextTools[toolResult.toolName]++;
                    }
                    _content = {
                      type: "text",
                      text: sub(_content.text, config$1.largeTextLength, true),
                    };
                    toolContent.value[r] = _content;
                  }
                }
              }
            }
          }
        }

        function defaultLLMProviderOptions() {
          return {
            openai: {
              stream_options: {
                include_usage: true,
              },
            },
            openrouter: {
              reasoning: {
                max_tokens: 10,
              },
            },
          };
        }
        function defaultMessageProviderOptions() {
          return {
            anthropic: {
              cacheControl: { type: "ephemeral" },
            },
            bedrock: {
              cachePoint: { type: "default" },
            },
            openrouter: {
              cacheControl: { type: "ephemeral" },
            },
          };
        }
        function convertTools(tools) {
          return tools.map((tool) => ({
            type: "function",
            name: tool.name,
            description: tool.description,
            inputSchema: tool.parameters,
            // providerOptions: defaultMessageProviderOptions()
          }));
        }
        function getTool(tools, name) {
          for (let i = 0; i < tools.length; i++) {
            if (tools[i].name == name) {
              return tools[i];
            }
          }
          return null;
        }
        function convertToolResult(toolUse, toolResult, user_messages) {
          let result;
          if (!toolResult || !toolResult.content) {
            result = {
              type: "error-text",
              value: "Error",
            };
          }
          else if (toolResult.content.length == 1 &&
            toolResult.content[0].type == "text") {
            let text = toolResult.content[0].text;
            result = {
              type: "text",
              value: text,
            };
            let isError = toolResult.isError == true;
            if (isError && !text.startsWith("Error")) {
              text = "Error: " + text;
              result = {
                type: "error-text",
                value: text,
              };
            }
            else if (!isError && text.length == 0) {
              text = "Successful";
              result = {
                type: "text",
                value: text,
              };
            }
            if (text &&
              ((text.startsWith("{") && text.endsWith("}")) ||
                (text.startsWith("[") && text.endsWith("]")))) {
              try {
                result = JSON.parse(text);
                result = {
                  type: "json",
                  value: result,
                };
              }
              catch (e) { }
            }
          }
          else {
            result = {
              type: "content",
              value: [],
            };
            for (let i = 0; i < toolResult.content.length; i++) {
              let content = toolResult.content[i];
              if (content.type == "text") {
                result.value.push({
                  type: "text",
                  text: content.text,
                });
              }
              else {
                if (config$1.toolResultMultimodal) {
                  // Support returning images from tool results
                  let mediaData = content.data;
                  if (mediaData.startsWith("data:")) {
                    mediaData = mediaData.substring(mediaData.indexOf(",") + 1);
                  }
                  result.value.push({
                    type: "media",
                    data: mediaData,
                    mediaType: content.mimeType || "image/png",
                  });
                }
                else {
                  // Only the claude model supports returning images from tool results, while openai only supports text,
                  // Compatible with other AI models that do not support tool results as images.
                  if (user_messages) {
                    user_messages.push({
                      role: "user",
                      content: [
                        {
                          type: "file",
                          data: toFile(content.data),
                          mediaType: content.mimeType || getMimeType(content.data),
                        },
                        {
                          type: "text",
                          text: `call \`${toolUse.toolName}\` tool result`,
                        },
                      ],
                    });
                  }
                  else {
                    result.value.push({
                      type: "text",
                      text: "[image]",
                    });
                  }
                }
              }
            }
          }
          return {
            type: "tool-result",
            toolCallId: toolUse.toolCallId,
            toolName: toolUse.toolName,
            output: result,
          };
        }
        async function callAgentLLM(agentContext, rlm, messages, tools, noCompress, toolChoice, retryNum = 0, callback, requestHandler) {
          await agentContext.context.checkAborted();
          if (!noCompress &&
            (messages.length >= config$1.compressThreshold ||
              (messages.length >= 10 &&
                estimatePromptTokens(messages, tools) >=
                config$1.compressTokensThreshold))) {
            // Compress messages
            await compressAgentMessages(agentContext, messages, tools);
          }
          if (!toolChoice) {
            // Append user dialogue
            appendUserConversation(agentContext, messages);
          }
          const context = agentContext.context;
          const agentChain = agentContext.agentChain;
          const agentNode = agentChain.agent;
          const streamCallback = callback ||
            context.config.callback || {
            onMessage: async () => { },
          };
          const stepController = new AbortController();
          const signal = AbortSignal.any([
            context.controller.signal,
            stepController.signal,
          ]);
          const request = {
            tools: tools,
            toolChoice,
            messages: messages,
            abortSignal: signal,
          };
          requestHandler && requestHandler(request);
          let streamText = "";
          let thinkText = "";
          let toolArgsText = "";
          let textStreamId = uuidv4();
          let thinkStreamId = uuidv4();
          let textStreamDone = false;
          const toolParts = [];
          let reader = null;
          try {
            agentChain.agentRequest = request;
            context.currentStepControllers.add(stepController);
            const result = await rlm.callStream(request);
            reader = result.stream.getReader();
            let toolPart = null;
            while (true) {
              await context.checkAborted();
              const { done, value } = await reader.read();
              if (done) {
                break;
              }
              const chunk = value;
              switch (chunk.type) {
                case "text-start": {
                  textStreamId = uuidv4();
                  break;
                }
                case "text-delta": {
                  if (toolPart && !chunk.delta) {
                    continue;
                  }
                  streamText += chunk.delta || "";
                  await streamCallback.onMessage({
                    streamType: "agent",
                    chatId: context.chatId,
                    taskId: context.taskId,
                    agentName: agentNode.name,
                    nodeId: agentNode.id,
                    type: "text",
                    streamId: textStreamId,
                    streamDone: false,
                    text: streamText,
                  }, agentContext);
                  if (toolPart) {
                    await streamCallback.onMessage({
                      streamType: "agent",
                      chatId: context.chatId,
                      taskId: context.taskId,
                      agentName: agentNode.name,
                      nodeId: agentNode.id,
                      type: "tool_use",
                      toolCallId: toolPart.toolCallId,
                      toolName: toolPart.toolName,
                      params: toolPart.input || {},
                    }, agentContext);
                    toolPart = null;
                  }
                  break;
                }
                case "text-end": {
                  textStreamDone = true;
                  if (streamText) {
                    await streamCallback.onMessage({
                      streamType: "agent",
                      chatId: context.chatId,
                      taskId: context.taskId,
                      agentName: agentNode.name,
                      nodeId: agentNode.id,
                      type: "text",
                      streamId: textStreamId,
                      streamDone: true,
                      text: streamText,
                    }, agentContext);
                  }
                  break;
                }
                case "reasoning-start": {
                  thinkStreamId = uuidv4();
                  break;
                }
                case "reasoning-delta": {
                  thinkText += chunk.delta || "";
                  await streamCallback.onMessage({
                    streamType: "agent",
                    chatId: context.chatId,
                    taskId: context.taskId,
                    agentName: agentNode.name,
                    nodeId: agentNode.id,
                    type: "thinking",
                    streamId: thinkStreamId,
                    streamDone: false,
                    text: thinkText,
                  }, agentContext);
                  break;
                }
                case "reasoning-end": {
                  if (thinkText) {
                    await streamCallback.onMessage({
                      streamType: "agent",
                      chatId: context.chatId,
                      taskId: context.taskId,
                      agentName: agentNode.name,
                      nodeId: agentNode.id,
                      type: "thinking",
                      streamId: thinkStreamId,
                      streamDone: true,
                      text: thinkText,
                    }, agentContext);
                  }
                  break;
                }
                case "tool-input-start": {
                  if (toolPart && toolPart.toolCallId == chunk.id) {
                    toolPart.toolName = chunk.toolName;
                  }
                  else {
                    toolPart = {
                      type: "tool-call",
                      toolCallId: chunk.id,
                      toolName: chunk.toolName,
                      input: {},
                    };
                    toolParts.push(toolPart);
                  }
                  break;
                }
                case "tool-input-delta": {
                  if (!textStreamDone) {
                    textStreamDone = true;
                    await streamCallback.onMessage({
                      streamType: "agent",
                      chatId: context.chatId,
                      taskId: context.taskId,
                      agentName: agentNode.name,
                      nodeId: agentNode.id,
                      type: "text",
                      streamId: textStreamId,
                      streamDone: true,
                      text: streamText,
                    }, agentContext);
                  }
                  toolArgsText += chunk.delta || "";
                  await streamCallback.onMessage({
                    streamType: "agent",
                    chatId: context.chatId,
                    taskId: context.taskId,
                    agentName: agentNode.name,
                    nodeId: agentNode.id,
                    type: "tool_streaming",
                    toolCallId: chunk.id,
                    toolName: toolPart?.toolName || "",
                    paramsText: toolArgsText,
                  }, agentContext);
                  break;
                }
                case "tool-call": {
                  toolArgsText = "";
                  const args = chunk.input ? JSON.parse(chunk.input) : {};
                  const message = {
                    streamType: "agent",
                    chatId: context.chatId,
                    taskId: context.taskId,
                    agentName: agentNode.name,
                    nodeId: agentNode.id,
                    type: "tool_use",
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    params: args,
                  };
                  await streamCallback.onMessage(message, agentContext);
                  if (toolPart == null) {
                    toolParts.push({
                      type: "tool-call",
                      toolCallId: chunk.toolCallId,
                      toolName: chunk.toolName,
                      input: message.params || args,
                    });
                  }
                  else {
                    toolPart.input = message.params || args;
                    toolPart = null;
                  }
                  break;
                }
                case "file": {
                  await streamCallback.onMessage({
                    streamType: "agent",
                    chatId: context.chatId,
                    taskId: context.taskId,
                    agentName: agentNode.name,
                    nodeId: agentNode.id,
                    type: "file",
                    mimeType: chunk.mediaType,
                    data: chunk.data,
                  }, agentContext);
                  break;
                }
                case "error": {
                  Log.error(`${agentNode.name} agent error: `, chunk);
                  await streamCallback.onMessage({
                    streamType: "agent",
                    chatId: context.chatId,
                    taskId: context.taskId,
                    agentName: agentNode.name,
                    nodeId: agentNode.id,
                    type: "error",
                    error: chunk.error,
                  }, agentContext);
                  throw new Error("LLM Error: " + chunk.error);
                }
                case "finish": {
                  if (!textStreamDone) {
                    textStreamDone = true;
                    await streamCallback.onMessage({
                      streamType: "agent",
                      chatId: context.chatId,
                      taskId: context.taskId,
                      agentName: agentNode.name,
                      nodeId: agentNode.id,
                      type: "text",
                      streamId: textStreamId,
                      streamDone: true,
                      text: streamText,
                    }, agentContext);
                  }
                  if (chunk.finishReason === "content-filter") {
                    throw new Error("LLM error: trigger content filtering violation");
                  }
                  else if (chunk.finishReason === "other") {
                    throw new Error("LLM error: terminated due to other reasons");
                  }
                  else if (chunk.finishReason === "length" &&
                    messages.length >= 3 &&
                    !noCompress &&
                    retryNum < config$1.maxRetryNum) {
                    await compressAgentMessages(agentContext, messages, tools);
                    return callAgentLLM(agentContext, rlm, messages, tools, noCompress, toolChoice, ++retryNum, streamCallback);
                  }
                  if (toolPart) {
                    await streamCallback.onMessage({
                      streamType: "agent",
                      chatId: context.chatId,
                      taskId: context.taskId,
                      agentName: agentNode.name,
                      nodeId: agentNode.id,
                      type: "tool_use",
                      toolCallId: toolPart.toolCallId,
                      toolName: toolPart.toolName,
                      params: toolPart.input || {},
                    }, agentContext);
                    toolPart = null;
                  }
                  await streamCallback.onMessage({
                    streamType: "agent",
                    chatId: context.chatId,
                    taskId: context.taskId,
                    agentName: agentNode.name,
                    nodeId: agentNode.id,
                    type: "finish",
                    finishReason: chunk.finishReason,
                    usage: {
                      promptTokens: chunk.usage.inputTokens || 0,
                      completionTokens: chunk.usage.outputTokens || 0,
                      totalTokens: chunk.usage.totalTokens ||
                        (chunk.usage.inputTokens || 0) +
                        (chunk.usage.outputTokens || 0),
                    },
                  }, agentContext);
                  break;
                }
              }
            }
          }
          catch (e) {
            await context.checkAborted();
            if (retryNum < config$1.maxRetryNum) {
              await sleep(300 * (retryNum + 1) * (retryNum + 1));
              if ((e + "").indexOf("is too long") > -1) {
                await compressAgentMessages(agentContext, messages, tools);
              }
              return callAgentLLM(agentContext, rlm, messages, tools, noCompress, toolChoice, ++retryNum, streamCallback);
            }
            throw e;
          }
          finally {
            reader && reader.releaseLock();
            context.currentStepControllers.delete(stepController);
          }
          agentChain.agentResult = streamText;
          return streamText
            ? [
              { type: "text", text: streamText },
              ...toolParts,
            ]
            : toolParts;
        }
        function estimatePromptTokens(messages, tools) {
          let tokens = messages.reduce((total, message) => {
            if (message.role == "system") {
              return total + estimateTokens(message.content);
            }
            else if (message.role == "user") {
              return (total +
                estimateTokens(message.content
                  .filter((part) => part.type == "text")
                  .map((part) => part.text)
                  .join("\n")));
            }
            else if (message.role == "assistant") {
              return (total +
                estimateTokens(message.content
                  .map((part) => {
                    if (part.type == "text") {
                      return part.text;
                    }
                    else if (part.type == "reasoning") {
                      return part.text;
                    }
                    else if (part.type == "tool-call") {
                      return part.toolName + JSON.stringify(part.input || {});
                    }
                    else if (part.type == "tool-result") {
                      return part.toolName + JSON.stringify(part.output || {});
                    }
                    return "";
                  })
                  .join("")));
            }
            else if (message.role == "tool") {
              return (total +
                estimateTokens(message.content
                  .map((part) => part.toolName + JSON.stringify(part.output || {}))
                  .join("")));
            }
            return total;
          }, 0);
          if (tools) {
            tokens += tools.reduce((total, tool) => {
              return total + estimateTokens(JSON.stringify(tool));
            }, 0);
          }
          return tokens;
        }
        function estimateTokens(text) {
          if (!text) {
            return 0;
          }
          let tokenCount = 0;
          for (let i = 0; i < text.length; i++) {
            const char = text[i];
            const code = char.charCodeAt(0);
            if ((code >= 0x4e00 && code <= 0x9fff) ||
              (code >= 0x3400 && code <= 0x4dbf) ||
              (code >= 0x3040 && code <= 0x309f) ||
              (code >= 0x30a0 && code <= 0x30ff) ||
              (code >= 0xac00 && code <= 0xd7af)) {
              tokenCount += 2;
            }
            else if (/\s/.test(char)) {
              continue;
            }
            else if (/[a-zA-Z]/.test(char)) {
              let word = "";
              while (i < text.length && /[a-zA-Z]/.test(text[i])) {
                word += text[i];
                i++;
              }
              i--;
              if (word.length <= 4) {
                tokenCount += 1;
              }
              else {
                tokenCount += Math.ceil(word.length / 4);
              }
            }
            else if (/\d/.test(char)) {
              let number = "";
              while (i < text.length && /\d/.test(text[i])) {
                number += text[i];
                i++;
              }
              i--;
              tokenCount += Math.max(1, Math.ceil(number.length / 3));
            }
            else {
              tokenCount += 1;
            }
          }
          return Math.max(1, tokenCount);
        }
        function appendUserConversation(agentContext, messages) {
          const userPrompts = agentContext.context.conversation
            .splice(0, agentContext.context.conversation.length)
            .filter((s) => !!s);
          if (userPrompts.length > 0) {
            const prompt = "The user is intervening in the current task, please replan and execute according to the following instructions:\n" +
              userPrompts.map((s) => `- ${s.trim()}`).join("\n");
            messages.push({
              role: "user",
              content: [{ type: "text", text: prompt }],
            });
          }
        }

        class TaskContext {
          constructor(chatId, taskId, config, agents, chain) {
            this.conversation = [];
            this.pauseStatus = 0;
            this.currentStepControllers = new Set();
            this.chatId = chatId;
            this.taskId = taskId;
            this.config = config;
            this.agents = agents;
            this.chain = chain;
            this.variables = new Map();
            this.controller = new AbortController();
          }
          async checkAborted(noCheckPause) {
            if (this.controller.signal.aborted) {
              const error = new Error("Operation was interrupted");
              error.name = "AbortError";
              throw error;
            }
            while (this.pauseStatus > 0 && !noCheckPause) {
              await sleep(500);
              if (this.pauseStatus == 2) {
                this.currentStepControllers.forEach((c) => {
                  c.abort("Pause");
                });
                this.currentStepControllers.clear();
              }
              if (this.controller.signal.aborted) {
                const error = new Error("Operation was interrupted");
                error.name = "AbortError";
                throw error;
              }
            }
          }
          currentAgent() {
            const agentNode = this.chain.agents[this.chain.agents.length - 1];
            if (!agentNode) {
              return null;
            }
            const agent = this.agents.filter((agent) => agent.Name == agentNode.agent.name)[0];
            if (!agent) {
              return null;
            }
            const agentContext = agent.AgentContext;
            return [agent, agentNode.agent, agentContext];
          }
          get pause() {
            return this.pauseStatus > 0;
          }
          setPause(pause, abortCurrentStep) {
            this.pauseStatus = pause ? (abortCurrentStep ? 2 : 1) : 0;
            if (this.pauseStatus == 2) {
              this.currentStepControllers.forEach((c) => {
                c.abort("Pause");
              });
              this.currentStepControllers.clear();
            }
          }
          reset() {
            this.pauseStatus = 0;
            if (!this.controller.signal.aborted) {
              this.controller.abort();
            }
            this.currentStepControllers.forEach((c) => {
              c.abort("reset");
            });
            this.currentStepControllers.clear();
            this.controller = new AbortController();
          }
        }
        class AgentContext {
          constructor(context, agent, agentChain) {
            this.context = context;
            this.agent = agent;
            this.agentChain = agentChain;
            this.variables = new Map();
            this.consecutiveErrorNum = 0;
          }
        }

        class RetryLanguageModel {
          constructor(llms, names, stream_first_timeout, stream_token_timeout, context) {
            this.llms = llms;
            this.names = names || [];
            context && this.setContext(context);
            this.stream_first_timeout = stream_first_timeout || 30000;
            this.stream_token_timeout = stream_token_timeout || 180000;
            if (this.names.indexOf("default") == -1) {
              this.names.push("default");
            }
          }
          setContext(context) {
            if (!context) {
              this.context = undefined;
              this.agentContext = undefined;
              return;
            }
            this.context = context instanceof TaskContext ? context : context.context;
            this.agentContext = context instanceof AgentContext ? context : undefined;
          }
          async call(request) {
            return await this.doGenerate({
              prompt: request.messages,
              tools: request.tools,
              toolChoice: request.toolChoice,
              maxOutputTokens: request.maxOutputTokens,
              temperature: request.temperature,
              topP: request.topP,
              topK: request.topK,
              stopSequences: request.stopSequences,
              abortSignal: request.abortSignal,
            });
          }
          async doGenerate(options) {
            const maxOutputTokens = options.maxOutputTokens;
            const providerOptions = options.providerOptions;
            const names = [...this.names, ...this.names];
            let lastError;
            for (let i = 0; i < names.length; i++) {
              const name = names[i];
              const llmConfig = this.llms[name];
              const llm = await this.getLLM(name);
              if (!llm) {
                continue;
              }
              if (!maxOutputTokens) {
                options.maxOutputTokens =
                  llmConfig.config?.maxOutputTokens || config$1.maxOutputTokens;
              }
              if (!providerOptions) {
                options.providerOptions = defaultLLMProviderOptions();
                options.providerOptions[llm.provider] = llmConfig.options || {};
              }
              let _options = options;
              if (llmConfig.handler) {
                _options = await llmConfig.handler(_options, this.context, this.agentContext);
              }
              try {
                let result = (await llm.doGenerate(_options));
                if (Log.isEnableDebug()) {
                  Log.debug(`LLM nonstream body, name: ${name} => `, result.request?.body);
                }
                result.llm = name;
                result.llmConfig = llmConfig;
                result.text = result.content.find((c) => c.type === "text")?.text;
                return result;
              }
              catch (e) {
                if (e?.name === "AbortError") {
                  throw e;
                }
                lastError = e;
                if (Log.isEnableInfo()) {
                  Log.info(`LLM nonstream request, name: ${name} => `, {
                    tools: _options.tools,
                    messages: _options.prompt,
                  });
                }
                Log.error(`LLM error, name: ${name} => `, e);
              }
            }
            return Promise.reject(lastError ? lastError : new Error("No LLM available"));
          }
          async callStream(request) {
            return await this.doStream({
              prompt: request.messages,
              tools: request.tools,
              toolChoice: request.toolChoice,
              maxOutputTokens: request.maxOutputTokens,
              temperature: request.temperature,
              topP: request.topP,
              topK: request.topK,
              stopSequences: request.stopSequences,
              abortSignal: request.abortSignal,
            });
          }
          async doStream(options) {
            const maxOutputTokens = options.maxOutputTokens;
            const providerOptions = options.providerOptions;
            const names = [...this.names, ...this.names];
            let lastError;
            for (let i = 0; i < names.length; i++) {
              const name = names[i];
              const llmConfig = this.llms[name];
              const llm = await this.getLLM(name);
              if (!llm) {
                continue;
              }
              if (!maxOutputTokens) {
                options.maxOutputTokens =
                  llmConfig.config?.maxOutputTokens || config$1.maxOutputTokens;
              }
              if (!providerOptions) {
                options.providerOptions = defaultLLMProviderOptions();
                options.providerOptions[llm.provider] = llmConfig.options || {};
              }
              let _options = options;
              if (llmConfig.handler) {
                _options = await llmConfig.handler(_options, this.context, this.agentContext);
              }
              try {
                const controller = new AbortController();
                const signal = _options.abortSignal
                  ? AbortSignal.any([_options.abortSignal, controller.signal])
                  : controller.signal;
                const result = (await call_timeout(async () => await llm.doStream({ ..._options, abortSignal: signal }), this.stream_first_timeout, (e) => {
                  controller.abort();
                }));
                const stream = result.stream;
                const reader = stream.getReader();
                const { done, value } = await call_timeout(async () => await reader.read(), this.stream_first_timeout, (e) => {
                  reader.cancel();
                  reader.releaseLock();
                  controller.abort();
                });
                if (done) {
                  Log.warn(`LLM stream done, name: ${name} => `, { done, value });
                  reader.releaseLock();
                  continue;
                }
                if (Log.isEnableDebug()) {
                  Log.debug(`LLM stream body, name: ${name} => `, result.request?.body);
                }
                let chunk = value;
                if (chunk.type == "error") {
                  Log.error(`LLM stream error, name: ${name}`, chunk);
                  reader.releaseLock();
                  continue;
                }
                result.llm = name;
                result.llmConfig = llmConfig;
                result.stream = this.streamWrapper([chunk], reader, controller);
                return result;
              }
              catch (e) {
                if (e?.name === "AbortError") {
                  throw e;
                }
                lastError = e;
                if (Log.isEnableInfo()) {
                  Log.info(`LLM stream request, name: ${name} => `, {
                    tools: _options.tools,
                    messages: _options.prompt,
                  });
                }
                Log.error(`LLM error, name: ${name} => `, e);
              }
            }
            return Promise.reject(lastError ? lastError : new Error("No LLM available"));
          }
          async getLLM(name) {
            const llm = this.llms[name];
            if (!llm) {
              return null;
            }
            let apiKey;
            if (typeof llm.apiKey === "string") {
              apiKey = llm.apiKey;
            }
            else {
              apiKey = await llm.apiKey();
            }
            let baseURL = undefined;
            if (llm.config?.baseURL) {
              if (typeof llm.config.baseURL === "string") {
                baseURL = llm.config.baseURL;
              }
              else {
                baseURL = await llm.config.baseURL();
              }
            }
            if (llm.provider == "openai") {
              if (!baseURL ||
                baseURL.indexOf("openai.com") > -1 ||
                llm.config?.organization ||
                llm.config?.openai) {
                return createOpenAI({
                  apiKey: apiKey,
                  baseURL: baseURL,
                  fetch: llm.fetch,
                  organization: llm.config?.organization,
                  project: llm.config?.project,
                  headers: llm.config?.headers,
                }).languageModel(llm.model);
              }
              else {
                return createOpenAICompatible({
                  name: llm.model,
                  apiKey: apiKey,
                  baseURL: baseURL,
                  fetch: llm.fetch,
                  headers: llm.config?.headers,
                }).languageModel(llm.model);
              }
            }
            else if (llm.provider == "anthropic") {
              return createAnthropic({
                apiKey: apiKey,
                baseURL: baseURL,
                fetch: llm.fetch,
                headers: llm.config?.headers,
              }).languageModel(llm.model);
            }
            else if (llm.provider == "google") {
              return createGoogleGenerativeAI({
                apiKey: apiKey,
                baseURL: baseURL,
                fetch: llm.fetch,
                headers: llm.config?.headers,
              }).languageModel(llm.model);
            }
            else if (llm.provider == "aws") {
              let keys = apiKey.split("=");
              return createAmazonBedrock({
                accessKeyId: keys[0],
                secretAccessKey: keys[1],
                baseURL: baseURL,
                region: llm.config?.region || "us-west-1",
                fetch: llm.fetch,
                headers: llm.config?.headers,
                sessionToken: llm.config?.sessionToken,
              }).languageModel(llm.model);
            }
            else if (llm.provider == "openai-compatible") {
              return createOpenAICompatible({
                name: llm.config?.name || llm.model.split("/")[0],
                apiKey: apiKey,
                baseURL: baseURL || "https://openrouter.ai/api/v1",
                fetch: llm.fetch,
                headers: llm.config?.headers,
              }).languageModel(llm.model);
            }
            else if (llm.provider == "openrouter") {
              return createOpenRouter({
                apiKey: apiKey,
                baseURL: baseURL || "https://openrouter.ai/api/v1",
                fetch: llm.fetch,
                headers: llm.config?.headers,
                compatibility: llm.config?.compatibility,
              }).languageModel(llm.model);
            }
            else if (llm.provider == "modelscope") {
              return createOpenAICompatible({
                name: llm.config?.name || llm.model.split("/")[0],
                apiKey: apiKey,
                baseURL: baseURL || "https://api-inference.modelscope.cn/v1",
                fetch: llm.fetch,
                headers: llm.config?.headers,
              }).languageModel(llm.model);
            }
            else if (llm.provider == "groq") {
              return createOpenAICompatible({
                name: llm.config?.name || "groq",
                apiKey: apiKey,
                baseURL: baseURL || "https://api.groq.com/openai/v1",
                fetch: llm.fetch,
                headers: llm.config?.headers,
              }).languageModel(llm.model);
            }
            else if (llm.provider == "cerebras") {
              return createOpenAICompatible({
                name: llm.config?.name || "cerebras",
                apiKey: apiKey,
                baseURL: baseURL || "https://api.cerebras.ai/v1",
                fetch: llm.fetch,
                headers: llm.config?.headers,
              }).languageModel(llm.model);
            }
            else {
              return llm.provider.languageModel(llm.model);
            }
          }
          streamWrapper(parts, reader, abortController) {
            let timer = null;
            return new ReadableStream({
              start: (controller) => {
                if (parts != null && parts.length > 0) {
                  for (let i = 0; i < parts.length; i++) {
                    controller.enqueue(parts[i]);
                  }
                }
              },
              pull: async (controller) => {
                timer = setTimeout(() => {
                  abortController.abort("Streaming request timeout");
                }, this.stream_token_timeout);
                const { done, value } = await reader.read();
                clearTimeout(timer);
                if (done) {
                  controller.close();
                  reader.releaseLock();
                  return;
                }
                controller.enqueue(value);
              },
              cancel: (reason) => {
                timer && clearTimeout(timer);
                reader.cancel(reason);
              },
            });
          }
          get Llms() {
            return this.llms;
          }
          get Names() {
            return this.names;
          }
        }

        const global = {
          chatMap: new Map(),
          taskMap: new Map(),
          prompts: new Map(),
        };

        const GlobalPromptKey = {
          planner_system: "planner_system",
          planner_example: "planner_example",
          planner_user: "planner_user",
          agent_system: "agent_system",
          chat_system: "chat_system",
          webpage_qa_prompt: "webpage_qa_prompt",
          deep_action_description: "deep_action_description",
          deep_action_param_task_description: "deep_action_param_task_description",
        };

        class PromptTemplate {
          /**
           * Simple template rendering method, does not support nesting.
           *
           * @param template - The prompt template to render.
           * Example:
           * ```
           * <if param1>
           * param1: {{param1}}
           * </if>
           * ----param2: {{param2}}
           * <if param3>
           * param3: {{param3}}
           * </if>
           * ```
           * @param data - The data to render the prompt template with.
           * Example:
           * ```
           * {
           *   param1: "value1",
           *   param2: "value2",
           *   param3: "value3",
           * }
           * ```
           * @returns The rendered prompt template.
           */
          static render(template, data) {
            let result = template;
            result = result.replace(/\n?<if\s+(\w+)>([\s\S]*?)<\/if>\n?/g, (match, varName, content) => {
              const value = data[varName];
              let hasValue = value !== undefined && value !== null && value !== "";
              if (hasValue && Array.isArray(value) && value.length == 0) {
                hasValue = false;
              }
              if (content.startsWith("\n")) {
                content = content.substring(1);
              }
              if (content.endsWith("\n")) {
                content = content.substring(0, content.length - 1);
              }
              if (!hasValue) {
                return "";
              }
              let result = this.replaceVars(content, data);
              if (match.startsWith("\n")) {
                result = "\n" + result;
              }
              if (match.endsWith("\n")) {
                result = result + "\n";
              }
              return result;
            });
            result = this.replaceVars(result, data);
            return result;
          }
          static replaceVars(text, data) {
            return text.replace(/\{\{([\w]+)\}\}/g, (match, varName) => {
              if (!(varName in data)) {
                return match;
              }
              const value = data[varName] ?? "";
              return typeof value == "string" ? value : JSON.stringify(value);
            });
          }
        }

        const PLAN_SYSTEM_TEMPLATE = `
You are {{name}}, an autonomous AI Agent Planner.

## Task Description
Your task is to understand the user's requirements, dynamically plan the user's tasks based on the Agent list, and please follow the steps below:
- Analyze the Agents that need to be used based on the user's requirements.
- Generate the Agent calling plan based on the analysis results.
- About agent name, please do not arbitrarily fabricate non-existent agent names.
- You only need to provide the steps to complete the user's task, key steps only, no need to be too detailed.
- Try to break down tasks into independently completable subtasks, and for maximum efficiency, run multiple independent subtasks in parallel whenever possible.
- Please strictly follow the output format and example output.
- The output language should follow the language corresponding to the user's task.

## Agent list
{{agents}}

## Output Rules and Format
<root>
  <!-- Task Name (Short) -->
  <name>Task Name</name>
  <!-- Need to break down the task into multi-agent collaboration. Please think step by step and output a detailed thought process. -->
  <thought>Your thought process on user demand planning</thought>
  <!-- Multiple Agents work together to complete the task -->
  <agents>
    <!--
    Multi-Agent supports parallelism, coordinating parallel tasks through dependencies, and passing dependent context information through node variables.
    name: The name of the Agent, where the name can only be an available name in the Agent list.
    id: Use subscript order as ID for dependency relationships between multiple agents.
    dependsOn: The IDs of agents that the current agent depends on, separated by commas when there are multiple dependencies.
    -->
    <agent name="Agent name" id="0" dependsOn="">
      <!-- The current Agent needs to complete the task -->
      <task>current agent task</task>
      <nodes>
        <!-- Nodes support input/output variables for parameter passing and dependency handling in multi-agent collaboration. -->
        <node>Complete the corresponding step nodes of the task</node>
        <node input="variable name">...</node>
        <node output="variable name">...</node>
        <!-- When including duplicate tasks, \`forEach\` can be used -->
        <forEach items="list or variable name">
          <node>forEach step node</node>
        </forEach>
        <!-- When you need to monitor changes in webpage DOM elements, you can use \`Watch\`, the loop attribute specifies whether to listen in a loop or listen once. -->
        <watch event="dom" loop="true">
          <description>Monitor task description</description>
          <trigger>
            <node>Trigger step node</node>
            <node>...</node>
          </trigger>
        </watch>
      </nodes>
    </agent>
    <!--
    Multi-agent Collaboration Dependency Example:

    Execution Flow:
    1. Agent 0: Initial agent with no dependencies (executes first)
    2. Agent 1: Depends on Agent 0 completion (executes after Agent 0)
    3. Agent 2 & 3: Both depend on Agent 1 completion (execute in parallel after Agent 1)
    4. Agent 4: Depends on both Agent 2 and Agent 3 completion (executes last)

    Dependency Chain: Agent 0 → Agent 1 → (Agent 2 ∥ Agent 3) → Agent 4
    -->
    <agent name="Agent name" id="0" dependsOn="">...</agent>
    <agent name="Agent name" id="1" dependsOn="0">...</agent>
    <agent name="Agent name" id="2" dependsOn="1">...</agent>
    <agent name="Agent name" id="3" dependsOn="1">...</agent>
    <agent name="Agent name" id="4" dependsOn="2,3">...</agent>
  </agents>
</root>

{{examples}}
`;
        const EXAMPLE_TEMPLATE = `
## Example 1
User: Open Boss Zhipin, find 10 operation positions in Chengdu, and send a personal introduction to the recruiters based on the page information.
Output result:
<root>
  <name>Submit resume</name>
  <thought>OK, now the user requests me to create a workflow that involves opening the Boss Zhipin website, finding 10 operation positions in Chengdu, and sending personal resumes to the recruiters based on the job information.</thought>
  <agents>
    <agent name="Browser" id="0" dependsOn="">
      <task>Open Boss Zhipin, find 10 operation positions in Chengdu, and send a personal introduction to the recruiters based on the page information.</task>
      <nodes>
        <node>Open Boss Zhipin, enter the job search page</node>
        <node>Set the regional filter to Chengdu and search for operational positions.</node>
        <node>Brows the job list and filter out 10 suitable operation positions.</node>
        <forEach items="list">
          <node>Analyze job requirements</node>
          <node>Send a self-introduction to the recruiter</node>
        </forEach>
      </nodes>
    </agent>
  </agents>
</root>

## Example 2
User: Help me collect the latest AI news, summarize it, and send it to the "AI news information" group chat on WeChat.
Output result:
<root>
  <name>Latest AI News</name>
  <thought>OK, users need to collect the latest AI news, summarize it, and send it to a WeChat group named "AI news information" This requires automation, including the steps of data collection, processing, and distribution.</thought>
  <agents>
    <agent name="Browser" id="0" dependsOn="">
      <task>Search for the latest updates on AI</task>
      <nodes>
        <node>Open Google</node>
        <node>Search for the latest updates on AI</node>
        <forEach items="list">
          <node>View Details</node>
        </forEach>
        <node output="summaryInfo">Summarize search information</node>
      </nodes>
    </agent>
    <agent name="Computer" id="1" dependsOn="0">
      <task>Send a message to the WeChat group chat "AI news information"</task>
      <nodes>
        <node>Open WeChat</node>
        <node>Search for the "AI news information" chat group</node>
        <node input="summaryInfo">Send summary message</node>
      </nodes>
    </agent>
  </agents>
</root>

## Example 3
User: Access the Google team's organization page on GitHub, extract all developer accounts from the team, and compile statistics on the countries and regions where these developers are located.
Output result:
<root>
  <name>Statistics of Google Team Developers' Geographic Distribution</name>
  <thought>Okay, I need to first visit GitHub, then find Google's organization page on GitHub, extract the team member list, and individually visit each developer's homepage to obtain location information for each developer. This requires using a browser to complete all operations.</thought>
  <agents>
    <agent name="Browser" id="0" dependsOn="">
      <task>Visit Google GitHub Organization Page and Analyze Developer Geographic Distribution</task>
      <nodes>
        <node>Visit https://github.com/google</node>
        <node>Click "People" tab to view team members</node>
        <node>Scroll the page to load all developer information</node>
        <node output="developers">Extract all developer account information</node>
        <forEach items="developers">
          <node>Visit developer's homepage</node>
          <node>Extract developer's location information</node>
        </forEach>
        <node>Compile and analyze the geographic distribution data of all developers</node>
      </nodes>
    </agent>
  </agents>
</root>

## Example 4
User: Open Discord to monitor messages in Group A, and automatically reply when new messages are received.
Output result:
<root>
  <name>Automatic reply to Discord messages</name>
  <thought>OK, monitor the chat messages in Discord group A and automatically reply.</thought>
  <agents>
    <agent name="Browser" id="0" dependsOn="">
      <task>Open Group A in Discord</task>
      <nodes>
        <node>Open Discord page</node>
        <node>Find and open Group A</node>
        <watch event="dom" loop="true">
          <description>Monitor new messages in group chat</description>
          <trigger>
            <node>Analyze message content</node>
            <node>Automatic reply to new messages</node>
          </trigger>
        </watch>
      </nodes>
    </agent>
  </agents>
</root>

## Example 5
User: Search for information about "fellou" compile the results into a summary profile, then share it across social media platforms including Twitter, Facebook, and Reddit. Finally, export the platform sharing operation results to an Excel file.
Output result:
<root>
<name>Fellou Research and Social Media Campaign</name>
<thought>The user wants me to research information about 'Fellou', create a summary profile, share it on multiple social media platforms (Twitter, Facebook, Reddit), and then compile the results into an Excel file. This requires multiple agents working together: Browser for research, Browser for social media posting (Twitter, Facebook, and Reddit in parallel), and File for creating the Excel export. I need to break this down into sequential steps with proper variable passing between agents.</thought>
<agents>
  <agent name="Browser" id="0" dependsOn="">
      <task>Research comprehensive information about 'Fellou'</task>
      <nodes>
        <node>Search for the latest information about 'Fellou' - its identity, purpose, and core features</node>
        <node>Search for Fellou's functionalities, capabilities, and technical specifications</node>
        <node>Search for recent news, updates, announcements, and developments related to Fellou</node>
        <node>Search for user reviews, feedback, and community discussions about Fellou</node>
        <node>Search for Fellou's market position, competitors, and industry context</node>
        <node output="researchData">Compile all research findings into a comprehensive summary profile</node>
      </nodes>
    </agent>
    <agent name="Browser" id="1" dependsOn="0">
      <task>Share Fellou's summary and collected interaction data on Twitter/X</task>
      <nodes>
        <node>Navigate to Twitter/X platform</node>
        <node input="researchData">Create and post Twitter-optimized content about Fellou (within character limits, using hashtags)</node>
        <node output="twitterResults">Capture Twitter post URL and initial engagement metrics</node>
      </nodes>
    </agent>
    <agent name="Browser" id="2" dependsOn="0">
      <task>Share Fellou's summary and collected interaction data on Facebook</task>
      <nodes>
        <node>Navigate to Facebook platform</node>
        <node input="researchData">Create and post Facebook-optimized content about Fellou (longer format, engaging description)</node>
        <node output="facebookResults">Capture Facebook post URL and initial engagement metrics</node>
      </nodes>
    </agent>
    <agent name="Browser" id="3" dependsOn="0">
      <task>Share Fellou's summary and collected interaction data on Reddit</task>
      <nodes>
        <node>Navigate to Reddit platform</node>
        <node input="researchData">Find appropriate subreddit and create Reddit-optimized post about Fellou (community-focused, informative)</node>
        <node output="redditResults">Capture Reddit post URL and initial engagement metrics</node>
      </nodes>
    </agent>
    <agent name="File" id="4" dependsOn="1,2,3">
      <task>Compile social media results into Excel file</task>
      <nodes>
        <node input="twitterResults,facebookResults,redditResults">Create Excel file with social media campaign results</node>
        <node>Include columns for Platform, Post URL, Content Summary, Timestamp, Initial Likes/Shares/Comments</node>
        <node>Format the Excel file with proper headers and styling</node>
        <node>Save the file as 'Fellou_Social_Media_Campaign_Results.xlsx'</node>
      </nodes>
    </agent>
  </agents>
</agents>
</root>
`;
        const PLAN_USER_TEMPLATE = `
<if language>
Language: {{language}}
</if>
User Platform: {{platform}}
<if taskWebsite>
Task Websites:
{{taskWebsite}}
</if>
<if dependentVariables>
Dependent Variables: {{dependentVariables}}
</if>
Current datetime: {{datetime}}
User Task Description: {{taskPrompt}}
<if attachments>
Attachments:
{{attachments}}
</if>
<if extPrompt>
{{extPrompt}}
</if>
`;
        async function getPlanSystemPrompt(context) {
          const agents_prompt = await buildAgentsPrompt(context.agents, context);
          const planSysPrompt = global.prompts.get(GlobalPromptKey.planner_system) || PLAN_SYSTEM_TEMPLATE;
          const planExamplePrompt = global.prompts.get(GlobalPromptKey.planner_example) || EXAMPLE_TEMPLATE;
          return PromptTemplate.render(planSysPrompt, {
            name: config$1.name,
            agents: agents_prompt.trim(),
            examples: planExamplePrompt.trim(),
          }).trim();
        }
        function getPlanUserPrompt(context, taskPrompt) {
          const planUserPrompt = global.prompts.get(GlobalPromptKey.planner_user) || PLAN_USER_TEMPLATE;
          return PromptTemplate.render(planUserPrompt, {
            taskPrompt: taskPrompt,
            platform: config$1.platform,
            taskWebsite: context.variables.get("taskWebsite"),
            language: context.variables.get("language"),
            attachments: context.variables.get("attachments"),
            dependentVariables: context.variables.get("dependentVariables"),
            datetime: context.variables.get("datetime") || new Date().toLocaleString(),
            extPrompt: context.variables.get("planExtPrompt"),
          }).trim();
        }
        async function buildAgentsPrompt(agents, context) {
          let agents_prompt = "";
          for (let i = 0; i < agents.length; i++) {
            let agent = agents[i];
            let tools = await agent.loadTools(context);
            if (agent.ignorePlan) {
              continue;
            }
            agents_prompt +=
              `<agent name="${agent.Name}">\n` +
              `Description: ${sub(agent.PlanDescription || agent.Description, 4000, true)}\n` +
              "Tools:\n" +
              tools
                .filter((tool) => !tool.noPlan)
                .map((tool) => `  - ${tool.name}: ${sub(tool.planDescription || tool.description || "", 500, true)}`)
                .join("\n") +
              "\n</agent>\n\n";
          }
          return agents_prompt.trim();
        }

        class Planner {
          constructor(context, callback) {
            this.context = context;
            this.taskId = context.taskId;
            this.callback = callback || context.config.callback;
          }
          async plan(taskPrompt, saveHistory, datetime) {
            let taskPromptStr;
            let userPrompt;
            if (typeof taskPrompt === "string") {
              taskPromptStr = taskPrompt;
              userPrompt = {
                type: "text",
                text: getPlanUserPrompt(this.context, taskPrompt),
              };
            }
            else {
              userPrompt = taskPrompt;
              taskPromptStr = taskPrompt.text || "";
            }
            const messages = [
              {
                role: "system",
                content: await getPlanSystemPrompt(this.context),
              },
              {
                role: "user",
                content: [userPrompt],
              },
            ];
            return await this.doPlan(taskPromptStr, messages, saveHistory ?? true);
          }
          async replan(taskPrompt, saveHistory = true, datetime) {
            const chain = this.context.chain;
            if (chain.planRequest && chain.planResult) {
              const messages = [
                ...chain.planRequest.messages,
                {
                  role: "assistant",
                  content: [{ type: "text", text: chain.planResult }],
                },
                {
                  role: "user",
                  content: [{ type: "text", text: taskPrompt }],
                },
              ];
              return await this.doPlan(taskPrompt, messages, saveHistory);
            }
            else {
              return this.plan(taskPrompt, saveHistory, datetime);
            }
          }
          async doPlan(taskPrompt, messages, saveHistory, retryNum = 0) {
            const config = this.context.config;
            const rlm = new RetryLanguageModel(config.llms, config.planLlms);
            rlm.setContext(this.context);
            const request = {
              maxOutputTokens: 8192,
              temperature: 0.7,
              messages: messages,
              abortSignal: this.context.controller.signal,
            };
            const result = await rlm.callStream(request);
            const reader = result.stream.getReader();
            let streamText = "";
            let thinkingText = "";
            try {
              while (true) {
                await this.context.checkAborted(true);
                const { done, value } = await reader.read();
                if (done) {
                  break;
                }
                let chunk = value;
                if (chunk.type == "error") {
                  Log.error("Plan, LLM Error: ", chunk);
                  throw new Error("LLM Error: " + chunk.error);
                }
                if (chunk.type == "reasoning-delta") {
                  thinkingText += chunk.delta || "";
                }
                if (chunk.type == "text-delta") {
                  streamText += chunk.delta || "";
                }
                if (chunk.type == "finish") {
                  if (chunk.finishReason == "content-filter") {
                    throw new Error("LLM error: trigger content filtering violation");
                  }
                  if (chunk.finishReason == "other") {
                    throw new Error("LLM error: terminated due to other reasons");
                  }
                }
                if (this.callback) {
                  let workflow = parseWorkflow(this.taskId, streamText, false, thinkingText);
                  if (workflow) {
                    await this.callback.onMessage({
                      streamType: "agent",
                      chatId: this.context.chatId,
                      taskId: this.taskId,
                      agentName: "Planer",
                      type: "workflow",
                      streamDone: false,
                      workflow: workflow,
                    });
                  }
                }
              }
            }
            catch (e) {
              if (retryNum < 3) {
                await sleep(1000);
                return await this.doPlan(taskPrompt, messages, saveHistory, ++retryNum);
              }
              throw e;
            }
            finally {
              reader.releaseLock();
              if (Log.isEnableInfo()) {
                Log.info("Planner result: \n" + streamText);
              }
            }
            if (saveHistory) {
              const chain = this.context.chain;
              chain.planRequest = request;
              chain.planResult = streamText;
            }
            let workflow = parseWorkflow(this.taskId, streamText, true, thinkingText);
            if (this.callback) {
              await this.callback.onMessage({
                streamType: "agent",
                chatId: this.context.chatId,
                taskId: this.taskId,
                agentName: "Planer",
                type: "workflow",
                streamDone: true,
                workflow: workflow,
              });
            }
            if (workflow.taskPrompt) {
              workflow.taskPrompt += "\n" + taskPrompt;
            }
            else {
              workflow.taskPrompt = taskPrompt;
            }
            workflow.taskPrompt = workflow.taskPrompt.trim();
            return workflow;
          }
        }

        class ToolChain {
          constructor(toolUse, request) {
            this.toolName = toolUse.toolName;
            this.toolCallId = toolUse.toolCallId;
            this.request = JSON.parse(JSON.stringify(request));
          }
          updateParams(params) {
            this.params = params;
            this.onUpdate && this.onUpdate();
          }
          updateToolResult(toolResult) {
            this.toolResult = toolResult;
            this.onUpdate && this.onUpdate();
          }
        }
        class AgentChain {
          constructor(agent) {
            this.tools = [];
            this.agent = agent;
          }
          push(tool) {
            tool.onUpdate = () => {
              this.onUpdate &&
                this.onUpdate({
                  type: "update",
                  target: tool,
                });
            };
            this.tools.push(tool);
            this.onUpdate &&
              this.onUpdate({
                type: "update",
                target: this,
              });
          }
        }
        class Chain {
          constructor(taskPrompt) {
            this.agents = [];
            this.listeners = [];
            this.taskPrompt = taskPrompt;
          }
          push(agent) {
            agent.onUpdate = (event) => {
              this.pub(event);
            };
            this.agents.push(agent);
            this.pub({
              type: "update",
              target: agent,
            });
          }
          pub(event) {
            this.listeners.forEach((listener) => listener(this, event));
          }
          addListener(callback) {
            this.listeners.push(callback);
          }
          removeListener(callback) {
            this.listeners = this.listeners.filter((listener) => listener !== callback);
          }
        }

        async function checkTaskReplan(agentContext) {
          try {
            const context = agentContext.context;
            const chain = agentContext.context.chain;
            if (!chain.planRequest || !chain.planResult) {
              return false;
            }
            const rlm = new RetryLanguageModel(context.config.llms, context.config.planLlms);
            rlm.setContext(agentContext);
            const agentExecution = getAgentExecutionPrompt(agentContext);
            const prompt = `# Task Execution Status
${agentExecution}

# Task Replan Check
Please review the plan for unexecuted tasks based on the results of partially executed tasks, and check whether it still meets the requirements of the current user task.
If after executing some subtasks it is found that the previous plan has issues or is no longer the optimal solution, then the unexecuted task nodes need to be replanned; otherwise, replanning is not necessary.`;
            const messages = [
              ...chain.planRequest.messages,
              {
                role: "assistant",
                content: [{ type: "text", text: chain.planResult }],
              },
              {
                role: "user",
                content: [{ type: "text", text: prompt }],
              },
            ];
            const functionName = "check_task_status";
            const request = {
              maxOutputTokens: 512,
              temperature: 0.7,
              messages: messages,
              abortSignal: context.controller.signal,
              tools: [
                {
                  type: "function",
                  name: functionName,
                  description: "Check the task status, and based on the results of partially executed tasks, examine whether the unexecuted task nodes need to be replanned.",
                  inputSchema: {
                    type: "object",
                    properties: {
                      thinking: {
                        type: "string",
                        description: "Output the thinking process, analyzing whether the unexecuted task nodes need to be replanned.(100 words or less)",
                      },
                      replan: {
                        type: "boolean",
                        description: "Determine whether replanning of unexecuted task nodes is needed. If the existing unexecuted task nodes can meet the task requirements, then replanning is not necessary; if they cannot meet the requirements, then replanning is needed.",
                      },
                    },
                    required: ["thinking", "replan"],
                  },
                },
              ],
              toolChoice: {
                type: "tool",
                toolName: functionName,
              },
            };
            const result = await rlm.call(request);
            let input = result.content.find((c) => c.type === "tool-call")?.input;
            if (input && typeof input === "string") {
              input = JSON.parse(input);
            }
            return input.replan;
          }
          catch (e) {
            Log.error("checkTaskReplan error: ", e);
            return false;
          }
        }
        async function replanWorkflow(agentContext) {
          let currentIndex = 0;
          const currentAgentId = agentContext.agentChain.agent.id;
          const agents = agentContext.context.workflow?.agents;
          for (let i = 0; i < agents.length; i++) {
            currentIndex = i;
            if (agents[i].id === currentAgentId) {
              break;
            }
          }
          const planner = new Planner(agentContext.context, {
            onMessage: async (message, _agentContext) => {
              if (message.type === "workflow") {
                mergeWorkflow(agentContext.context.workflow, JSON.parse(JSON.stringify(message.workflow)), currentIndex);
                agentContext.context.config.callback?.onMessage({
                  ...message,
                  workflow: agentContext.context.workflow,
                });
              }
            },
          });
          const agentExecution = getAgentExecutionPrompt(agentContext);
          const prompt = `# Task Execution Status
${agentExecution}

# Replan
The previous plan is no longer suitable for the current task.
Please reformulate the plan for unexecuted tasks based on the results of partially executed tasks to meet the requirements of the current task.
Please do not output nodes that have already been executed. The new plan is an incremental update to the unexecuted plan nodes, and can use the results and variables from previously executed tasks.`;
          let newWorkflow;
          const chain = agentContext.context.chain;
          if (chain.planRequest && chain.planResult) {
            const messages = [
              ...chain.planRequest.messages,
              {
                role: "assistant",
                content: [{ type: "text", text: chain.planResult }],
              },
              {
                role: "user",
                content: [{ type: "text", text: prompt }],
              },
            ];
            newWorkflow = await planner.doPlan("", messages, true);
          }
          else {
            newWorkflow = await planner.plan({ type: "text", text: prompt }, true);
          }
          const workflow = agentContext.context.workflow;
          mergeWorkflow(workflow, newWorkflow, currentIndex);
          workflow.modified = true;
        }
        function mergeWorkflow(workflow, newWorkflow, currentIndex) {
          workflow.name = newWorkflow.name;
          workflow.thought = newWorkflow.thought;
          const old_number = currentIndex + 1;
          workflow.agents.splice(old_number, workflow.agents.length - old_number);
          for (let i = 0; i < newWorkflow.agents.length; i++) {
            const agent = newWorkflow.agents[i];
            const idx = i + currentIndex + 1;
            agent.id = workflow.taskId + "-" + (idx < 10 ? "0" + idx : idx);
            const dependsOn = agent.dependsOn || [];
            if (i == 0) {
              agent.dependsOn = [workflow.agents[workflow.agents.length - 1].id];
            }
            else {
              for (let j = 0; j < dependsOn.length; j++) {
                const dependId = dependsOn[j];
                const arr = dependId.split("-");
                const dependIndex = parseInt(arr[arr.length - 1]) + currentIndex + 1;
                arr[arr.length - 1] =
                  dependIndex < 10 ? "0" + dependIndex : dependIndex + "";
                dependsOn[j] = arr.join("-");
              }
            }
            workflow.agents.push(agent);
          }
          workflow.xml = newWorkflow.xml;
        }
        function getAgentExecutionPrompt(currentAgentContext) {
          let prompt = "";
          const agentMap = {};
          const chain = currentAgentContext.context.chain;
          for (let i = 0; i < chain.agents.length; i++) {
            const agentChain = chain.agents[i];
            agentMap[agentChain.agent.id] = agentChain;
          }
          let before = true;
          const workflow = currentAgentContext.context.workflow;
          const currentAgentId = currentAgentContext.agentChain.agent.id;
          for (let i = 0; i < workflow.agents.length; i++) {
            const agent = workflow.agents[i];
            const agentChain = agentMap[agent.id];
            if (agent.id === currentAgentId) {
              before = false;
            }
            if (agentChain && agentChain.agentResult && before) {
              prompt += `## ${agent.name} Agent: ${agent.task}\nExecuted, execution result:\n${agentChain.agentResult}\n\n`;
            }
            else if (agentChain && agentChain.agentRequest) {
              const messages = getExecutionMessages(agentChain.agentRequest.messages);
              prompt += `## ${agent.name} Agent: ${agent.task}\nCurrently executing, execution progress:\n${messages.join("\n\n")}\n\n`;
            }
            else {
              prompt += `## ${agent.name} Agent: ${agent.task}\nNot started execution.\n\n`;
            }
          }
          return prompt.trim();
        }
        function getExecutionMessages(messages) {
          const messagesContents = [];
          for (let i = 0; i < messages.length; i++) {
            const message = messages[i];
            if (message.role === "user") {
              const contents = message.content
                .filter((s) => s.type === "text" && s.text)
                .map((s) => s.text);
              for (let j = 0; j < contents.length; j++) {
                messagesContents.push("User: " + sub(contents[j], i < 3 ? 2000 : 500, true));
              }
            }
            else if (message.role === "assistant") {
              for (let j = 0; j < message.content.length; j++) {
                const content = message.content[j];
                if (content.type === "text" && content.text) {
                  messagesContents.push("Assistant: " + sub(content.text, 500, true));
                }
                else if (content.type === "tool-call") {
                  messagesContents.push(`Call \`${content.toolName}\` Tool Params: ` +
                    JSON.stringify(content.input || {}));
                }
              }
            }
            else if (message.role === "tool") {
              for (let j = 0; j < message.content.length; j++) {
                const content = message.content[j];
                const output = content.output;
                const result = JSON.stringify(output.value);
                messagesContents.push(`Call \`${content.toolName}\` Tool Result: ${sub(result, 500, true)}`);
              }
            }
          }
          return messagesContents;
        }

        class Eko {
          constructor(config, chatId = uuidv4()) {
            this.config = config;
            this.chatId = chatId;
          }
          async generate(taskPrompt, taskId = uuidv4(), contextParams, datetime) {
            const agents = [...(this.config.agents || [])];
            const chain = new Chain(taskPrompt);
            const context = new TaskContext(this.chatId, taskId, this.config, agents, chain);
            if (contextParams) {
              Object.keys(contextParams).forEach((key) => context.variables.set(key, contextParams[key]));
            }
            try {
              global.taskMap.set(taskId, context);
              if (this.config.a2aClient) {
                const a2aList = await this.config.a2aClient.listAgents(taskPrompt);
                context.agents = mergeAgents(context.agents, a2aList);
              }
              const planner = new Planner(context);
              context.workflow = await planner.plan(taskPrompt, true, datetime);
              return context.workflow;
            }
            catch (e) {
              this.deleteTask(taskId);
              throw e;
            }
          }
          async modify(taskId, modifyTaskPrompt) {
            const context = global.taskMap.get(taskId);
            if (!context) {
              return await this.generate(modifyTaskPrompt, taskId);
            }
            if (this.config.a2aClient) {
              const a2aList = await this.config.a2aClient.listAgents(modifyTaskPrompt);
              context.agents = mergeAgents(context.agents, a2aList);
            }
            const planner = new Planner(context);
            context.workflow = await planner.replan(modifyTaskPrompt);
            return context.workflow;
          }
          async execute(taskId) {
            const context = this.getTask(taskId);
            if (!context) {
              throw new Error("The task does not exist");
            }
            if (context.pause) {
              context.setPause(false);
            }
            if (context.controller.signal.aborted) {
              context.reset();
            }
            context.conversation = [];
            try {
              return await this.doRunWorkflow(context);
            }
            catch (e) {
              Log.error("execute error", e);
              return {
                taskId,
                success: false,
                stopReason: e?.name == "AbortError" ? "abort" : "error",
                result: typeof e == "string"
                  ? e
                  : e instanceof Error
                    ? e.name + ": " + e.message
                    : String(e || "Unknown error"),
                error: e,
              };
            }
          }
          async run(taskPrompt, taskId = uuidv4(), contextParams) {
            await this.generate(taskPrompt, taskId, contextParams);
            return await this.execute(taskId);
          }
          async initContext(workflow, contextParams) {
            const agents = this.config.agents || [];
            const chain = new Chain(workflow.taskPrompt || workflow.name);
            const context = new TaskContext(this.chatId, workflow.taskId, this.config, agents, chain);
            if (this.config.a2aClient) {
              const a2aList = await this.config.a2aClient.listAgents(workflow.taskPrompt || workflow.name);
              context.agents = mergeAgents(context.agents, a2aList);
            }
            if (contextParams) {
              Object.keys(contextParams).forEach((key) => context.variables.set(key, contextParams[key]));
            }
            context.workflow = workflow;
            global.taskMap.set(workflow.taskId, context);
            return context;
          }
          async doRunWorkflow(context) {
            const agents = context.agents;
            const workflow = context.workflow;
            if (!workflow || workflow.agents.length == 0) {
              throw new Error("Workflow error");
            }
            const agentNameMap = agents.reduce((map, item) => {
              map[item.Name] = item;
              return map;
            }, {});
            let agentTree = buildAgentTree(workflow.agents);
            const results = [];
            while (true) {
              await context.checkAborted();
              let lastAgent;
              if (agentTree.type === "normal") {
                // normal agent
                const agent = agentNameMap[agentTree.agent.name];
                if (!agent) {
                  throw new Error("Unknown Agent: " + agentTree.agent.name);
                }
                lastAgent = agent;
                const agentNode = agentTree.agent;
                const agentChain = new AgentChain(agentNode);
                context.chain.push(agentChain);
                agentTree.result = await this.runAgent(context, agent, agentTree, agentChain);
                results.push(agentTree.result);
              }
              else {
                // parallel agent
                const parallelAgents = agentTree.agents;
                const doRunAgent = async (agentNode, index) => {
                  const agent = agentNameMap[agentNode.agent.name];
                  if (!agent) {
                    throw new Error("Unknown Agent: " + agentNode.agent.name);
                  }
                  lastAgent = agent;
                  const agentChain = new AgentChain(agentNode.agent);
                  context.chain.push(agentChain);
                  const result = await this.runAgent(context, agent, agentNode, agentChain);
                  return { result: result, agentChain, index };
                };
                let agent_results = [];
                let agentParallel = context.variables.get("agentParallel");
                if (agentParallel === undefined) {
                  agentParallel = config$1.agentParallel;
                }
                if (agentParallel) {
                  // parallel execution
                  const parallelResults = await Promise.all(parallelAgents.map((agent, index) => doRunAgent(agent, index)));
                  parallelResults.sort((a, b) => a.index - b.index);
                  parallelResults.forEach(({ agentChain }) => {
                    context.chain.push(agentChain);
                  });
                  agent_results = parallelResults.map(({ result }) => result);
                }
                else {
                  // serial execution
                  for (let i = 0; i < parallelAgents.length; i++) {
                    const { result, agentChain } = await doRunAgent(parallelAgents[i], i);
                    context.chain.push(agentChain);
                    agent_results.push(result);
                  }
                }
                results.push(agent_results.join("\n\n"));
              }
              context.conversation.splice(0, context.conversation.length);
              if (config$1.mode == "expert" &&
                !workflow.modified &&
                agentTree.nextAgent &&
                lastAgent?.AgentContext &&
                (await checkTaskReplan(lastAgent.AgentContext))) {
                // replan
                await replanWorkflow(lastAgent.AgentContext);
              }
              if (workflow.modified) {
                workflow.modified = false;
                agentTree = buildAgentTree(workflow.agents.filter((agent) => agent.status == "init"));
                continue;
              }
              if (!agentTree.nextAgent) {
                break;
              }
              agentTree = agentTree.nextAgent;
            }
            return {
              success: true,
              stopReason: "done",
              taskId: context.taskId,
              result: results[results.length - 1] || "",
            };
          }
          async runAgent(context, agent, agentNode, agentChain) {
            try {
              agentNode.agent.status = "running";
              this.config.callback &&
                (await this.config.callback.onMessage({
                  streamType: "agent",
                  chatId: context.chatId,
                  taskId: context.taskId,
                  agentName: agentNode.agent.name,
                  nodeId: agentNode.agent.id,
                  type: "agent_start",
                  agentNode: agentNode.agent,
                }, agent.AgentContext));
              agentNode.result = await agent.run(context, agentChain);
              agentNode.agent.status = "done";
              this.config.callback &&
                (await this.config.callback.onMessage({
                  streamType: "agent",
                  chatId: context.chatId,
                  taskId: context.taskId,
                  agentName: agentNode.agent.name,
                  nodeId: agentNode.agent.id,
                  type: "agent_result",
                  agentNode: agentNode.agent,
                  result: agentNode.result,
                }, agent.AgentContext));
              return agentNode.result;
            }
            catch (e) {
              agentNode.agent.status = "error";
              this.config.callback &&
                (await this.config.callback.onMessage({
                  streamType: "agent",
                  chatId: context.chatId,
                  taskId: context.taskId,
                  agentName: agentNode.agent.name,
                  nodeId: agentNode.agent.id,
                  type: "agent_result",
                  agentNode: agentNode.agent,
                  error: e,
                }, agent.AgentContext));
              throw e;
            }
          }
          getTask(taskId) {
            return global.taskMap.get(taskId);
          }
          getAllTaskId() {
            return [...global.taskMap.keys()];
          }
          deleteTask(taskId) {
            this.abortTask(taskId);
            const context = global.taskMap.get(taskId);
            if (context) {
              context.variables.clear();
            }
            return global.taskMap.delete(taskId);
          }
          abortTask(taskId, reason) {
            const context = global.taskMap.get(taskId);
            if (context) {
              context.setPause(false);
              this.onTaskStatus(context, "abort", reason);
              context.controller.abort(reason);
              return true;
            }
            else {
              return false;
            }
          }
          pauseTask(taskId, pause, abortCurrentStep, reason) {
            const context = global.taskMap.get(taskId);
            if (context) {
              this.onTaskStatus(context, pause ? "pause" : "resume-pause", reason);
              context.setPause(pause, abortCurrentStep);
              return true;
            }
            else {
              return false;
            }
          }
          chatTask(taskId, userPrompt) {
            const context = global.taskMap.get(taskId);
            if (context) {
              context.conversation.push(userPrompt);
              return context.conversation;
            }
          }
          addAgent(agent) {
            this.config.agents = this.config.agents || [];
            this.config.agents.push(agent);
          }
          async onTaskStatus(context, status, reason) {
            const [agent] = context.currentAgent() || [];
            if (agent) {
              const onTaskStatus = agent["onTaskStatus"];
              if (onTaskStatus) {
                await onTaskStatus.call(agent, status, reason);
              }
            }
          }
        }

        class ToolWrapper {
          constructor(toolSchema, execute) {
            this.tool = convertToolSchema(toolSchema);
            this.execute = execute;
          }
          get name() {
            return this.tool.name;
          }
          getTool() {
            return this.tool;
          }
          async callTool(args, agentContext, toolCall) {
            return await this.execute.execute(args, agentContext, toolCall);
          }
        }

        const TOOL_NAME$a = "foreach_task";
        class ForeachTaskTool {
          constructor() {
            this.name = TOOL_NAME$a;
            this.description = `When executing the \`forEach\` node, please use the current tool for counting to ensure tasks are executed sequentially, the tool needs to be called with each loop iteration.`;
            this.parameters = {
              type: "object",
              properties: {
                nodeId: {
                  type: "number",
                  description: "forEach node ID.",
                },
                progress: {
                  type: "string",
                  description: "Current execution progress.",
                },
                next_step: {
                  type: "string",
                  description: "Next task description.",
                },
              },
              required: ["nodeId", "progress", "next_step"],
            };
          }
          async execute(args, agentContext) {
            let nodeId = args.nodeId;
            let agentXml = agentContext.agentChain.agent.xml;
            let node = extractAgentXmlNode(agentXml, nodeId);
            if (node == null) {
              throw new Error("Node ID does not exist: " + nodeId);
            }
            if (node.tagName !== "forEach") {
              throw new Error("Node ID is not a forEach node: " + nodeId);
            }
            let items = node.getAttribute("items");
            let varValue = null;
            let resultText = "Recorded";
            if (items && items != "list") {
              varValue = agentContext.context.variables.get(items.trim());
              if (varValue) {
                let key = "foreach_" + nodeId;
                let loop_count = agentContext.variables.get(key) || 0;
                if (loop_count % 5 == 0) {
                  resultText = `Variable information associated with the current loop task.\nvariable_name: ${items.trim()}\nvariable_value: ${varValue}`;
                }
                agentContext.variables.set(key, ++loop_count);
              }
            }
            return {
              content: [
                {
                  type: "text",
                  text: resultText,
                },
              ],
            };
          }
        }

        const TOOL_NAME$9 = "watch_trigger";
        const watch_system_prompt = `You are a tool for detecting element changes. Given a task description, compare two images to determine whether the changes described in the task have occurred.
If the changes have occurred, return an json with \`changed\` set to true and \`changeInfo\` containing a description of the changes. If no changes have occurred, return an object with \`changed\` set to false.

## Example
User: Monitor new messages in group chat
### No changes detected
Output:
{
  "changed": false
}
### Change detected
Output:
{
  "changed": true,
  "changeInfo": "New message received in the group chat. The message content is: 'Hello, how are you?'"
}`;
        class WatchTriggerTool {
          constructor() {
            this.name = TOOL_NAME$9;
            this.description = `When executing the \`watch\` node, please use it to monitor DOM element changes, it will block the listener until the element changes or times out.`;
            this.parameters = {
              type: "object",
              properties: {
                nodeId: {
                  type: "number",
                  description: "watch node ID.",
                },
                watch_area: {
                  type: "array",
                  description: "Element changes in monitoring area, eg: [x, y, width, height].",
                  items: {
                    type: "number",
                  },
                },
                watch_index: {
                  type: "array",
                  description: "The index of elements to be monitoring multiple elements simultaneously.",
                  items: {
                    type: "number",
                  },
                },
                frequency: {
                  type: "number",
                  description: "Check frequency, how many seconds between each check, default 1 seconds.",
                  default: 1,
                  minimum: 0.5,
                  maximum: 30,
                },
                timeout: {
                  type: "number",
                  description: "Timeout in minute, default 5 minutes.",
                  default: 5,
                  minimum: 1,
                  maximum: 30,
                },
              },
              required: ["nodeId"],
            };
          }
          async execute(args, agentContext) {
            let nodeId = args.nodeId;
            let agentXml = agentContext.agentChain.agent.xml;
            let node = extractAgentXmlNode(agentXml, nodeId);
            if (node == null) {
              throw new Error("Node ID does not exist: " + nodeId);
            }
            if (node.tagName !== "watch") {
              throw new Error("Node ID is not a watch node: " + nodeId);
            }
            let task_description = node.getElementsByTagName("description")[0]?.textContent || "";
            if (!task_description) {
              return {
                content: [
                  {
                    type: "text",
                    text: "The watch node does not have a description, skip.",
                  },
                ],
              };
            }
            await this.init_eko_observer(agentContext);
            const image1 = await this.get_screenshot(agentContext);
            const start = new Date().getTime();
            const timeout = (args.timeout || 5) * 60000;
            const frequency = Math.max(500, (args.frequency || 1) * 1000);
            const rlm = new RetryLanguageModel(agentContext.context.config.llms, agentContext.agent.Llms);
            rlm.setContext(agentContext);
            while (new Date().getTime() - start < timeout) {
              await agentContext.context.checkAborted();
              await new Promise((resolve) => setTimeout(resolve, frequency));
              let changed = await this.has_eko_changed(agentContext);
              if (changed == "false") {
                continue;
              }
              await this.init_eko_observer(agentContext);
              const image2 = await this.get_screenshot(agentContext);
              const changeResult = await this.is_dom_change(agentContext, rlm, image1, image2, task_description);
              if (changeResult.changed) {
                return {
                  content: [
                    {
                      type: "text",
                      text: changeResult.changeInfo || "DOM change detected.",
                    },
                  ],
                };
              }
            }
            return {
              content: [
                {
                  type: "text",
                  text: "Timeout reached, no DOM changes detected.",
                },
              ],
            };
          }
          async get_screenshot(agentContext) {
            const screenshot = agentContext.agent["screenshot"];
            const imageResult = (await screenshot.call(agentContext.agent, agentContext));
            const image = toImage(imageResult.imageBase64);
            return {
              image: image,
              imageType: imageResult.imageType,
            };
          }
          async init_eko_observer(agentContext) {
            try {
              const screenshot = agentContext.agent["execute_script"];
              await screenshot.call(agentContext.agent, agentContext, () => {
                let _window = window;
                _window.has_eko_changed = false;
                _window.eko_observer && _window.eko_observer.disconnect();
                let eko_observer = new MutationObserver(function (mutations) {
                  _window.has_eko_changed = true;
                });
                eko_observer.observe(document.body, {
                  childList: true,
                  subtree: true,
                  attributes: true,
                  attributeOldValue: true,
                  characterData: true,
                  characterDataOldValue: true,
                });
                _window.eko_observer = eko_observer;
              }, []);
            }
            catch (error) {
              console.error("Error initializing Eko observer:", error);
            }
          }
          async has_eko_changed(agentContext) {
            try {
              const screenshot = agentContext.agent["execute_script"];
              let result = (await screenshot.call(agentContext.agent, agentContext, () => {
                return window.has_eko_changed + "";
              }, []));
              return result;
            }
            catch (e) {
              console.error("Error checking Eko change:", e);
              return "undefined";
            }
          }
          async is_dom_change(agentContext, rlm, image1, image2, task_description) {
            try {
              let request = {
                messages: [
                  {
                    role: "system",
                    content: watch_system_prompt,
                  },
                  {
                    role: "user",
                    content: [
                      {
                        type: "file",
                        data: image1.image,
                        mediaType: image1.imageType,
                      },
                      {
                        type: "file",
                        data: image2.image,
                        mediaType: image2.imageType,
                      },
                      {
                        type: "text",
                        text: task_description,
                      },
                    ],
                  },
                ],
                abortSignal: agentContext.context.controller.signal,
              };
              const result = await rlm.call(request);
              let resultText = result.text || "{}";
              resultText = resultText.substring(resultText.indexOf("{"), resultText.lastIndexOf("}") + 1);
              return JSON.parse(resultText);
            }
            catch (error) {
              Log.error("Error in is_dom_change:", error);
            }
            return {
              changed: false,
            };
          }
        }

        const TOOL_NAME$8 = "human_interact";
        class HumanInteractTool {
          constructor() {
            this.name = TOOL_NAME$8;
            this.noPlan = true;
            this.description = `AI interacts with humans:
confirm: Ask the user to confirm whether to execute an operation, especially when performing dangerous actions such as deleting system files, users will choose Yes or No.
input: Prompt the user to enter text; for example, when a task is ambiguous, the AI can choose to ask the user for details, and the user can respond by inputting.
select: Allow the user to make a choice; in situations that require selection, the AI can ask the user to make a decision.
request_help: Request assistance from the user; for instance, when an operation is blocked, the AI can ask the user for help, For example, login required, CAPTCHA verification, SMS verification code, QR code scanning, payment operations, etc.`;
            this.parameters = {
              type: "object",
              properties: {
                interactType: {
                  type: "string",
                  description: "The type of interaction with users.",
                  enum: ["confirm", "input", "select", "request_help"],
                },
                prompt: {
                  type: "string",
                  description: "Display prompts to users",
                },
                selectOptions: {
                  type: "array",
                  description: "Options provided to users, this parameter is required when interactType is select.",
                  items: {
                    type: "string",
                  },
                },
                selectMultiple: {
                  type: "boolean",
                  description: "isMultiple, used when interactType is select",
                },
                helpType: {
                  type: "string",
                  description: "Help type, required when interactType is request_help.",
                  enum: ["request_login", "request_assistance"],
                },
              },
              required: ["interactType", "prompt"],
            };
          }
          async execute(args, agentContext) {
            let interactType = args.interactType;
            let callback = agentContext.context.config.callback;
            let resultText = "";
            if (callback) {
              switch (interactType) {
                case "confirm":
                  if (callback.onHumanConfirm) {
                    let result = await callback.onHumanConfirm(agentContext, args.prompt);
                    resultText = `confirm result: ${result ? "Yes" : "No"}`;
                  }
                  break;
                case "input":
                  if (callback.onHumanInput) {
                    let result = await callback.onHumanInput(agentContext, args.prompt);
                    resultText = `input result: ${result}`;
                  }
                  break;
                case "select":
                  if (callback.onHumanSelect) {
                    let result = await callback.onHumanSelect(agentContext, args.prompt, (args.selectOptions || []), (args.selectMultiple || false));
                    resultText = `select result: ${JSON.stringify(result)}`;
                  }
                  break;
                case "request_help":
                  if (callback.onHumanHelp) {
                    if (args.helpType == "request_login" &&
                      (await this.checkIsLogined(agentContext))) {
                      resultText = "Already logged in";
                      break;
                    }
                    let result = await callback.onHumanHelp(agentContext, (args.helpType || "request_assistance"), args.prompt);
                    resultText = `request_help result: ${result ? "Solved" : "Unresolved"}`;
                  }
                  break;
              }
            }
            if (resultText) {
              return {
                content: [
                  {
                    type: "text",
                    text: resultText,
                  },
                ],
              };
            }
            else {
              return {
                content: [
                  {
                    type: "text",
                    text: `Error: Unsupported ${interactType} interaction operation`,
                  },
                ],
                isError: true,
              };
            }
          }
          async checkIsLogined(agentContext) {
            let screenshot = agentContext.agent["screenshot"];
            if (!screenshot) {
              return false;
            }
            try {
              let imageResult = (await screenshot.call(agentContext.agent, agentContext));
              let rlm = new RetryLanguageModel(agentContext.context.config.llms, agentContext.agent.Llms);
              rlm.setContext(agentContext);
              let image = toImage(imageResult.imageBase64);
              let request = {
                messages: [
                  {
                    role: "user",
                    content: [
                      {
                        type: "file",
                        data: image,
                        mediaType: imageResult.imageType,
                      },
                      {
                        type: "text",
                        text: "Check if the current website is logged in. If not logged in, output `NOT_LOGIN`. If logged in, output `LOGGED_IN`. Output directly without explanation.",
                      },
                    ],
                  },
                ],
                abortSignal: agentContext.context.controller.signal,
              };
              let result = await rlm.call(request);
              return result.text && result.text.indexOf("LOGGED_IN") > -1;
            }
            catch (error) {
              console.error("Error auto checking login status:", error);
              return false;
            }
          }
        }

        const TOOL_NAME$7 = "task_node_status";
        class TaskNodeStatusTool {
          constructor() {
            this.name = TOOL_NAME$7;
            this.description = `After completing each step of the task, you need to call this tool to update the status of the task node, and think about the tasks to be processed and the next action plan.`;
            this.parameters = {
              type: "object",
              properties: {
                thought: {
                  type: "string",
                  description: "Current thinking content, which can be analysis of the problem, assumptions, insights, reflections, or a summary of the previous, suggest the next action step to be taken, which should be specific, executable, and verifiable."
                },
                doneIds: {
                  type: "array",
                  description: "List of completed node IDs.",
                  items: {
                    type: "number",
                  },
                },
                todoIds: {
                  type: "array",
                  description: "List of pending node IDs.",
                  items: {
                    type: "number",
                  },
                },
              },
              required: ["thought", "doneIds", "todoIds"],
            };
          }
          async execute(args, agentContext) {
            let doneIds = args.doneIds;
            let todoIds = args.todoIds;
            let agentNode = agentContext.agentChain.agent;
            let taskPrompt = agentContext.context.chain.taskPrompt;
            let agentXml = buildAgentRootXml(agentNode.xml, taskPrompt, (nodeId, node) => {
              let done = doneIds.indexOf(nodeId) > -1;
              let todo = todoIds.indexOf(nodeId) > -1;
              if (done && todo) {
                throw new Error("The ID cannot appear in both doneIds and todoIds simultaneously, nodeId: " +
                  nodeId);
              }
              node.setAttribute("status", done ? "done" : "todo");
            });
            return {
              content: [
                {
                  type: "text",
                  text: agentXml,
                },
              ],
            };
          }
        }

        const TOOL_NAME$6 = "variable_storage";
        class VariableStorageTool {
          constructor() {
            this.name = TOOL_NAME$6;
            this.description = `Used for storing, reading, and retrieving variable data, and maintaining input/output variables in task nodes. When the same variable is stored repeatedly, it will overwrite the previous value.`;
            this.parameters = {
              type: "object",
              properties: {
                operation: {
                  type: "string",
                  description: "variable storage operation type.",
                  enum: ["read_variable", "write_variable", "list_all_variable"],
                },
                name: {
                  type: "string",
                  description: "variable name, required when reading and writing variables, If reading variables, it supports reading multiple variables separated by commas.",
                },
                value: {
                  type: "string",
                  description: "variable value, required when writing variables",
                },
              },
              required: ["operation"],
            };
          }
          async execute(args, agentContext) {
            let operation = args.operation;
            let resultText = "";
            switch (operation) {
              case "read_variable": {
                if (!args.name) {
                  resultText = "Error: name is required";
                }
                else {
                  let result = {};
                  let name = args.name;
                  let keys = name.split(",");
                  for (let i = 0; i < keys.length; i++) {
                    let key = keys[i].trim();
                    let value = agentContext.context.variables.get(key);
                    result[key] = value;
                  }
                  resultText = JSON.stringify(result);
                }
                break;
              }
              case "write_variable": {
                if (!args.name) {
                  resultText = "Error: name is required";
                  break;
                }
                if (args.value == undefined) {
                  resultText = "Error: value is required";
                  break;
                }
                let key = args.name;
                agentContext.context.variables.set(key.trim(), args.value);
                resultText = "success";
                break;
              }
              case "list_all_variable": {
                resultText = JSON.stringify([...agentContext.context.variables.keys()]);
                break;
              }
            }
            return {
              content: [
                {
                  type: "text",
                  text: resultText || "",
                },
              ],
            };
          }
        }

        class McpTool {
          constructor(toolWrapper) {
            this.toolWrapper = toolWrapper;
            this.name = toolWrapper.name;
            this.description = toolWrapper.getTool().description;
            this.parameters = toolWrapper.getTool().inputSchema;
          }
          async execute(args, agentContext, toolCall) {
            return this.toolWrapper.callTool(args, agentContext, toolCall);
          }
        }

        const TOOL_NAME$5 = "task_result_check";
        class TaskResultCheckTool {
          constructor() {
            this.name = TOOL_NAME$5;
            this.description = `Check the current task execution process and results, evaluate the overall completion status of the current task, and whether the output variables in the nodes are stored.`;
            this.parameters = {
              type: "object",
              properties: {
                thought: {
                  type: "string",
                  description: "Please conduct thoughtful analysis of the overall execution process and results of the current task, analyzing whether the task has been completed.",
                },
                completionStatus: {
                  type: "string",
                  description: "The completion status of the current task is only considered complete when the entire current task is finished; partial completion or task failure is considered incomplete",
                  enum: ["completed", "incomplete"],
                },
                todoList: {
                  type: "string",
                  description: "Pending task list for incomplete tasks, when tasks are not fully completed, please describe which tasks remain to be completed",
                },
              },
              required: ["thought", "completionStatus"],
            };
          }
          async execute(args, agentContext) {
            return {
              content: [
                {
                  type: "text",
                  text: "success",
                },
              ],
            };
          }
        }
        async function doTaskResultCheck(agentContext, rlm, messages, tools) {
          try {
            // extract used tool
            const usedTools = extractUsedTool(messages, tools);
            const taskResultCheck = new TaskResultCheckTool();
            const newTools = mergeTools(usedTools, [
              {
                type: "function",
                name: taskResultCheck.name,
                description: taskResultCheck.description,
                inputSchema: taskResultCheck.parameters,
              },
            ]);
            // handle messages
            const newMessages = [...messages];
            newMessages.push({
              role: "user",
              content: [
                {
                  type: "text",
                  text: `Task:\n${agentContext.agentChain.agent.xml}\n\nPlease check the completion status of the current task.`,
                },
              ],
            });
            const result = await callAgentLLM(agentContext, rlm, newMessages, newTools, true, {
              type: "tool",
              toolName: taskResultCheck.name,
            });
            const toolCall = result.filter((s) => s.type == "tool-call")[0];
            const args = typeof toolCall.input == "string"
              ? JSON.parse(toolCall.input || "{}")
              : toolCall.input || {};
            const toolResult = await taskResultCheck.execute(args, agentContext);
            const callback = agentContext.context.config.callback;
            if (callback) {
              await callback.onMessage({
                streamType: "agent",
                chatId: agentContext.context.chatId,
                taskId: agentContext.context.taskId,
                agentName: agentContext.agent.Name,
                nodeId: agentContext.agentChain.agent.id,
                type: "tool_result",
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                params: args,
                toolResult: toolResult,
              }, agentContext);
            }
            if (args.completionStatus == "incomplete") {
              messages.push({
                role: "user",
                content: [
                  {
                    type: "text",
                    text: `It seems that your task has not been fully completed. Please continue with the remaining steps:\n${args.todoList || ""}`,
                  },
                ],
              });
            }
            return {
              completionStatus: args.completionStatus,
            };
          }
          catch (e) {
            Log.error("TaskResultCheckTool error", e);
            return {
              completionStatus: "completed",
            };
          }
        }

        const TOOL_NAME$4 = "todo_list_manager";
        class TodoListManagerTool {
          constructor() {
            this.name = TOOL_NAME$4;
            this.description =
              "Current task to-do list management, used for managing the to-do list of current tasks. During task execution, the to-do list needs to be updated according to the task execution status: completed, pending. It also detects whether tasks are being executed in repetitive loops during the execution process.";
            this.parameters = {
              type: "object",
              properties: {
                completedList: {
                  type: "array",
                  description: "Current completed task list items. Please update the completed list items based on the current task completion status.",
                  items: {
                    type: "string",
                  },
                },
                todoList: {
                  type: "array",
                  description: "Current pending task list items. Please update the pending list items based on the current task pending status.",
                  items: {
                    type: "string",
                  },
                },
                loopDetection: {
                  type: "string",
                  description: "Check if the current step is being repeatedly executed by comparing with previous steps.",
                  enum: ["loop", "no_loop"],
                },
              },
              required: ["completedList", "todoList", "loopDetection"],
            };
          }
          async execute(args, agentContext) {
            return {
              content: [
                {
                  type: "text",
                  text: "success",
                },
              ],
            };
          }
        }
        async function doTodoListManager(agentContext, rlm, messages, tools) {
          try {
            // extract used tool
            const usedTools = extractUsedTool(messages, tools);
            const todoListManager = new TodoListManagerTool();
            const newTools = mergeTools(usedTools, [
              {
                type: "function",
                name: todoListManager.name,
                description: todoListManager.description,
                inputSchema: todoListManager.parameters,
              },
            ]);
            // handle messages
            const newMessages = [...messages];
            newMessages.push({
              role: "user",
              content: [
                {
                  type: "text",
                  text: `Task:\n${agentContext.agentChain.agent.xml}\n\nPlease check the completion status of the current task.`,
                },
              ],
            });
            const result = await callAgentLLM(agentContext, rlm, newMessages, newTools, true, {
              type: "tool",
              toolName: todoListManager.name,
            });
            const toolCall = result.filter((s) => s.type == "tool-call")[0];
            const args = typeof toolCall.input == "string"
              ? JSON.parse(toolCall.input || "{}")
              : toolCall.input || {};
            const toolResult = await todoListManager.execute(args, agentContext);
            const callback = agentContext.context.config.callback;
            if (callback) {
              await callback.onMessage({
                streamType: "agent",
                chatId: agentContext.context.chatId,
                taskId: agentContext.context.taskId,
                agentName: agentContext.agent.Name,
                nodeId: agentContext.agentChain.agent.id,
                type: "tool_result",
                toolCallId: toolCall.toolCallId,
                toolName: toolCall.toolName,
                params: args,
                toolResult: toolResult,
              }, agentContext);
            }
            let userPrompt = "# Task Execution Status\n";
            if (args.completedList && args.completedList.length > 0) {
              userPrompt += "## Completed task list\n";
              for (let i = 0; i < args.completedList.length; i++) {
                userPrompt += `- ${args.completedList[i]}\n`;
              }
              userPrompt += "\n";
            }
            if (args.todoList && args.todoList.length > 0) {
              userPrompt += "## Pending task list\n";
              for (let i = 0; i < args.todoList.length; i++) {
                userPrompt += `- ${args.todoList[i]}\n`;
              }
              userPrompt += "\n";
            }
            if (args.loopDetection == "loop") {
              userPrompt += `## Loop detection\nIt seems that your task is being executed in a loop, Please change the execution strategy and try other methods to complete the current task.\n\n`;
            }
            userPrompt += "Please continue executing the remaining tasks.";
            messages.push({
              role: "user",
              content: [
                {
                  type: "text",
                  text: userPrompt.trim(),
                },
              ],
            });
          }
          catch (e) {
            Log.error("TodoListManagerTool error", e);
          }
        }

        const AGENT_SYSTEM_TEMPLATE = `
You are {{name}}, an autonomous AI agent for {{agent}} agent.

# Agent Description
<if description>
{{description}}
</if>
<if extSysPrompt>
{{extSysPrompt}}
</if>
<if ${TOOL_NAME$8}Tool>
* HUMAN INTERACT
During the task execution process, you can use the \`${TOOL_NAME$8}\` tool to interact with humans, please call it in the following situations:
- When performing dangerous operations such as deleting files, confirmation from humans is required.
- When encountering obstacles while accessing websites, such as requiring user login, captcha verification, QR code scanning, or human verification, you need to request manual assistance.
- Please do not use the \`${TOOL_NAME$8}\` tool frequently.
- The \`${TOOL_NAME$8}\` tool does not support parallel calls.
</if>
<if ${TOOL_NAME$6}Tool>
* VARIABLE STORAGE
When a step node has input/output variable attributes, use the \`${TOOL_NAME$6}\` tool to read from and write to these variables, these variables enable context sharing and coordination between multiple agents.
The \`${TOOL_NAME$6}\` tool does not support parallel calls.
</if>
<if ${TOOL_NAME$a}Tool>
* forEach node
For repetitive tasks, when executing a forEach node, the \`${TOOL_NAME$a}\` tool must be used. Loop tasks support parallel tool calls, and during parallel execution, this tool needs to be called interspersed throughout the process.
</if>
<if ${TOOL_NAME$9}Tool>
* watch node
monitor changes in webpage DOM elements, when executing to the watch node, require the use of the \`${TOOL_NAME$9}\` tool.
</if>

<if mainTask>
Main task: {{mainTask}}
</if>
<if preTaskResult>
Pre-task execution results:
<subtask_results>
{{preTaskResult}}
</subtask_results>
</if>

# User input task instructions
<root>
  <!-- Main task, completed through the collaboration of multiple Agents -->
  <mainTask>main task</mainTask>
  <!-- The tasks that the current agent needs to complete, the current agent only needs to complete the currentTask -->
  <currentTask>specific task</currentTask>
  <!-- Complete the corresponding step nodes of the task, Only for reference -->
  <nodes>
    <!-- node supports input/output variables to pass dependencies -->
    <node input="variable name" output="variable name" status="todo / done">task step node</node>
<if hasForEachNode>
    <!-- duplicate task node, items support list and variable -->
    <forEach items="list or variable name">
      <node>forEach item step node</node>
    </forEach>
</if>
<if hasWatchNode>
    <!-- monitor task node, the loop attribute specifies whether to listen in a loop or listen once -->
    <watch event="dom" loop="true">
      <description>Monitor task description</description>
      <trigger>
        <node>Trigger step node</node>
        <node>...</node>
      </trigger>
    </watch>
</if>
  </nodes>
</root>

Current datetime: {{datetime}}
<if canParallelToolCalls>
For maximum efficiency, when executing multiple independent operations that do not depend on each other or conflict with one another, these tools can be called in parallel simultaneously.
</if>
The output language should follow the language corresponding to the user's task.
`;
        function getAgentSystemPrompt(agent, agentNode, context, tools, extSysPrompt) {
          tools = tools || agent.Tools;
          const toolVars = {};
          for (let i = 0; i < tools.length; i++) {
            toolVars[tools[i].name + "Tool"] = true;
          }
          let mainTask = "";
          let preTaskResult = "";
          if (context.chain.agents.length > 1) {
            mainTask = context.chain.taskPrompt.trim();
            preTaskResult = buildPreTaskResult(context);
          }
          const agentSysPrompt = global.prompts.get(GlobalPromptKey.agent_system) || AGENT_SYSTEM_TEMPLATE;
          return PromptTemplate.render(agentSysPrompt, {
            name: config$1.name,
            agent: agent.Name,
            description: agent.Description,
            extSysPrompt: extSysPrompt?.trim() || "",
            mainTask: mainTask,
            preTaskResult: preTaskResult.trim(),
            hasWatchNode: agentNode.xml.indexOf("</watch>") > -1,
            hasForEachNode: agentNode.xml.indexOf("</forEach>") > -1,
            canParallelToolCalls: agent.canParallelToolCalls(),
            datetime: context.variables.get("datetime") || new Date().toLocaleString(),
            ...toolVars,
          }).trim();
        }
        function buildPreTaskResult(context) {
          let preTaskResult = "";
          for (let i = 0; i < context.chain.agents.length; i++) {
            const agentChain = context.chain.agents[i];
            if (agentChain.agentResult) {
              preTaskResult += `<subtask_result agent="${agentChain.agent.name}">Subtask: ${agentChain.agent.task}\nResult: ${sub(agentChain.agentResult, 600)}</subtask_result>`;
            }
          }
          return preTaskResult.trim();
        }
        function getAgentUserPrompt(agent, agentNode, context, tools) {
          const hasTaskNodeStatusTool = (tools || agent.Tools).filter((tool) => tool.name == TOOL_NAME$7)
            .length > 0;
          return buildAgentRootXml(agentNode.xml, context.chain.taskPrompt, (nodeId, node) => {
            if (hasTaskNodeStatusTool) {
              node.setAttribute("status", "todo");
            }
          });
        }

        class Agent {
          constructor(params) {
            this.tools = [];
            this.name = params.name;
            this.description = params.description;
            this.tools = params.tools;
            this.llms = params.llms;
            this.mcpClient = params.mcpClient;
            this.planDescription = params.planDescription;
            this.requestHandler = params.requestHandler;
          }
          async run(context, agentChain) {
            const mcpClient = this.mcpClient || context.config.defaultMcpClient;
            const agentContext = new AgentContext(context, this, agentChain);
            try {
              this.agentContext = agentContext;
              mcpClient &&
                !mcpClient.isConnected() &&
                (await mcpClient.connect(context.controller.signal));
              return await this.runWithContext(agentContext, mcpClient, config$1.maxReactNum);
            }
            finally {
              mcpClient && (await mcpClient.close());
            }
          }
          async runWithContext(agentContext, mcpClient, maxReactNum = 100, historyMessages = []) {
            let loopNum = 0;
            let checkNum = 0;
            this.agentContext = agentContext;
            const context = agentContext.context;
            const agentNode = agentContext.agentChain.agent;
            const tools = [
              ...this.tools,
              ...this.system_auto_tools(agentNode, agentContext),
            ];
            const systemPrompt = await this.buildSystemPrompt(agentContext, tools);
            const userPrompt = await this.buildUserPrompt(agentContext, tools);
            const messages = [
              {
                role: "system",
                content: systemPrompt,
                providerOptions: defaultMessageProviderOptions(),
              },
              ...historyMessages,
              {
                role: "user",
                content: userPrompt,
                providerOptions: defaultMessageProviderOptions(),
              },
            ];
            agentContext.messages = messages;
            const rlm = new RetryLanguageModel(context.config.llms, this.llms);
            rlm.setContext(agentContext);
            let agentTools = tools;
            while (loopNum < maxReactNum) {
              await context.checkAborted();
              if (mcpClient) {
                const controlMcp = await this.controlMcpTools(agentContext, messages, loopNum);
                if (controlMcp.mcpTools) {
                  const mcpTools = await this.listTools(context, mcpClient, agentNode, controlMcp.mcpParams);
                  const usedTools = extractUsedTool(messages, agentTools);
                  const _agentTools = mergeTools(tools, usedTools);
                  agentTools = mergeTools(_agentTools, mcpTools);
                }
              }
              await this.handleMessages(agentContext, messages, tools);
              const llm_tools = convertTools(agentTools);
              const results = await callAgentLLM(agentContext, rlm, messages, llm_tools, false, undefined, 0, this.callback, this.requestHandler);
              const forceStop = agentContext.variables.get("forceStop");
              if (forceStop) {
                return forceStop;
              }
              const finalResult = await this.handleCallResult(agentContext, messages, agentTools, results);
              loopNum++;
              if (!finalResult) {
                if (config$1.mode == "expert" &&
                  loopNum % config$1.expertModeTodoLoopNum == 0) {
                  await doTodoListManager(agentContext, rlm, messages, llm_tools);
                }
                continue;
              }
              if (config$1.mode == "expert" && checkNum == 0) {
                checkNum++;
                const { completionStatus } = await doTaskResultCheck(agentContext, rlm, messages, llm_tools);
                if (completionStatus == "incomplete") {
                  continue;
                }
              }
              return finalResult;
            }
            return "Unfinished";
          }
          async handleCallResult(agentContext, messages, agentTools, results) {
            const user_messages = [];
            const toolResults = [];
            // results = memory.removeDuplicateToolUse(results);
            messages.push({
              role: "assistant",
              content: results,
            });
            if (results.length == 0) {
              return null;
            }
            if (results.every((s) => s.type == "text")) {
              return results.map((s) => s.text).join("\n\n");
            }
            const toolCalls = results.filter((s) => s.type == "tool-call");
            if (toolCalls.length > 1 &&
              this.canParallelToolCalls(toolCalls) &&
              toolCalls.every((s) => agentTools.find((t) => t.name == s.toolName)?.supportParallelCalls)) {
              const results = await Promise.all(toolCalls.map((toolCall) => this.callToolCall(agentContext, agentTools, toolCall, user_messages)));
              for (let i = 0; i < results.length; i++) {
                toolResults.push(results[i]);
              }
            }
            else {
              for (let i = 0; i < toolCalls.length; i++) {
                const toolCall = toolCalls[i];
                const toolResult = await this.callToolCall(agentContext, agentTools, toolCall, user_messages);
                toolResults.push(toolResult);
              }
            }
            if (toolResults.length > 0) {
              messages.push({
                role: "tool",
                content: toolResults,
              });
              user_messages.forEach((message) => messages.push(message));
              return null;
            }
            else {
              return results
                .filter((s) => s.type == "text")
                .map((s) => s.text)
                .join("\n\n");
            }
          }
          async callToolCall(agentContext, agentTools, result, user_messages = []) {
            const context = agentContext.context;
            const toolChain = new ToolChain(result, agentContext.agentChain.agentRequest);
            agentContext.agentChain.push(toolChain);
            let toolResult;
            try {
              const args = typeof result.input == "string"
                ? JSON.parse(result.input || "{}")
                : result.input || {};
              toolChain.params = args;
              let tool = getTool(agentTools, result.toolName);
              if (!tool) {
                throw new Error(result.toolName + " tool does not exist");
              }
              toolResult = await tool.execute(args, agentContext, result);
              toolChain.updateToolResult(toolResult);
              agentContext.consecutiveErrorNum = 0;
            }
            catch (e) {
              Log.error("tool call error: ", result.toolName, result.input, e);
              toolResult = {
                content: [
                  {
                    type: "text",
                    text: e + "",
                  },
                ],
                isError: true,
              };
              toolChain.updateToolResult(toolResult);
              if (++agentContext.consecutiveErrorNum >= 10) {
                throw e;
              }
            }
            const callback = this.callback || context.config.callback;
            if (callback) {
              await callback.onMessage({
                streamType: "agent",
                chatId: context.chatId,
                taskId: context.taskId,
                agentName: agentContext.agent.Name,
                nodeId: agentContext.agentChain.agent.id,
                type: "tool_result",
                toolCallId: result.toolCallId,
                toolName: result.toolName,
                params: result.input || {},
                toolResult: toolResult,
              }, agentContext);
            }
            return convertToolResult(result, toolResult, user_messages);
          }
          system_auto_tools(agentNode, agentContext) {
            const tools = [];
            const agentNodeXml = agentNode.xml;
            const hasVariable = agentNodeXml.indexOf("input=") > -1 ||
              agentNodeXml.indexOf("output=") > -1;
            if (hasVariable) {
              tools.push(new VariableStorageTool());
            }
            const hasForeach = agentNodeXml.indexOf("</forEach>") > -1;
            if (hasForeach) {
              tools.push(new ForeachTaskTool());
            }
            const hasWatch = agentNodeXml.indexOf("</watch>") > -1;
            if (hasWatch) {
              tools.push(new WatchTriggerTool());
            }
            const callback = this.callback || agentContext.context.config.callback;
            if (callback?.onHumanConfirm ||
              callback?.onHumanInput ||
              callback?.onHumanSelect ||
              callback?.onHumanHelp) {
              tools.push(new HumanInteractTool());
            }
            const toolNames = this.tools.map((tool) => tool.name);
            return tools.filter((tool) => toolNames.indexOf(tool.name) == -1);
          }
          async buildSystemPrompt(agentContext, tools) {
            return getAgentSystemPrompt(this, agentContext.agentChain.agent, agentContext.context, tools, await this.extSysPrompt(agentContext, tools));
          }
          async buildUserPrompt(agentContext, tools) {
            return [
              {
                type: "text",
                text: getAgentUserPrompt(this, agentContext.agentChain.agent, agentContext.context, tools),
              },
            ];
          }
          async extSysPrompt(agentContext, tools) {
            return "";
          }
          async listTools(context, mcpClient, agentNode, mcpParams) {
            try {
              if (!mcpClient.isConnected()) {
                await mcpClient.connect(context.controller.signal);
              }
              let list = await mcpClient.listTools({
                taskId: context.taskId,
                nodeId: agentNode?.id,
                environment: config$1.platform,
                agent_name: agentNode?.name || this.name,
                params: {},
                prompt: agentNode?.task || context.chain.taskPrompt,
                ...(mcpParams || {}),
              }, context.controller.signal);
              let mcpTools = [];
              for (let i = 0; i < list.length; i++) {
                let toolSchema = list[i];
                let execute = this.toolExecuter(mcpClient, toolSchema.name);
                let toolWrapper = new ToolWrapper(toolSchema, execute);
                mcpTools.push(new McpTool(toolWrapper));
              }
              return mcpTools;
            }
            catch (e) {
              Log.error("Mcp listTools error", e);
              return [];
            }
          }
          async controlMcpTools(agentContext, messages, loopNum) {
            return {
              mcpTools: loopNum == 0,
            };
          }
          toolExecuter(mcpClient, name) {
            return {
              execute: async function (args, agentContext) {
                return await mcpClient.callTool({
                  name: name,
                  arguments: args,
                  extInfo: {
                    taskId: agentContext.context.taskId,
                    nodeId: agentContext.agentChain.agent.id,
                    environment: config$1.platform,
                    agent_name: agentContext.agent.Name,
                  },
                }, agentContext.context.controller.signal);
              },
            };
          }
          async handleMessages(agentContext, messages, tools) {
            // Only keep the last image / file, large tool-text-result
            handleLargeContextMessages(messages);
          }
          async callInnerTool(fun) {
            let result = await fun();
            return {
              content: [
                {
                  type: "text",
                  text: result
                    ? typeof result == "string"
                      ? result
                      : JSON.stringify(result)
                    : "Successful",
                },
              ],
            };
          }
          async loadTools(context) {
            if (this.mcpClient) {
              let mcpTools = await this.listTools(context, this.mcpClient);
              if (mcpTools && mcpTools.length > 0) {
                return mergeTools(this.tools, mcpTools);
              }
            }
            return this.tools;
          }
          addTool(tool) {
            this.tools.push(tool);
          }
          async onTaskStatus(status, reason) {
            if (status == "abort" && this.agentContext) {
              this.agentContext?.variables.clear();
            }
          }
          canParallelToolCalls(toolCalls) {
            return config$1.parallelToolCalls;
          }
          get Llms() {
            return this.llms;
          }
          get Name() {
            return this.name;
          }
          get Description() {
            return this.description;
          }
          get Tools() {
            return this.tools;
          }
          get PlanDescription() {
            return this.planDescription;
          }
          get McpClient() {
            return this.mcpClient;
          }
          get AgentContext() {
            return this.agentContext;
          }
        }

        function extract_page_content(max_url_length = 200, max_content_length = 50000) {
          let result = "";
          max_url_length = max_url_length || 200;
          try {
            function traverse(node) {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toLowerCase();
                if (["script", "style", "noscript"].includes(tagName)) {
                  return;
                }
                const style = window.getComputedStyle(node);
                if (style.display == "none" ||
                  style.visibility == "hidden" ||
                  style.opacity == "0") {
                  return;
                }
              }
              if (node.nodeType === Node.TEXT_NODE) {
                // text
                const text = node.textContent.trim();
                if (text) {
                  result += text + " ";
                }
              }
              else if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toLowerCase();
                if (["input", "select", "textarea"].includes(tagName)) {
                  // input / select / textarea
                  if (tagName == "input" && node.type == "checkbox") {
                    result += node.checked + " ";
                  }
                  else if (tagName == "input" && node.type == "radio") {
                    if (node.checked && node.value) {
                      result += node.value + " ";
                    }
                  }
                  else if (node.value) {
                    result += node.value + " ";
                  }
                }
                else if (tagName === "img") {
                  // image
                  const src = node.src ||
                    node.getAttribute("src") ||
                    node.getAttribute("data-src");
                  const alt = node.alt || node.title || "";
                  if (src &&
                    src.length <= max_url_length &&
                    node.width * node.height >= 10000 &&
                    src.startsWith("http")) {
                    result += `![${alt ? alt : "image"}](${src.trim()}) `;
                  }
                }
                else if (tagName === "a" && node.children.length == 0) {
                  // link
                  const href = node.href || node.getAttribute("href");
                  const text = node.innerText.trim() || node.title;
                  if (text &&
                    href &&
                    href.length <= max_url_length &&
                    href.startsWith("http")) {
                    result += `[${text}](${href.trim()}) `;
                  }
                  else {
                    result += text + " ";
                  }
                }
                else if (tagName === "video" || tagName == "audio") {
                  // video / audio
                  let src = node.src || node.getAttribute("src");
                  const sources = node.querySelectorAll("source");
                  if (sources.length > 0 && sources[0].src) {
                    src = sources[0].src;
                    if (src && src.startsWith("http") && sources[0].type) {
                      result += sources[0].type + " ";
                    }
                  }
                  if (src && src.startsWith("http")) {
                    result += src.trim() + " ";
                  }
                }
                else if (tagName === "br") {
                  // br
                  result += "\n";
                }
                else if (["p", "div", "h1", "h2", "h3", "h4", "h5", "h6"].includes(tagName)) {
                  // block
                  result += "\n";
                  for (let child of node.childNodes) {
                    traverse(child);
                  }
                  result += "\n";
                  return;
                }
                else if (tagName === "hr") {
                  // hr
                  result += "\n--------\n";
                }
                else {
                  // recursive
                  for (let child of node.childNodes) {
                    traverse(child);
                  }
                }
              }
            }
            traverse(document.body);
          }
          catch (e) {
            result = document.body.innerText;
          }
          result = result.replace(/\s*\n/g, "\n").replace(/\n+/g, "\n").trim();
          if (result.length > max_content_length) {
            // result = result.slice(0, max_content_length) + "...";
            result = Array.from(result).slice(0, max_content_length).join("") + "...";
          }
          return result;
        }
        function mark_screenshot_highlight_elements(screenshot, area_map, client_rect) {
          return new Promise(async (resolve, reject) => {
            try {
              const hasOffscreen = typeof OffscreenCanvas !== "undefined";
              const hasCreateImageBitmap = typeof createImageBitmap !== "undefined";
              const hasDOM = typeof document !== "undefined" && typeof Image !== "undefined";
              // @ts-ignore
              const isNode = typeof window === "undefined" && typeof process !== "undefined" && !!process.versions && !!process.versions.node;
              const loadImageAny = async () => {
                if (hasCreateImageBitmap) {
                  const base64Data = screenshot.imageBase64;
                  const binaryString = atob(base64Data);
                  const bytes = new Uint8Array(binaryString.length);
                  for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                  }
                  const blob = new Blob([bytes], { type: screenshot.imageType });
                  const imageBitmap = await createImageBitmap(blob, {
                    resizeQuality: "high",
                    resizeWidth: client_rect.width,
                    resizeHeight: client_rect.height,
                  });
                  return { img: imageBitmap };
                }
                if (hasDOM) {
                  const img = await new Promise((resolveImg, rejectImg) => {
                    const image = new Image();
                    image.onload = () => resolveImg(image);
                    image.onerror = (e) => rejectImg(e);
                    image.src = `data:${screenshot.imageType};base64,${screenshot.imageBase64}`;
                  });
                  return { img };
                }
                if (isNode) {
                  const canvasMod = await loadPackage("canvas");
                  const { loadImage } = canvasMod;
                  const dataUrl = `data:${screenshot.imageType};base64,${screenshot.imageBase64}`;
                  const img = await loadImage(dataUrl);
                  return { img };
                }
                throw new Error("No image environment available");
              };
              const createCanvasAny = async (width, height) => {
                if (hasOffscreen) {
                  const canvas = new OffscreenCanvas(width, height);
                  return {
                    ctx: canvas.getContext("2d"),
                    exportDataUrl: async (mime) => {
                      const blob = await canvas.convertToBlob({ type: mime });
                      return await new Promise((res, rej) => {
                        const reader = new FileReader();
                        reader.onloadend = () => res(reader.result);
                        reader.onerror = () => rej(new Error("Failed to convert blob to base64"));
                        reader.readAsDataURL(blob);
                      });
                    },
                  };
                }
                if (hasDOM) {
                  const canvas = document.createElement("canvas");
                  canvas.width = width;
                  canvas.height = height;
                  return {
                    ctx: canvas.getContext("2d"),
                    exportDataUrl: async (mime) => canvas.toDataURL(mime),
                  };
                }
                if (isNode) {
                  const canvasMod = await loadPackage("canvas");
                  const { createCanvas } = canvasMod;
                  const canvas = createCanvas(width, height);
                  return {
                    ctx: canvas.getContext("2d"),
                    exportDataUrl: async (mime) => canvas.toDataURL(mime),
                  };
                }
                throw new Error("No canvas environment available");
              };
              const loaded = await loadImageAny();
              const targetWidth = client_rect.width;
              const targetHeight = client_rect.height;
              const { ctx, exportDataUrl } = await createCanvasAny(targetWidth, targetHeight);
              if (!ctx) {
                reject(new Error("Failed to get canvas context"));
                return;
              }
              ctx.imageSmoothingEnabled = true;
              ctx.imageSmoothingQuality = "high";
              ctx.drawImage(loaded.img, 0, 0, targetWidth, targetHeight);
              const sortedEntries = Object.entries(area_map)
                .filter(([id, area]) => area.width > 0 && area.height > 0)
                .sort((a, b) => {
                  const areaA = a[1].width * a[1].height;
                  const areaB = b[1].width * b[1].height;
                  return areaB - areaA;
                });
              const colors = [
                "#FF0000",
                "#00FF00",
                "#0000FF",
                "#FFA500",
                "#800080",
                "#008080",
                "#FF69B4",
                "#4B0082",
                "#FF4500",
                "#2E8B57",
                "#DC143C",
                "#4682B4",
              ];
              sortedEntries.forEach(([id, area], index) => {
                const color = colors[index % colors.length];
                if (area.width * area.height < 40000) {
                  // Draw a background color
                  ctx.fillStyle = color + "1A";
                  ctx.fillRect(area.x, area.y, area.width, area.height);
                }
                // Draw a border
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.strokeRect(area.x, area.y, area.width, area.height);
                // Draw ID tag background
                const fontSize = Math.min(12, Math.max(8, area.height / 2));
                ctx.font = `${fontSize}px sans-serif`;
                const metrics = ctx.measureText(id);
                const textWidth = metrics && metrics.width ? metrics.width : 0;
                const padding = 4;
                const labelWidth = textWidth + padding * 2;
                const labelHeight = fontSize + padding * 2;
                // The tag position is in the upper right corner.
                const labelX = area.x + area.width - labelWidth;
                let labelY = area.y;
                // Adjust if box is too small
                if (area.width < labelWidth + 4 || area.height < labelHeight + 4) {
                  // Position outside the box if it's too small
                  labelY = area.y - labelHeight;
                }
                // Draw label background
                ctx.fillStyle = color;
                ctx.fillRect(labelX, labelY, labelWidth, labelHeight);
                // Draw ID text
                ctx.fillStyle = "#FFFFFF";
                ctx.textBaseline = "top";
                ctx.fillText(id, labelX + padding, labelY + padding);
              });
              // Export the image
              const out = await exportDataUrl(screenshot.imageType);
              resolve(out);
            }
            catch (error) {
              reject(error);
            }
          });
        }

        const AGENT_NAME = "Browser";
        class BaseBrowserAgent extends Agent {
          async go_back(agentContext) {
            try {
              await this.execute_script(agentContext, () => {
                window.navigation.back();
              }, []);
              await sleep(100);
            }
            catch (e) { }
          }
          async extract_page_content(agentContext, variable_name) {
            let content = await this.execute_script(agentContext, extract_page_content, []);
            let pageInfo = await this.get_current_page(agentContext);
            let result = `title: ${pageInfo.title}\npage_url: ${pageInfo.url}\npage_content: \n${content}`;
            if (variable_name) {
              agentContext.context.variables.set(variable_name, result);
            }
            return {
              title: pageInfo.title || "",
              page_url: pageInfo.url,
              page_content: content,
            };
          }
          async controlMcpTools(agentContext, messages, loopNum) {
            if (loopNum > 0) {
              let url = null;
              try {
                url = (await this.get_current_page(agentContext)).url;
              }
              catch (e) { }
              let lastUrl = agentContext.variables.get("lastUrl");
              agentContext.variables.set("lastUrl", url);
              return {
                mcpTools: loopNum == 0 || url != lastUrl,
                mcpParams: {
                  environment: "browser",
                  browser_url: url,
                },
              };
            }
            else {
              return {
                mcpTools: true,
                mcpParams: {
                  environment: "browser",
                },
              };
            }
          }
          toolExecuter(mcpClient, name) {
            return {
              execute: async (args, agentContext) => {
                let result = await mcpClient.callTool({
                  name: name,
                  arguments: args,
                  extInfo: {
                    taskId: agentContext.context.taskId,
                    nodeId: agentContext.agentChain.agent.id,
                    environment: "browser",
                    agent_name: agentContext.agent.Name,
                    browser_url: agentContext.variables.get("lastUrl"),
                  },
                }, agentContext.context.controller.signal);
                if (result.extInfo &&
                  result.extInfo["javascript"] &&
                  result.content[0].type == "text") {
                  let script = result.content[0].text;
                  let params = JSON.stringify(args);
                  let runScript = `${script};execute(${params})`;
                  let scriptResult = await this.execute_mcp_script(agentContext, runScript);
                  let resultText;
                  if (typeof scriptResult == "string" ||
                    typeof scriptResult == "number") {
                    resultText = scriptResult + "";
                  }
                  else {
                    resultText = scriptResult
                      ? JSON.stringify(scriptResult)
                      : "Successful";
                  }
                  return {
                    content: [
                      {
                        type: "text",
                        text: resultText,
                      },
                    ],
                  };
                }
                return result;
              },
            };
          }
          async get_current_page(agentContext) {
            return await this.execute_script(agentContext, () => {
              return {
                url: window.location.href,
                title: window.document.title,
              };
            }, []);
          }
          lastToolResult(messages) {
            let lastMessage = messages[messages.length - 1];
            if (lastMessage.role != "tool") {
              return null;
            }
            let toolResult = lastMessage.content.filter((t) => t.type == "tool-result")[0];
            if (!toolResult) {
              return null;
            }
            let result = toolResult.output.value;
            for (let i = messages.length - 2; i > 0; i--) {
              if (messages[i].role !== "assistant" ||
                typeof messages[i].content == "string") {
                continue;
              }
              for (let j = 0; j < messages[i].content.length; j++) {
                let content = messages[i].content[j];
                if (typeof content !== "string" && content.type !== "tool-call") {
                  continue;
                }
                let toolUse = content;
                if (toolResult.toolCallId != toolUse.toolCallId) {
                  continue;
                }
                return {
                  id: toolResult.toolCallId,
                  toolName: toolUse.toolName,
                  args: toolUse.input,
                  result,
                };
              }
            }
            return null;
          }
          toolUseNames(messages) {
            let toolNames = [];
            if (!messages) {
              return toolNames;
            }
            for (let i = 0; i < messages.length; i++) {
              let message = messages[i];
              if (message.role == "tool") {
                toolNames.push(message.content[0].toolName);
              }
            }
            return toolNames;
          }
          async execute_mcp_script(agentContext, script) {
            return;
          }
        }

        // @ts-nocheck
        function run_build_dom_tree() {
          var computedStyleCache = new WeakMap();
          /**
           * Gets the cached computed style for an element.
           */
          function getCachedComputedStyle(element) {
            if (!element)
              return null;
            if (computedStyleCache.has(element)) {
              return computedStyleCache.get(element);
            }
            try {
              const style = window.getComputedStyle(element);
              if (style) {
                computedStyleCache.set(element, style);
              }
              return style;
            }
            catch (e) {
              return null;
            }
          }
          /**
           * Get clickable elements on the page
           *
           * @param {*} markHighlightElements Is mark highlighted
           * @param {*} includeAttributes [attr_names...]
           * @returns { element_str, client_rect, selector_map, area_map }
           */
          function get_clickable_elements(markHighlightElements = true, includeAttributes) {
            window.clickable_elements = {};
            computedStyleCache = new WeakMap();
            document.querySelectorAll("[eko-user-highlight-id]").forEach(ele => ele.removeAttribute("eko-user-highlight-id"));
            let page_tree = build_dom_tree(markHighlightElements);
            let element_tree = parse_node(page_tree);
            let element_str = clickable_elements_to_string(element_tree, includeAttributes);
            let client_rect = {
              width: window.innerWidth || document.documentElement.clientWidth,
              height: window.innerHeight || document.documentElement.clientHeight,
            };
            if (markHighlightElements) {
              let selector_map = {};
              // selector_map = create_selector_map(element_tree);
              return { element_str, client_rect, selector_map };
            }
            else {
              let area_map = create_area_map(element_tree);
              return { element_str, client_rect, area_map };
            }
          }
          function get_highlight_element(highlightIndex) {
            let element = document.querySelector(`[eko-user-highlight-id="eko-highlight-${highlightIndex}"]`);
            return element || window.clickable_elements[highlightIndex];
          }
          function remove_highlight() {
            let highlight = document.getElementById('eko-highlight-container');
            if (highlight) {
              highlight.remove();
            }
            computedStyleCache = new WeakMap();
          }
          function clickable_elements_to_string(element_tree, includeAttributes) {
            if (!includeAttributes) {
              includeAttributes = [
                'id',
                'title',
                'type',
                'name',
                'role',
                'class',
                'src',
                'href',
                'aria-label',
                'placeholder',
                'value',
                'alt',
                'aria-expanded',
              ];
            }
            function get_all_text_till_next_clickable_element(element_node) {
              let text_parts = [];
              function collect_text(node) {
                if (node.tagName && node != element_node && node.highlightIndex != null) {
                  return;
                }
                if (!node.tagName && node.text) {
                  text_parts.push(node.text);
                }
                else if (node.tagName) {
                  for (let i = 0; i < node.children.length; i++) {
                    collect_text(node.children[i]);
                  }
                }
              }
              collect_text(element_node);
              return text_parts.join('\n').trim().replace(/\n+/g, ' ');
            }
            function has_parent_with_highlight_index(node) {
              let current = node.parent;
              while (current) {
                if (current.highlightIndex != null) {
                  return true;
                }
                current = current.parent;
              }
              return false;
            }
            let formatted_text = [];
            function process_node(node, depth) {
              if (node.text == null) {
                if (node.highlightIndex != null) {
                  let attributes_str = '';
                  if (includeAttributes) {
                    for (let i = 0; i < includeAttributes.length; i++) {
                      let key = includeAttributes[i];
                      let value = node.attributes[key];
                      if (key == "class" && value && value.length > 30) {
                        let classList = value.split(" ").slice(0, 3);
                        value = classList.join(" ");
                      }
                      else if ((key == "src" || key == "href") && value && value.length > 200) {
                        continue;
                      }
                      else if ((key == "src" || key == "href") && value && value.startsWith("/")) {
                        value = window.location.origin + value;
                      }
                      if (key && value) {
                        attributes_str += ` ${key}="${value}"`;
                      }
                    }
                    attributes_str = attributes_str.replace(/\n+/g, ' ');
                  }
                  let text = get_all_text_till_next_clickable_element(node);
                  formatted_text.push(`[${node.highlightIndex}]:<${node.tagName}${attributes_str}>${text}</${node.tagName}>`);
                }
                for (let i = 0; i < node.children.length; i++) {
                  let child = node.children[i];
                  process_node(child);
                }
              }
              else if (!has_parent_with_highlight_index(node)) {
                formatted_text.push(`[]:${node.text}`);
              }
            }
            process_node(element_tree);
            return formatted_text.join('\n');
          }
          function create_area_map(element_tree) {
            let area_map = {};
            function process_node(node) {
              if (node.tagName) {
                if (node.highlightIndex != null) {
                  const element = window.clickable_elements[node.highlightIndex];
                  area_map[node.highlightIndex] = get_element_real_bounding_rect(element);
                }
                for (let i = 0; i < node.children.length; i++) {
                  process_node(node.children[i]);
                }
              }
            }
            process_node(element_tree);
            return area_map;
          }
          function get_element_real_bounding_rect(element) {
            if (!element || !(element instanceof Element)) {
              return { x: 0, y: 0, width: 0, height: 0 };
            }
            let rect = element.getBoundingClientRect();
            let x = rect.left;
            let y = rect.top;
            let width = rect.width;
            let height = rect.height;
            let win = element.ownerDocument.defaultView;
            let maxDepth = 10;
            let depth = 0;
            while (win && win !== win.parent && depth < maxDepth) {
              depth++;
              const frameElement = win.frameElement;
              if (!frameElement) {
                break;
              }
              const frameRect = frameElement.getBoundingClientRect();
              x += frameRect.left;
              y += frameRect.top;
              // Consider the border and padding of the iframe.
              const frameStyle = getCachedComputedStyle(frameElement);
              x += parseFloat(frameStyle.borderLeftWidth) || 0;
              y += parseFloat(frameStyle.borderTopWidth) || 0;
              x += parseFloat(frameStyle.paddingLeft) || 0;
              y += parseFloat(frameStyle.paddingTop) || 0;
              win = win.parent;
            }
            return { x, y, width, height };
          }
          function parse_node(node_data, parent) {
            if (!node_data) {
              return;
            }
            if (node_data.type == 'TEXT_NODE') {
              return {
                text: node_data.text || '',
                isVisible: node_data.isVisible || false,
                parent: parent,
              };
            }
            let element_node = {
              tagName: node_data.tagName,
              xpath: node_data.xpath,
              highlightIndex: node_data.highlightIndex,
              attributes: node_data.attributes || {},
              isVisible: node_data.isVisible || false,
              isInteractive: node_data.isInteractive || false,
              isTopElement: node_data.isTopElement || false,
              shadowRoot: node_data.shadowRoot || false,
              children: [],
              parent: parent,
            };
            if (node_data.children) {
              let children = [];
              for (let i = 0; i < node_data.children.length; i++) {
                let child = node_data.children[i];
                if (child) {
                  let child_node = parse_node(child, element_node);
                  if (child_node) {
                    children.push(child_node);
                  }
                }
              }
              element_node.children = children;
            }
            return element_node;
          }
          function build_dom_tree(markHighlightElements) {
            let highlightIndex = 0; // Reset highlight index
            let duplicates = new Set();
            function highlightElement(element, index, parentIframe = null) {
              // Create or get highlight container
              let container = document.getElementById('eko-highlight-container');
              if (!container) {
                container = document.createElement('div');
                container.id = 'eko-highlight-container';
                container.style.position = 'fixed';
                container.style.pointerEvents = 'none';
                container.style.top = '0';
                container.style.left = '0';
                container.style.width = '100%';
                container.style.height = '100%';
                container.style.zIndex = '2147483647'; // Maximum z-index value
                document.documentElement.appendChild(container);
              }
              // Generate a color based on the index
              const colors = [
                '#FF0000',
                '#00FF00',
                '#0000FF',
                '#FFA500',
                '#800080',
                '#008080',
                '#FF69B4',
                '#4B0082',
                '#FF4500',
                '#2E8B57',
                '#DC143C',
                '#4682B4',
              ];
              const colorIndex = index % colors.length;
              const baseColor = colors[colorIndex];
              const backgroundColor = `${baseColor}1A`; // 10% opacity version of the color
              // Create highlight overlay
              const overlay = document.createElement('div');
              overlay.style.position = 'absolute';
              overlay.style.border = `2px solid ${baseColor}`;
              overlay.style.pointerEvents = 'none';
              overlay.style.boxSizing = 'border-box';
              // Position overlay based on element
              const rect = element.getBoundingClientRect();
              let top = rect.top;
              let left = rect.left;
              if (rect.width < window.innerWidth / 2 || rect.height < window.innerHeight / 2) {
                overlay.style.backgroundColor = backgroundColor;
              }
              // Adjust position if element is inside an iframe
              if (parentIframe) {
                const iframeRect = parentIframe.getBoundingClientRect();
                top += iframeRect.top;
                left += iframeRect.left;
              }
              overlay.style.top = `${top}px`;
              overlay.style.left = `${left}px`;
              overlay.style.width = `${rect.width}px`;
              overlay.style.height = `${rect.height}px`;
              // Create label
              const label = document.createElement('div');
              label.className = 'eko-highlight-label';
              label.style.position = 'absolute';
              label.style.background = baseColor;
              label.style.color = 'white';
              label.style.padding = '1px 4px';
              label.style.borderRadius = '4px';
              label.style.fontSize = `${Math.min(12, Math.max(8, rect.height / 2))}px`; // Responsive font size
              label.textContent = index;
              // Calculate label position
              const labelWidth = 20; // Approximate width
              const labelHeight = 16; // Approximate height
              // Default position (top-right corner inside the box)
              let labelTop = top + 2;
              let labelLeft = left + rect.width - labelWidth - 2;
              // Adjust if box is too small
              if (rect.width < labelWidth + 4 || rect.height < labelHeight + 4) {
                // Position outside the box if it's too small
                labelTop = top - labelHeight - 2;
                labelLeft = left + rect.width - labelWidth;
              }
              // Ensure label stays within viewport
              if (labelTop < 0)
                labelTop = top + 2;
              if (labelLeft < 0)
                labelLeft = left + 2;
              if (labelLeft + labelWidth > window.innerWidth) {
                labelLeft = left + rect.width - labelWidth - 2;
              }
              label.style.top = `${labelTop}px`;
              label.style.left = `${labelLeft}px`;
              // Add to container
              container.appendChild(overlay);
              container.appendChild(label);
              // Store reference for cleanup
              element.setAttribute('eko-user-highlight-id', `eko-highlight-${index}`);
              return index + 1;
            }
            // Helper function to generate XPath as a tree
            function getXPathTree(element, stopAtBoundary = true) {
              const segments = [];
              let currentElement = element;
              while (currentElement && currentElement.nodeType === Node.ELEMENT_NODE) {
                // Stop if we hit a shadow root or iframe
                if (stopAtBoundary &&
                  (currentElement.parentNode instanceof ShadowRoot ||
                    currentElement.parentNode instanceof HTMLIFrameElement)) {
                  break;
                }
                let index = 0;
                let sibling = currentElement.previousSibling;
                while (sibling) {
                  if (sibling.nodeType === Node.ELEMENT_NODE &&
                    sibling.nodeName === currentElement.nodeName) {
                    index++;
                  }
                  sibling = sibling.previousSibling;
                }
                const tagName = currentElement.nodeName.toLowerCase();
                const xpathIndex = index > 0 ? `[${index + 1}]` : '';
                segments.unshift(`${tagName}${xpathIndex}`);
                currentElement = currentElement.parentNode;
              }
              return segments.join('/');
            }
            // Helper function to check if element is accepted
            function isElementAccepted(element) {
              const leafElementDenyList = new Set(['svg', 'script', 'style', 'link', 'meta', 'noscript', 'template']);
              return !leafElementDenyList.has(element.tagName.toLowerCase());
            }
            // Helper function to check if element is interactive
            function isInteractiveElement(element) {
              if (!element || element.nodeType !== Node.ELEMENT_NODE) {
                return false;
              }
              // Base interactive elements and roles
              const interactiveElements = new Set([
                'a',
                'button',
                'details',
                'embed',
                'input',
                'label',
                'menu',
                'menuitem',
                'object',
                'select',
                'textarea',
                'summary',
                'option',
                'optgroup',
                'fieldset',
                'legend',
              ]);
              const interactiveRoles = new Set([
                'button',
                'menu',
                'menuitem',
                'menubar',
                'link',
                'checkbox',
                'radio',
                'slider',
                'tab',
                'tabpanel',
                'textbox',
                'combobox',
                'grid',
                'listbox',
                'option',
                'progressbar',
                'scrollbar',
                'searchbox',
                'switch',
                'tree',
                'treeitem',
                'spinbutton',
                'tooltip',
                'a-button-inner',
                'a-dropdown-button',
                'click',
                'menuitemcheckbox',
                'menuitemradio',
                'a-button-text',
                'button-text',
                'button-icon',
                'button-icon-only',
                'button-text-icon-only',
                'dropdown',
                'combobox',
              ]);
              const tagName = element.tagName.toLowerCase();
              const role = element.getAttribute('role');
              const ariaRole = element.getAttribute('aria-role');
              const tabIndex = element.getAttribute('tabindex');
              // Basic role/attribute checks
              const hasInteractiveRole = interactiveElements.has(tagName) ||
                interactiveRoles.has(role) ||
                interactiveRoles.has(ariaRole) ||
                (tabIndex !== null && tabIndex !== '-1') ||
                element.getAttribute('data-action') === 'a-dropdown-select' ||
                element.getAttribute('data-action') === 'a-dropdown-button' ||
                element.getAttribute('contenteditable') === 'true';
              if (hasInteractiveRole)
                return true;
              // const eventTypes = [
              //   'click',
              //   'mousedown',
              //   'mouseup',
              //   'touchstart',
              //   'touchend',
              //   'keydown',
              //   'keyup',
              //   'focus',
              //   'blur',
              // ];
              const clickEventTypes = [
                'click',
                'mousedown',
                'mouseup',
                'touchstart',
                'touchend',
              ];
              // Filter elements that have no real event listeners at all
              if (window.getEventListeners) {
                const listeners = window.getEventListeners(element);
                const hasRealClickListeners = clickEventTypes.some((type) => listeners[type]?.length > 0);
                if (!hasRealClickListeners) {
                  return false;
                }
              }
              // Check for event listeners
              const hasClickHandler = element.onclick !== null ||
                element.getAttribute('onclick') !== null ||
                element.hasAttribute('ng-click') ||
                element.hasAttribute('@click') ||
                element.hasAttribute('v-on:click');
              // Helper function to safely get event listeners
              function getElementEventListeners(el) {
                // List of common event types to check
                const listeners = {};
                for (const type of clickEventTypes) {
                  const handler = el[`on${type}`];
                  if (handler) {
                    listeners[type] = [
                      {
                        listener: handler,
                        useCapture: false,
                      },
                    ];
                  }
                }
                return listeners;
              }
              // Check for click-related events on the element itself
              const listeners = getElementEventListeners(element);
              const hasClickListeners = clickEventTypes.some((type) => listeners[type]?.length > 0);
              // Check for ARIA properties that suggest interactivity
              const hasAriaProps = element.hasAttribute('aria-expanded') ||
                element.hasAttribute('aria-pressed') ||
                element.hasAttribute('aria-selected') ||
                element.hasAttribute('aria-checked');
              // Check if element is draggable
              const isDraggable = element.draggable || element.getAttribute('draggable') === 'true';
              if (hasAriaProps || hasClickHandler || hasClickListeners || isDraggable) {
                return true;
              }
              // Check if element has click-like styling
              let hasClickStyling = element.style.cursor === 'pointer' || getCachedComputedStyle(element).cursor === 'pointer';
              if (hasClickStyling) {
                let count = 0;
                let current = element.parentElement;
                while (current && current !== document.documentElement) {
                  hasClickStyling = current.style.cursor === 'pointer' || getCachedComputedStyle(current).cursor === 'pointer';
                  if (hasClickStyling)
                    return false;
                  current = current.parentElement;
                  if (++count > 10)
                    break;
                }
                return true;
              }
              return false;
            }
            // Helper function to check if element is visible
            function isElementVisible(element) {
              if (element.offsetWidth === 0 && element.offsetHeight === 0) {
                return false;
              }
              const style = getCachedComputedStyle(element);
              return (style?.visibility !== 'hidden' &&
                style?.display !== 'none');
            }
            // Helper function to check if element is the top element at its position
            function isTopElement(element) {
              // Find the correct document context and root element
              let doc = element.ownerDocument;
              // If we're in an iframe, elements are considered top by default
              if (doc !== window.document) {
                return true;
              }
              // For shadow DOM, we need to check within its own root context
              const shadowRoot = element.getRootNode();
              if (shadowRoot instanceof ShadowRoot) {
                const rect = element.getBoundingClientRect();
                const point = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
                try {
                  // Use shadow root's elementFromPoint to check within shadow DOM context
                  const topEl = shadowRoot.elementFromPoint(point.x, point.y);
                  if (!topEl)
                    return false;
                  // Check if the element or any of its parents match our target element
                  let count = 0;
                  let current = topEl;
                  while (current && current !== shadowRoot) {
                    if (current === element)
                      return true;
                    current = current.parentElement;
                    if (++count > 15)
                      break;
                  }
                  return false;
                }
                catch (e) {
                  return true; // If we can't determine, consider it visible
                }
              }
              // Regular DOM elements
              const rect = element.getBoundingClientRect();
              const point = { x: rect.left + rect.width / 2, y: rect.top + rect.height / 2 };
              try {
                const topEl = document.elementFromPoint(point.x, point.y);
                if (!topEl)
                  return false;
                let count = 0;
                let current = topEl;
                while (current && current !== document.documentElement) {
                  if (current === element)
                    return true;
                  current = current.parentElement;
                  if (++count > 15)
                    break;
                }
                return false;
              }
              catch (e) {
                return true;
              }
            }
            // Helper function to check if text node is visible
            function isTextNodeVisible(textNode) {
              const range = document.createRange();
              range.selectNodeContents(textNode);
              const rect = range.getBoundingClientRect();
              return (rect.width !== 0 &&
                rect.height !== 0 &&
                rect.top >= 0 &&
                rect.top <= window.innerHeight &&
                textNode.parentElement?.checkVisibility({
                  checkOpacity: true,
                  checkVisibilityCSS: true,
                }));
            }
            // Function to traverse the DOM and create nested JSON
            function buildDomTree(node, parentIframe = null) {
              if (!node || duplicates.has(node)) {
                return null;
              }
              duplicates.add(node);
              // Special case for text nodes
              if (node.nodeType === Node.TEXT_NODE) {
                const textContent = node.textContent.trim();
                if (textContent && isTextNodeVisible(node)) {
                  return {
                    type: 'TEXT_NODE',
                    text: textContent,
                    isVisible: true,
                  };
                }
                return null;
              }
              // Check if element is accepted
              if (node.nodeType === Node.ELEMENT_NODE && !isElementAccepted(node)) {
                return null;
              }
              const nodeData = {
                tagName: node.tagName ? node.tagName.toLowerCase() : null,
                attributes: {},
                xpath: node.nodeType === Node.ELEMENT_NODE ? getXPathTree(node, true) : null,
                children: [],
              };
              // Copy all attributes if the node is an element
              if (node.nodeType === Node.ELEMENT_NODE && node.attributes) {
                // Use getAttributeNames() instead of directly iterating attributes
                const attributeNames = node.getAttributeNames?.() || [];
                for (const name of attributeNames) {
                  nodeData.attributes[name] = node.getAttribute(name);
                }
              }
              if (node.nodeType === Node.ELEMENT_NODE) {
                const isInteractive = isInteractiveElement(node);
                const isVisible = isElementVisible(node);
                const isTop = isTopElement(node);
                nodeData.isInteractive = isInteractive;
                nodeData.isVisible = isVisible;
                nodeData.isTopElement = isTop;
                // For Shadow DOM elements, use more lenient criteria
                const isInShadowDOM = node.getRootNode() instanceof ShadowRoot;
                const shouldHighlight = isInteractive && isVisible && (isTop || isInShadowDOM);
                // Highlight if element meets all criteria and highlighting is enabled
                if (shouldHighlight) {
                  nodeData.highlightIndex = highlightIndex++;
                  window.clickable_elements[nodeData.highlightIndex] = node;
                  if (markHighlightElements) {
                    highlightElement(node, nodeData.highlightIndex, parentIframe);
                  }
                }
              }
              // Only add iframeContext if we're inside an iframe
              // if (parentIframe) {
              //     nodeData.iframeContext = `iframe[src="${parentIframe.src || ''}"]`;
              // }
              // Only add shadowRoot field if it exists
              if (node.shadowRoot) {
                nodeData.shadowRoot = true;
              }
              // Handle shadow DOM
              if (node.shadowRoot) {
                const shadowChildren = Array.from(node.shadowRoot.children).map((child) => buildDomTree(child, parentIframe)).filter(child => child !== null);
                nodeData.children.push(...shadowChildren);
              }
              // Handle iframes
              if (node.tagName === 'IFRAME') {
                try {
                  const iframeDoc = node.contentDocument || node.contentWindow.document;
                  if (iframeDoc) {
                    const iframeChildren = Array.from(iframeDoc.body.children).map((child) => buildDomTree(child, node)).filter(child => child !== null);
                    nodeData.children.push(...iframeChildren);
                  }
                }
                catch (e) {
                  console.warn('Unable to access iframe:', node);
                }
              }
              else {
                const style = getCachedComputedStyle(node);
                if (style && style.display !== 'none') {
                  const children = Array.from(node.children).map((child) => buildDomTree(child, parentIframe)).filter(child => child !== null);
                  nodeData.children.push(...children);
                }
              }
              return nodeData;
            }
            return buildDomTree(document.body);
          }
          window.get_clickable_elements = get_clickable_elements;
          window.get_highlight_element = get_highlight_element;
          window.remove_highlight = remove_highlight;
        }

        class BaseBrowserLabelsAgent extends BaseBrowserAgent {
          constructor(llms, ext_tools, mcpClient) {
            let description = `You are a browser operation agent, use structured commands to interact with the browser.
* This is a browser GUI interface where you need to analyze webpages by taking screenshot and page element structures, and specify action sequences to complete designated tasks.
* For your first visit, please start by calling either the \`navigate_to\` or \`current_page\` tool. After each action you perform, I will provide you with updated information about the current state, including page screenshots and structured element data that has been specially processed for easier analysis.
* During execution, please output user-friendly step information. Do not output HTML-related element and index information to users, as this would cause user confusion.

* Screenshot description:
  - Screenshot are used to understand page layouts, with labeled bounding boxes corresponding to element indexes. Each bounding box and its label share the same color, with labels typically positioned in the top-right corner of the box.
  - Screenshot help verify element positions and relationships. Labels may sometimes overlap, so extracted elements are used to verify the correct elements.
  - In addition to screenshot, simplified information about interactive elements is returned, with element indexes corresponding to those in the screenshot.
  - This tool can ONLY screenshot the VISIBLE content. If a complete content is required, use 'extract_page_content' instead.
  - If the webpage content hasn't loaded, please use the \`wait\` tool to allow time for the content to load.
* Element interaction:
  - Only use indexes that exist in the provided element list
  - Browser tools only return elements in visible viewport by default
  - Each element has a unique index number (e.g., "[33]:<button>Submit</button>")
  - Elements marked with "[]:" are non-interactive (for context only, e.g., "[]: Google")
  - Use the latest element index, do not rely on historical outdated element indexes
  - Due to technical limitations, not all interactive elements may be identified; use coordinates to interact with unlisted elements
* Error handling:
  - If no suitable elements exist, use other functions to complete the task
  - If stuck, try alternative approaches, don't refuse tasks
  - Handle popups/cookies by accepting or closing them
  - When encountering scenarios that require user assistance such as login, verification codes, QR code scanning, Payment, etc, you can request user help.
* Browser operation:
  - Use scroll to find elements you are looking for, When extracting content, prioritize using extract_page_content, only scroll when you need to load more content
  - Please follow user instructions and don't be lazy until the task is completed. For example, if a user asks you to find 30 people, don't just find 10 - keep searching until you find all 30.`;
            if (config$1.parallelToolCalls) {
              description += `
* Parallelism:
   - Do not call the navigate_to tool simultaneously
   - Operations that support parallelism generally only include clicking and input operations
   - When filling out a form, fields that are not dependent on each other should be filled simultaneously
   - Avoid parallel processing for dependent operations, such as those that need to wait for page loading, DOM changes, redirects, subsequent operations that depend on the results of previous operations, or operations that may interfere with each other and affect the same page elements. In these cases, please do not use parallelization.`;
            }
            const _tools_ = [];
            super({
              name: AGENT_NAME,
              description: description,
              tools: _tools_,
              llms: llms,
              mcpClient: mcpClient,
              planDescription: "Browser operation agent, interact with the browser using the mouse and keyboard.",
            });
            let init_tools = this.buildInitTools();
            if (ext_tools && ext_tools.length > 0) {
              init_tools = mergeTools(init_tools, ext_tools);
            }
            init_tools.forEach((tool) => _tools_.push(tool));
          }
          async input_text(agentContext, index, text, enter) {
            await this.execute_script(agentContext, typing, [{ index, text, enter }]);
            if (enter) {
              await sleep(200);
            }
          }
          async click_element(agentContext, index, num_clicks, button) {
            await this.execute_script(agentContext, do_click, [
              { index, num_clicks, button },
            ]);
          }
          async scroll_to_element(agentContext, index) {
            await this.execute_script(agentContext, (index) => {
              return window
                .get_highlight_element(index)
                .scrollIntoView({ behavior: "smooth" });
            }, [index]);
            await sleep(200);
          }
          async scroll_mouse_wheel(agentContext, amount, extract_page_content) {
            await this.execute_script(agentContext, scroll_by, [{ amount }]);
            await sleep(200);
            if (!extract_page_content) {
              const tools = this.toolUseNames(agentContext.agentChain.agentRequest?.messages);
              let scroll_count = 0;
              for (let i = tools.length - 1; i >= Math.max(tools.length - 8, 0); i--) {
                if (tools[i] == "scroll_mouse_wheel") {
                  scroll_count++;
                }
              }
              if (scroll_count >= 3) {
                extract_page_content = true;
              }
            }
            if (extract_page_content) {
              let page_result = await this.extract_page_content(agentContext);
              return {
                result: "The current page content has been extracted, latest page content:\n" +
                  "title: " +
                  page_result.title +
                  "\n" +
                  "page_url: " +
                  page_result.page_url +
                  "\n" +
                  "page_content: " +
                  page_result.page_content,
              };
            }
          }
          async hover_to_element(agentContext, index) {
            await this.execute_script(agentContext, hover_to, [{ index }]);
          }
          async get_select_options(agentContext, index) {
            return await this.execute_script(agentContext, get_select_options, [
              { index },
            ]);
          }
          async select_option(agentContext, index, option) {
            return await this.execute_script(agentContext, select_option, [
              { index, option },
            ]);
          }
          async screenshot_and_html(agentContext) {
            try {
              let element_result;
              let double_screenshots;
              for (let i = 0; i < 5; i++) {
                await sleep(200);
                await this.execute_script(agentContext, run_build_dom_tree, []);
                await sleep(50);
                element_result = (await this.execute_script(agentContext, (markHighlightElements) => {
                  return window.get_clickable_elements(markHighlightElements);
                }, [config$1.mode != "fast" && config$1.markImageMode == "dom"]));
                if (element_result) {
                  break;
                }
              }
              await sleep(100);
              const screenshot = config$1.mode == "fast"
                ? undefined
                : await this.screenshot_and_compress(agentContext, element_result.client_rect);
              if (config$1.markImageMode == "draw" &&
                screenshot?.imageBase64 &&
                element_result.area_map) {
                double_screenshots = { ...screenshot };
                const markImageBase64 = await mark_screenshot_highlight_elements(screenshot, element_result.area_map, element_result.client_rect);
                screenshot.imageBase64 = markImageBase64;
              }
              const pseudoHtml = element_result.element_str || "";
              return {
                double_screenshots: double_screenshots,
                imageBase64: screenshot?.imageBase64,
                imageType: screenshot?.imageType,
                pseudoHtml: pseudoHtml,
                client_rect: element_result.client_rect,
              };
            }
            finally {
              try {
                await this.execute_script(agentContext, () => {
                  return window.remove_highlight();
                }, []);
              }
              catch (e) { }
            }
          }
          async screenshot_and_compress(agentContext, client_rect) {
            const screenshot = await this.screenshot(agentContext);
            if (!client_rect || !screenshot) {
              return screenshot;
            }
            const compressedImage = await compressImageData(screenshot.imageBase64, screenshot.imageType, {
              resizeWidth: client_rect.width,
              resizeHeight: client_rect.height,
            });
            return {
              imageBase64: compressedImage.imageBase64,
              imageType: compressedImage.imageType,
            };
          }
          get_element_script(index) {
            return `window.get_highlight_element(${index});`;
          }
          canParallelToolCalls(toolCalls) {
            if (toolCalls) {
              for (let i = 0; i < toolCalls.length; i++) {
                const toolCall = toolCalls[i];
                if (toolCall.toolName == "wait" ||
                  toolCall.toolName == "navigate_to" ||
                  toolCall.toolName == "switch_tab" ||
                  toolCall.toolName == "scroll_mouse_wheel") {
                  return false;
                }
              }
            }
            return super.canParallelToolCalls(toolCalls);
          }
          buildInitTools() {
            return [
              {
                name: "navigate_to",
                description: "Navigate to a specific URL in the browser. Use this tool when you need to visit a webpage or change the current page location.",
                parameters: {
                  type: "object",
                  properties: {
                    url: {
                      type: "string",
                      description: "The complete URL to navigate to",
                    },
                  },
                  required: ["url"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.navigate_to(agentContext, args.url));
                },
              },
              {
                name: "current_page",
                description: "Get the currently active webpage information, return tabId, URL and title",
                parameters: {
                  type: "object",
                  properties: {},
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.get_current_page(agentContext));
                },
              },
              {
                name: "go_back",
                description: "Go back to the previous page in browser history",
                parameters: {
                  type: "object",
                  properties: {},
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.go_back(agentContext));
                },
              },
              {
                name: "input_text",
                description: "Inputs text into a element by first clicking to focus the element, then clearing any existing text and typing the new text. Optionally presses Enter after input completion.",
                parameters: {
                  type: "object",
                  properties: {
                    index: {
                      type: "number",
                      description: "The index of the element to input text into",
                    },
                    text: {
                      type: "string",
                      description: "The text to input",
                    },
                    enter: {
                      type: "boolean",
                      description: "When text input is completed, press Enter (applicable to search boxes)",
                      default: false,
                    },
                  },
                  required: ["index", "text"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.input_text(agentContext, args.index, args.text, args.enter));
                },
              },
              {
                name: "click_element",
                description: "Click on an element by index",
                parameters: {
                  type: "object",
                  properties: {
                    index: {
                      type: "number",
                      description: "The index of the element to click",
                    },
                    num_clicks: {
                      type: "number",
                      description: "number of times to click the element, default 1",
                    },
                    button: {
                      type: "string",
                      description: "Mouse button type, default left",
                      enum: ["left", "right", "middle"],
                    },
                  },
                  required: ["index"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.click_element(agentContext, args.index, (args.num_clicks || 1), (args.button || "left")));
                },
              },
              {
                name: "scroll_mouse_wheel",
                description: "Scroll the mouse wheel at current position, only scroll when you need to load more content",
                parameters: {
                  type: "object",
                  properties: {
                    amount: {
                      type: "number",
                      description: "Scroll amount (up / down)",
                      minimum: 1,
                      maximum: 10,
                    },
                    direction: {
                      type: "string",
                      enum: ["up", "down"],
                    },
                    extract_page_content: {
                      type: "boolean",
                      default: false,
                      description: "After scrolling is completed, whether to extract the current latest page content",
                    },
                  },
                  required: ["amount", "direction", "extract_page_content"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(async () => {
                    let amount = args.amount;
                    await this.scroll_mouse_wheel(agentContext, args.direction == "up" ? -amount : amount, args.extract_page_content == true);
                  });
                },
              },
              {
                name: "hover_to_element",
                description: "Hover the mouse over an element, use it when you need to hover to display more interactive information",
                parameters: {
                  type: "object",
                  properties: {
                    index: {
                      type: "number",
                      description: "The index of the element to input text into",
                    },
                  },
                  required: ["index"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.hover_to_element(agentContext, args.index));
                },
              },
              {
                name: "extract_page_content",
                description: "Extracts all content from the current webpage, including text and image links. Please use this tool when you need to retrieve webpage content.",
                parameters: {
                  type: "object",
                  properties: {},
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.extract_page_content(agentContext));
                },
              },
              {
                name: "get_select_options",
                description: "Get all options from a native dropdown element (<select>).",
                parameters: {
                  type: "object",
                  properties: {
                    index: {
                      type: "number",
                      description: "The index of the element to select",
                    },
                  },
                  required: ["index"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.get_select_options(agentContext, args.index));
                },
              },
              {
                name: "select_option",
                description: "Select the native dropdown option, Use this after get_select_options and when you need to select an option from a dropdown.",
                parameters: {
                  type: "object",
                  properties: {
                    index: {
                      type: "number",
                      description: "The index of the element to select",
                    },
                    option: {
                      type: "string",
                      description: "Text option",
                    },
                  },
                  required: ["index", "option"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.select_option(agentContext, args.index, args.option));
                },
              },
              {
                name: "get_all_tabs",
                description: "Get all tabs of the current browser, returns the tabId, URL, and title of all tab pages",
                parameters: {
                  type: "object",
                  properties: {},
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.get_all_tabs(agentContext));
                },
              },
              {
                name: "switch_tab",
                description: "Switch to the specified tab (based on tabId)",
                parameters: {
                  type: "object",
                  properties: {
                    tabId: {
                      type: "number",
                      description: "Tab ID, obtained through get_all_tabs",
                    },
                  },
                  required: ["tabId"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.switch_tab(agentContext, args.tabId));
                },
              },
              {
                name: "wait",
                noPlan: true,
                description: "Wait/pause execution for a specified duration. Use this tool when you need to wait for data loading, page rendering, or introduce delays between operations.",
                parameters: {
                  type: "object",
                  properties: {
                    duration: {
                      type: "number",
                      description: "Wait duration in milliseconds",
                      default: 500,
                      minimum: 200,
                      maximum: 10000,
                    },
                  },
                  required: ["duration"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => sleep((args.duration || 200)));
                },
              },
            ];
          }
          async double_screenshots(agentContext, messages, tools) {
            return config$1.mode == "expert";
          }
          async handleMessages(agentContext, messages, tools) {
            const pseudoHtmlDescription = "This is the environmental information after the operation, including the latest browser screenshot and page elements. Please perform the next operation based on the environmental information. Do not output the following elements and index information in your response.\n\nIndex and elements:\n";
            let lastTool = this.lastToolResult(messages);
            if (lastTool &&
              lastTool.toolName !== "extract_page_content" &&
              lastTool.toolName !== "get_all_tabs" &&
              lastTool.toolName !== "variable_storage") {
              await sleep(300);
              const image_contents = [];
              const result = await this.screenshot_and_html(agentContext);
              if (await this.double_screenshots(agentContext, messages, tools)) {
                const imageResult = result.double_screenshots
                  ? result.double_screenshots
                  : await this.screenshot_and_compress(agentContext, result.client_rect);
                const image = toImage(imageResult.imageBase64);
                image_contents.push({
                  type: "file",
                  data: image,
                  mediaType: imageResult.imageType,
                });
              }
              if (result.imageBase64) {
                const image = toImage(result.imageBase64);
                image_contents.push({
                  type: "file",
                  data: image,
                  mediaType: result.imageType || "image/png",
                });
              }
              messages.push({
                role: "user",
                content: [
                  ...image_contents,
                  {
                    type: "text",
                    text: pseudoHtmlDescription + "```html\n" + result.pseudoHtml + "\n```",
                  },
                ],
              });
            }
            super.handleMessages(agentContext, messages, tools);
            this.handlePseudoHtmlText(messages, pseudoHtmlDescription);
          }
          handlePseudoHtmlText(messages, pseudoHtmlDescription) {
            for (let i = 0; i < messages.length; i++) {
              let message = messages[i];
              if (message.role !== "user" || message.content.length <= 1) {
                continue;
              }
              let content = message.content;
              for (let j = 0; j < content.length; j++) {
                let _content = content[j];
                if (_content.type == "text" &&
                  _content.text.startsWith(pseudoHtmlDescription)) {
                  if (i >= 2 && i < messages.length - 3) {
                    _content.text = this.removePseudoHtmlAttr(_content.text, [
                      "class",
                      "src",
                      "href",
                    ]);
                  }
                }
              }
              if (content[0].text == "[image]" &&
                content[1].text == "[image]") {
                content.splice(0, 1);
              }
            }
          }
          removePseudoHtmlAttr(pseudoHtml, remove_attrs) {
            return pseudoHtml
              .split("\n")
              .map((line) => {
                if (!line.startsWith("[") || line.indexOf("]:<") == -1) {
                  return line;
                }
                line = line.substring(line.indexOf("]:<") + 2);
                for (let i = 0; i < remove_attrs.length; i++) {
                  let sIdx = line.indexOf(remove_attrs[i] + '="');
                  if (sIdx == -1) {
                    continue;
                  }
                  let eIdx = line.indexOf('"', sIdx + remove_attrs[i].length + 3);
                  if (eIdx == -1) {
                    continue;
                  }
                  line = line.substring(0, sIdx) + line.substring(eIdx + 1).trim();
                }
                return line.replace('" >', '">').replace(" >", ">");
              })
              .join("\n");
          }
        }
        function typing(params) {
          let { index, text, enter } = params;
          let element = window.get_highlight_element(index);
          if (!element) {
            return false;
          }
          let input;
          if (element.tagName == "IFRAME") {
            let iframeDoc = element.contentDocument || element.contentWindow.document;
            input =
              iframeDoc.querySelector("textarea") ||
              iframeDoc.querySelector('*[contenteditable="true"]') ||
              iframeDoc.querySelector("input");
          }
          else if (element.tagName == "INPUT" ||
            element.tagName == "TEXTAREA" ||
            element.childElementCount == 0) {
            input = element;
          }
          else {
            input = element.querySelector("input") || element.querySelector("textarea");
            if (!input) {
              input = element.querySelector('*[contenteditable="true"]') || element;
              if (input.tagName == "DIV") {
                input =
                  input.querySelector("span") || input.querySelector("div") || input;
              }
            }
          }
          input.focus && input.focus();
          if (!text && enter) {
            ["keydown", "keypress", "keyup"].forEach((eventType) => {
              const event = new KeyboardEvent(eventType, {
                key: "Enter",
                code: "Enter",
                keyCode: 13,
                bubbles: true,
                cancelable: true,
              });
              input.dispatchEvent(event);
            });
            return true;
          }
          if (input.value == undefined) {
            input.textContent = text;
          }
          else {
            input.value = text;
            if (input.__proto__) {
              let value_setter = Object.getOwnPropertyDescriptor(input.__proto__, "value")?.set;
              value_setter && value_setter.call(input, text);
            }
          }
          input.dispatchEvent(new Event("input", { bubbles: true }));
          if (enter) {
            ["keydown", "keypress", "keyup"].forEach((eventType) => {
              const event = new KeyboardEvent(eventType, {
                key: "Enter",
                code: "Enter",
                keyCode: 13,
                bubbles: true,
                cancelable: true,
              });
              input.dispatchEvent(event);
            });
          }
          return true;
        }
        function do_click(params) {
          let { index, button, num_clicks } = params;
          function simulateMouseEvent(eventTypes, button) {
            let element = window.get_highlight_element(index);
            if (!element) {
              return false;
            }
            for (let n = 0; n < num_clicks; n++) {
              for (let i = 0; i < eventTypes.length; i++) {
                const eventType = eventTypes[i];
                const event = new MouseEvent(eventType, {
                  view: window,
                  bubbles: true,
                  cancelable: true,
                  button, // 0 left; 1 middle; 2 right
                });
                if (eventType === "click" && element.click) {
                  // support shadow dom element
                  element.click();
                }
                else {
                  element.dispatchEvent(event);
                }
                element.focus?.();
              }
            }
            return true;
          }
          if (button == "right") {
            return simulateMouseEvent(["mousedown", "mouseup", "contextmenu"], 2);
          }
          else if (button == "middle") {
            return simulateMouseEvent(["mousedown", "mouseup", "click"], 1);
          }
          else {
            return simulateMouseEvent(["mousedown", "mouseup", "click"], 0);
          }
        }
        function hover_to(params) {
          let element = window.get_highlight_element(params.index);
          if (!element) {
            return false;
          }
          const event = new MouseEvent("mouseenter", {
            bubbles: true,
            cancelable: true,
            view: window,
          });
          element.dispatchEvent(event);
          return true;
        }
        function get_select_options(params) {
          let element = window.get_highlight_element(params.index);
          if (!element || element.tagName.toUpperCase() !== "SELECT") {
            return "Error: Not a select element";
          }
          return {
            options: Array.from(element.options).map((opt) => ({
              index: opt.index,
              text: opt.text.trim(),
              value: opt.value,
            })),
            name: element.name,
          };
        }
        function select_option(params) {
          let element = window.get_highlight_element(params.index);
          if (!element || element.tagName.toUpperCase() !== "SELECT") {
            return "Error: Not a select element";
          }
          let text = params.option.trim();
          let option = Array.from(element.options).find((opt) => opt.text.trim() === text);
          if (!option) {
            option = Array.from(element.options).find((opt) => opt.value.trim() === text);
          }
          if (!option) {
            return {
              success: false,
              error: "Select Option not found",
              availableOptions: Array.from(element.options).map((o) => o.text.trim()),
            };
          }
          element.value = option.value;
          element.dispatchEvent(new Event("change"));
          return {
            success: true,
            selectedValue: option.value,
            selectedText: option.text.trim(),
          };
        }
        function scroll_by(params) {
          const amount = params.amount;
          const documentElement = document.documentElement || document.body;
          if (documentElement.scrollHeight > window.innerHeight * 1.2) {
            const y = Math.max(20, Math.min((window.innerHeight || documentElement.clientHeight) / 10, 200));
            window.scrollBy(0, y * amount);
            return;
          }
          function findNodes(element = document, nodes = []) {
            for (const node of Array.from(element.querySelectorAll("*"))) {
              if (node.tagName === "IFRAME" && node.contentDocument) {
                findNodes(node.contentDocument, nodes);
              }
              else {
                nodes.push(node);
              }
            }
            return nodes;
          }
          function findScrollableElements() {
            const allElements = findNodes();
            let elements = allElements.filter((el) => {
              const style = window.getComputedStyle(el);
              const overflowY = style.getPropertyValue("overflow-y");
              return ((overflowY === "auto" || overflowY === "scroll") &&
                el.scrollHeight > el.clientHeight);
            });
            if (elements.length == 0) {
              elements = allElements.filter((el) => {
                const style = window.getComputedStyle(el);
                const overflowY = style.getPropertyValue("overflow-y");
                return (overflowY === "auto" ||
                  overflowY === "scroll" ||
                  el.scrollHeight > el.clientHeight);
              });
            }
            return elements;
          }
          function getVisibleArea(element) {
            const rect = element.getBoundingClientRect();
            const viewportHeight = window.innerHeight || documentElement.clientHeight;
            const viewportWidth = window.innerWidth || documentElement.clientWidth;
            const visibleLeft = Math.max(0, Math.min(rect.left, viewportWidth));
            const visibleRight = Math.max(0, Math.min(rect.right, viewportWidth));
            const visibleTop = Math.max(0, Math.min(rect.top, viewportHeight));
            const visibleBottom = Math.max(0, Math.min(rect.bottom, viewportHeight));
            const visibleWidth = visibleRight - visibleLeft;
            const visibleHeight = visibleBottom - visibleTop;
            return visibleWidth * visibleHeight;
          }
          function getComputedZIndex(element) {
            while (element &&
              element !== document.body &&
              element !== document.body.parentElement) {
              const style = window.getComputedStyle(element);
              let zIndex = style.zIndex === "auto" ? 0 : parseInt(style.zIndex) || 0;
              if (zIndex > 0) {
                return zIndex;
              }
              element = element.parentElement;
            }
            return 0;
          }
          const scrollableElements = findScrollableElements();
          if (scrollableElements.length === 0) {
            const y = Math.max(20, Math.min((window.innerHeight || documentElement.clientHeight) / 10, 200));
            window.scrollBy(0, y * amount);
            return false;
          }
          const sortedElements = scrollableElements.sort((a, b) => {
            let z = getComputedZIndex(b) - getComputedZIndex(a);
            if (z > 0) {
              return 1;
            }
            else if (z < 0) {
              return -1;
            }
            let v = getVisibleArea(b) - getVisibleArea(a);
            if (v > 0) {
              return 1;
            }
            else if (v < 0) {
              return -1;
            }
            return 0;
          });
          const largestElement = sortedElements[0];
          const viewportHeight = largestElement.clientHeight;
          const y = Math.max(20, Math.min(viewportHeight / 10, 200));
          largestElement.scrollBy(0, y * amount);
          const maxHeightElement = sortedElements.sort((a, b) => b.getBoundingClientRect().height - a.getBoundingClientRect().height)[0];
          if (maxHeightElement != largestElement) {
            const viewportHeight = maxHeightElement.clientHeight;
            const y = Math.max(20, Math.min(viewportHeight / 10, 200));
            maxHeightElement.scrollBy(0, y * amount);
          }
          return true;
        }

        class BaseBrowserScreenAgent extends BaseBrowserAgent {
          constructor(llms, ext_tools, mcpClient) {
            const description = `You are a browser operation agent, use a mouse and keyboard to interact with a browser.
* This is a browser GUI interface, observe the webpage execution through screenshots, and specify action sequences to complete designated tasks.
* For the first visit, please call the \`navigate_to\` or \`current_page\` tool first. After that, each of your actions will return a screenshot of the page.
* BROWSER OPERATIONS:
  - Navigate to URLs and manage history
  - Fill forms and submit data
  - Click elements and interact with pages
  - Extract text and HTML content
  - Wait for elements to load
  - Scroll pages and handle infinite scroll
  - YOU CAN DO ANYTHING ON THE BROWSER - including clicking on elements, filling forms, submitting data, etc.`;
            const _tools_ = [];
            super({
              name: AGENT_NAME,
              description: description,
              tools: _tools_,
              llms: llms,
              mcpClient: mcpClient,
              planDescription: "Browser operation agent, interact with the browser using the mouse and keyboard.",
            });
            let init_tools = this.buildInitTools();
            if (ext_tools && ext_tools.length > 0) {
              init_tools = mergeTools(init_tools, ext_tools);
            }
            init_tools.forEach((tool) => _tools_.push(tool));
          }
          buildInitTools() {
            return [
              {
                name: "navigate_to",
                description: "Navigate to a specific url",
                parameters: {
                  type: "object",
                  properties: {
                    url: {
                      type: "string",
                      description: "The url to navigate to",
                    },
                  },
                  required: ["url"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.navigate_to(agentContext, args.url));
                },
              },
              {
                name: "current_page",
                description: "Get the information of the current webpage (url, title)",
                parameters: {
                  type: "object",
                  properties: {},
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.get_current_page(agentContext));
                },
              },
              {
                name: "go_back",
                description: "Navigate back in browser history",
                parameters: {
                  type: "object",
                  properties: {},
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.go_back(agentContext));
                },
              },
              {
                name: "typing",
                description: "Type specified text",
                parameters: {
                  type: "object",
                  properties: {
                    text: {
                      type: "string",
                      description: "Text to type",
                    },
                  },
                  required: ["text"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.typing(agentContext, args.text));
                },
              },
              {
                name: "click",
                description: "Click at current or specified position",
                parameters: {
                  type: "object",
                  properties: {
                    x: {
                      type: "number",
                      description: "X coordinate",
                    },
                    y: {
                      type: "number",
                      description: "Y coordinate",
                    },
                    num_clicks: {
                      type: "number",
                      description: "Number of clicks",
                      enum: [1, 2, 3],
                      default: 1,
                    },
                    button: {
                      type: "string",
                      description: "Mouse button to click",
                      enum: ["left", "right", "middle"],
                      default: "left",
                    },
                  },
                  required: ["x", "y"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.click(agentContext, args.x, args.y, (args.num_clicks || 1), (args.button || "left")));
                },
              },
              {
                name: "move_to",
                description: "Move cursor to specified position",
                parameters: {
                  type: "object",
                  properties: {
                    x: {
                      type: "number",
                      description: "X coordinate",
                    },
                    y: {
                      type: "number",
                      description: "Y coordinate",
                    },
                  },
                  required: ["x", "y"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.move_to(agentContext, args.x, args.y));
                },
              },
              {
                name: "scroll",
                description: "Scroll the mouse wheel at current position",
                parameters: {
                  type: "object",
                  properties: {
                    amount: {
                      type: "number",
                      description: "Scroll amount (up / down)",
                      minimum: 1,
                      maximum: 10,
                    },
                    direction: {
                      type: "string",
                      enum: ["up", "down"],
                    },
                  },
                  required: ["amount", "direction"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(async () => {
                    let amount = args.amount;
                    await this.scroll(agentContext, args.direction == "up" ? -amount : amount);
                  });
                },
              },
              {
                name: "extract_page_content",
                description: "Extract the text content and image links of the current webpage, please use this tool to obtain webpage data.",
                parameters: {
                  type: "object",
                  properties: {},
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.extract_page_content(agentContext));
                },
              },
              {
                name: "press",
                description: "Press and release a key, supports Enter, Delete, Backspace, Tab, Space",
                parameters: {
                  type: "object",
                  properties: {
                    key: {
                      type: "string",
                      description: "Key to press",
                      enum: ["enter", "tab", "space", "backspace", "delete"],
                    },
                  },
                  required: ["key"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.press(agentContext, args.key));
                },
              },
              {
                name: "drag_and_drop",
                description: "Drag and drop operation",
                parameters: {
                  type: "object",
                  properties: {
                    x1: {
                      type: "number",
                      description: "From X coordinate",
                    },
                    y1: {
                      type: "number",
                      description: "From Y coordinate",
                    },
                    x2: {
                      type: "number",
                      description: "Target X coordinate",
                    },
                    y2: {
                      type: "number",
                      description: "Target Y coordinate",
                    },
                  },
                  required: ["x1", "y1", "x2", "y2"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.drag_and_drop(agentContext, args.x1, args.y1, args.x2, args.y2));
                },
              },
              {
                name: "get_all_tabs",
                description: "Get all tabs of the current browser",
                parameters: {
                  type: "object",
                  properties: {},
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.get_all_tabs(agentContext));
                },
              },
              {
                name: "switch_tab",
                description: "Switch to the specified tab page",
                parameters: {
                  type: "object",
                  properties: {
                    tabId: {
                      type: "number",
                      description: "Tab ID, obtained through get_all_tabs",
                    },
                  },
                  required: ["tabId"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => this.switch_tab(agentContext, args.tabId));
                },
              },
              {
                name: "wait",
                noPlan: true,
                description: "Wait for specified duration",
                parameters: {
                  type: "object",
                  properties: {
                    duration: {
                      type: "number",
                      description: "Duration in millisecond",
                      default: 500,
                      minimum: 200,
                      maximum: 10000,
                    },
                  },
                  required: ["duration"],
                },
                execute: async (args, agentContext) => {
                  return await this.callInnerTool(() => sleep((args.duration || 200)));
                },
              },
            ];
          }
          async handleMessages(agentContext, messages, tools) {
            let lastTool = this.lastToolResult(messages);
            if (lastTool &&
              lastTool.toolName !== "extract_page_content" &&
              lastTool.toolName !== "get_all_tabs" &&
              lastTool.toolName !== "variable_storage") {
              await sleep(300);
              let result = await this.screenshot(agentContext);
              let image = toImage(result.imageBase64);
              messages.push({
                role: "user",
                content: [
                  {
                    type: "file",
                    data: image,
                    mediaType: result.imageType,
                  },
                  {
                    type: "text",
                    text: "This is the latest screenshot",
                  },
                ],
              });
            }
            super.handleMessages(agentContext, messages, tools);
          }
        }

        class EkoMemory {
          constructor(systemPrompt, messages = [], memoryConfig = config$1.memoryConfig) {
            this.messages = messages;
            this.systemPrompt = systemPrompt;
            this.memoryConfig = memoryConfig;
          }
          genMessageId() {
            return uuidv4();
          }
          async import(data) {
            this.messages = [...data.messages];
            if (data.config) {
              await this.updateConfig(data.config);
            }
            else {
              await this.manageCapacity();
            }
          }
          setSystemPrompt(systemPrompt) {
            this.systemPrompt = systemPrompt;
          }
          getSystemPrompt() {
            return this.systemPrompt;
          }
          async addMessages(messages) {
            this.messages.push(...messages);
            await this.manageCapacity();
          }
          getMessages() {
            return this.messages;
          }
          getMessageById(id) {
            return this.messages.find((message) => message.id === id);
          }
          removeMessageById(id, removeToNextUserMessages = true) {
            const removedIds = [];
            for (let i = 0; i < this.messages.length; i++) {
              const message = this.messages[i];
              if (message.id === id) {
                removedIds.push(id);
                if (removeToNextUserMessages) {
                  for (let j = i + 1; j < this.messages.length; j++) {
                    const nextMessage = this.messages[j];
                    if (nextMessage.role == "user") {
                      break;
                    }
                    removedIds.push(nextMessage.id);
                  }
                }
                this.messages.splice(i, removedIds.length);
                break;
              }
            }
            return removedIds.length > 0 ? removedIds : undefined;
          }
          getEstimatedTokens(calcSystemPrompt = true) {
            let tokens = 0;
            if (calcSystemPrompt && this.systemPrompt) {
              tokens += this.calcTokens(this.systemPrompt);
            }
            return this.messages.reduce((total, message) => {
              const content = typeof message.content === "string"
                ? message.content
                : JSON.stringify(message.content.filter((part) => part.type != "file"));
              return total + this.calcTokens(content);
            }, tokens);
          }
          calcTokens(content) {
            // Simple estimation: Each Chinese character is 1 token, other characters are counted as 1 token for every 4.
            const chineseCharCount = (content.match(/[\u4e00-\u9fff]/g) || []).length;
            const otherCharCount = content.length - chineseCharCount;
            return chineseCharCount + Math.ceil(otherCharCount / 4);
          }
          async updateConfig(config) {
            if (config.maxMessageNum !== undefined) {
              this.memoryConfig.maxMessageNum = config.maxMessageNum;
            }
            if (config.maxInputTokens !== undefined) {
              this.memoryConfig.maxInputTokens = config.maxInputTokens;
            }
            if (config.enableCompression !== undefined) {
              this.memoryConfig.enableCompression = config.enableCompression;
            }
            if (config.compressionThreshold !== undefined) {
              this.memoryConfig.compressionThreshold = config.compressionThreshold;
            }
            if (config.compressionMaxLength !== undefined) {
              this.memoryConfig.compressionMaxLength = config.compressionMaxLength;
            }
            await this.manageCapacity();
          }
          async manageCapacity() {
            if (this.messages.length > this.memoryConfig.maxMessageNum) {
              const excess = this.messages.length - this.memoryConfig.maxMessageNum;
              this.messages.splice(0, excess);
            }
            if (this.memoryConfig.enableCompression &&
              this.messages.length > this.memoryConfig.compressionThreshold) {
              // compress messages
              for (let i = 0; i < this.messages.length; i++) {
                const message = this.messages[i];
                if (message.role == "assistant") {
                  message.content = message.content.map((part) => {
                    if (part.type == "text" &&
                      part.text.length > this.memoryConfig.compressionMaxLength) {
                      return {
                        type: "text",
                        text: sub(part.text, this.memoryConfig.compressionMaxLength, true),
                      };
                    }
                    return part;
                  });
                }
                if (message.role == "tool") {
                  message.content = message.content.map((part) => {
                    if (typeof part.result === "string" &&
                      part.result.length > this.memoryConfig.compressionMaxLength) {
                      return {
                        ...part,
                        result: sub(part.result, this.memoryConfig.compressionMaxLength, true),
                      };
                    }
                    return part;
                  });
                }
              }
            }
            while (this.getEstimatedTokens(true) > this.memoryConfig.maxInputTokens &&
              this.messages.length > 0) {
              this.messages.shift();
            }
            this.fixDiscontinuousMessages();
          }
          fixDiscontinuousMessages() {
            if (this.messages.length > 0 && this.messages[0].role != "user") {
              for (let i = 0; i < this.messages.length; i++) {
                const message = this.messages[i];
                if (message.role == "user") {
                  this.messages.splice(0, i);
                  break;
                }
              }
            }
            const removeIds = [];
            let lastMessage = null;
            for (let i = 0; i < this.messages.length; i++) {
              const message = this.messages[i];
              if (message.role == "user" &&
                lastMessage &&
                lastMessage.role == "user"
                // && message.content == lastMessage.content
              ) {
                // remove duplicate user messages
                removeIds.push(lastMessage.id);
                continue;
              }
              if (lastMessage &&
                lastMessage.role == "assistant" &&
                lastMessage.content.filter((part) => part.type == "tool-call").length >
                0 &&
                message.role != "tool") {
                // add tool result message
                this.messages.push({
                  role: "tool",
                  id: this.genMessageId(),
                  timestamp: message.timestamp + 1,
                  content: lastMessage.content
                    .filter((part) => part.type == "tool-call")
                    .map((part) => {
                      return {
                        type: "tool-result",
                        toolCallId: part.toolCallId,
                        toolName: part.toolName,
                        result: "Error: No result",
                      };
                    }),
                });
              }
              lastMessage = message;
            }
            if (removeIds.length > 0) {
              removeIds.forEach((id) => this.removeMessageById(id));
            }
          }
          getFirstUserMessage() {
            return this.messages.filter((message) => message.role === "user")[0];
          }
          getLastUserMessage() {
            const userMessages = this.messages.filter((message) => message.role === "user");
            return userMessages[userMessages.length - 1];
          }
          hasMessage(id) {
            return this.messages.some((message) => message.id === id);
          }
          clear() {
            this.messages = [];
          }
          buildMessages() {
            const llmMessages = [];
            for (let i = 0; i < this.messages.length; i++) {
              const message = this.messages[i];
              if (message.role == "user") {
                llmMessages.push({
                  role: message.role,
                  content: typeof message.content === "string"
                    ? [
                      {
                        type: "text",
                        text: message.content,
                      },
                    ]
                    : message.content.map((part) => {
                      if (part.type == "text") {
                        return {
                          type: "text",
                          text: part.text,
                        };
                      }
                      else {
                        return {
                          type: "file",
                          data: toFile(part.data),
                          mediaType: part.mimeType || getMimeType(part.data),
                        };
                      }
                    }),
                  providerOptions: defaultMessageProviderOptions(),
                });
              }
              else if (message.role == "assistant") {
                llmMessages.push({
                  role: message.role,
                  content: message.content.map((part) => {
                    if (part.type == "text") {
                      return {
                        type: "text",
                        text: part.text,
                      };
                    }
                    else if (part.type == "reasoning") {
                      return {
                        type: "reasoning",
                        text: part.text,
                      };
                    }
                    else if (part.type == "tool-call") {
                      return {
                        type: "tool-call",
                        toolCallId: part.toolCallId,
                        toolName: part.toolName,
                        input: part.args,
                      };
                    }
                    else {
                      return part;
                    }
                  }),
                });
              }
              else if (message.role == "tool") {
                llmMessages.push({
                  role: message.role,
                  content: message.content.map((part) => {
                    return {
                      type: "tool-result",
                      toolCallId: part.toolCallId,
                      toolName: part.toolName,
                      output: typeof part.result == "string"
                        ? {
                          type: "text",
                          value: part.result,
                        }
                        : {
                          type: "json",
                          value: part.result,
                        },
                    };
                  }),
                });
              }
            }
            return [
              {
                role: "system",
                content: this.getSystemPrompt() || "You are a helpful assistant.",
                providerOptions: defaultMessageProviderOptions(),
              },
              ...llmMessages,
            ];
          }
        }

        async function callChatLLM(messageId, chatContext, rlm, messages, tools, toolChoice, retryNum = 0, callback, signal) {
          const streamCallback = callback?.chatCallback || {
            onMessage: async () => { },
          };
          const request = {
            tools: tools,
            toolChoice,
            messages: messages,
            abortSignal: signal,
          };
          let streamText = "";
          let thinkText = "";
          let toolArgsText = "";
          let textStreamId = uuidv4();
          let thinkStreamId = uuidv4();
          let textStreamDone = false;
          const toolParts = [];
          let reader = null;
          try {
            const result = await rlm.callStream(request);
            reader = result.stream.getReader();
            let toolPart = null;
            while (true) {
              const { done, value } = await reader.read();
              if (done) {
                break;
              }
              const chunk = value;
              switch (chunk.type) {
                case "text-start": {
                  textStreamId = uuidv4();
                  break;
                }
                case "text-delta": {
                  if (toolPart && !chunk.delta) {
                    continue;
                  }
                  streamText += chunk.delta || "";
                  await streamCallback.onMessage({
                    streamType: "chat",
                    chatId: chatContext.getChatId(),
                    messageId,
                    type: "text",
                    streamId: textStreamId,
                    streamDone: false,
                    text: streamText,
                  });
                  if (toolPart) {
                    await streamCallback.onMessage({
                      streamType: "chat",
                      chatId: chatContext.getChatId(),
                      messageId,
                      type: "tool_use",
                      toolCallId: toolPart.toolCallId,
                      toolName: toolPart.toolName,
                      params: toolPart.input || {},
                    });
                    toolPart = null;
                  }
                  break;
                }
                case "text-end": {
                  textStreamDone = true;
                  if (streamText) {
                    await streamCallback.onMessage({
                      streamType: "chat",
                      chatId: chatContext.getChatId(),
                      messageId,
                      type: "text",
                      streamId: textStreamId,
                      streamDone: true,
                      text: streamText,
                    });
                  }
                  break;
                }
                case "reasoning-start": {
                  thinkStreamId = uuidv4();
                  break;
                }
                case "reasoning-delta": {
                  thinkText += chunk.delta || "";
                  await streamCallback.onMessage({
                    streamType: "chat",
                    chatId: chatContext.getChatId(),
                    messageId,
                    type: "thinking",
                    streamId: thinkStreamId,
                    streamDone: false,
                    text: thinkText,
                  });
                  break;
                }
                case "reasoning-end": {
                  if (thinkText) {
                    await streamCallback.onMessage({
                      streamType: "chat",
                      chatId: chatContext.getChatId(),
                      messageId,
                      type: "thinking",
                      streamId: thinkStreamId,
                      streamDone: true,
                      text: thinkText,
                    });
                  }
                  break;
                }
                case "tool-input-start": {
                  if (toolPart && toolPart.toolCallId == chunk.id) {
                    toolPart.toolName = chunk.toolName;
                  }
                  else {
                    toolPart = {
                      type: "tool-call",
                      toolCallId: chunk.id,
                      toolName: chunk.toolName,
                      input: {},
                    };
                    toolParts.push(toolPart);
                  }
                  break;
                }
                case "tool-input-delta": {
                  if (!textStreamDone) {
                    textStreamDone = true;
                    await streamCallback.onMessage({
                      streamType: "chat",
                      chatId: chatContext.getChatId(),
                      messageId,
                      type: "text",
                      streamId: textStreamId,
                      streamDone: true,
                      text: streamText,
                    });
                  }
                  toolArgsText += chunk.delta || "";
                  await streamCallback.onMessage({
                    streamType: "chat",
                    chatId: chatContext.getChatId(),
                    messageId,
                    type: "tool_streaming",
                    toolCallId: chunk.id,
                    toolName: toolPart?.toolName || "",
                    paramsText: toolArgsText,
                  });
                  break;
                }
                case "tool-call": {
                  toolArgsText = "";
                  const args = chunk.input ? JSON.parse(chunk.input) : {};
                  const message = {
                    streamType: "chat",
                    chatId: chatContext.getChatId(),
                    messageId,
                    type: "tool_use",
                    toolCallId: chunk.toolCallId,
                    toolName: chunk.toolName,
                    params: args,
                  };
                  await streamCallback.onMessage(message);
                  if (toolPart == null) {
                    toolParts.push({
                      type: "tool-call",
                      toolCallId: chunk.toolCallId,
                      toolName: chunk.toolName,
                      input: message.params || args,
                    });
                  }
                  else {
                    toolPart.input = message.params || args;
                    toolPart = null;
                  }
                  break;
                }
                case "error": {
                  Log.error(`chatLLM error: `, chunk);
                  await streamCallback.onMessage({
                    streamType: "chat",
                    chatId: chatContext.getChatId(),
                    messageId,
                    type: "error",
                    error: chunk.error,
                  });
                  throw new Error("LLM Error: " + chunk.error);
                }
                case "finish": {
                  if (!textStreamDone) {
                    textStreamDone = true;
                    await streamCallback.onMessage({
                      streamType: "chat",
                      chatId: chatContext.getChatId(),
                      messageId,
                      type: "text",
                      streamId: textStreamId,
                      streamDone: true,
                      text: streamText,
                    });
                  }
                  if (toolPart) {
                    await streamCallback.onMessage({
                      streamType: "chat",
                      chatId: chatContext.getChatId(),
                      messageId,
                      type: "tool_use",
                      toolCallId: toolPart.toolCallId,
                      toolName: toolPart.toolName,
                      params: toolPart.input || {},
                    });
                    toolPart = null;
                  }
                  await streamCallback.onMessage({
                    streamType: "chat",
                    chatId: chatContext.getChatId(),
                    messageId,
                    type: "finish",
                    finishReason: chunk.finishReason,
                    usage: {
                      promptTokens: chunk.usage.inputTokens || 0,
                      completionTokens: chunk.usage.outputTokens || 0,
                      totalTokens: chunk.usage.totalTokens ||
                        (chunk.usage.inputTokens || 0) +
                        (chunk.usage.outputTokens || 0),
                    },
                  });
                  break;
                }
              }
            }
          }
          catch (e) {
            if (retryNum < config$1.maxRetryNum) {
              await sleep(200 * (retryNum + 1) * (retryNum + 1));
              return callChatLLM(messageId, chatContext, rlm, messages, tools, toolChoice, ++retryNum, callback, signal);
            }
            throw e;
          }
          finally {
            reader && reader.releaseLock();
          }
          return streamText
            ? [
              { type: "text", text: streamText },
              ...toolParts,
            ]
            : toolParts;
        }
        function convertAssistantToolResults(results) {
          return results.map((part) => {
            if (part.type == "text") {
              return {
                type: "text",
                text: part.text,
              };
            }
            else if (part.type == "tool-call") {
              return {
                type: "tool-call",
                toolCallId: part.toolCallId,
                toolName: part.toolName,
                args: (part.input || {}),
              };
            }
            return part;
          });
        }
        function convertToolResults(toolResults) {
          return toolResults.map((part) => {
            const output = part.output;
            return {
              type: "tool-result",
              toolCallId: part.toolCallId,
              toolName: part.toolName,
              result: output.type == "text" || output.type == "error-text"
                ? output.value
                : output.type == "json" || output.type == "error-json"
                  ? output.value
                  : output.value
                    .map((s) => {
                      if (s.type == "text") {
                        return s.text;
                      }
                      else if (s.type == "media") {
                        return JSON.stringify({
                          data: s.data,
                          mimeType: s.mediaType,
                        });
                      }
                    })
                    .join("\n"),
            };
          });
        }

        class ChatContext {
          constructor(chatId, config) {
            this.chatId = chatId;
            this.config = config;
            this.ekoMap = new Map();
            this.globalVariables = new Map();
          }
          getChatId() {
            return this.chatId;
          }
          getConfig() {
            return this.config;
          }
          addEko(taskId, eko) {
            this.ekoMap.set(taskId, eko);
          }
          getEko(taskId) {
            return this.ekoMap.get(taskId);
          }
          getGlobalVariables() {
            return this.globalVariables;
          }
        }

        const TOOL_NAME$3 = "webpageQa";
        const WEBPAGE_QA_PROMPT = `
You are a helpful assistant that can answer questions based on the provided webpage context.

# Webpage Context
<webpage_contexts>
{{contexts}}
</webpage_contexts>

# User Question
<user_question>
{{userPrompt}}
</user_question>
<if language>
<language>{{language}}</language>
</if>

Answer user's question based on the webpage context, the answer should be in the same language as the user's question.
`;
        class WebpageQaTool {
          constructor(chatContext, params) {
            this.name = TOOL_NAME$3;
            this.params = params;
            this.chatContext = chatContext;
            this.description = `This tool is designed only for handling simple web-related tasks, including summarizing webpage content, extracting data from web pages, translating webpage content, and converting webpage information into more easily understandable forms. It does not interact with or operate web pages. For more complex browser tasks, please use deepAction.It does not perform operations on the webpage itself, but only involves reading the page content. Users do not need to provide the web page content, as the tool can automatically extract the content of the web page based on the tabId to respond.`;
            this.parameters = {
              type: "object",
              properties: {
                language: {
                  type: "string",
                  description: "User language used, eg: English",
                },
                tabIds: {
                  type: "array",
                  description: "The browser tab ids to be used for the QA. When the user says 'left side' or 'current', it means current active tab.",
                  items: { type: "integer" },
                },
              },
              required: ["tabIds", "language"],
            };
          }
          async execute(args, toolCall, messageId) {
            if (!global.browserService) {
              return {
                content: [
                  {
                    type: "text",
                    text: "Error: not implemented",
                  },
                ],
              };
            }
            const tabIds = args.tabIds;
            const language = args.language;
            const tabs = await global.browserService.extractPageContents(this.chatContext.getChatId(), tabIds);
            const chatConfig = this.chatContext.getConfig();
            const rlm = new RetryLanguageModel(chatConfig.llms, chatConfig.chatLlms);
            const prompt = PromptTemplate.render(global.prompts.get(GlobalPromptKey.webpage_qa_prompt) ||
              WEBPAGE_QA_PROMPT, {
              language: language,
              userPrompt: this.params.user
                .map((part) => (part.type == "text" ? part.text : ""))
                .join("\n")
                .trim(),
              contexts: this.buildTabContents(tabs),
            }).trim();
            const result = await rlm.callStream({
              temperature: 0.7,
              maxOutputTokens: config$1.maxOutputTokens,
              messages: [{ role: "user", content: [{ type: "text", text: prompt }] }],
            });
            const stream = result.stream;
            const reader = stream.getReader();
            const streamId = uuidv4();
            const callback = this.params.callback.chatCallback;
            let text = "";
            try {
              while (true) {
                const { done, value } = await reader.read();
                if (done) {
                  break;
                }
                const chunk = value;
                if (chunk.type == "text-delta") {
                  text += chunk.delta;
                  await callback.onMessage({
                    streamType: "chat",
                    chatId: this.chatContext.getChatId(),
                    messageId: messageId,
                    type: "tool_running",
                    toolName: this.name,
                    toolCallId: toolCall.toolCallId,
                    text: text,
                    streamId: streamId,
                    streamDone: false,
                  });
                }
                else if (chunk.type == "error") {
                  throw new Error(chunk.error);
                }
                else if (chunk.type == "finish") {
                  break;
                }
              }
            }
            finally {
              reader.releaseLock();
              await callback.onMessage({
                streamType: "chat",
                chatId: this.chatContext.getChatId(),
                messageId: messageId,
                type: "tool_running",
                toolName: this.name,
                toolCallId: toolCall.toolCallId,
                text: text,
                streamId: streamId,
                streamDone: true,
              });
            }
            return {
              content: [
                {
                  type: "text",
                  text: text,
                },
              ],
            };
          }
          buildTabContents(tabs) {
            return tabs
              .map((tab) => {
                return `<webpage>\nTabId: ${tab.tabId}\nTitle: ${tab.title}\nURL: ${tab.url}\nContent: ${sub(tab.content, 8000)}\n</webpage>`;
              })
              .join("\n");
          }
        }

        const TOOL_NAME$2 = "webSearch";
        class WebSearchTool {
          constructor(chatContext, params) {
            this.name = TOOL_NAME$2;
            this.params = params;
            this.chatContext = chatContext;
            this.description = `Search the web for information using search engine API. This tool can perform web searches to find current information, news, articles, and other web content related to the query. It returns search results with titles, descriptions, URLs, and other relevant metadata, use this tool when users need the latest data/information and have NOT specified a particular platform or website, use the search tool.`;
            this.parameters = {
              type: "object",
              properties: {
                query: {
                  type: "string",
                  description: "The search query to execute. Use specific keywords and phrases for better results.",
                },
                language: {
                  type: "string",
                  description: "Language code for search results (e.g., 'en', 'zh', 'ja'). If not specified, will be auto-detected from query.",
                },
                count: {
                  type: "integer",
                  description: "Number of search results to return (default: 10, max: 50)",
                  default: 10,
                  minimum: 1,
                  maximum: 50,
                },
              },
              required: ["query", "keywords"],
            };
          }
          async execute(args) {
            if (!global.chatService) {
              return {
                content: [
                  {
                    type: "text",
                    text: "Error: not implemented",
                  },
                ],
              };
            }
            const query = args.query;
            const language = args.language;
            const count = args.count || 10;
            const results = await global.chatService.websearch(this.chatContext.getChatId(), query, undefined, language, count);
            return Promise.resolve({
              content: [
                {
                  type: "text",
                  text: JSON.stringify(results.map((result) => {
                    return {
                      title: result.title,
                      url: result.url,
                      content: sub(result.content || result.snippet || "", 6000),
                    };
                  })),
                },
              ],
            });
          }
        }

        async function recursiveTextNode(node, callback) {
          if (node.type === "normal") {
            callback(node, node);
          }
          if (node.type === "forEach") {
            node.nodes.map((item) => recursiveTextNode(item, callback));
          }
          if (node.type === "watch") {
            node.triggerNodes.map((triggerNode) => recursiveTextNode(triggerNode, callback));
          }
        }

        const TOOL_NAME$1 = "deepAction";
        const deep_action_description = "Delegate tasks to a Javis AI assistant for completion. This assistant can understand natural language instructions and has full control over both networked computers, browser agent, and multiple specialized agents ({agentNames}). The assistant can autonomously decide to use various software tools, browse the internet to query information, write code, and perform direct operations to complete tasks. He can deliver various digitized outputs (text reports, tables, images, music, videos, websites, deepSearch, programs, etc.) and handle design/analysis tasks. and execute operational tasks (such as batch following bloggers of specific topics on certain websites). For operational tasks, the focus is on completing the process actions rather than delivering final outputs, and the assistant can complete these types of tasks well. It should also be noted that users may actively mention deepsearch, which is also one of the capabilities of this tool. If users mention it, please explicitly tell the assistant to use deepsearch. Supports parallel execution of multiple tasks.";
        const deep_action_param_task_description = "Task description, please output the user's original instructions without omitting any information from the user's instructions, and use the same language as the user's question.";
        class DeepActionTool {
          constructor(chatContext, params) {
            this.name = TOOL_NAME$1;
            this.chatContext = chatContext;
            const agents = this.chatContext.getConfig().agents || [];
            const agentNames = agents.map((agent) => agent.Name).join(", ");
            const description = global.prompts.get(GlobalPromptKey.deep_action_description) ||
              deep_action_description;
            const paramTaskDescription = global.prompts.get(GlobalPromptKey.deep_action_param_task_description) ||
              deep_action_param_task_description;
            this.description = description.replace("{agentNames}", agentNames).trim();
            this.parameters = {
              type: "object",
              properties: {
                language: {
                  type: "string",
                  description: "User language used, eg: English",
                },
                taskDescription: {
                  type: "string",
                  description: paramTaskDescription.trim(),
                },
                tabIds: {
                  type: "array",
                  description: "Browser Tab IDs associated with this task, When user says 'left side' or 'current', it means current active tab",
                  items: { type: "integer" },
                },
                dependentVariables: {
                  type: "array",
                  description: "The current task relies on variable data from prerequisite execution outputs. Provide the name of the dependent variable.",
                  items: {
                    type: "string",
                  },
                },
              },
              required: ["language", "taskDescription"],
            };
            this.params = params;
          }
          async execute(args, toolCall, messageId) {
            const chatId = this.chatContext.getChatId();
            const language = args.language;
            const taskDescription = args.taskDescription;
            const tabIds = args.tabIds;
            const dependentVariables = args.dependentVariables;
            const config = this.chatContext.getConfig();
            const globalVariables = this.chatContext.getGlobalVariables();
            const eko = new Eko({
              ...config,
              callback: this.params.callback?.taskCallback,
            }, chatId);
            this.chatContext.addEko(messageId, eko);
            if (this.params.signal) {
              if (this.params.signal.aborted) {
                const error = new Error("Operation was interrupted");
                error.name = "AbortError";
                throw error;
              }
              this.params.signal.addEventListener("abort", () => {
                eko.abortTask(messageId, "User aborted");
              });
            }
            const attachments = this.params.user
              .filter((part) => part.type === "file")
              .filter((part) => part.data && part.data.length < 500)
              .map((part) => {
                return {
                  file_name: part.filename,
                  file_path: part.filePath,
                  file_url: part.data,
                };
              });
            const taskWebsite = await this.gettaskWebsite(tabIds);
            const workflow = await eko.generate(taskDescription, messageId, {
              ...globalVariables,
              tabIds: tabIds,
              language: language,
              attachments: attachments,
              taskWebsite: taskWebsite,
              dependentVariables: dependentVariables,
              datetime: this.params.datetime || new Date().toLocaleString(),
            });
            const context = eko.getTask(messageId);
            console.log("==> workflow", workflow);
            const result = await eko.execute(messageId);
            const variableNames = [];
            if (context.variables && context.variables.size > 0) {
              workflow.agents
                .map((agent) => agent.nodes)
                .flat()
                .forEach((node) => {
                  recursiveTextNode(node, async (textNode) => {
                    if (textNode.output) {
                      variableNames.push(textNode.output);
                      globalVariables.set(textNode.output, context.variables.get(textNode.output));
                    }
                  });
                });
            }
            return {
              content: [
                {
                  type: "text",
                  text: JSON.stringify({
                    taskPlan: workflow.xml,
                    subAgents: context.chain.agents.map((agent) => {
                      return {
                        agent: agent.agent.name,
                        subTask: agent.agent.task,
                        agentResult: sub(agent.agentResult || "", 800, true),
                      };
                    }),
                    variables: variableNames,
                    taskResult: result.result,
                    success: result.success,
                  }),
                },
              ],
            };
          }
          async gettaskWebsite(tabIds) {
            if (!global.browserService) {
              return [];
            }
            const tabs = await global.browserService.loadTabs(this.chatContext.getChatId(), tabIds);
            return tabs.map((tab) => {
              return {
                tabId: tab.tabId,
                title: tab.title,
                url: sub(tab.url, 300),
              };
            });
          }
        }

        const TOOL_NAME = "taskVariableStorage";
        class TaskVariableStorageTool {
          constructor(chatContext, params) {
            this.name = TOOL_NAME;
            this.params = params;
            this.chatContext = chatContext;
            this.description = `Used for storing, reading, and retrieving variable data, and maintaining input/output variables in task nodes.`;
            this.parameters = {
              type: "object",
              properties: {
                operation: {
                  type: "string",
                  description: "variable storage operation type.",
                  enum: ["read_variable", "write_variable", "list_all_variable"],
                },
                name: {
                  type: "string",
                  description: "variable name, required when reading and writing variables, If reading variables, it supports reading multiple variables separated by commas.",
                },
                value: {
                  type: "string",
                  description: "variable value, required when writing variables",
                },
              },
              required: ["operation"],
            };
          }
          async execute(args) {
            let operation = args.operation;
            let resultText = "";
            switch (operation) {
              case "read_variable": {
                if (!args.name) {
                  resultText = "Error: name is required";
                }
                else {
                  let result = {};
                  let name = args.name;
                  let keys = name.split(",");
                  for (let i = 0; i < keys.length; i++) {
                    let key = keys[i].trim();
                    let value = this.chatContext.getGlobalVariables().get(key);
                    result[key] = value;
                  }
                  resultText = JSON.stringify(result);
                }
                break;
              }
              case "write_variable": {
                if (!args.name) {
                  resultText = "Error: name is required";
                  break;
                }
                if (args.value == undefined) {
                  resultText = "Error: value is required";
                  break;
                }
                let key = args.name;
                this.chatContext.getGlobalVariables().set(key.trim(), args.value);
                resultText = "success";
                break;
              }
              case "list_all_variable": {
                resultText = JSON.stringify([
                  ...this.chatContext.getGlobalVariables().keys(),
                ]);
                break;
              }
            }
            return {
              content: [
                {
                  type: "text",
                  text: resultText || "",
                },
              ],
            };
          }
        }

        const CHAT_SYSTEM_TEMPLATE = `
You are {{name}}, it is an action-oriented assistant in the browser, a general-purpose intelligent agent running in the browser environment.

<tool_instructions>
General Principles:
- Only one tool can be called at a time.
- Users may not be able to clearly describe their needs in a single conversation. When needs are ambiguous or lack details, assistant can appropriately initiate follow-up questions before making tool calls. Follow-up rounds should not exceed two rounds.
- Users may switch topics multiple times during ongoing conversations. When calling tools, assistant must focus ONLY on the current user question and ignore previous conversation topics unless they are directly related to the current request. Each question should be treated as independent unless explicitly building on previous context.

For non-chat related tasks issued by users, the following tools need to be called to complete them:
<if ${TOOL_NAME$1}Tool>
- ${TOOL_NAME$1}: This tool is used to execute tasks, delegate to Javis AI assistant with full computer control.
</if>
<if ${TOOL_NAME$3}Tool>
- ${TOOL_NAME$3}: When a user's query involves finding content in a webpage within a browser tab, extracting webpage content, summarizing webpage content, translating webpage content, read PDF page content, or converting webpage content into a more understandable format, this tool should be used. If the task requires performing actions based on webpage content, deepAction should be used. only needs to provide the required invocation parameters according to the tool's needs; users do not need to manually provide the content of the browser tab.
</if>
<if ${TOOL_NAME$2}Tool>
- ${TOOL_NAME$2}: Search the web for information using search engine API. This tool can perform web searches to find current information, news, articles, and other web content related to the query. It returns search results with titles, descriptions, URLs, and other relevant metadata. Use this tool when you need to find current information from the internet that may not be available in your training data.
</if>
<if ${TOOL_NAME}Tool>
- ${TOOL_NAME}: This tool is used to read output variables from task nodes and write input variables to task nodes, mainly used to retrieve variable results after task execution is completed.
</if>
</tool_instructions>

<if memory>
The assistant always focuses on the user's current question and will not allow previous conversation turns or irrelevant memory content to interfere with the response to the user's current question. Each question should be handled independently unless it explicitly builds upon prior context.
Before responding to user questions, the assistant intelligently analyzes the relevance of memories. When responding, the assistant first determines whether the user's current question is related to information in the retrieved memories, and only incorporates memory data when there is clear contextual relevance. If the user's question is unrelated to the retrieved memories, the assistant will directly respond to the current question without referencing memory content, ensuring the conversation flows naturally.
Avoid forcing the use of memories when they are irrelevant to the current context, prioritizing the accuracy and relevance of responses over the inclusion of memories.
<retrieved_memories>
{{memory}}
</retrieved_memories>
</if>

<if tabs>
The information about the browser tabs currently open by the user is as follows:
<browser_tabs>
{{tabs}}
</browser_tabs>
</if>

Current datetime: {{datetime}}
The output language should match the user's conversation language.
`;
        function getChatSystemPrompt(tools, datetime, memory, tabs) {
          const systemPrompt = global.prompts.get(GlobalPromptKey.chat_system) || CHAT_SYSTEM_TEMPLATE;
          const toolVars = {};
          for (let i = 0; i < tools.length; i++) {
            toolVars[tools[i].name + "Tool"] = true;
          }
          return PromptTemplate.render(systemPrompt, {
            name: config$1.name,
            datetime: datetime,
            memory: memory || "",
            tabs: getTabsInfo(tabs),
            ...toolVars,
          }).trim();
        }
        function getTabsInfo(tabs) {
          if (!tabs || tabs.length == 0) {
            return "Empty";
          }
          return JSON.stringify(tabs.slice(0, 10).map((tab) => {
            return {
              tabId: tab.tabId,
              title: sub(tab.title, 50),
              url: sub(tab.url, 300),
              active: tab.active,
              lastAccessed: tab.lastAccessed,
            };
          }), null, 2);
        }

        class ChatAgent {
          constructor(config, chatId = uuidv4(), memory, tools) {
            this.tools = tools ?? [];
            this.memory = memory ?? new EkoMemory();
            this.chatContext = new ChatContext(chatId, config);
            global.chatMap.set(chatId, this.chatContext);
          }
          async chat(params) {
            return this.doChat(params, false);
          }
          async doChat(params, segmentedExecution) {
            const runStartTime = Date.now();
            let reactLoopNum = 0;
            let errorInfo = null;
            try {
              if (params.callback?.chatCallback) {
                await params.callback.chatCallback.onMessage({
                  streamType: "chat",
                  chatId: this.chatContext.getChatId(),
                  messageId: params.messageId,
                  type: "chat_start",
                });
              }
              const chatTools = mergeTools(this.buildInnerTools(params), this.tools);
              await this.buildSystemPrompt(params, chatTools);
              await this.addUserMessage(params.messageId, params.user);
              const config = this.chatContext.getConfig();
              const rlm = new RetryLanguageModel(config.llms, config.chatLlms);
              for (; reactLoopNum < 15; reactLoopNum++) {
                const messages = this.memory.buildMessages();
                const results = await callChatLLM(params.messageId, this.chatContext, rlm, messages, convertTools(chatTools), undefined, 0, params.callback, params.signal);
                const finalResult = await this.handleCallResult(params.messageId, chatTools, results, params.callback);
                if (finalResult) {
                  return finalResult;
                }
                if (params.signal?.aborted) {
                  const error = new Error("Operation was interrupted");
                  error.name = "AbortError";
                  throw error;
                }
              }
              reactLoopNum--;
              return "Unfinished";
            }
            catch (e) {
              Log.error("chat error: ", e);
              if (e instanceof Error) {
                errorInfo = e.name + ": " + e.message;
              }
              else {
                errorInfo = String(e);
              }
              return errorInfo;
            }
            finally {
              if (params.callback?.chatCallback) {
                await params.callback.chatCallback.onMessage({
                  streamType: "chat",
                  chatId: this.chatContext.getChatId(),
                  messageId: params.messageId,
                  type: "chat_end",
                  error: errorInfo,
                  duration: Date.now() - runStartTime,
                  reactLoopNum: reactLoopNum + 1,
                });
              }
            }
          }
          async initMessages() {
            if (!global.chatService) {
              return;
            }
            const messages = this.memory.getMessages();
            if (messages.length == 0) {
              const messages = await global.chatService.loadMessages(this.chatContext.getChatId());
              if (messages && messages.length > 0) {
                await this.memory.addMessages(messages);
              }
            }
          }
          async buildSystemPrompt(params, chatTools) {
            let _memory = undefined;
            if (global.chatService) {
              try {
                const userPrompt = params.user
                  .map((part) => (part.type == "text" ? part.text : ""))
                  .join("\n")
                  .trim();
                if (userPrompt) {
                  _memory = await global.chatService.memoryRecall(this.chatContext.getChatId(), userPrompt);
                }
              }
              catch (e) {
                Log.error("chat service memory recall error: ", e);
              }
            }
            let _tabs = undefined;
            if (global.browserService) {
              try {
                _tabs = await global.browserService.loadTabs(this.chatContext.getChatId());
              }
              catch (e) {
                Log.error("browser service load tabs error: ", e);
              }
            }
            const datetime = params.datetime || new Date().toLocaleString();
            const systemPrompt = getChatSystemPrompt(chatTools, datetime, _memory, _tabs);
            this.memory.setSystemPrompt(systemPrompt);
          }
          async addUserMessage(messageId, user) {
            const message = {
              id: messageId,
              role: "user",
              timestamp: Date.now(),
              content: user,
            };
            await this.addMessages([message]);
            return message;
          }
          async addMessages(messages, storage = true) {
            await this.memory.addMessages(messages);
            if (storage && global.chatService) {
              await global.chatService.addMessage(this.chatContext.getChatId(), messages);
            }
          }
          buildInnerTools(params) {
            const tools = [];
            tools.push(new DeepActionTool(this.chatContext, params));
            if (global.browserService) {
              tools.push(new WebpageQaTool(this.chatContext, params));
            }
            tools.push(new WebSearchTool(this.chatContext, params));
            tools.push(new TaskVariableStorageTool(this.chatContext, params));
            return tools;
          }
          getChatContext() {
            return this.chatContext;
          }
          async handleCallResult(messageId, chatTools, results, chatStreamCallback) {
            let text = null;
            const toolResults = [];
            if (results.length == 0) {
              return null;
            }
            for (let i = 0; i < results.length; i++) {
              const result = results[i];
              if (result.type == "text") {
                text = result.text;
                continue;
              }
              let toolResult;
              try {
                const args = typeof result.input == "string"
                  ? JSON.parse(result.input || "{}")
                  : result.input || {};
                const tool = getTool(chatTools, result.toolName);
                if (!tool) {
                  throw new Error(result.toolName + " tool does not exist");
                }
                toolResult = await tool.execute(args, result, messageId);
              }
              catch (e) {
                Log.error("tool call error: ", result.toolName, result.input, e);
                toolResult = {
                  content: [
                    {
                      type: "text",
                      text: e + "",
                    },
                  ],
                  isError: true,
                };
              }
              const callback = chatStreamCallback?.chatCallback;
              if (callback) {
                await callback.onMessage({
                  streamType: "chat",
                  chatId: this.chatContext.getChatId(),
                  messageId: messageId,
                  type: "tool_result",
                  toolCallId: result.toolCallId,
                  toolName: result.toolName,
                  params: result.input || {},
                  toolResult: toolResult,
                });
              }
              const llmToolResult = convertToolResult(result, toolResult);
              toolResults.push(llmToolResult);
            }
            await this.addMessages([
              {
                id: this.memory.genMessageId(),
                role: "assistant",
                timestamp: Date.now(),
                content: convertAssistantToolResults(results),
              },
            ]);
            if (toolResults.length > 0) {
              await this.addMessages([
                {
                  id: this.memory.genMessageId(),
                  role: "tool",
                  timestamp: Date.now(),
                  content: convertToolResults(toolResults),
                },
              ]);
              return null;
            }
            else {
              return text;
            }
          }
        }

        class SimpleSseMcpClient {
          constructor(sseServerUrl, clientName = "EkoMcpClient", headers = {}) {
            this.protocolVersion = "2024-11-05";
            this.sseUrl = sseServerUrl;
            this.clientName = clientName;
            this.headers = headers;
            this.requestMap = new Map();
          }
          async connect(signal) {
            Log.info("MCP Client, connecting...", this.sseUrl);
            if (this.sseHandler && this.sseHandler.readyState == 1) {
              this.sseHandler.close && this.sseHandler.close();
              this.sseHandler = undefined;
            }
            this.pingTimer && clearInterval(this.pingTimer);
            this.reconnectTimer && clearTimeout(this.reconnectTimer);
            await new Promise((resolve) => {
              const timer = setTimeout(resolve, 15000);
              this.sseHandler = {
                onopen: () => {
                  Log.info("MCP Client, connection successful", this.sseUrl);
                  clearTimeout(timer);
                  setTimeout(resolve, 200);
                },
                onmessage: (data) => this.onmessage(data),
                onerror: (e) => {
                  Log.error("MCP Client, error: ", e);
                  clearTimeout(timer);
                  if (this.sseHandler?.readyState === 2) {
                    this.pingTimer && clearInterval(this.pingTimer);
                    this.reconnectTimer = setTimeout(() => {
                      this.connect();
                    }, 500);
                  }
                  resolve();
                },
              };
              connectSse(this.sseUrl, this.sseHandler, this.headers, signal);
            });
            this.pingTimer = setInterval(() => this.ping(), 10000);
          }
          onmessage(data) {
            Log.debug("MCP Client, onmessage", this.sseUrl, data);
            if (data.event == "endpoint") {
              let uri = data.data;
              let msgUrl;
              let idx = this.sseUrl.indexOf("/", 10);
              if (idx > -1) {
                msgUrl = this.sseUrl.substring(0, idx) + uri;
              }
              else {
                msgUrl = this.sseUrl + uri;
              }
              this.msgUrl = msgUrl;
              this.initialize();
            }
            else if (data.event == "message") {
              let message = JSON.parse(data.data);
              let _resolve = this.requestMap.get(message.id);
              _resolve && _resolve(message);
            }
          }
          async initialize() {
            await this.request("initialize", {
              protocolVersion: this.protocolVersion,
              capabilities: {
                tools: {
                  listChanged: true,
                },
                sampling: {},
              },
              clientInfo: {
                name: this.clientName,
                version: "1.0.0",
              },
            });
            try {
              await this.request("notifications/initialized", {});
            }
            catch (ignored) { }
          }
          ping() {
            this.request("ping", {});
          }
          async listTools(param, signal) {
            const message = await this.request("tools/list", {
              ...param,
            }, signal);
            return message.result.tools || [];
          }
          async callTool(param, signal) {
            const message = await this.request("tools/call", {
              ...param,
            }, signal);
            return message.result;
          }
          async request(method, params, signal) {
            const id = method.startsWith("notifications/") ? undefined : uuidv4();
            try {
              const callback = new Promise((resolve, reject) => {
                if (signal) {
                  signal.addEventListener("abort", () => {
                    const error = new Error("Operation was interrupted");
                    error.name = "AbortError";
                    reject(error);
                  });
                }
                id && this.requestMap.set(id, resolve);
              });
              Log.debug(`MCP Client, ${method}`, id, params);
              const response = await fetch(this.msgUrl, {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  ...this.headers,
                },
                body: JSON.stringify({
                  jsonrpc: "2.0",
                  id: id,
                  method: method,
                  params: {
                    ...params,
                  },
                }),
                signal: signal,
              });
              const body = await response.text();
              if (body == "Accepted") {
                const message = await callback;
                if (message.error) {
                  Log.error(`MCP ${method} error: ` + message.error);
                  throw new Error(`MCP ${method} error: ` +
                    (typeof message.error === "string"
                      ? message.error
                      : message.error.message));
                }
                if (message.result?.isError == true) {
                  if (message.result.content) {
                    throw new Error(`MCP ${method} error: ` +
                      (typeof message.result.content === "string"
                        ? message.result.content
                        : message.result.content[0].text));
                  }
                  else {
                    throw new Error(`MCP ${method} error: ` + JSON.stringify(message.result));
                  }
                }
                return message;
              }
              else {
                throw new Error(`MCP ${method} error:` + body);
              }
            }
            finally {
              id && this.requestMap.delete(id);
            }
          }
          isConnected() {
            if (this.sseHandler && this.sseHandler.readyState == 1) {
              return true;
            }
            return false;
          }
          async close() {
            try {
              await this.request("notifications/cancelled", {
                requestId: uuidv4(),
                reason: "User requested cancellation",
              });
            }
            catch (ignored) { }
            this.pingTimer && clearInterval(this.pingTimer);
            this.reconnectTimer && clearTimeout(this.reconnectTimer);
            this.sseHandler && this.sseHandler.close && this.sseHandler.close();
            this.pingTimer = undefined;
            this.sseHandler = undefined;
            this.reconnectTimer = undefined;
          }
        }
        async function connectSse(sseUrl, hander, headers = {}, _signal) {
          try {
            hander.readyState = 0;
            const controller = new AbortController();
            const signal = _signal
              ? AbortSignal.any([controller.signal, _signal])
              : controller.signal;
            const response = await fetch(sseUrl, {
              method: "GET",
              headers: {
                "Content-Type": "text/event-stream",
                "Cache-Control": "no-cache",
                ...headers,
              },
              body: null,
              keepalive: true,
              signal: signal,
            });
            const reader = response.body?.getReader();
            hander.close = () => {
              controller.abort();
              hander.readyState = 2;
              Log.debug("McpClient close abort.", sseUrl);
            };
            let str = "";
            const decoder = new TextDecoder();
            hander.readyState = 1;
            hander.onopen();
            while (hander.readyState == 1) {
              const { value, done } = await reader?.read();
              if (done) {
                break;
              }
              const text = decoder.decode(value);
              str += text;
              if (str.indexOf("\n\n") > -1) {
                const chunks = str.split("\n\n");
                for (let i = 0; i < chunks.length - 1; i++) {
                  const chunk = chunks[i];
                  const chunkData = parseChunk(chunk);
                  hander.onmessage(chunkData);
                }
                str = chunks[chunks.length - 1];
              }
            }
          }
          catch (e) {
            if (e?.name !== "AbortError") {
              Log.error("MCP Client, connectSse error:", e);
              hander.onerror(e);
            }
          }
          finally {
            hander.readyState = 2;
          }
        }
        function parseChunk(chunk) {
          const lines = chunk.split("\n");
          const chunk_obj = {};
          for (let j = 0; j < lines.length; j++) {
            const line = lines[j];
            if (line.startsWith("id:")) {
              chunk_obj["id"] = line.substring(3).trim();
            }
            else if (line.startsWith("event:")) {
              chunk_obj["event"] = line.substring(6).trim();
            }
            else if (line.startsWith("data:")) {
              chunk_obj["data"] = line.substring(5).trim();
            }
            else {
              const idx = line.indexOf(":");
              if (idx > -1) {
                chunk_obj[line.substring(0, idx)] = line.substring(idx + 1).trim();
              }
            }
          }
          return chunk_obj;
        }

        class SimpleHttpMcpClient {
          constructor(httpUrl, clientName = "EkoMcpClient", headers = {}) {
            this.protocolVersion = "2025-06-18";
            this.connected = false;
            this.httpUrl = httpUrl;
            this.clientName = clientName;
            this.headers = headers;
          }
          async connect(signal) {
            Log.info("MCP Client, connecting...", this.httpUrl);
            this.mcpSessionId = null;
            await this.request("initialize", {
              protocolVersion: this.protocolVersion,
              capabilities: {
                tools: {
                  listChanged: true,
                },
                sampling: {},
              },
              clientInfo: {
                name: this.clientName,
                version: "1.0.0",
              },
            }, signal);
            if (this.mcpSessionId) {
              try {
                await this.request("notifications/initialized", {});
              }
              catch (ignored) { }
            }
            this.connected = true;
          }
          async listTools(param, signal) {
            const message = await this.request("tools/list", {
              ...param,
            }, signal);
            return message.result.tools || [];
          }
          async callTool(param, signal) {
            const message = await this.request("tools/call", {
              ...param,
            }, signal);
            return message.result;
          }
          isConnected() {
            return this.connected;
          }
          async close() {
            this.connected = false;
            if (this.mcpSessionId) {
              try {
                await this.request("notifications/cancelled", {
                  requestId: uuidv4(),
                  reason: "User requested cancellation",
                });
              }
              catch (ignored) { }
              this.mcpSessionId = null;
            }
          }
          async request(method, params, signal) {
            try {
              const id = method.startsWith("notifications/") ? undefined : uuidv4();
              const extHeaders = {};
              if (this.mcpSessionId && method !== "initialize") {
                extHeaders["Mcp-Session-Id"] = this.mcpSessionId;
              }
              const response = await fetch(this.httpUrl, {
                method: "POST",
                headers: {
                  "Cache-Control": "no-cache",
                  "Content-Type": "application/json",
                  Accept: "application/json, text/event-stream",
                  "MCP-Protocol-Version": this.protocolVersion,
                  ...extHeaders,
                  ...this.headers,
                },
                body: JSON.stringify({
                  jsonrpc: "2.0",
                  id: id,
                  method: method,
                  params: {
                    ...params,
                  },
                }),
                keepalive: true,
                signal: signal,
              });
              if (method.startsWith("notifications/")) {
                return;
              }
              if (method == "initialize") {
                this.mcpSessionId =
                  response.headers.get("Mcp-Session-Id") ||
                  response.headers.get("mcp-session-id");
              }
              const contentType = response.headers.get("Content-Type") ||
                response.headers.get("content-type") ||
                "application/json";
              if (contentType?.includes("text/event-stream")) {
                // SSE
                const reader = response.body?.getReader();
                let str = "";
                let message;
                const decoder = new TextDecoder();
                while (true) {
                  const { value, done } = await reader?.read();
                  if (done) {
                    break;
                  }
                  const text = decoder.decode(value);
                  str += text;
                  if (str.indexOf("\n\n") > -1) {
                    const chunks = str.split("\n\n");
                    for (let i = 0; i < chunks.length - 1; i++) {
                      const chunk = chunks[i];
                      const chunkData = this.parseChunk(chunk);
                      if (chunkData.event == "message") {
                        message = JSON.parse(chunkData.data);
                        if (message.id == id) {
                          return message;
                        }
                      }
                    }
                    str = chunks[chunks.length - 1];
                  }
                }
                this.handleError(method, message);
                return message;
              }
              else {
                // JSON
                const message = await response.json();
                this.handleError(method, message);
                return message;
              }
            }
            catch (e) {
              if (e?.name !== "AbortError") {
                Log.error("MCP Client, connectSse error:", e);
              }
              throw e;
            }
          }
          handleError(method, message) {
            if (!message) {
              throw new Error(`MCP ${method} error: no response`);
            }
            if (message?.error) {
              Log.error(`MCP ${method} error: ` + message.error);
              throw new Error(`MCP ${method} error: ` +
                (typeof message.error === "string"
                  ? message.error
                  : message.error.message));
            }
            if (message.result?.isError == true) {
              if (message.result.content) {
                throw new Error(`MCP ${method} error: ` +
                  (typeof message.result.content === "string"
                    ? message.result.content
                    : message.result.content[0].text));
              }
              else {
                throw new Error(`MCP ${method} error: ` + JSON.stringify(message.result));
              }
            }
          }
          parseChunk(chunk) {
            const lines = chunk.split("\n");
            const chunk_obj = {};
            for (let j = 0; j < lines.length; j++) {
              const line = lines[j];
              if (line.startsWith("id:")) {
                chunk_obj["id"] = line.substring(3).trim();
              }
              else if (line.startsWith("event:")) {
                chunk_obj["event"] = line.substring(6).trim();
              }
              else if (line.startsWith("data:")) {
                chunk_obj["data"] = line.substring(5).trim();
              }
              else {
                const idx = line.indexOf(":");
                if (idx > -1) {
                  chunk_obj[line.substring(0, idx)] = line.substring(idx + 1).trim();
                }
              }
            }
            return chunk_obj;
          }
        }


        //# sourceMappingURL=index.esm.js.map


        /***/
}),

/***/ "../../packages/eko-extension/dist/index.esm.js":
/*!******************************************************!*\
  !*** ../../packages/eko-extension/dist/index.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BrowserAgent: () => (/* binding */ BrowserAgent)
          /* harmony export */
});
/* harmony import */ var _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @eko-ai/eko */ "../../packages/eko-core/dist/index.esm.js");


        class BrowserAgent extends _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__.BaseBrowserLabelsAgent {
          async screenshot(agentContext) {
            let windowId = await this.getWindowId(agentContext);
            let dataUrl;
            try {
              dataUrl = await chrome.tabs.captureVisibleTab(windowId, {
                format: "jpeg",
                quality: 60,
              });
            }
            catch (e) {
              await this.sleep(1000);
              dataUrl = await chrome.tabs.captureVisibleTab(windowId, {
                format: "jpeg",
                quality: 60,
              });
            }
            let data = dataUrl.substring(dataUrl.indexOf("base64,") + 7);
            return {
              imageBase64: data,
              imageType: "image/jpeg",
            };
          }
          async navigate_to(agentContext, url) {
            let windowId = await this.getWindowId(agentContext);
            let tab = await chrome.tabs.create({
              url: url,
              windowId: windowId,
            });
            tab = await this.waitForTabComplete(tab.id);
            await this.sleep(200);
            agentContext.variables.set("windowId", tab.windowId);
            let navigateTabIds = agentContext.variables.get("navigateTabIds") || [];
            navigateTabIds.push(tab.id);
            agentContext.variables.set("navigateTabIds", navigateTabIds);
            return {
              url: url,
              title: tab.title,
              tabId: tab.id
            };
          }
          async get_all_tabs(agentContext) {
            let windowId = await this.getWindowId(agentContext);
            let tabs = await chrome.tabs.query({
              windowId: windowId,
            });
            let result = [];
            for (let i = 0; i < tabs.length; i++) {
              let tab = tabs[i];
              result.push({
                tabId: tab.id,
                url: tab.url,
                title: tab.title,
              });
            }
            return result;
          }
          async switch_tab(agentContext, tabId) {
            let tab = await chrome.tabs.update(tabId, { active: true });
            if (!tab) {
              throw new Error("tabId does not exist: " + tabId);
            }
            agentContext.variables.set("windowId", tab.windowId);
            return {
              tabId: tab.id,
              url: tab.url,
              title: tab.title,
            };
          }
          async go_back(agentContext) {
            try {
              let canGoBack = await this.execute_script(agentContext, () => {
                return window.navigation.canGoBack;
              }, []);
              if (canGoBack + "" == "true") {
                await this.execute_script(agentContext, () => {
                  window.navigation.back();
                }, []);
                await this.sleep(100);
                return;
              }
              let history_length = await this.execute_script(agentContext, () => {
                return window.history.length;
              }, []);
              if (history_length > 1) {
                await this.execute_script(agentContext, () => {
                  window.history.back();
                }, []);
              }
              else {
                let navigateTabIds = agentContext.variables.get("navigateTabIds");
                if (navigateTabIds && navigateTabIds.length > 0) {
                  return await this.switch_tab(agentContext, navigateTabIds[navigateTabIds.length - 1]);
                }
              }
              await this.sleep(100);
            }
            catch (e) {
              console.error("BrowserAgent, go_back, error: ", e);
            }
          }
          async execute_script(agentContext, func, args) {
            let tabId = await this.getTabId(agentContext);
            let frameResults = await chrome.scripting.executeScript({
              target: { tabId: tabId },
              func: func,
              args: args,
            });
            return frameResults[0].result;
          }
          async getTabId(agentContext) {
            let windowId = await this.getWindowId(agentContext);
            let tabs = (await chrome.tabs.query({
              windowId,
              active: true,
              windowType: "normal",
            }));
            if (tabs.length == 0) {
              tabs = (await chrome.tabs.query({
                windowId,
                windowType: "normal",
              }));
            }
            return tabs[tabs.length - 1].id;
          }
          async getWindowId(agentContext) {
            let windowId = agentContext.variables.get("windowId");
            if (windowId) {
              return windowId;
            }
            let window = await chrome.windows.getLastFocused({
              windowTypes: ["normal"],
            });
            if (!window) {
              window = await chrome.windows.getCurrent({
                windowTypes: ["normal"],
              });
            }
            if (window) {
              return window.id;
            }
            let tabs = (await chrome.tabs.query({
              windowType: "normal",
              currentWindow: true,
            }));
            if (tabs.length == 0) {
              tabs = (await chrome.tabs.query({
                windowType: "normal",
                lastFocusedWindow: true,
              }));
            }
            return tabs[tabs.length - 1].windowId;
          }
          async waitForTabComplete(tabId, timeout = 8000) {
            return new Promise(async (resolve, reject) => {
              const time = setTimeout(async () => {
                chrome.tabs.onUpdated.removeListener(listener);
                let tab = await chrome.tabs.get(tabId);
                if (tab.status === "complete") {
                  resolve(tab);
                }
                else {
                  resolve(tab);
                }
              }, timeout);
              const listener = async (updatedTabId, changeInfo, tab) => {
                if (updatedTabId == tabId && changeInfo.status === "complete") {
                  chrome.tabs.onUpdated.removeListener(listener);
                  clearTimeout(time);
                  resolve(tab);
                }
              };
              let tab = await chrome.tabs.get(tabId);
              if (tab.status === "complete") {
                resolve(tab);
                clearTimeout(time);
                return;
              }
              chrome.tabs.onUpdated.addListener(listener);
            });
          }
          sleep(time) {
            return new Promise((resolve) => setTimeout(() => resolve(), time));
          }
        }


        //# sourceMappingURL=index.esm.js.map


        /***/
}),

/***/ "./src/background/agent/browser-service.ts":
/*!*************************************************!*\
  !*** ./src/background/agent/browser-service.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SimpleBrowserService: () => (/* binding */ SimpleBrowserService)
          /* harmony export */
});
/* harmony import */ var pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pdfjs-dist */ "../../node_modules/.pnpm/pdfjs-dist@5.4.394/node_modules/pdfjs-dist/build/pdf.mjs");

        pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.GlobalWorkerOptions.workerSrc = chrome.runtime.getURL("pdf.worker.min.js");
        class SimpleBrowserService {
          async loadTabs(chatId, tabIds) {
            let tabs = await chrome.tabs.query({});
            if (tabIds) {
              tabs = tabs.filter((tab) => tabIds.includes(String(tab.id)));
            }
            const sortedTabs = tabs
              .sort((a, b) => {
                const aTime = a.lastAccessed || 0;
                const bTime = b.lastAccessed || 0;
                return bTime - aTime;
              })
              .filter((tab) => !tab.url.startsWith("chrome://"))
              .map((tab) => {
                const lastAccessed = tab.lastAccessed;
                const pageTab = {
                  tabId: String(tab.id),
                  windowId: String(tab.windowId),
                  title: tab.title || "",
                  url: tab.url || "",
                  active: tab.active,
                  status: tab.status,
                  favicon: tab.favIconUrl,
                  lastAccessed: lastAccessed
                    ? new Date(lastAccessed).toLocaleString()
                    : undefined,
                };
                return pageTab;
              })
              .slice(0, 15);
            return Promise.resolve(sortedTabs);
          }
          async extractPageContents(chatId, tabIds) {
            const contents = [];
            for (const tabId of tabIds) {
              const tab = await chrome.tabs.get(Number(tabId));
              const frameResults = await chrome.scripting.executeScript({
                target: { tabId: Number(tabId) },
                func: extractPageContent,
                args: [],
              });
              let tabHtmls = frameResults[0].result;
              if (!tabHtmls) {
                tabHtmls = await this.extractPdfContent(tab.url);
              }
              contents.push({
                tabId: tabId,
                url: tab.url,
                title: tab.title,
                content: tabHtmls,
              });
            }
            return Promise.resolve(contents);
          }
          async extractPdfContent(pdfUrl) {
            try {
              const loadingTask = (0, pdfjs_dist__WEBPACK_IMPORTED_MODULE_0__.getDocument)(pdfUrl);
              const pdf = await loadingTask.promise;
              let textContent = "";
              for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
                const page = await pdf.getPage(pageNum);
                const textData = await page.getTextContent();
                const pageText = textData.items.map((item) => item.str).join(" ");
                textContent += `PDF Page ${pageNum}:\n${pageText}\n\n`;
              }
              return textContent;
            }
            catch (error) {
              console.warn("Unable to load PDF:", error);
              return "";
            }
          }
        }
        function extractPageContent(max_url_length = 200) {
          let result = "";
          max_url_length = max_url_length || 200;
          try {
            function traverse(node) {
              if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toLowerCase();
                if (["script", "style", "noscript"].includes(tagName)) {
                  return;
                }
                const style = window.getComputedStyle(node);
                if (style.display == "none" ||
                  style.visibility == "hidden" ||
                  style.opacity == "0") {
                  return;
                }
              }
              if (node.nodeType === Node.TEXT_NODE) {
                // text
                const text = node.textContent.trim();
                if (text) {
                  result += text + " ";
                }
              }
              else if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toLowerCase();
                if (["input", "select", "textarea"].includes(tagName)) {
                  // input / select / textarea
                  if (tagName == "input" && node.type == "checkbox") {
                    result += node.checked + " ";
                  }
                  else if (tagName == "input" && node.type == "radio") {
                    if (node.checked && node.value) {
                      result += node.value + " ";
                    }
                  }
                  else if (node.value) {
                    result += node.value + " ";
                  }
                }
                else if (tagName === "img") {
                  // image
                  const src = node.src ||
                    node.getAttribute("src") ||
                    node.getAttribute("data-src");
                  const alt = node.alt || node.title || "";
                  if (src &&
                    src.length <= max_url_length &&
                    node.width * node.height >= 10000 &&
                    src.startsWith("http")) {
                    result += `![${alt ? alt : "image"}](${src.trim()}) `;
                  }
                }
                else if (tagName === "a" && node.children.length == 0) {
                  // link
                  const href = node.href || node.getAttribute("href");
                  const text = node.innerText.trim() || node.title;
                  if (text &&
                    href &&
                    href.length <= max_url_length &&
                    href.startsWith("http")) {
                    result += `[${text}](${href.trim()}) `;
                  }
                  else {
                    result += text + " ";
                  }
                }
                else if (tagName === "video" || tagName == "audio") {
                  // video / audio
                  let src = node.src || node.getAttribute("src");
                  const sources = node.querySelectorAll("source");
                  if (sources.length > 0 && sources[0].src) {
                    src = sources[0].src;
                    if (src && src.startsWith("http") && sources[0].type) {
                      result += sources[0].type + " ";
                    }
                  }
                  if (src && src.startsWith("http")) {
                    result += src.trim() + " ";
                  }
                }
                else if (tagName === "br") {
                  // br
                  result += "\n";
                }
                else if (["p", "div", "h1", "h2", "h3", "h4", "h5", "h6"].includes(tagName)) {
                  // block
                  result += "\n";
                  for (let child of node.childNodes) {
                    traverse(child);
                  }
                  result += "\n";
                  return;
                }
                else if (tagName === "hr") {
                  // hr
                  result += "\n--------\n";
                }
                else {
                  // recursive
                  for (let child of node.childNodes) {
                    traverse(child);
                  }
                }
              }
            }
            traverse(document.body);
          }
          catch (e) {
            result = document.body.innerText;
          }
          return result.replace(/\s*\n/g, "\n").replace(/\n+/g, "\n").trim();
        }


        /***/
}),

/***/ "./src/background/agent/chat-service.ts":
/*!**********************************************!*\
  !*** ./src/background/agent/chat-service.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SimpleChatService: () => (/* binding */ SimpleChatService)
          /* harmony export */
});
/* harmony import */ var _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @eko-ai/eko */ "../../packages/eko-core/dist/index.esm.js");

        class SimpleChatService {
          loadMessages(chatId) {
            return Promise.resolve([]);
          }
          addMessage(chatId, messages) {
            return Promise.resolve();
          }
          memoryRecall(chatId, prompt) {
            return Promise.resolve("");
          }
          async uploadFile(file, chatId, taskId) {
            const fileId = (0, _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__.uuidv4)();
            if (file instanceof File) {
              const mimeType = file.type || "application/octet-stream";
              if (typeof FileReader !== "undefined") {
                return new Promise((resolve, reject) => {
                  const reader = new FileReader();
                  reader.onload = () => resolve({
                    fileId: fileId,
                    url: reader.result,
                  });
                  reader.onerror = reject;
                  reader.readAsDataURL(file);
                });
              }
              // @ts-ignore
              if (typeof Buffer !== "undefined") {
                const arrayBuffer = await file.arrayBuffer();
                // @ts-ignore
                const buffer = Buffer.from(arrayBuffer);
                const base64 = buffer.toString("base64");
                return Promise.resolve({
                  fileId: fileId,
                  url: `data:${mimeType};base64,${base64}`,
                });
              }
              else {
                const arrayBuffer = await file.arrayBuffer();
                const base64 = btoa(String.fromCharCode(...new Uint8Array(arrayBuffer)));
                return Promise.resolve({
                  fileId: fileId,
                  url: `data:${mimeType};base64,${base64}`,
                });
              }
            }
            else {
              return Promise.resolve({
                fileId: fileId,
                url: `data:${file.mimeType};base64,${file.base64Data}`,
              });
            }
          }
          websearch(chatId, query, site, language, maxResults) {
            return Promise.resolve([]);
          }
        }


        /***/
}),

/***/ "./src/background/agent/index.ts":
/*!***************************************!*\
  !*** ./src/background/agent/index.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

        "use strict";
        __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   initAgentServices: () => (/* binding */ initAgentServices)
          /* harmony export */
});
/* harmony import */ var _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @eko-ai/eko */ "../../packages/eko-core/dist/index.esm.js");
/* harmony import */ var _chat_service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chat-service */ "./src/background/agent/chat-service.ts");
/* harmony import */ var _browser_service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./browser-service */ "./src/background/agent/browser-service.ts");



        function initAgentServices() {
          _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__.global.browserService = new _browser_service__WEBPACK_IMPORTED_MODULE_2__.SimpleBrowserService();
          _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__.global.chatService = new _chat_service__WEBPACK_IMPORTED_MODULE_1__.SimpleChatService();
        }


        /***/
})

    /******/
});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
      /******/
}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
      /******/
};
/******/
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
    /******/
}
/******/
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for (var key in definition) {
/******/ 				if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
          /******/
}
        /******/
}
      /******/
};
    /******/
})();
/******/
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
    /******/
})();
/******/
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
        /******/
}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
      /******/
};
    /******/
})();
  /******/
  /************************************************************************/
  var __webpack_exports__ = {};
  // This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
  (() => {
    "use strict";
    /*!*********************************!*\
      !*** ./src/background/index.ts ***!
      \*********************************/
    __webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   init: () => (/* binding */ init)
      /* harmony export */
});
/* harmony import */ var _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @eko-ai/eko */ "../../packages/eko-core/dist/index.esm.js");
/* harmony import */ var _agent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./agent */ "./src/background/agent/index.ts");
/* harmony import */ var _eko_ai_eko_extension__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @eko-ai/eko-extension */ "../../packages/eko-extension/dist/index.esm.js");



    var chatAgent = null;
    const humanCallbackIdMap = new Map();
    const abortControllers = new Map();
    // Chat callback
    const chatCallback = {
      onMessage: async (message) => {
        chrome.runtime.sendMessage({
          type: "chat_callback",
          data: message,
        });
        console.log("chat message: ", JSON.stringify(message, null, 2));
      },
    };
    // Task agent callback
    const taskCallback = {
      onMessage: async (message) => {
        chrome.runtime.sendMessage({
          type: "task_callback",
          data: { ...message, messageId: message.taskId },
        });
        console.log("task message: ", JSON.stringify(message, null, 2));
      },
      onHumanConfirm: async (context, prompt) => {
        const callbackId = (0, _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__.uuidv4)();
        chrome.runtime.sendMessage({
          type: "task_callback",
          data: {
            streamType: "agent",
            chatId: context.context.chatId,
            taskId: context.context.taskId,
            agentName: context.agent.Name,
            nodeId: context.agentChain.agent.id,
            messageId: context.context.taskId,
            type: "human_confirm",
            callbackId: callbackId,
            prompt: prompt,
          },
        });
        console.log("human_confirm: ", prompt);
        return new Promise((resolve) => {
          humanCallbackIdMap.set(callbackId, (value) => {
            humanCallbackIdMap.delete(callbackId);
            resolve(value);
          });
        });
      },
      onHumanInput: async (context, prompt) => {
        const callbackId = (0, _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__.uuidv4)();
        chrome.runtime.sendMessage({
          type: "task_callback",
          data: {
            streamType: "agent",
            chatId: context.context.chatId,
            taskId: context.context.taskId,
            agentName: context.agent.Name,
            nodeId: context.agentChain.agent.id,
            messageId: context.context.taskId,
            type: "human_input",
            callbackId: callbackId,
            prompt: prompt,
          },
        });
        console.log("human_input: ", prompt);
        return new Promise((resolve) => {
          humanCallbackIdMap.set(callbackId, (value) => {
            humanCallbackIdMap.delete(callbackId);
            resolve(value);
          });
        });
      },
      onHumanSelect: async (context, prompt, options, multiple) => {
        const callbackId = (0, _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__.uuidv4)();
        chrome.runtime.sendMessage({
          type: "task_callback",
          data: {
            streamType: "agent",
            chatId: context.context.chatId,
            taskId: context.context.taskId,
            agentName: context.agent.Name,
            nodeId: context.agentChain.agent.id,
            messageId: context.context.taskId,
            type: "human_select",
            callbackId: callbackId,
            prompt: prompt,
            options: options,
            multiple: multiple,
          },
        });
        console.log("human_select: ", prompt);
        return new Promise((resolve) => {
          humanCallbackIdMap.set(callbackId, (value) => {
            humanCallbackIdMap.delete(callbackId);
            resolve(value);
          });
        });
      },
      onHumanHelp: async (context, helpType, prompt) => {
        const callbackId = (0, _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__.uuidv4)();
        chrome.runtime.sendMessage({
          type: "task_callback",
          data: {
            streamType: "agent",
            chatId: context.context.chatId,
            taskId: context.context.taskId,
            agentName: context.agent.Name,
            nodeId: context.agentChain.agent.id,
            messageId: context.context.taskId,
            type: "human_help",
            callbackId: callbackId,
            helpType: helpType,
            prompt: prompt,
          },
        });
        console.log("human_help: ", prompt);
        return new Promise((resolve) => {
          humanCallbackIdMap.set(callbackId, (value) => {
            humanCallbackIdMap.delete(callbackId);
            resolve(value);
          });
        });
      },
    };
    async function init() {
      const storageKey = "llmConfig";
      const llmConfig = (await chrome.storage.sync.get([storageKey]))[storageKey];
      if (!llmConfig || !llmConfig.apiKey) {
        printLog("Please configure apiKey, configure in the eko extension options of the browser extensions.", "error");
        setTimeout(() => {
          chrome.runtime.openOptionsPage();
        }, 1000);
        return;
      }
      (0, _agent__WEBPACK_IMPORTED_MODULE_1__.initAgentServices)();
      const llms = {
        default: {
          provider: llmConfig.llm,
          model: llmConfig.modelName,
          apiKey: llmConfig.apiKey,
          config: {
            baseURL: llmConfig.options.baseURL,
          },
        },
      };
      const agents = [new _eko_ai_eko_extension__WEBPACK_IMPORTED_MODULE_2__.BrowserAgent()];
      chatAgent = new _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__.ChatAgent({ llms, agents });
      chatAgent.initMessages().catch((e) => {
        printLog("init messages error: " + e, "error");
      });
      return chatAgent;
    }
    // Handle chat request
    async function handleChat(requestId, data) {
      const messageId = data.messageId;
      if (!chatAgent) {
        chrome.runtime.sendMessage({
          requestId,
          type: "chat_result",
          data: { messageId, error: "ChatAgent not initialized" },
        });
        return;
      }
      const user = data.user;
      const abortController = new AbortController();
      abortControllers.set(messageId, abortController);
      try {
        const result = await chatAgent.chat({
          user: user,
          messageId,
          callback: {
            chatCallback,
            taskCallback,
          },
          signal: abortController.signal,
        });
        chrome.runtime.sendMessage({
          requestId,
          type: "chat_result",
          data: { messageId, result },
        });
      }
      catch (error) {
        chrome.runtime.sendMessage({
          requestId,
          type: "chat_result",
          data: { messageId, error: String(error) },
        });
      }
    }
    // Handle human callback request
    async function handleHumanCallback(requestId, data) {
      const callbackId = data.callbackId;
      const value = data.value;
      const callback = humanCallbackIdMap.get(callbackId);
      if (callback) {
        callback(value);
      }
      chrome.runtime.sendMessage({
        requestId,
        type: "human_callback_result",
        data: { callbackId, success: callback != null },
      });
    }
    // Handle upload file request
    async function handleUploadFile(requestId, data) {
      if (!chatAgent) {
        chrome.runtime.sendMessage({
          requestId,
          type: "uploadFile_result",
          data: { error: "ChatAgent not initialized" },
        });
        return;
      }
      const base64Data = data.base64Data;
      const mimeType = data.mimeType;
      const filename = data.filename;
      try {
        const { fileId, url } = await _eko_ai_eko__WEBPACK_IMPORTED_MODULE_0__.global.chatService.uploadFile({ base64Data, mimeType, filename }, chatAgent.getChatContext().getChatId());
        chrome.runtime.sendMessage({
          requestId,
          type: "uploadFile_result",
          data: { fileId, url },
        });
      }
      catch (error) {
        chrome.runtime.sendMessage({
          requestId,
          type: "uploadFile_result",
          data: { error: error + "" },
        });
      }
    }
    // Handle stop request
    async function handleStop(requestId, data) {
      const abortController = abortControllers.get(data.messageId);
      if (abortController) {
        abortController.abort("User aborted");
        abortControllers.delete(data.messageId);
      }
    }
    // Handle get tabs request
    async function handleGetTabs(requestId, data) {
      try {
        const tabs = await chrome.tabs.query({});
        const sortedTabs = tabs
          .sort((a, b) => {
            const aTime = a.lastAccessed || 0;
            const bTime = b.lastAccessed || 0;
            return bTime - aTime;
          })
          .filter((tab) => !tab.url.startsWith("chrome://"))
          .map((tab) => {
            const lastAccessed = tab.lastAccessed;
            return {
              tabId: String(tab.id),
              title: tab.title || "",
              url: tab.url || "",
              active: tab.active,
              status: tab.status,
              favicon: tab.favIconUrl,
              lastAccessed: lastAccessed
                ? new Date(lastAccessed).toLocaleString()
                : "",
            };
          })
          .slice(0, 15);
        chrome.runtime.sendMessage({
          requestId,
          type: "getTabs_result",
          data: { tabs: sortedTabs },
        });
      }
      catch (error) {
        chrome.runtime.sendMessage({
          requestId,
          type: "getTabs_result",
          data: { error: String(error) },
        });
      }
    }
    // Event routing mapping
    const eventHandlers = {
      chat: handleChat,
      human_callback: handleHumanCallback,
      uploadFile: handleUploadFile,
      stop: handleStop,
      getTabs: handleGetTabs,
    };
    // Message listener
    chrome.runtime.onMessage.addListener(async function (request, sender, sendResponse) {
      const requestId = request.requestId;
      const type = request.type;
      const data = request.data;
      if (!chatAgent) {
        await init();
      }
      const handler = eventHandlers[type];
      if (handler) {
        handler(requestId, data).catch((error) => {
          printLog(`Error handling ${type}: ${error}`, "error");
        });
      }
    });
    function printLog(message, level) {
      chrome.runtime.sendMessage({
        type: "log",
        data: {
          level: level || "info",
          message: message + "",
        },
      });
    }
    if (chrome.sidePanel) {
      // open panel on action click
      chrome.sidePanel.setPanelBehavior({ openPanelOnActionClick: true });
    }

  })();

  /******/
})()
  ;
//# sourceMappingURL=background.js.map